<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WebAPIs</title>
    <link href="/2021/04/09/JavaScript/webapis/"/>
    <url>/2021/04/09/JavaScript/webapis/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ul><li>API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结其内在实现。</li><li>Web API主要是浏览器提供接口，允许我们操作BOM和DOM元素。</li><li>API一般都是函数或方法，有输入和输出，Web API也不例外。</li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（Document Object Model），是W3C阻止推荐的处理可扩展标记语言（HTML或XML）的标准编程接口。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p><img src="/./image-20210109150913764.png" alt="image-20210109150913764"></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM使用node表示节点，节点也就是一个个节点对象。</li><li>元素：HTML标签就是元素，DOM中使用element表示。</li><li>文档：一个页面就是一个文档，DOM中用document表示</li></ol><h4 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h4><ul><li>文档节点，特指 <code>document</code></li><li>元素节点，即标签, html节点是<code>document.documentElement</code></li><li>属性节点 , 可以通过element.getAttributeNode(attrName) 获得</li><li>文本节点</li></ul><h4 id="节点的共有属性"><a href="#节点的共有属性" class="headerlink" title="节点的共有属性"></a>节点的共有属性</h4><table><thead><tr><th></th><th>nodeName</th><th>nodeType</th><th>nodeValue</th></tr></thead><tbody><tr><td>文档节点</td><td>#document</td><td>9</td><td>null</td></tr><tr><td>元素节点</td><td>标签名大写 ⭐❗</td><td>1</td><td>null</td></tr><tr><td>属性节点</td><td>属性名小写  ❗</td><td>2</td><td>属性值</td></tr><tr><td>文本节点</td><td>#text</td><td>3 ⭐</td><td>文本内容 ⭐</td></tr></tbody></table><hr><h3 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h3><h4 id="兼容-IE8："><a href="#兼容-IE8：" class="headerlink" title="兼容 IE8："></a>兼容 IE8：</h4><ul><li><p><code>document.getElementById(id)</code></p></li><li><p><code>element.getElementsByTagName(tageName)</code></p></li><li><p><code>document.getElementsByName(name)</code></p></li></ul><h4 id="HTML5新增-IE9-："><a href="#HTML5新增-IE9-：" class="headerlink" title="HTML5新增 IE9+："></a>HTML5新增 IE9+：</h4><ul><li><code>element.getElementsByClassName(className)</code></li><li><code>element.querySelector(selector)</code></li><li><code>element.querySelectorAll(selector)</code></li></ul><h4 id="特殊元素的获取"><a href="#特殊元素的获取" class="headerlink" title="特殊元素的获取"></a>特殊元素的获取</h4><ul><li>html元素：<code>document.documentElement</code></li><li>body元素：<code>document.body</code></li><li>head元素：<code>document.head</code></li></ul><h4 id="查询方法分类"><a href="#查询方法分类" class="headerlink" title="查询方法分类"></a>查询方法分类</h4><ol><li><p>document的方法：</p><ul><li>getElementById</li><li>getElementsByName</li></ul></li><li><p>可以变化范围的属于一般element的方法：</p><ul><li>getElementsByTagName</li><li>getElementsByClassName</li><li>querySelector</li><li>querySelectorAll</li></ul></li><li><p>返回查询到的第一个元素的：</p><ul><li>getElementById</li><li>querySelector</li></ul></li><li><p>返回一个NodeList的：</p><ul><li>getElementsByName</li><li>getElementsByTagName</li><li>getElementsByClassName</li><li>querySelectorAll</li></ul><blockquote><p>NodeList是一个伪数组，在遍历功能上只实现了ForEach方法。</p></blockquote></li></ol><p>⭐ <strong>总结：</strong></p><ul><li><p><font color='red'>一共有6种DOM查询方法</font>。</p></li><li><p><font color='red'>两种方法只属于document</font>，分别为<code>document.getElementById</code>和<code>document.getElementsByName</code>；</p><p><font color='red'>其他四种方法都属于一般DOM元素</font>，且<font color='red'>搜寻范围为后代元素</font>。</p></li><li><p><font color='red'>两种方法只返回第一个查询到的DOM元素</font>，分别为<code>document.getElementById</code>和<code>node.querySelector</code>；</p><p><font color='red'>其他四种方法都返回一个NodeList。</font></p></li></ul><hr><h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><h4 id="1-子节点"><a href="#1-子节点" class="headerlink" title="1. 子节点"></a>1. 子节点</h4><ul><li><p><code>childNodes</code>属性</p><p>属性值为当前节点的所有子节点所组成的伪数组<code>NodeList</code>，包含文本子节点。</p></li><li><p><code>firstChild</code>属性</p><p>属性值为第一个子节点，如果不存在子节点，则值为<code>null</code></p></li><li><p><code>lastChild</code>属性</p><p>属性值为最后一个子节点，如果不存在子节点，则值为<code>null</code></p></li></ul><ul><li><p><code>children</code>属性</p><p>属性值为当前节点的所有<code>子元素节点</code>所组成的伪数组<code>NodeList</code>，不包含文本字节点。</p><blockquote><p>children属性是非标准属性，但兼容所有浏览器，放心使用。</p></blockquote></li><li><p><code>firstElementChild</code>属性 </p><p>IE9+支持，属性值为第一个<code>子元素节点</code>，如果不存在子元素节点，则值为<code>null</code></p><blockquote><p>实际开发中尽量使用node.children[0]代替firstElementChild</p></blockquote></li><li><p><code>lastElementChild</code>属性</p><p>IE9+支持，属性值为最后一个<code>子元素节点</code>，如果不存在子元素节点 ，则值为<code>null</code></p><blockquote><p>实际开发中尽量使用node.children[node.children.length-1]代替lastElementChild</p></blockquote></li></ul><h4 id="2-父节点"><a href="#2-父节点" class="headerlink" title="2. 父节点"></a>2. 父节点</h4><ul><li><p><code>parentNode</code>属性</p><p>返回当前节点的父节点。</p><blockquote><p>html的父节点是document，document的父节点是null。</p></blockquote></li></ul><h4 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="3. 兄弟节点"></a>3. 兄弟节点</h4><ul><li><p><code>previousSibling</code>属性</p><p>属性值为当前节点的前一个兄弟节点 （可能为文本节点），若不存在则值为<code>null</code></p></li><li><p><code>nextSibling</code>属性</p><p>属性值为当前节点的后一个兄弟节点（可能为文本节点），若不存在则值为<code>null</code></p></li></ul><ul><li><p><code>previousElementSibling</code>属性</p><p>IE9+支持，属性值为当前节点的前一个兄弟<code>元素节点 </code>，若不存在则值为<code>null</code></p></li><li><p><code>nextElementSibling</code>属性</p><p>IE9+支持，属性值为当前节点的后一个兄弟<code>元素节点</code>，若不存在则值为<code>null</code></p></li></ul><hr><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="读写文本或HTML片段"><a href="#读写文本或HTML片段" class="headerlink" title="读写文本或HTML片段"></a>读写文本或HTML片段</h4><p>通过以下DOM元素的属性，可以操作元素的内容：</p><ol><li><code>innerText</code></li><li><code>innerHTML</code></li><li><code>textContent</code></li></ol><p>区别：</p><ul><li><strong>innerText</strong>：返回由css决定的<font color='red'>可显示的后代节点中所有的文本内容，display: none的元素的文本子节点会被忽略。</font>文本节点text两端的空白字符会被忽略（导致全是空白字符的文本节点会被忽略），文本节点text内的换行符当作一个空格来处理，块元素的文本与其他文本节点内容之间用”\n”连接，内联元素的文本与文本节点的文本之间用””连接。❓ 由于受css影响，会触发回流 ❓。</li><li><strong>textContent</strong>：不受css影响，<font color='red'>display: none的元素不会被忽略</font>，返回所有子结点中所有的文本内容，保留所有空白字符。文本内容间用””连接。</li><li><strong>innerHTML</strong>：返回元素的HTML代码，保留所有空白字符。</li></ul><blockquote><p>以上属性都可以读写。</p></blockquote><hr><h4 id="DOM-增删改"><a href="#DOM-增删改" class="headerlink" title="DOM 增删改"></a>DOM 增删改</h4><p><strong>1. 创建文本节点</strong></p><p><code>document.createTextNode(text)</code></p><p>返回nodeValue为text的文本节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-built_in">document</span>.body.appendChild(tNode)<br></code></pre></td></tr></table></figure><p><strong>2. 创建元素节点</strong></p><ul><li><p>使用<code>document.createElement(tagName)</code></p><p>返回标签名为tagName的空元素节点</p></li><li><p>使用<code>node.innerHTML</code>创建子树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">box.innerHTML = <span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span><br></code></pre></td></tr></table></figure></li><li><p><code>document.write(htmlText)</code></p><p>在body元素中写入新的HTML片段，但如果实在文档流已经解析完的情况下调用该方法，会触发文档的重绘。</p></li></ul><blockquote><p>在为元素新增子节点或子树的操作中，相比于createElement创建元素再插入的做法，将html片段字符串赋值给父元素的innerHTML属性的做法效率更高。</p></blockquote><p><strong>3. 向父节点添加一个子节点（尾插）</strong></p><p><code>parentNode.appendChild(childNode)</code></p><p><strong>4. 在指定子节点前插入一个子节点</strong></p><p><code>parentNode.insertBefore(newChild, targetChild)</code></p><p><strong>5. 替换一个子节点</strong></p><p><code>parentNode.replaceChild(newChild, oldChild)</code></p><blockquote><p>如果oldChild不是parentNode的子节点，则会抛出异常。</p></blockquote><p><strong>6. 删除一个子节点</strong></p><p><code>parentNode.removeChild(childNode)</code></p><blockquote><p>如果childNode不是parentNode的子节点，则抛出异常。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.parent.removeChild(node); <span class="hljs-comment">// 自杀行为</span><br></code></pre></td></tr></table></figure><p><strong>7. 节点克隆</strong></p><p><code>node.cloneNode(deep = false)</code></p><p>该方法属于DOMNode，返回调用该方法的节点的一个副本。</p><p>deep参数可选，是否采用深度克隆。</p><ul><li>默认值为<code>false</code>，只克隆该节点本身（<font color='red'>如果为元素节点，则也会复制元素属性</font>）。</li><li>如果为<code>true,</code>则该节点的所有<font color='red'>后代元素节点</font>也都会被克隆，即会返回一棵节点树。</li></ul><blockquote><p><strong>关于deep参数默认值的问题：</strong></p><p>在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，<code>deep</code>是一个可选参数。如果省略的话，参数的默认值为 <code>true，</code>也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 <code>false。</code></p><p>在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。</p><p><font color='red'>所以在使用cloneNode方法时，最好明确deep参数的值，以防兼容性问题。</font></p></blockquote><blockquote><p><strong>关于克隆模板节点的Id和Name属性唯一性的问题：</strong></p><p>如果原始节点设置了ID，并且克隆节点会被插入到相同的文档中，那么应该更新克隆节点的ID以保证唯一性。name属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。</p><p><font color='red'>对存在Id或Name属性的节点进行克隆后，在将克隆节点插入到文档之前，应更新Id和Name属性。</font></p></blockquote><hr><h4 id="读写内置属性与自定义属性"><a href="#读写内置属性与自定义属性" class="headerlink" title="读写内置属性与自定义属性"></a>读写内置属性与自定义属性</h4><p><strong>1.内置属性的读写</strong></p><p>内置属性是HTML各类的标签所拥有的原生属性，包括普通的id、class、title以及img的src等。</p><p>内置属性可以直接通过 <code>element.xxx </code>读写。</p><p>内置属性也可以通过<code>element.getAttribute</code>读取，通过<code>element.setAttribute</code>修改。</p><blockquote><p>❗ 需要注意的是获取class属性值时，需要使用element.className，而不是class</p></blockquote><p><strong>2.自定义属性的读写</strong></p><p>自定义属性是指内置属性以外的标签属性，开发人员可以自定义属性上保存数据。</p><p>自定义属性可以通过element.getAttribute读取，element.setAttribute修改。</p><blockquote><p>使用element.getAttribute(attrName)，若属性不存在则返回null</p></blockquote><p>⭐ H5标准 ⭐</p><p>H5规范中要求自定义属性必须以<code>data-</code>开头。</p><p>以<code>data-</code>开头的自定义属性，除了可以用上述的<code>getAttribute</code>和<code>setAttribute</code>读写外，还可以在<code>element.dataset</code>中访问。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">data-my-prop</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 自定义属性 data-my-prop --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.getAttribute(<span class="hljs-string">&#x27;data-my-prop&#x27;</span>)); </span><br><span class="javascript">    <span class="hljs-comment">// 输出 123</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.dataset.myProp); <span class="hljs-comment">// 👈 驼峰命名法，不带 &#x27;data&#x27;</span></span><br><span class="javascript">    <span class="hljs-comment">// 输入 123</span></span><br><span class="javascript">    box.dataset.myProp = <span class="hljs-string">&#x27;321&#x27;</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 等价于data.dataset[&#x27;myProp&#x27;] = &#x27;321&#x27;;</span></span><br><span class="javascript">    <span class="hljs-comment">// 等价于 box.setAttribute(&#x27;data-my-prop&#x27;, &#x27;321&#x27;);</span></span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>❗ 兼容性问题：通过<code>element.dataset</code>访问自定义属性，只有<code>IE11+</code>兼容。</p></blockquote><p><strong>3. 删除属性</strong></p><p><code>element.removeAttribute(attrName)</code></p><p>如果指定的属性不存在也不会生成错误。</p><blockquote><p>若要彻底移除一个属性的效果，应当使用  <code>removeAttribute()</code>，而不是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute"><code>setAttribute()</code></a> 将属性值设置为 <code>null</code>。</p></blockquote><hr><h4 id="类名的增删查"><a href="#类名的增删查" class="headerlink" title="类名的增删查"></a>类名的增删查</h4><p><strong>1.读取class属性</strong></p><ul><li><p>element.className 属性，返回标签中class属性值，字符串类型。</p></li><li><p>element.classList 属性，返回标签中class属性值，伪数组类型<code>DOMTokenList</code>。</p></li><li><p>element.classList.value，返回标签中的class属性，字符串类型。</p></li><li><p>element.getAttribute(‘class’)，返回标签中class属性值，字符串类型。</p></li></ul><p><strong>2.增删类名</strong></p><ul><li><p>直接修改标签的class属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.className = <span class="hljs-string">&#x27;...&#x27;</span>;<br>element.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>封装操作className字符串的方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用正则表达式 ⭐</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elHasClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw <span class="hljs-string">`\b<span class="hljs-subst">$&#123;cn&#125;</span>\b`</span>);<br>    <span class="hljs-keyword">return</span> reg.test(el.className);<br>&#125;<br><span class="hljs-comment">// 增加一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(!elHasClassName(el, cn)) &#123;<br>        el.className = el.className + <span class="hljs-string">&#x27; &#x27;</span> + cn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 清除一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    el.className = el.className.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\b$(cn)\\b`</span>), <span class="hljs-string">&#x27;&#x27;</span>); <br>&#125;<br><span class="hljs-comment">// 切换一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(elHasClassName(el, cn)) &#123;<br>        removeClassName(el, cn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addClassName(el, cn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>通过element.classList的各种方法增删类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. contains()方法，判断一个元素是否具有某一个类名</span><br>element.classList.contains(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 2. add()方法，增加一个或多个类名  兼容性:IE10+</span><br>element.classList.add(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2...&#x27;</span>);<br><br><span class="hljs-comment">// 3. remove()方法，删除1个或多个类名 兼容性 IE10+</span><br>element.classList.remove(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2&#x27;</span>);<br><br><span class="hljs-comment">// 4. toggle()方法，切换一个类名的存在状态 兼容性:IE10+</span><br>element.classList.toggle(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 5. replace()方法，将一个类名替换为新类名 ❗ 兼容性不好，尽量不要使用。其实也不好用。</span><br>element.classList.replace(<span class="hljs-string">&#x27;oldClassName&#x27;</span>, <span class="hljs-string">&#x27;newClassName&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>element.classList的类型<code>DOMTokenList</code>严格意义上是一个只读属性，但能通过该类型的方法（如add、remove）来改变自身的元素。<a href="https://developer.mozilla.org/en-US/docs/web/api/element/classlist">参考连接</a></p></blockquote></li></ul><hr><h4 id="读写样式"><a href="#读写样式" class="headerlink" title="读写样式"></a>读写样式</h4><p><strong>1. 读写内联样式</strong></p><ul><li>通过<code>element.style </code>读取css字符串，或 <code>element.style.样式名 </code>读取样式值。</li><li>通过 <code>element.style.样式名 = 样式值 </code>修改内联样式</li></ul><blockquote><p>通过JS访问元素的style属性只能够读写内联样式，不能读取到css样式表中的样式。</p></blockquote><p><strong>2.读取元素当前显示的样式</strong></p><ul><li><p><code>element.currentStyle.样式名</code></p><p>兼容性：<strong>只有IE支持</strong>。</p><p>可访问性：只读。</p><p>若元素未设置该样式，则返回该样式的默认值</p></li><li><p><code>window.getComputedStyle(element, null)</code></p><p>兼容性：只有IE9+支持。</p><p>可访问性：只读。</p><p>参数：getComputedstyle是window的方法，传入两个参数，第一个参数是所求元素，第二个参数传入一个伪元素（一般设置为null）。</p><p>返回值：返回一个对象，该对象封装了当前元素的样式。</p></li><li><p><code>兼容方案</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">el, prop</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle) &#123;<br>        <span class="hljs-keyword">return</span> getComputedStyle(el, <span class="hljs-literal">null</span>)[prop];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> el.currentStyle[prop];<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><p>事件三要素：</p><ol><li>事件源，谁发生了事件。（可以在响应函数中用event.target获取到）</li><li>事件类型，发生了什么事件。</li><li>事件处理程序，就是事件响应函数。</li></ol><h4 id="注册和移除事件的响应函数"><a href="#注册和移除事件的响应函数" class="headerlink" title="注册和移除事件的响应函数"></a>注册和移除事件的响应函数</h4><p><strong>1. 传统方式</strong></p><p><code>element.onclick = fn</code></p><p><code>element.onblur = fn</code></p><p><code>....</code></p><ul><li><p>这种方式具有唯一性，即同一元素只能对一个事件注册一个响应函数，后面注册的会覆盖前面的。</p></li><li><p>不存在兼容性问题。</p></li></ul><p><strong>移除响应函数：</strong><code>element.onclick = null</code></p><p><strong>2. W3C推荐的方式：监听事件</strong></p><p><code>element.addEventListener(事件名， listener, options/useCapture)</code></p><ul><li><p>事件名不带”on”。</p></li><li><p>可以为同一事件绑定多个响应函数，先注册的先执行。</p></li><li><p>允许输入<code>第三个参数</code>，如果第三个参数为<code>true</code>，则响应函数会在<code>捕获阶段执行</code>。</p></li><li><p>如果<code>第三个参数为Object类型</code>，则认为是一个<code>options对象</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    capture: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在捕获阶段执行listener</span><br>    once: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在listener执行一次后移除该listener，即只执行一次</span><br>    passive: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否不允许listener中执行preventDefault()</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>移除响应函数：</strong><code>element.removeEventListener(事件名, fn)</code></p><p><strong>3. IE6~8的方式</strong></p><p><code>element.attachEvent(on事件名，fn)</code></p><ul><li>事件名带”on”。</li><li>可以为同一事件绑定多个响应函数，<code>先注册的后执行</code>。</li><li>这种方式绑定的响应函数只会在冒泡阶段执行。</li></ul><p><strong>移除响应函数：</strong> <code>element.detachEvent(on事件名，fn)</code></p><p><strong>4. 兼容性解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注册事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.addEventListener) &#123;<br>        el.addEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.attachEvent) &#123;<br>        el.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = fn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 移除事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.removeEventListener) &#123;<br>        el.removeEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.detachEvent) &#123;<br>        el.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="事件流（事件的传播）"><a href="#事件流（事件的传播）" class="headerlink" title="事件流（事件的传播）"></a>事件流（事件的传播）</h4><p><strong>概念</strong></p><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件发生时会在元素节点之间按照<code>从外至内、从内向外</code>的顺序传播，这个<code>传播过程</code>叫做DOM事件流。</p><p>比如我们给一个div注册了单击事件的响应函数：</p><p><img src="/./image-20210115202428033.png" alt="image-20210115202428033"> </p><p><strong>事件传播的三个阶段</strong></p><p>W3C综合了网景和微软的方案，将DOM事件流分为三个阶段：</p><ol><li>捕获阶段：从最外层的祖先元素向目标元素进行捕获，但默认此时不会触发事件的响应函数。（网景提出）</li><li>目标阶段：捕获到目标元素，按顺序执行响应函数。</li><li>冒泡阶段：向祖先元素传递，依次触发祖先元素上的事件响应函数。（微软提出）</li></ol><blockquote><ul><li>如果希望在捕获阶段执行响应函数，则需要将addEventListener方法的第三个参数设置为true，则该次注册的响应函数会在捕获阶段执行。</li><li>IE8及以下没有捕获阶段，使用<code>传统方法</code>和<code>attachEvent</code>方法注册的函数永远<code>不会在捕获阶段执行</code>。</li></ul></blockquote><p>❗ <strong>误区</strong> ❗：<code>在目标阶段</code>，即使是设置为捕获阶段执行的响应函数，不一定会在冒泡型响应函数之前执行。</p><p>举例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble body&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定捕获阶段的响应函数</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture body&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">//true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble box&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定捕获阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture box&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble content&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定捕获阶段的响应函数</span></span><br><span class="javascript">       content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture content&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 👇 结果输出 👇 --&gt;</span><br>capture body<br>capture box<br>bubble content   <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 原因是在事件传播到了content时已经处于目标阶段<br>capture content  <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 目标阶段会按照函数注册的顺序执行，而不会考虑该函数是在哪个阶段执行<br>bubble box<br>bubble body<br><span class="hljs-comment">&lt;!------------------&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p><strong>概念</strong></p><p>当DOM事件发生时，浏览器都会按照事件流将一个事件对象传递给各元素的响应函数。</p><p>在事件对象中封装了当前事件相关的一切信息，比如事件源、事件类型、鼠标的坐标、键盘的键位等。</p><blockquote><p>在捕获阶段，响应函数中的target属性已经存在，且指向事件源。</p></blockquote><p><strong>兼容性</strong></p><p>IE6~8浏览器将事件对象保存在了window.event属性中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;<br>    evt = evt || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-built_in">console</span>.log(evt);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件对象的常见属性和方法</strong></p><table><thead><tr><th>事件对的属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>e.target</td><td>返回触发事件的源对象    ✔ 标准  ⭐</td></tr><tr><td>window.event.srcElement</td><td>返回触发事件的源对象    ❌ 非标准，IE6~8使用</td></tr><tr><td>e.type</td><td>返回时间的类型 比如 click mouseover 不带”on” ⭐</td></tr><tr><td>window.event.cancelBubble</td><td>布尔值，该属性值设为false则阻止冒泡 ❌ 非标准 ，IE6~8使用</td></tr><tr><td>window.event.returnValue</td><td>布尔值，该属性值设为false则阻止事件的默认行为 ❌非标准 IE6~8使用， Chrome、火狐兼容，IE9+反而不兼容。                                                                                    反正就不要用这个属性了, 用return false就可以。</td></tr><tr><td>e.preventDefault()</td><td>该方法阻止事件的默认行为         ✔ 标准   ⭐</td></tr><tr><td>e.preventPropagation()</td><td>该方法阻止事件的传播，包括捕获和冒泡。 ✔ 标准 ⭐</td></tr></tbody></table><blockquote><p>在事件的响应函数中，要区分this 和 e.target，this不一定是事件源。</p></blockquote><hr><h4 id="阻止事件的默认行为"><a href="#阻止事件的默认行为" class="headerlink" title="阻止事件的默认行为"></a>阻止事件的默认行为</h4><ol><li><code>preventDefault()</code></li><li><code>return false</code></li><li><code>event.returnValue = false</code> ❌ 兼容性很奇葩，不推荐使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-comment">// 第一种方式</span><br>    <span class="hljs-keyword">if</span>(e.preventDefault) e.preventDefault();  <span class="hljs-comment">// IE9+支持</span><br>    <br>    <span class="hljs-comment">// .....</span><br>    <span class="hljs-comment">// 因为IE6~8 不认识 preventDefault方法</span><br><br>    <span class="hljs-comment">// 第二种方式</span><br>    e.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ❌ IE9~11不支持，IE6~8支持，其他浏览器支持。</span><br>    <br>    <span class="hljs-comment">// 第三种方式，兼容所有浏览器的方法 👇</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 兼容性做法 </span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><ol><li><code>event.preventPropagation()</code>  👈 IE9+ 不只是阻止冒泡，也会中断事件的捕获。</li><li><code>window.event.cancelBubble = true</code> 👈 IE6~8</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-keyword">if</span>(e.preventPropagation) &#123;<br>        e.preventPropagation();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        e.cancelBubble = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="冒泡的应用：事件委托"><a href="#冒泡的应用：事件委托" class="headerlink" title="冒泡的应用：事件委托"></a>冒泡的应用：事件委托</h4><p>事件委托也称为事件代理，在jQuery中也叫做事件委派。</p><p><strong>原理：</strong></p><p>不是在每个子节点上单独设置事件监听器，而是在父节点上设置事件监听器，然后利用冒泡原理监听所有子节点的某个事件。</p><hr><h4 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h4><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标左键单击一次触发</td></tr><tr><td>ondbclick</td><td>鼠标左键双击一次触发</td></tr><tr><td>onmouseover</td><td>鼠标进入元素范围触发，<code>会进行冒泡</code>。</td></tr><tr><td>onmouseout</td><td>鼠标离开元素范围触发，<code>会进行冒泡</code>。</td></tr><tr><td>onfocus</td><td>获得鼠标焦点</td></tr><tr><td>onblur</td><td>失去鼠标焦点</td></tr><tr><td>onmousemove</td><td>鼠标在元素范围内移动“1px”触发。</td></tr><tr><td>onmousedown</td><td>鼠标按下一次触发。滚轮、右键、上下翻页键也会触发。</td></tr><tr><td>onmouseup</td><td>鼠标松开一次触发。滚轮、右键、上下翻页键也会触发。</td></tr><tr><td>onmouseenter</td><td>鼠标进入元素范围触发，<code>不会冒泡</code>。⭐</td></tr><tr><td>onmouseleave</td><td>鼠标离开元素范围触发，<code>不会冒泡</code>。⭐</td></tr></tbody></table><ul><li><p>onmousedown事件，单次点击只会触发一次，直到松开鼠标键后才会触发下一次。</p></li><li><p>onmouseenter/ onmouseleave 和 onmouseover/ onmouseout 之间的区别是 “是否会触发冒泡”。</p><p>前一组不会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>不会触发</code>父容器的鼠标enter/ leave。</p><p>后一组会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>会多次触发</code>父容器的鼠标over/ out。</p><blockquote><p><strong>mouseover和mouseenter的另外一个区别</strong></p><p>鼠标从父容器独有的范围内进入后代元素的范围，会先触发父容器的mouseout，再触发后代元素的mouseover，然后再冒泡父容器的mouseover。</p><p>鼠标从后代元素范围中挪出，进入父容器独有的范围会先冒泡onmouseout， 然后再次触发父容器的onmouseover。</p></blockquote></li></ul><p><strong>鼠标事件对象的属性</strong></p><ul><li><p><code>type</code>属性标识了鼠标事件的类型，如click, mousedown, mouseenter等。</p></li><li><p><code>which</code>属性标识了鼠标按键。</p><p>1：没有按键或左键</p><p>2：滚轮按下</p><p>3：右键</p></li><li><p><code>clientX</code> / <code>clientY</code> 属性，是鼠标事件发生的位置相对于浏览器视口左上角的偏移量。</p></li><li><p><code>pageX</code> / <code>pageY</code> 属性，是鼠标事件发生的位置相对于页面（布局视口）左上角的偏移量。不论页面怎么滚动，鼠标点击页面中同一位置时，event.pageX 和 event.pageY的值不会发生改变。</p><blockquote><p>pageX / pageY属性仅在 IE9+中支持。</p></blockquote></li><li><p><code>screenX</code> / <code>screenY</code> 属性，是鼠标事件发生的位置相对于设备屏幕左上角的偏移量。</p></li></ul><hr><h4 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h4><table><thead><tr><th>键盘事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键松开时会<code>触发一次</code>。⭐ 尽可能用onkeyup，因为不会不断触发。</td></tr><tr><td>onkeydown</td><td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td></tr><tr><td>onkeypress</td><td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td></tr></tbody></table><p>onkeydown和onkeypress的区别在于：</p><ol><li><p>onkeypress不会识别功能键。即Backspace、ctrl、alt、shift、箭头方向键按下时，不会触发onkeypress事件。</p><p>而onkeydown能够识别功能键。</p></li><li><p>onkeydown不区分按键的大小写，即按下a和大写A时都认为按下了”a”，keyCode都是97。</p></li><li><p>在函数执行顺序上，onkeydown事件绑定的响应函数会先于onkeypress事件绑定的响应函数。</p></li></ol><blockquote><p>在input标签中onkeydown/ onkeypress事件的回调函数会先于input标签更新value执行。</p><p>所以要获取键盘输入后的input的value值，应该在onkeyup的响应函数中才能获取。</p></blockquote><p><strong>键盘事件对象的属性</strong></p><ul><li><p><code>keyCode</code>属性</p><p>键盘键位的asc码值</p></li></ul><ul><li><p><code>key</code>属性，IE9+支持</p><p>键盘键位的特征字符串</p><ol><li>回车 Enter</li><li>退格 Backspace</li><li>大写键 CapsLock</li><li>大写键盘开启按a A</li><li>….</li></ol></li></ul><hr><h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p><strong>1. 阻止鼠标右键菜单的显示</strong></p><p><code>contextmenu</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault()); <span class="hljs-comment">// 这里好像不能用return false</span><br><span class="hljs-comment">// html.addEventListener(&#x27;contextmenu&#x27;, e =&gt; e.preventDefault()); 对html绑定也可以</span><br><span class="hljs-comment">// 对其他指定DOM元素绑定也可以，实现阻止局部范围内右键菜单的显示。</span><br></code></pre></td></tr></table></figure><p><strong>2. 不允许选中内容</strong></p><p><code>selectstart</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault());<br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model，浏览器对象模型，它提供独立于内容而与浏览器窗口进行交互的对象，其<code>核心+顶级</code>的对象是window。</p><p>简而言之，BOM为我们提供了一组对象，用来完成对浏览器的操作。</p><blockquote><p>BOM缺乏标准， JavaScript语法的标准化组织是ECMA，DOM的标准化阻止是W3C，而BOM最初是Netscape浏览器标准的一部分。</p></blockquote><h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><p>BOM比DOM更大，它包含了DOM。</p><p><img src="/./image-20210123104526159.png" alt="image-20210123104526159"> </p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p><font color="red">window对象是浏览器的顶级对象，它具有双重角色</font></p><ol><li><p>它是JS访问浏览器的一个接口</p></li><li><p>它是一个全局对象。定在<code>全局作用域中的变量和函数</code>会分别成为<code>window对象的属性和方法</code>。</p><p>在调用全局函数、访问全局变量时，可以省略书写window。</p><blockquote><p>注意：window下存在一个特殊属性window.name，所以不要在全局作用域中用”name”作为变量名。</p></blockquote></li></ol><hr><h4 id="onload事件"><a href="#onload事件" class="headerlink" title="onload事件"></a>onload事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    ...<br>&#125;;<br><br><span class="hljs-comment">// 或者使用标准方法可绑定多个页面加载完成的响应函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><p>window.onload是窗口（页面）加载事件，当文档的内容<code>完全加载完成</code>后才会触发该事件，<code>包括图像的加载、脚本文件、CSS文件等</code>。</p><hr><h4 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br><span class="hljs-comment">// 这个事件只能这样绑定响应函数</span><br></code></pre></td></tr></table></figure><p>DOMContentLoaded事件会在<code>DOM加载完成时</code>就触发，<code>不会等待图片、flash、样式表的加载</code>。</p><blockquote><p>❗ 兼容性：IE9+支持，且只能使用标准方法绑定响应函数。</p></blockquote><p>如果<code>页面的图片很多</code>的话，从页面打开到onload事件触发可能需要很长的事件，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适。</p><hr><h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-comment">// </span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure><p>window.onresize是调整浏览器窗口大小的事件。</p><p>只要窗口的尺寸发生变化，就会触发这个事件。我们会利用这个事件完成<code>响应式布局、移动端适配</code>等，会用到相关的属性有<code>window.innerWidth</code>、<code>window.innerHeigth</code>。</p><blockquote><p>⭐区别：window.innerWidth / window.innerHeight和documentElement.clientWidth、clientHeight都是描述浏览器视口尺寸的属性，他们的区别在于前一组包含html滚动条的宽度，后一组不包含html滚动条的宽度。</p><p>此外，window还有<code>outerWidth</code>和<code>outerHeight</code>属性，他们表示整个浏览器窗口的尺寸，包含菜单、工具栏等。</p></blockquote><hr><h4 id="对话框方法"><a href="#对话框方法" class="headerlink" title="对话框方法"></a>对话框方法</h4><ol><li><p><code>alert(message)</code> 显示带有一段消息和一个确认按钮的对话框。</p><blockquote><p>参数message是对话框中要显示的信息。</p></blockquote></li></ol><ol start="2"><li><p><code>confirm(message)</code>显示带有一段消息和确认、取消两个按钮的对话框。</p><blockquote><p><code>message参数</code>是对话框中的提示信息，confirm方法会<code>返回一个布尔值</code>，当用户点击确认会返回<code>true</code>，取消会返回<code>false</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;当前操作会引发危险，是否继续？&#x27;</span>);<br><span class="hljs-keyword">if</span>(ret) &#123;<br>    <span class="hljs-comment">// continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// stop</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><code>prompt(message, value)</code>显示可提示用户输入的对话框。</p><blockquote><p><code>message参数</code>是对话框中的提示信息，<code>value参数</code>是输入框中的默认值，默认为空字符串。<code>prompt方法会返回一个字符串</code>，该字符串是用户在对话框的输入框中输入的内容。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.prompt(<span class="hljs-string">&#x27;请输入您想输入的内容&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(ret);<br></code></pre></td></tr></table></figure></li></ol><h4 id="定时器方法"><a href="#定时器方法" class="headerlink" title="定时器方法"></a>定时器方法</h4><ol><li><p><code>setTimeout(cb, timeout) / clearTimeout(timer)</code></p></li><li><p><code>setInterval(cb, interval) / clearInterval(timer)</code></p></li></ol><hr><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是window对象的一个属性，它提供了读写浏览器窗体的URL的接口，并且封装了对URL的解析结果。</p><p>URL的一般语法格式为：</p><p><code>protocol://hostName[:port]/path/[?query]#fagnent</code></p><h4 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h4><ol><li><code>href</code> 整个URL</li><li><code>protocol</code> 协议名 + “:”</li><li><code>host</code> IP地址 / 域名 + 端口号</li><li><code>port</code> url显式的端口号，如果是域名，则该值为空串</li><li><code>hostname</code> IP地址 / 域名</li><li><code>pathname</code> path字符串，”/“ 开头</li><li><code>search</code> query字符串，”?” 开头</li><li><code>hash</code> fragnent字符串，”#” 开头</li></ol><h4 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h4><ol><li><p><code>assign(url)</code> </p><p>用于跳转页面，作用和直接修改<code>location</code>或<code>location.href</code>效果相同。</p></li><li><p><code>replace(url)</code></p><p>同样是用于跳转页面，用法和<code>assign</code>相同，但会重置栈顶并跳转，即无法回退到前一个url对应的页面。</p></li><li><p><code>reload([forcedReload])</code></p><p>用于刷新页面，作用相当于按下<code>F5</code>。forcedReload参数可选，表示是否强制清除缓存，如果为<code>true</code>，相当于按下<code>ctrl+F5</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.reload(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="通过location对象进行页面跳转"><a href="#通过location对象进行页面跳转" class="headerlink" title="通过location对象进行页面跳转"></a>通过location对象进行页面跳转</h4><p>实现跳转的方法有很多：</p><ul><li>```javascript<br>location = url;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.href = url<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><pre><code class="javascript">location.assign(url);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.replace(url)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>&gt; url要求是一个字符串类型，可以是完整的url，也可以是相对路径，也可以是以&quot;/&quot;开头的根路径。</code></pre></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.assign(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;image/1.png&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;../index.html&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;/index.html&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>window对象的history属性让我们能够与浏览器的历史记录进行交互。</p><h4 id="history对象的属性"><a href="#history对象的属性" class="headerlink" title="history对象的属性"></a>history对象的属性</h4><ol><li><p><code>length</code></p><p>可以获取到当前访问过的链接数量，其实就是保存访问url顺序的栈结构的长度。</p></li></ol><h4 id="前后跳转页面的方法"><a href="#前后跳转页面的方法" class="headerlink" title="前后跳转页面的方法"></a>前后跳转页面的方法</h4><ol><li><p><code>history.go(n)</code></p><p>传入一个整数参数，表示跳转步长，正为前进，负为后退。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">history.go(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>history.back()</code></p><p>回退到上一个页面，作用和浏览器回退按钮一样，相当于<code>history.go(-1)</code>。</p></li><li><p><code>history.forward()</code></p><p>跳转到下一个页面，作用和浏览器前进按钮一样，相当于<code>history.go(1)</code>。</p></li></ol><h4 id="H5新增方法（与前端路由相关）"><a href="#H5新增方法（与前端路由相关）" class="headerlink" title="H5新增方法（与前端路由相关）"></a>H5新增方法（与前端路由相关）</h4><p>🐕 后续补充</p><hr><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象包含有关客户端的信息，它有很多熟悉，我们最常用的是<code>navigator.userAgent</code>。</p><p><code>navigator.userAgent </code>是一个只读的字符串，声明了浏览器用于 <code>HTTP 请求的用户代理头</code>的值。</p><p><code>User-Agent</code>是HTTP请求中的用户标识，一般发送一个能够代表客户端类型的字符串，比如浏览器类型 操作系统等信息。User-Agent 的约定格式是：应用名，跟一个斜线，跟版本号，剩下的是自由的格式。</p><blockquote><p>一般都是以 Mozilla/5.0 开头</p></blockquote><p>对于前端而言：</p><p><code>navigator.userAgent</code>可以帮助我们识别设备、平台、浏览器，从而进行兼容处理。</p><blockquote><p>根据具体情况，到百度查找识别方法。因为navigator.userAgent属性值千奇百怪，缺乏标准。</p></blockquote><p>对于后端而言：</p><p><code>navigator.userAgent</code>会赋值给<code>HTTP</code>中头部信息的<code>User-Agent</code>，用于通知后端HTTP请求来源于什么设备、什么平台、什么浏览器。</p><hr><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>PC端一般不用。🐕 后续补充内容</p><hr>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scss</title>
    <link href="/2021/03/25/CSS/scss/"/>
    <url>/2021/03/25/CSS/scss/</url>
    
    <content type="html"><![CDATA[<h1 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h1><h2 id="不依赖于IDE的sass安装"><a href="#不依赖于IDE的sass安装" class="headerlink" title="不依赖于IDE的sass安装"></a>不依赖于IDE的sass安装</h2><h3 id="node-sass"><a href="#node-sass" class="headerlink" title="node-sass"></a>node-sass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g node-sass<br></code></pre></td></tr></table></figure><p><strong>基本使用</strong></p><ul><li><p>单文件编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span>-sass  原有的scss文件 生成的css文件<br><span class="hljs-variable">$node</span>-sass  原有的scss文件 -o 生成目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass a.scss b.css<br><span class="hljs-variable">$node</span>-sass a.scss css_files<br></code></pre></td></tr></table></figure></li><li><p>多文件编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span>-sass 原有的scss文件目录 -o 生成的css文件目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass c -o d<br></code></pre></td></tr></table></figure></li><li><p>文件监听模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在&quot;1&quot;和&quot;2&quot;的基础上填加&quot;-w&quot;命令行参数即可</span><br><span class="hljs-variable">$node</span>-sass -w 原有的scss文件 -o 输出目录 <span class="hljs-comment">#编译的结果会保存在输出目录的同名文件</span><br><span class="hljs-variable">$node</span>-sass -w 原有的scss文件目录 -o css文件输出目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass -w a.scss -o css<br><span class="hljs-variable">$node</span>-sass -w scss -o css<br><br><span class="hljs-comment"># 效果：编译进程不结束，监听文件内容</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs">  <br>  <br><br>&gt; -o 相当于--output，之后跟输出的目录<br>&gt;<br>&gt; -w 参数相当于--watch， 不跟参数值，用于监听目标文件/目录<br><br><br><br>## 注释<br><br>1. Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会, 所以后者亦称作`静默注释`。<br><br>2. 将 `!` 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。<br><br>3. 插值语句 (interpolation) 也可写进多行注释中输出变量值<br><br>例如：<br><br>​```scss<br>/* <br>hello<br>world!<br>*/<br><br>// compile scss files to css<br>// it&#x27;s ready to do it.<br>$pink: #f3e1e1;<br><span class="hljs-attribute">html&#123;</span><br>    background-color: $pink;<br>&#125;<br><br>$author: &#x27;gdream@126.com&#x27;;<br>/*!<br>Author: #&#123;$author&#125;.   语法👉 #&#123;插值内容&#125;<br>*/<br></code></pre></td></tr></table></figure><p>开发模式编译后：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* </span><br><span class="hljs-comment">hello</span><br><span class="hljs-comment">world!</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">html</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f3e1e1</span>;<br>&#125;<br><span class="hljs-comment">/*!</span><br><span class="hljs-comment">Author: &#x27;gdream@126.com&#x27;.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$width</span>: <span class="hljs-number">1600px</span>;<br><span class="hljs-variable">$pen-size</span>: <span class="hljs-number">3em</span>;<br></code></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>直接使用变量的名称即可调用变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#app</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-variable">$width</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$pen-size</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明 </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#foo</span> &#123;<br>  <span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span> !global;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-id">#bar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#foo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-id">#bar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>SassScript 支持 7 种主要的数据类型：</p><ul><li><p>数字，<code>1, 2, 13, 10px, 5a</code> </p><blockquote><p>整数/小数 [+ 英文单位]</p></blockquote></li><li><p>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></p><blockquote><p>尽量使用带双引号的字符串</p></blockquote></li><li><p>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></p></li><li><p>布尔型，<code>true, false</code></p></li><li><p>空值，<code>null</code></p><blockquote><p>不常用，一般用在逻辑判断中</p></blockquote></li><li><p>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></p></li><li><p>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></p></li></ul><p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p><p>判断数据类型的方式：<code>type-of($value)</code></p><h3 id="1-字符串-Strings"><a href="#1-字符串-Strings" class="headerlink" title="1.字符串 (Strings)"></a>1.字符串 (Strings)</h3><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$name</span>: <span class="hljs-string">&#x27;Tom Bob&#x27;</span>;<br><span class="hljs-variable">$container</span>: <span class="hljs-string">&quot;top bottom&quot;</span>;<br><span class="hljs-variable">$what</span>: heart;<br></code></pre></td></tr></table></figure><blockquote><p>注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 <code>#&#123;&#125;</code> (interpolation)  /ɪnˌtɜːpəˈleɪʃn/ 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$div</span>: <span class="hljs-string">&quot;div&quot;</span>;<br><span class="hljs-keyword">@mixin</span> boxFontSize(<span class="hljs-variable">$index</span>, <span class="hljs-variable">$fontSize</span>) &#123;<br><span class="hljs-selector-class">.box-</span>#&#123;<span class="hljs-variable">$index</span>&#125; &#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$fontSize</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-selector-tag">html</span> &#123;<br><span class="hljs-keyword">@include</span> boxFontSize(<span class="hljs-number">1</span>, <span class="hljs-number">16px</span>);<br>&#125;<br><br><span class="hljs-comment">// 编译结果 👇</span><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-class">.box-1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="2-数字-Numbers"><a href="#2-数字-Numbers" class="headerlink" title="2.数字(Numbers)"></a>2.数字(Numbers)</h3><p>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可整可浮点）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$my-age</span>: <span class="hljs-number">19</span>;<br><span class="hljs-variable">$your-age</span>: <span class="hljs-number">19.5</span>;<br><span class="hljs-variable">$height</span>: <span class="hljs-number">120px</span>;<br><br><span class="hljs-comment">// 注：单位会和数字当做一个整体，进行算数运算</span><br></code></pre></td></tr></table></figure><h3 id="3-空值-Null"><a href="#3-空值-Null" class="headerlink" title="3.空值(Null)"></a>3.空值(Null)</h3><p>只有一个取值<code>null</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$value</span>: null;<br><br><span class="hljs-comment">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span><br></code></pre></td></tr></table></figure><h3 id="4-布尔型-Booleans"><a href="#4-布尔型-Booleans" class="headerlink" title="4.布尔型(Booleans)"></a>4.布尔型(Booleans)</h3><p>只有两个取值：<code>true</code>和<code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: true;<br><span class="hljs-variable">$b</span>: false;<br></code></pre></td></tr></table></figure><blockquote><p>注：只有自身是false和null在逻辑判断时才会返回false，其他一切都将返回true</p></blockquote><h3 id="5-数组-Lists"><a href="#5-数组-Lists" class="headerlink" title="5.数组 (Lists)"></a>5.数组 (Lists)</h3><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$list0</span>: <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">6px</span>;<br><span class="hljs-variable">$list1</span>: <span class="hljs-number">1px</span> <span class="hljs-number">2px</span>, <span class="hljs-number">5px</span> <span class="hljs-number">6px</span>;<br><span class="hljs-variable">$list2</span>: (<span class="hljs-number">1px</span> <span class="hljs-number">2px</span>) (<span class="hljs-number">5px</span> <span class="hljs-number">6px</span>);<br></code></pre></td></tr></table></figure><p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p><p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p><p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p><p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p><h3 id="6-映射-Maps"><a href="#6-映射-Maps" class="headerlink" title="6.映射(Maps)"></a>6.映射(Maps)</h3><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$map</span>: ( <br>  key1: value1, <br>  key2: value2, <br>  key3: value3,<br>  <span class="hljs-string">&quot;1&quot;</span> : value4,<br>   <span class="hljs-number">1</span>: value5     // <span class="hljs-string">&quot;1&quot;</span>和<span class="hljs-number">1</span> 是不同数据类型，是不同的键<br>)<br></code></pre></td></tr></table></figure><blockquote><p>Maps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键和值之间用<code>冒号</code>连接，键值对之间用<code>逗号</code>分割 。</p><p>Maps中的<code>keys和values</code>可以是sass script的<code>任何数据类型</code>。（包括任意的sassscript表达式 arbitrary SassScript expressions）</p><p>和Lists一样，Maps主要为sass script函数服务，</p><p>如 map-get函数用于查找键值，</p><p>map-get($map, key1)、map-get($map, “key1”)</p><p>map-merge函数用于map和新加的键值融合，</p><p>@each命令可添加样式到一个map中的每个键值对。</p><p>Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。</p></blockquote><h3 id="7-颜色-Colors"><a href="#7-颜色-Colors" class="headerlink" title="7.颜色 (Colors)"></a>7.颜色 (Colors)</h3><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词。</p><p>SCSS提供了与颜色有关的内置函数，从而使用户能够更方便地使用颜色。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color0</span>: green;<br><span class="hljs-variable">$color1</span>: lighten(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color2</span>: darken(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color3</span>: saturate(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color4</span>: desaturate(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color5</span>: (green + red);<br></code></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h3><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p><p>如果要保留运算符号，则应该使用插值语法</p><ul><li><p><code>+</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 纯数字</span><br><span class="hljs-variable">$add1</span>: <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<span class="hljs-comment">// 3</span><br><span class="hljs-variable">$add2</span>: <span class="hljs-number">1</span> + <span class="hljs-number">2px</span>; <span class="hljs-comment">// 3px</span><br><span class="hljs-variable">$add3</span>: <span class="hljs-number">1px</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 3px</span><br><span class="hljs-variable">$add4</span>: <span class="hljs-number">1px</span> + <span class="hljs-number">2px</span>;<span class="hljs-comment">//3px</span><br><br><span class="hljs-comment">// 纯字符串</span><br><span class="hljs-variable">$add5</span>: <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// &quot;ab&quot;</span><br><span class="hljs-variable">$add6</span>: <span class="hljs-string">&quot;a&quot;</span> + b;  <span class="hljs-comment">// &quot;ab&quot;</span><br><span class="hljs-variable">$add7</span>: a + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// ab</span><br><span class="hljs-variable">$add8</span>: a + b;  <span class="hljs-comment">// ab</span><br><br><span class="hljs-comment">// 数字和字符串</span><br><span class="hljs-variable">$add9</span>: <span class="hljs-number">1</span> + a;<span class="hljs-comment">// 1a</span><br><span class="hljs-variable">$adda</span>: a + <span class="hljs-number">1</span>;<span class="hljs-comment">// a1</span><br><span class="hljs-variable">$addb</span>: <span class="hljs-string">&quot;1&quot;</span> + a; <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-variable">$addc</span>: <span class="hljs-number">1</span> + <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-variable">$addd</span>: <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// &quot;a1&quot;</span><br><span class="hljs-variable">$adde</span>: a + <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// a1</span><br><span class="hljs-variable">$addf</span>: <span class="hljs-number">1</span> + <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// &quot;11&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 总结：</span><br><span class="hljs-selector-tag">a</span>.纯数字：只要表达式中某个数字值带有单位，则结果必有单位。<br><span class="hljs-selector-tag">b</span>.纯字符串：第一个字符串有无引号决定结果是否有引号<br>c数字和字符串：结果一定为字符串。数字与字符串的加法表达式中，最靠左的字符串字面量是否带引号，将决定相加的结果字符串是否带引号。<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>-</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$add1</span>: <span class="hljs-number">1</span> - <span class="hljs-number">2</span>;<span class="hljs-comment">// -1</span><br><span class="hljs-variable">$add2</span>: <span class="hljs-number">1</span> - <span class="hljs-number">2px</span>; <span class="hljs-comment">// -1px</span><br><span class="hljs-variable">$add3</span>: <span class="hljs-number">1px</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// -1px</span><br><span class="hljs-variable">$add4</span>: <span class="hljs-number">1px</span> - <span class="hljs-number">2px</span>;<span class="hljs-comment">//-1px</span><br><br><span class="hljs-variable">$sub1</span>: a - <span class="hljs-number">1</span>;  <span class="hljs-comment">// a-1</span><br><span class="hljs-variable">$sub2</span>: <span class="hljs-number">1</span> - a;  <span class="hljs-comment">// 1-a</span><br><span class="hljs-variable">$sub3</span>: <span class="hljs-string">&quot;a&quot;</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">// &quot;a&quot;-1</span><br><span class="hljs-variable">$sub4</span>: a - <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-comment">// a-&quot;1&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>减法表达式中出现字符串类型， 则整个表达式视作一个字符串。</p></blockquote></li></ul><ul><li><p><code>*</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$num1</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2</span>;    <span class="hljs-comment">// 2</span><br><span class="hljs-variable">$mul2</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2px</span>;  <span class="hljs-comment">// 2px</span><br><span class="hljs-variable">$num3</span>: <span class="hljs-number">1px</span> * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 2px</span><br><span class="hljs-variable">$num4</span>: <span class="hljs-number">2px</span> * <span class="hljs-number">2px</span>;<span class="hljs-comment">// 编译不通过</span><br><br><span class="hljs-variable">$num5</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2</span>abc; <span class="hljs-comment">// 2abc</span><br></code></pre></td></tr></table></figure><blockquote><p>允许至多一个带单位的数字出现在乘号两侧。</p></blockquote></li></ul><ul><li><p><code>/</code></p><blockquote><p>不会四舍五入，精确到小数点后5位。</p><p>被除数允许带单位，除数不允许带单位。</p></blockquote></li></ul><ul><li><p><code>%</code></p><blockquote><p>表达式两侧的值与”%”之间必须要有空格，否则会被看做字符串</p></blockquote></li></ul><h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h3><p>大前提：两端必须为<code>数字类型</code>， 单位不同的数字之间无法比较。 </p><p>返回值：<code>true</code> or <code>false</code></p><ul><li><p><code>&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>&gt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt;= <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-相等运算符"><a href="#3-相等运算符" class="headerlink" title="3.相等运算符"></a>3.相等运算符</h3><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p><p>返回值：<code>true</code> or <code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> == <span class="hljs-number">1px</span>; <span class="hljs-comment">// true</span><br><span class="hljs-variable">$b</span>: <span class="hljs-string">&quot;a&quot;</span> == a; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>数字类型相比较，只比较数字部分，不比较单位。</p><p>字符串类型相比较，有无引号不影响结果，只比较各个位置字符是否相同。</p></blockquote><h3 id="4-布尔运算符"><a href="#4-布尔运算符" class="headerlink" title="4.布尔运算符"></a>4.布尔运算符</h3><p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span> and <span class="hljs-number">0</span>&gt;=<span class="hljs-number">5</span>; <span class="hljs-comment">// fasle</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 总结：</span><br>值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure><h3 id="5-颜色值运算"><a href="#5-颜色值运算" class="headerlink" title="5.颜色值运算"></a>5.颜色值运算</h3><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p><ul><li><p><code>颜色值与颜色值</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#010203</span> + <span class="hljs-number">#040506</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#050709</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>颜色值与数字</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#010203</span> * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#020406</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>RGB和HSL</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span><br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: rgba(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>) + rgba(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>);<br>&#125;<br><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: rgba(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>); &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-运算优先级"><a href="#6-运算优先级" class="headerlink" title="6.运算优先级"></a>6.运算优先级</h3><ol start="0"><li><p><code>()</code></p></li><li><p><code>*</code>、<code>/</code>、<code>%</code></p></li><li><p><code>+</code>、<code>-</code></p></li><li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p></li></ol><hr><h2 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h2><h3 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h3><p>scss允许css选择器进行嵌套，表示父子关系。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br>&#125;<br><span class="hljs-comment">// 编译后 👇 css</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><h3 id="CSS属性嵌套"><a href="#CSS属性嵌套" class="headerlink" title="CSS属性嵌套"></a>CSS属性嵌套</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">font</span>: &#123;  // 👈 注意这里有个冒号，是与选择器嵌套的区别<br>        family: Arial;<br>        size: <span class="hljs-number">16px</span>; &#125;<br>    <span class="hljs-attribute">margin</span>: &#123;<br>left: <span class="hljs-number">20px</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">40px</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译后👇 css</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">40px</span>; &#125;<br><br></code></pre></td></tr></table></figure><h2 id="模板字符串-插值语法"><a href="#模板字符串-插值语法" class="headerlink" title="模板字符串(插值语法)"></a>模板字符串(插值语法)</h2><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p><p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$name</span>: foo;<br><span class="hljs-variable">$attr</span>: border;<br><span class="hljs-selector-tag">p</span>.#&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br>  #&#123;<span class="hljs-variable">$attr</span>&#125;-<span class="hljs-attribute">color</span>: <span class="hljs-variable">$name</span>;<br>&#125;<br><br><span class="hljs-comment">// 编译后：</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.foo</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: foo;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父选择器"><a href="#父选择器" class="headerlink" title="父选择器"></a>父选择器</h2><p><code>&amp;</code>为父选择器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span>&#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>    &amp;<span class="hljs-selector-pseudo">:active</span>&#123;<br>        <span class="hljs-attribute">color</span>: blank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="default-和-global"><a href="#default-和-global" class="headerlink" title="!default 和 !global"></a>!default 和 !global</h2><h3 id="default"><a href="#default" class="headerlink" title="!default"></a>!default</h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p><blockquote><p>这个语法主要在scss的文件模块化时起作用。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$content</span>: <span class="hljs-string">&quot;First content&quot;</span>;<br><span class="hljs-variable">$content</span>: <span class="hljs-string">&quot;Second content?&quot;</span> !default;<br><span class="hljs-variable">$new_content</span>: <span class="hljs-string">&quot;First time reference&quot;</span> !default;<br><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-variable">$content</span>;<br>  new-<span class="hljs-attribute">content</span>: <span class="hljs-variable">$new_content</span>;<br>&#125;<br><br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;First content&quot;</span>;<br>  new-<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;First time reference&quot;</span>; &#125;<br></code></pre></td></tr></table></figure><p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。 </p><h3 id="global"><a href="#global" class="headerlink" title="!global"></a>!global</h3><p>将局部变量提升为全局变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#foo</span> &#123;<br>    <span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span> !global;<br>&#125;<br><span class="hljs-selector-id">#bar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块化指令-import"><a href="#模块化指令-import" class="headerlink" title="模块化指令 @import"></a>模块化指令 @import</h2><h3 id="基本使用与注意点"><a href="#基本使用与注意点" class="headerlink" title="基本使用与注意点"></a>基本使用与注意点</h3><p>Sass <code>拓展了css的 @import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p><blockquote><p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。即以下情况的<code>@import</code>被当作css语句执行。</p><ul><li>文件拓展名是 <code>.css</code>；</li><li>文件名以 <code>http://</code> 开头；</li><li>文件名是 <code>url()</code>；</li><li><code>@import</code> 包含 media queries。</li></ul></blockquote><p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a/bar.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a/bar&quot;</span><br>// 以上两种方式均可<br><br><br>// 以下方式均不可行<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo.css&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo&quot;</span> screen;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;http://foo.com/bar&quot;</span>;<br><span class="hljs-keyword">@import</span> url(foo);<br></code></pre></td></tr></table></figure><h3 id="导入多个文件"><a href="#导入多个文件" class="headerlink" title="导入多个文件"></a>导入多个文件</h3><p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;rounded-corners&quot;</span>, <span class="hljs-string">&quot;text-shadow&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="路径插值"><a href="#路径插值" class="headerlink" title="路径插值"></a>路径插值</h3><p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于<code>CSS</code>的 <code>url()</code> 导入方式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$family</span>: unquote(<span class="hljs-string">&quot;Droid+Sans&quot;</span>);<br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=\#&#123;$family&#125;&quot;</span>);<br><br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>如果你有一个 SCSS 或 Sass <code>模板文件</code>需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以<code>在文件名前面加一个下划线</code>，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;template/_bar.scss&quot;</span>; <br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;template/bar&quot;</span>;  <span class="hljs-comment">// 等价于上面的写法</span><br></code></pre></td></tr></table></figure><blockquote><p>当使用 @import “template/bar” 时，template目录下不允许存在_bar.scss和bar.scss，否则编译器不知道该导入哪个scss文件（出现歧义）</p></blockquote><h3 id="支持在嵌套语法中使用-import"><a href="#支持在嵌套语法中使用-import" class="headerlink" title="支持在嵌套语法中使用@import"></a>支持在嵌套语法中使用@import</h3><p>–b.scss</p><p>–_a.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// _a.scss的内容</span><br><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>:<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// b.scss的内容</span><br><span class="hljs-selector-class">.b</span> &#123;<br>    <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a.scss&quot;</span><br>&#125;<br>// 编译b.scss的结果 👇<br>.b div &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承指令-extend"><a href="#继承指令-extend" class="headerlink" title="继承指令 @extend"></a>继承指令 @extend</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用方法1</span><br><span class="hljs-selector-id">#app</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-id">#app2</span> &#123;<br>    <span class="hljs-keyword">@extend</span> <span class="hljs-number">#a</span>pp;<br>&#125;<br><span class="hljs-comment">// 编译结果👇</span><br><span class="hljs-selector-id">#app</span>, <span class="hljs-selector-id">#app1</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用方法2</span><br>%colorred &#123;    <span class="hljs-comment">// “%”开头的选择器叫做占位选择器，本身不会起实际作用，只能被继承</span><br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.b</span> &#123;<br><span class="hljs-keyword">@extend</span> %colorred;<br><span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><span class="hljs-comment">// 编译结果👇</span><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">color</span>: red; &#125;<br><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black; &#125;<br><br></code></pre></td></tr></table></figure><h2 id="媒体查询扩展-media"><a href="#媒体查询扩展-media" class="headerlink" title="媒体查询扩展 @media"></a>媒体查询扩展 @media</h2><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，<code>包含嵌套的父选择器</code>。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-comment">// 👇 这里的媒体查询规则是作用域父级选择器，即 .sidebar， 而不是.sidebar的子元素</span><br>  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;   <br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为 👇    实际编译后的格式可能与下面不同，但一定是将媒体查询规则提到顶层。</span><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>; <br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;  <br>    <span class="hljs-selector-class">.sidebar</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> screen &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-keyword">@media</span> (orientation: landscape) &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$media</span>: screen;<br><span class="hljs-variable">$feature</span>: -webkit-min-device-pixel-ratio;<br><span class="hljs-variable">$value</span>: <span class="hljs-number">1.5</span>;<br><br><span class="hljs-keyword">@media</span> #&#123;<span class="hljs-variable">$media</span>&#125; and (<span class="hljs-variable">$feature</span>: <span class="hljs-variable">$value</span>) &#123;<br>  .sidebar &#123;<br>    width: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1.5</span>) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="debug"><a href="#debug" class="headerlink" title="@debug"></a>@debug</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$max</span>: <span class="hljs-number">1000px</span>;<br><span class="hljs-keyword">@debug</span> <span class="hljs-variable">$max</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-keyword">@debug</span> <span class="hljs-string">&quot;hello word&quot;</span>;<br>&#125;<br><br>👇 会在控制台输出<br>1000px<br>hello world;<br></code></pre></td></tr></table></figure><p><img src="/./image-20201120194928824.png" alt="image-20201120194928824"></p><h3 id="warn"><a href="#warn" class="headerlink" title="@warn"></a>@warn</h3><p>没试过</p><h3 id="error"><a href="#error" class="headerlink" title="@error"></a>@error</h3><p>没试过</p><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p><em><code>if()</code>语句就是SassScript中的三目运算符</em></p><p>表达式：<code>if(expression, value1, value2)</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: if(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>, green, yellow);<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>: green;&#125;<br></code></pre></td></tr></table></figure><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="@if @else if  @else"></a>@if @else if  @else</h3><p><em>条件语句</em></p><p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p><p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p><ul><li><p><code>单@if</code></p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125; <span class="hljs-keyword">@else</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@if - @else if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$age</span>: <span class="hljs-number">19</span>;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-variable">$age</span> == <span class="hljs-number">18</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125; <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$age</span> == <span class="hljs-number">19</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125; <span class="hljs-keyword">@else</span> &#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><h3 id="for"><a href="#for" class="headerlink" title="@for"></a>@for</h3><p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p><p>through 和 to 的相同点与不同点：</p><ul><li>相同点：两者均包含<start>的值</li><li>不同点：through包含<end>的值，但to不包含<end>的值</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span>; &#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>; &#125;<br><span class="hljs-selector-class">.item-3</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6em</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="@while"></a>@while</h3><p>表达式：<code>@while expression</code></p><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$i</span>: <span class="hljs-number">6</span>;<br><span class="hljs-keyword">@while</span> <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<br>  <span class="hljs-variable">$i</span>: <span class="hljs-variable">$i</span> - <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.item-6</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>; &#125;<br><span class="hljs-selector-class">.item-4</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">8em</span>; &#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="each"><a href="#each" class="headerlink" title="@each"></a>@each</h3><p>表达式：<code>@each $var in $vars</code></p><p><code>$var</code> 可以是任何变量名</p><p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p><ul><li><p>一维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/puma.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/sea-slug.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/egret.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.salamander-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/salamander.png&#x27;</span>); &#125;<br></code></pre></td></tr></table></figure></li><li><p>二维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$cursor</span> in (puma, black, default),<br>                                  (sea-slug, blue, pointer),<br>                                  (egret, white, move) &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-variable">$color</span>;<br>    <span class="hljs-attribute">cursor</span>: <span class="hljs-variable">$cursor</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/puma.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">cursor</span>: default; &#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/sea-slug.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;<br>  <span class="hljs-attribute">cursor</span>: pointer; &#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/egret.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid white;<br>  <span class="hljs-attribute">cursor</span>: move; &#125;<br></code></pre></td></tr></table></figure></li><li><p>maps</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$header</span>, <span class="hljs-variable">$size</span> in (h1: <span class="hljs-number">2em</span>, h2: <span class="hljs-number">1.5em</span>, h3: <span class="hljs-number">1.2em</span>) &#123;<br>  #&#123;<span class="hljs-variable">$header</span>&#125; &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$size</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>; &#125;<br><span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span>; &#125;<br><span class="hljs-selector-tag">h3</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="混合指令-mixin与-include"><a href="#混合指令-mixin与-include" class="headerlink" title="混合指令@mixin与@include"></a>混合指令@mixin与@include</h2><blockquote><p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left&#123;float: left&#125;</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p></blockquote><p>注意：这不是函数！没有返回值！！</p><h3 id="1-定义普通的mixin"><a href="#1-定义普通的mixin" class="headerlink" title="1.定义普通的mixin"></a>1.定义普通的mixin</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 格式：</span><br><span class="hljs-keyword">@mixin</span> name &#123;<br>    <span class="hljs-comment">// 样式....</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example：</span><br><span class="hljs-keyword">@mixin</span> large-text &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    family: Arial;<br>    size: <span class="hljs-number">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-引用混合样式"><a href="#2-引用混合样式" class="headerlink" title="2.引用混合样式"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 格式：</span><br><span class="hljs-keyword">@include</span> name;<br><br><span class="hljs-comment">// 注：无参数或参数都有默认值时，带不带括号都可以</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example：</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@include</span> large-text;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-带参数的mixin"><a href="#3-带参数的mixin" class="headerlink" title="3.带参数的mixin"></a>3.带参数的mixin</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p><p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p><h4 id="a-位置传参"><a href="#a-位置传参" class="headerlink" title="a. 位置传参"></a>a. 位置传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-关键词传参"><a href="#b-关键词传参" class="headerlink" title="b.关键词传参"></a>b.关键词传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-参数默认值"><a href="#c-参数默认值" class="headerlink" title="c.参数默认值"></a>c.参数默认值</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">500px</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">300px</span>);<br>    <span class="hljs-comment">// or</span><br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d-不定参数"><a href="#d-不定参数" class="headerlink" title="d.不定参数"></a>d.不定参数</h4><blockquote><p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数<code>装包为一个数组类型的参数</code>处理。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mar(<span class="hljs-variable">$value</span>...) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-mixin中的”插槽”"><a href="#4-mixin中的”插槽”" class="headerlink" title="4.mixin中的”插槽”"></a>4.mixin中的”插槽”</h3><p>在引用混合样式的时候，可以先将一段代码插入到mixin的插槽中，然后再输出完整的mixin，插入内容将填充 <code>@content</code> 标志的地方</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> example &#123;<br>    <span class="hljs-selector-tag">html</span> &#123;<br>        <span class="hljs-keyword">@content</span>; 👈 <span class="hljs-comment">// 占位&quot;插槽&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> example&#123;  👈 <span class="hljs-comment">// 用&#123;&#125;括起，向插槽中填充内容</span><br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-selector-class">.logo</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译成css的结果👇</span><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="函数指令"><a href="#函数指令" class="headerlink" title="函数指令"></a>函数指令</h2><h3 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1.内置函数"></a>1.内置函数</h3><h4 id="a-字符串函数"><a href="#a-字符串函数" class="headerlink" title="a. 字符串函数"></a>a. 字符串函数</h4><p>SassScript提供的字符串函数包括 引号处理、大小写转换、查询、插入、切片等功能。</p><table><thead><tr><th align="left">函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td align="left">quote($string)</td><td align="center">添加引号</td></tr><tr><td align="left">unquote($string)</td><td align="center">除去引号</td></tr><tr><td align="left">to-lower-case($string)</td><td align="center">变为小写</td></tr><tr><td align="left">to-upper-case($string)</td><td align="center">变为大写</td></tr><tr><td align="left">str-length($string)</td><td align="center">返回$string的长度(汉字算一个)</td></tr><tr><td align="left">str-index($string，$substring)</td><td align="center">返回$substring在$string的位置</td></tr><tr><td align="left">str-insert($string, $insert, $index)</td><td align="center">在$string的$index处插入$insert</td></tr><tr><td align="left">str-slice($string, $start-at, $end-at）</td><td align="center">截取$string的$start-at和$end-at之间的字符串</td></tr></tbody></table><blockquote><p>字符串的索引第一个为1，最后一个为-1；切片两边均为闭区间</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// str-slice 函数测试</span><br><span class="hljs-variable">$str</span>: <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">@debug</span> str-slice(<span class="hljs-variable">$str</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  &gt;&gt;&gt; abc<br></code></pre></td></tr></table></figure><h4 id="b-数字函数"><a href="#b-数字函数" class="headerlink" title="b. 数字函数"></a>b. 数字函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>percentage($number)</td><td align="center">转换为百分比形式</td></tr><tr><td>round($number)</td><td align="center">四舍五入为整数</td></tr><tr><td>ceil($number)</td><td align="center">数值向上取整</td></tr><tr><td>floor($number)</td><td align="center">数值向下取整</td></tr><tr><td>abs($number)</td><td align="center">获取绝对值</td></tr><tr><td>min($number…)</td><td align="center">获取最小值</td></tr><tr><td>max($number…)</td><td align="center">获取最大值</td></tr><tr><td>random($number?:number)</td><td align="center">不传入值：获得0-1的<code>随机小数</code>；<br>传入<code>正整数n</code>：获得0-n的<code>随机整数</code>（<code>左开右闭</code>）</td></tr></tbody></table><blockquote><p>round、ceil、floor、abs、max、min这些函数若传入带单位的数字，其返回值也会带单位。</p></blockquote><h4 id="c-数组函数"><a href="#c-数组函数" class="headerlink" title="c. 数组函数"></a>c. 数组函数</h4><p>提供了访问数组元素、查询指定元素、尾插、合并、对位组合等功能。</p><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>length($list)</td><td align="center">获取数组长度</td></tr><tr><td>nth($list, n) ⭐</td><td align="center">获取指定下标的元素</td></tr><tr><td>set-nth($list, $n, $value)⭐</td><td align="center">返回一个新数组，其值为$list的$n处设置为$value后的新数组。</td></tr><tr><td>join($list1, $list2, $separator)</td><td align="center">返回一个新数组，其值为拼接$list1和list2后的结果；<br>$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>append($list, $val, $separator)</td><td align="center">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>index($list, $value)</td><td align="center">返回$value值在$list中的索引值</td></tr><tr><td>zip($lists…)</td><td align="center">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td></tr></tbody></table><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// zip 函数测试</span><br><span class="hljs-variable">$l1</span>: <span class="hljs-number">1px</span> solid black; <br><span class="hljs-variable">$l2</span>: <span class="hljs-number">2px</span> dashed red;<br><span class="hljs-keyword">@debug</span> zip(<span class="hljs-variable">$l1</span>, <span class="hljs-variable">$l2</span>);  &gt;&gt;&gt; 1px 2px, solid dashed, black red <span class="hljs-comment">// 这里表现为上下两两结合</span><br></code></pre></td></tr></table></figure><h4 id="d-映射函数"><a href="#d-映射函数" class="headerlink" title="d. 映射函数"></a>d. 映射函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>map-get($map, $key)  ⭐</td><td align="center">获取$map中$key对应的$value</td></tr><tr><td>map-merge($map1, $map2)</td><td align="center">合并$map1和$map2，返回一个新$map</td></tr><tr><td>map-remove($map, $key)⭐</td><td align="center">从$map中删除$key，返回一个新$map</td></tr><tr><td>map-keys($map)⭐</td><td align="center">返回$map所有的$key</td></tr><tr><td>map-values($map)⭐</td><td align="center">返回$map所有的$value</td></tr><tr><td>map-has-key($map, $key)</td><td align="center">判断$map中是否存在$key，返回对应的布尔值</td></tr><tr><td>keywords($args)</td><td align="center">返回一个函数的参数，并可以动态修改其值</td></tr></tbody></table><h4 id="e-颜色函数"><a href="#e-颜色函数" class="headerlink" title="e. 颜色函数"></a>e. 颜色函数</h4><ul><li><p><strong>RGB函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>rgb($red, $green, $blue)</td><td align="center">返回一个16进制颜色值</td></tr><tr><td>rgba($red,$green,$blue,$alpha)⭐</td><td align="center">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td></tr><tr><td>red($color)</td><td align="center">从$color中获取其中红色值</td></tr><tr><td>green($color)</td><td align="center">从$color中获取其中绿色值</td></tr><tr><td>blue($color)</td><td align="center">从$color中获取其中蓝色值</td></tr><tr><td>mix($color1,$color2,$weight?)⭐</td><td align="center">按照$weight比例，将$color1和$color2混合为一个新颜色</td></tr></tbody></table></li><li><p><strong>HSL函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th>函数作用</th></tr></thead><tbody><tr><td>hsl($hue,$saturation,$lightness)</td><td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td></tr><tr><td>hsla($hue,$saturation,$lightness,$alpha)</td><td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td></tr><tr><td>saturation($color)</td><td>从一个颜色中获取饱和度（saturation）值</td></tr><tr><td>lightness($color)</td><td>从一个颜色中获取亮度（lightness）值</td></tr><tr><td>adjust-hue($color,$degrees)</td><td>通过改变一个颜色的色相值，创建一个新的颜色</td></tr><tr><td>lighten($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td></tr><tr><td>darken($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td></tr><tr><td>hue($color)</td><td>从一个颜色中获取亮度色相（hue）值</td></tr></tbody></table></li><li><p><strong>Opacity函数</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>alpha($color)/opacity($color)</td><td>获取颜色透明度值</td></tr><tr><td>rgba($color,$alpha)</td><td>改变颜色的透明度</td></tr><tr><td>opacify($color, $amount) / fade-in($color, $amount) ⭐</td><td>使颜色更不透明</td></tr><tr><td>transparentize($color, $amount) / fade-out($color, $amount) ⭐</td><td>使颜色更加透明</td></tr></tbody></table></li></ul><h4 id="f-Introspection函数"><a href="#f-Introspection函数" class="headerlink" title="f. Introspection函数"></a>f. Introspection函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>type-of($value)⭐</td><td align="center">返回$value的类型</td></tr><tr><td>unit($number)⭐</td><td align="center">返回$number的单位</td></tr><tr><td>unitless($number)⭐</td><td align="center">判断$number是否不带单位，返回对应的布尔值</td></tr><tr><td>comparable($number1, $number2)</td><td align="center">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td></tr></tbody></table><h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2.自定义函数"></a>2.自定义函数</h3><blockquote><p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p><p>Params: 与Mixin一致</p><p>函数的作用在于将函数返回值作为scss规则的一部分。</p></blockquote><p><strong>基本格式：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> fn-name(<span class="hljs-variable">$params</span>...) &#123;<br>    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$params</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example:</span><br><span class="hljs-keyword">@function</span> fn-name(<span class="hljs-variable">$params</span>...) &#123;<br>    <span class="hljs-keyword">@return</span> nth(<span class="hljs-variable">$params</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">height</span>: fn-name(<span class="hljs-number">1px</span>);<br>&#125;<br><br><span class="hljs-comment">// compiled:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="细节与展望"><a href="#细节与展望" class="headerlink" title="细节与展望"></a>细节与展望</h2><h3 id="1-细节"><a href="#1-细节" class="headerlink" title="1.细节"></a>1.细节</h3><p>a. @extend、@Mixin和@function的选择</p><p><a href="https://csswizardry.com/2016/02/mixins-better-for-performance/">原文链接</a></p><blockquote><p><code>minxins</code>在网络传输中比<code>@extend</code> 拥有更好的性能.尽管有些文件未压缩时更大，但使用<code>gzip</code>压缩后，依然可以保证我们拥有更好的性能。</p></blockquote><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p><blockquote><p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p><p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p></blockquote><h3 id="2-展望"><a href="#2-展望" class="headerlink" title="2.展望"></a>2.展望</h3><blockquote><p>以上内容算是”基础”部分，但是对于日常开发，我觉得是足够使用的了。</p><p>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x组件化分析</title>
    <link href="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <url>/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue2-x组件化的实现"><a href="#Vue2-x组件化的实现" class="headerlink" title="Vue2.x组件化的实现"></a>Vue2.x组件化的实现</h1><h2 id="从-h-gt-h-app-说起"><a href="#从-h-gt-h-app-说起" class="headerlink" title="从 h =&gt; h(app)说起"></a>从 h =&gt; h(app)说起</h2><p>我们知道，由vue-cli3创建的runtime-only脚手架项目里的<code>main.js</code>文件有这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架项目顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router, <br>  store, <br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在我学习的过程中，常规的创建Vue实例的手段是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el: <span class="hljs-string">&#x27;#app&#x27;</span><br>    template: <span class="hljs-string">&#x27;&lt;app/&gt;&#x27;</span>,<br>    component: &#123;<br>    App<br>&#125;,<br>    router,<br>    store<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>而为什么vue-cli3没有这样做呢？</strong></p><p>因为是脚手架构建runtime-only版本的项目，对于js文件，webpack只是会压缩部分代码，但是不会像对待<code>*.vue</code>文件那样使用<code>vue-loader</code>将main.js中的模板进行编译成render函数。</p><p><strong>但是，那为何不像下面做呢？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-comment">// 此时App已经是一个具有render函数的extendOptions</span><br><span class="hljs-comment">// App: &#123;name: &#x27;Vue&#x27;, data()&#123;...&#125;, render: new Function(`with(this)&#123;...&#125;`)&#125;</span><br>App.router = router<br>App.store = store<br>App.el = <span class="hljs-string">&#x27;#app&#x27;</span><br><span class="hljs-keyword">new</span> Vue(App);<br><br></code></pre></td></tr></table></figure><p>答案是：你当然可以这样做。但相比于原版<code>main.js</code>中不够优雅，当越来越多额外的option选项（如Vuex的store、vue-router的router）需要传给Vue构造函数时，就会越来越丑陋，而且逻辑不够清晰。</p><p>其实我更推荐的做法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    ...App,<br>    store,<br>    router<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>); <span class="hljs-comment">/* 这样创建好的顶级组件实例的根vnode就是一个tag为div的vnode，</span><br><span class="hljs-comment">而不再是一个tag为app的组件vnode /*</span><br></code></pre></td></tr></table></figure><p><strong>接下来我们来从两个问题切入，分析原版的main.js：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router, <br>  store, <br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>第一个问题：</strong>为什么用<code>$mount(&#39;#app&#39;)</code>？</p><p>答案：其实这没啥，因为<code>$mount(&#39;#app&#39;)</code>和在options中设置<code>&#123;el: &#39;#app&#39;&#125;</code>效果是等价的。原因是Vue实例初始化的最后存在一个逻辑是<code>if (vm.$el) vm.$mount(vm.$el)</code>（即vm._init()方法最后几句代码）。</p><blockquote><p>vm.$el属性是在mountComponent(vm, el)时挂载到Vue实例上的：</p><p>el = el &amp;&amp; query(el)；</p><p>vm.$el = el；</p></blockquote><p>如果在创建Vue实例时不传入el属性，则组件实例调用$mount时只会创建自己根vnode和绑定的根elm，而不会将根elm插入到某个父亲DOM元素中。将来可以在某个时机将vnode.elm插入到某个父亲元素中。</p><p><font color='red'>vm.$mount(‘#app’)会调用mountComponent，而mountComponent中会创建vm的渲染watcher，即</font> <code>new Watcher(vm, ()=&gt; vm._update(vm.render()))</code><font color='red'>，Watcher的构造函数第二个参数是一个字符串或一个getter表达式，渲染watcher的getter就是调用一次vm的update方法。渲染watcher实例化时会立刻调用一次getter，这是为了获取初始的value，从而依次执行了update和render，继而使得vm的渲染的流程正式开始了。</font></p><p><strong>第二个问题：</strong>render: h =&gt; h(App)会执行哪些逻辑？h是什么？</p><p>答：h是vm.$createElement，而vm.$createElement是对createElement函数的封装，createElement又是对_createElement的封装。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318222745530.png" alt="image-20210318222745530"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318222705175.png" alt="image-20210318222705175"></p><p> <code>vm.$createElement</code>是一个闭包函数，含有对vm的引用，即保证内层的<code>createElement</code>函数在执行时的上下文环境永远是vm，而不会是其他组件实例。</p><p>而<code>createElement</code>又是对<code>_createElement</code>函数的封装，见下图：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318223450113.png" alt="image-20210318223450113"></p><p><strong>所以，h =&gt; h(App) 的逻辑是：在render函数执行时，将App作为参数tag传入给<code>_createElement</code>并执行。</strong></p><blockquote><p>这里注意为什么App在h中明明是第一个参数，却传给了第二个占位参数tag。</p><p>在vm.$createElement函数的定义中，参数位置发生了改变，并且vm作为自由变量被传入到_createElement参数的第一个位置，形成闭包。</p></blockquote><p>接下来我们就深入<code>_createElement</code>函数一探究竟。</p><h2 id="createElement"><a href="#createElement" class="headerlink" title="_createElement"></a>_createElement</h2><p>如果你了解模板编译，看到往上第二张图就会发现<code>$createElement</code>函数就是代码字符串的<code>_c</code>方法，只是在最后一个参数上不同。<code>vm._c</code>就是在模板编译情况下的render函数需要调用的方法。而不论是<code>$createElement</code>还是<code>vm._c</code>都将最后调用<code>_createElement</code></p><blockquote><p>代码字符串: <code>with(this)&#123; _c(tag, [data], [children])&#125;</code></p></blockquote><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318225101219.png" alt="image-20210318225101219"></p><p><code>_createElement</code>逻辑比较复杂，我们还是从 <code>render: h =&gt; h(app)</code>执行时会发生什么切入。</p><p>我们刚才提到 <code>h =&gt; h(App) </code>的逻辑是：在render函数执行时，将App作为参数tag传入给<code>_createElement</code>并执行。所以tag是App，而App不是String类型，所以会进入上图所示的else部分，即执行createComponent。</p><blockquote><p>这里多说一句，我在一开始展示了另外一种main.js的写法，</p><p>即<code>new Vue(App)</code>，由于App.vue是经过vue-loader编译的，所以App组件的模板编译成了render函数，而App实例的根标签将会是div#app，所以如果使用<code>new Vue(App)</code>，顶层tag会是<code>&#39;div&#39;</code>，会进入上图里第一个if逻辑，即 <code>if (config.isReservedTag(&#39;div&#39;))</code>，从而执行<code>new Vnode(&#39;div&#39;, data, children)</code>。</p></blockquote><p>重新陈述一遍，由于App是编译后的extendOptions，所以是引用类型，h =&gt; h(app)最终要执行<code>createComponent(App, undefined, vm, undefined)</code>。</p><p><strong>这里我们小结一下：</strong><code>_createElement</code>函数的主要逻辑就是</p><p>① 如果tag是一个HTML内置标签，则创建以该标签为tag的根Vnode；</p><p>② 如果tag是String类型，但tag不是HTML内置标签，则认为该tag是组件标签，类似于’<cpn/>‘、’<my-component/>‘这些，则应该到当前vm实例的components属性上查找该子组件的定义并赋值给Ctor变量，Ctor变量的值可能会是子组件的构造函数或extendOptions，然后继续执行createComponent(Ctor, data, vm, children, tag)，创建一个根Vnode。</p><p>③如果tag不是String类型，则该Tag应该是一个子组件的构造函数或extendOptions，执行createComponent(App, undefined, vm, undefined)，创建一个根Vnode。</p><blockquote><p>①~③都会得到一个Vnode，<code>_createElement</code>会返回这个Vnode，最终一层层向上返回值，最终使得<code>vm._render</code>的返回值为该Vnode。</p></blockquote><h2 id="创建组件Vnode：createComponent"><a href="#创建组件Vnode：createComponent" class="headerlink" title="创建组件Vnode：createComponent"></a>创建组件Vnode：createComponent</h2><p>Vue源码中有两个createComponent函数，一个定义在vdom目录下的create-component.js中，另一个定义在vdom目录下的patch.js中的patch方法内部。我们这里将要分析的是前者，<font color='red'>它的作用是接收一些参数，创建一个组件Vnode</font>，而非元素Vnode或文本Vnode。</p><p>_createElement函数会在遇到组件标签或tag实参不是String类型时，执行createComponent。</p><p><strong>我们来分析一下createComponent函数的逻辑，以下为转载内容 + 参杂我的分析：</strong></p><p><a href="https://www.jianshu.com/p/b7535850cddc">参考链接</a></p><pre><code>**createComponent** 的逻辑会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里**针对组件渲染这个 case 主要就 3 个关键步骤：构造子类构造函数，安装组件钩子函数和实例化 vnode**。</code></pre><h3 id="新建一个子类"><a href="#新建一个子类" class="headerlink" title="新建一个子类"></a>新建一个子类</h3><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319104118330.png" alt="image-20210319104118330"></p><p>我们在编写一个组件的时候，通常都是创建一个普通对象，还是以我们的 App.vue 为例，代码如下：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319104314590.png" alt="image-20210319104314590"></p><p>这里HelloWorld是导入的一个extendOptions对象，所以 createComponent 里的代码逻辑会执行到 **baseCtor.extend(Ctor)**。当然， h =&gt; h(App)也是同理，App将会作为第一个实参传给createComponent，也就是赋值给了Ctor，isObject(App)为true，所以也会执行 Ctor = baseCtor.extend(App)。</p><p>在这里 <strong>baseCtor 实际上就是 Vue</strong>，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 函数有这么一段逻辑：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319105227985.png" alt="image-20210319105227985"></p><p> <strong>这里定义的是 Vue.options，而vm.options_base能拿到Vue是经历了两个步骤。</strong></p><p><strong>第一步：首先Vue.extend方法会生成一个子类Ctor</strong>，<strong>extend方法执行过程中会将Vue.options浅复制到Ctor.options上。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extendOptions</span>) </span>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">const</span> Sub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VueComponent</span> (<span class="hljs-params">options</span>) </span>&#123; <br>      <span class="hljs-built_in">this</span>._init(options) <span class="hljs-comment">// 模板方法，_init实际是Vue.prototype的方法</span><br>    &#125;<br>    Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype)  <span class="hljs-comment">// 原型继承的逻辑</span><br>    Sub.prototype.constructor = Sub<br>Sub.superOptions = Super.options<br>    Sub.extendOptions = extendOptions<br>    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)<br>    Sub.options = mergeOptions(<br>      Super.options,<br>      extendOptions<br>    )<br>    Sub[<span class="hljs-string">&#x27;super&#x27;</span>] = Super<br>    <span class="hljs-comment">//....</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们来看一下 <strong>Vue.extend</strong> 函数的定义，在 src/core/global-api/extend.js 中。</p><p> <strong>Vue.extend</strong> 的作用就是构造一个 Vue 的子类，它使用一种非常经典的<strong>原型继承</strong>的方式。子类的原型对象的<code>__proto__</code>属性指向父类的<code>prototype</code>对象，从而继承父类的实例方法。</p><p>然后对 Sub 这个构造函数本身扩展了一些属性（类的属性和方法），如扩展 options、添加全局 API 等；并且对配置中的 props 和 computed 做了规格化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个extendOptions对象重复构造新的子类。</p><p>所以经过在createComponent调用 Vue.extend(CtorExtendOptions)，会将Vue的options与Ctor的options合并，在Ctor.options_base中保存了Vue。</p><p><strong>第二步：这样当我们去实例化Ctor 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑。（这里用到了模板方法设计模式）而vm._init中有下图的这一段逻辑：</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319105309320.png" alt="image-20210319105309320"></p><pre><code>而我们的 createComponent 取的是 **context.$options**，实际上在 src/core/instance/init.js 里 Vue 原型上的 _init 函数中有这么一段逻辑：这样就又将Ctor.options扩展到了vm.$options上。所以我们也就能通过 vm.$options.\_base 拿到 Vue 这个构造函数了。 </code></pre><blockquote><p>小结：任何组件构造器都能通过 <code>options._base</code>拿到Vue，任何组件实例都能通过<code>$options._base</code>拿到Vue。</p></blockquote><h3 id="收集注入内容"><a href="#收集注入内容" class="headerlink" title="收集注入内容"></a>收集注入内容</h3><p>此部分暂时省略，主要逻辑就是将vm的状态以及子组件标签上需要的data进行融合，其目的主要就是产生propsData和parentListener，绑定到组件Vnode的componentOptions上。</p><p>当然还要处理插槽等额外的注入。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153125657.png" alt="image-20210319153125657"></p><h3 id="为组件Vnode安装钩子"><a href="#为组件Vnode安装钩子" class="headerlink" title="为组件Vnode安装钩子"></a>为组件Vnode安装钩子</h3><p>我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a>，它的一个特点是在 <strong>VNode 的 patch 流程中对外暴露了各种时机的钩子函数</strong>，<strong>方便我们做一些额外的事情</strong>，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153446768.png" alt="image-20210319153446768"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153620358.png" alt="image-20210319153620358"></p><p>整个 <strong>installComponentHooks</strong> 的过程就是<strong>把 componentVNodeHooks 的钩子函数合并到 data.hook</strong> 中，在 VNode 执行 patch 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 patch 过程中会详细介绍。这里要注意的是<strong>合并策略</strong>，在合并过程中，如果某个时机的钩子已经存在 data.hook 中，那么通过执行 mergeHook 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。</p><p>这些钩子同样定义在vdom目录下的create-component.js中</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153723962.png" alt="image-20210319153723962"></p><ul><li><p>init钩子用于为该组件Vnode创建一个组件实例。</p></li><li><p>prepatch钩子用于在patch组件Vnode时，更新组件Vnode的数据。</p></li><li><p>insert钩子与keep-alive、vue-router相关。</p></li><li><p>destroy钩子调用时会调用子组件Vnode的组件实例的$destroy()方法，如果用keep-alive包裹只是会取消该子组件的激活状态。</p></li></ul><h3 id="实例化VNode并返回"><a href="#实例化VNode并返回" class="headerlink" title="实例化VNode并返回"></a>实例化VNode并返回</h3><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319160651038.png" alt="image-20210319160651038"></p><p> 最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键。</p><p>到此createComponent会将创建好的组件Vnode传给上层<code>_createElement</code>，然后继续向上返回，直到作为render函数的返回值。</p><p>对于 render：h =&gt; h(app)而言，它的返回值就是一个Vnode，类似于下面这种结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    tag: <span class="hljs-string">&#x27;Vue-component-0&#x27;</span><br>    data: &#123;<br>      hooks: &#123;<br>          init钩子，<br>          prepatch钩子,<br>          insert钩子,<br>          destroy钩子<br>      &#125;  <br>    &#125;,<br>    children: <span class="hljs-literal">undefined</span>,<br>    componentOptions: &#123;<br>        Ctor: App的构造函数<br>        propsData: &#123;...&#125;,<br>        listeners: &#123;...&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行vm-update-vm-render"><a href="#执行vm-update-vm-render" class="headerlink" title="执行vm._update(vm._render())"></a>执行vm._update(vm._render())</h2><p>流程走到<code>vm._update(vm._render)</code>，从之前的介绍可知，render: h =&gt; h(app)得到了一个VNode，接下来我们要对该VNode和旧的Vnode进行patch。等一下，哪来的旧的Vnode？对，此时确实是没有旧的VNode的，所以_update方法对patch做了一层封装。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319165736432.png" alt="image-20210319165736432"></p><p>如果没有preVnode，则调用 vm.$el = vm.<strong>patch</strong>(vm.$el, vnode)。图中解释了，对于第一个Vue实例而言，它是具有$el属性的，因为他使用了$mount(‘#app’)，HTML中的div#app此时就是vm.$el。</p><p>而当存在preVnode时，只需要对新旧Vnode进行patch。</p><blockquote><p>对于除去顶级组件的internalComponent而言，在第一次进行patch时，$el属性都为undefined，所以执行的是</p><p>vm.__patch__(undefined, vm.render())。</p></blockquote><h2 id="执行-patch-vm-el-vnode"><a href="#执行-patch-vm-el-vnode" class="headerlink" title="执行__patch__(vm.$el, vnode)"></a>执行__patch__(vm.$el, vnode)</h2><p>执行该方法会将HTML模板中的div#app替换为由vnode创建的DOM元素。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319170548586.png" alt="image-20210319170548586"></p><p><font color='red'>由于<code>vm.$el</code>是一个真实的DOM元素</font>，根据if else逻辑，代码会执行红框中的代码块。为了简单起见，我们忽略关于SSR的部分。<code>emptyNodeAt()</code>函数会以HTML文件中的div#app为参照，创建一个VNode，并命名为oldVnode。</p><p>Vue的思路是：认为以div#app为模板创建的Vnode是一个旧的vnode，而render函数生成的vnode是新的vnode，新的vnode和oldvnode不是同一个vnode，新的应该替换掉旧的。</p><p>所以接下来的逻辑就是以vnode创建一个DOM元素，替换掉div#app。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319171001006.png" alt="image-20210319171001006"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319171433536.png" alt="image-20210319171433536"></p><p>执行完该方法后，<code>vm.$el = vm._update(vm_render())</code>，即vm.$el等于由vm._render创建的vnode生成的新的DOM元素，也就是App组件实例第一次渲染后对应的DOM元素。</p><h2 id="createElm-vnode-queue-parentElm-refElm"><a href="#createElm-vnode-queue-parentElm-refElm" class="headerlink" title="createElm(vnode, queue, parentElm, refElm)"></a>createElm(vnode, queue, parentElm, refElm)</h2><p>组件第一次渲染时，patch 的过程会调用 <strong>createElm 根据新的vnode创建元素节点及其子节点</strong>。</p><p>来看一下 createElm 的实现，它的定义在 src/core/vdom/patch.js 中：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319194420225.png" alt="image-20210319194420225"></p><p>我们删掉多余的代码，只保留关键的逻辑，这里会判断 <strong>createComponent</strong>(vnode, insertedVnodeQueue, parentElm, refElm) 的返回值，如果为 true 则直接结束，那么接下来看一下 createComponent 方法的实现。</p><h2 id="创建组件实例：createComponent"><a href="#创建组件实例：createComponent" class="headerlink" title="创建组件实例：createComponent"></a>创建组件实例：createComponent</h2><p><code>createElm &gt;&gt; createComponent</code></p><p>createComponent的整体逻辑如下：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319194554511.png" alt="createComponent"></p><p>首先对Vnode进行检测，如果其data属性上挂载了hooks.init说明是一个组件Vnode，然后要调用其init钩子，初始化组件Vnode。</p><p>我们之前提到在vdom目录下的create-component.js中定义的createComponent在创建组件Vnode前会为组件Vnode的data属性挂载4个钩子，init钩子就是其中之一。该钩子函数的调用时机就是在执行createElm(Vnode)为一个Vnode创建元素时发现该Vnode是一个组件Vnode，就需要对该组件Vnode进行初始化操作。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319195103101.png" alt="组件Vnode的init钩子"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init</code></p><p>init 钩子函数执行也很简单，我们先不考虑 keepAlive 的情况，它是通过 <strong>createComponentInstanceForVnode 为组件Vnode创建一个组件实例，然后调用 $mount 方法，先来看一下 createComponentInstanceForVnode</strong> 的实现。</p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init &gt;&gt; createComponentInstanceForVnode</code></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324144302581.png" alt="createComponentInstanceForVnode"></p><p> 忽略inline-template的部分，createComponentInstanceForVnode做了一件事，新建一个options，并新建一个组件实例。</p><ul><li><p>_isComponent: true 用于标记该组件为一个internalComponent，</p></li><li><p>_parentVnode: vnode 指示由组件vnode创建的组件实例的_parentVnode指向该vnode，</p></li><li><p>parent的实参值为activeInstance，activeInstance永远指向正在执行update方法的那一个vm，所以parent的含义是将vnode产生的组件实例的父组件实例。</p></li></ul><p>将这三个内容合并为一个options，然后创建一个Ctor实例，新建的实例将在构建函数中执行_init方法，这里我们回顾一下vm._init方法。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324191342131.png" alt="vm._init"></p><p>vm._init方法中，如果options._isComponent为true，则执行initInternalComponent。说明_isComponent === true是internalComponent的唯一标识，internalComponent可以理解为由模板中的子组件标签生成的组件，这种组件实例的创建统一交给了Vue来处理，而不是用new语法创建。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324191807618.png" alt="initInternalComponent"></p><p>initInternalComponent主要是处理options。</p><p>在vm._init函数中，需要对创建实例时传入的options进行处理，而Vue源码中有两种方式：</p><ul><li><p>一种是如果组件是internalComponent，则用initInternalComponent处理options；</p></li><li><p>另一种是使用mergeOptions合并传入的options和组件构造器的options。</p><blockquote><p>这两种方式的目的都是让创建的vm同时能访问组件构造器的options以及使用new实例化时传入的options参数。</p></blockquote></li></ul><p>initInternalComponent不是执行合并操作，而是将vm的$options原型指向组件构造器的options，然后向vm.$options挂载_parentVnode、parent、propsData以及_parentListeners等等一些内容。</p><blockquote><p>第一次渲染时，父组件向子组件注入数据就是在这一步。props以及父组件对子组件的监听器就是在这时候挂载到子组件实例上的。vm._init方法后面会继续执行initProps、initEvents等一系列初始化流程。</p></blockquote><p>由于原型链的存在，以后vm.$options可以访问到组件构造器中的options。</p><p>在initInternalComponent执行完后，vm._init会继续对数据进行规格化，对状态进行初始化。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324193544853.png" alt="vm._init的剩余流程"></p><p>由于我们单文件组件中一般不在组件options中书写el，options._el为undefined，所以vm._init不会挂载子组件。</p><p>到此，我们就完成了对 App组件实例的创建，该从createComponentInstance回到init钩子。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324194301580.png" alt="children.$mount()"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init</code></p><p>init钩子最后执行了一句关键的child.$mount()。child就是我们刚刚创建好的子组件实例，它挂载到了组件vnode.componentInstance上。在非SSR环境下，此时child.$el还不存在，所以child.$mount()最终会执行 child.$el = child.__patch__(undefined, child.render())。这就开启了子组件的第一次渲染，但需要注意的是子组件创建的$el还不会插入到父组件中。</p><blockquote><p>child.$mount会依次执行vnode = child.render()、update.update(vnode)、patch(undefined, vnode)、createElm(vnode)，从而创建了一个组件及其根虚拟Vnode，以及根$el，这个$el是真实的创建好的DOM子树根节点。</p></blockquote><p>子组件实例调用$mount完成属于自己的第一次渲染后，就从组件Vnode的init钩子中跳出，执行子组件Vnode的剩余操作。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324193900834.png" alt="createComponent创建组件实例并初始化"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; initComponent</code></p><p>首先，由于子组件Vnode实例化了一个组件实例，一定具有componentInstance属性，因为该属性值指向与子组件Vnode绑定的组件实例。往下继续执行initComponent。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324200927306.png" alt="initComponent"></p><p>initComponent主要做了三件事：</p><ul><li><p>insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)</p><p>如果子组件在渲染的过程中由于插入了元素而将对应的vnode加入到了插入顺序队列中，则将子组件中所有安装了insert钩子的的vnode加入到父组件的插入顺序队列中。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324202145673.png" alt="invokeInsertHook"></p><blockquote><p>这是第一次渲染的特殊操作，每个组件第一次执行patch时，会将新的具有insert钩子的vnode加入到插入顺序队列中，子组件会将自己的插入顺序队列保存到组件Vnode.data.pendingInsert中。</p><p>详见 invokeInsertHook。</p><p>最终，所有具有insert钩子的vnode（父组件以及子孙组件的vnode）都按照从父亲到后代的顺序加入到了顶级组件的插入顺序队列中，而insert的调用顺序是从子到父。（队列结构）</p></blockquote></li><li><p>vnode.elm = vnode.componentInstance.$el</p><p>将子组件Vnode的elm属性指向子组件实例创建好的$el元素。</p></li><li><p>invokeCreateHooks(vnode, inseredVnodeQueue)</p><p>调用组件vnode的create钩子，如果本组件vnode具有insert钩子，也将添加到插入顺序队列中。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324202230704.png" alt="image-20210324202230704"></p></li></ul><p>initComponent完成后，跳回createComponent。</p><p><code>createElm &gt;&gt; createComponent</code></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324203302805.png" alt="image-20210324203302805"></p><p>接下来的逻辑就比较简单，将子组件Vnode的elm插入到父级DOM元素中。然后return true 跳回creatElm。</p><h2 id="第一次渲染完成"><a href="#第一次渲染完成" class="headerlink" title="第一次渲染完成"></a>第一次渲染完成</h2><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324214146624.png" alt="creatElm部分逻辑"></p><p>由于createComponent返回的是true，所以createElm也会直接return结束执行。</p><p><strong>到这里，我们就彻底完成了从new Vue( {render: h =&gt; h(App)]})，到App组件渲染成DOM并插入到body中的过程。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324215104859.png" alt="image-20210324215104859"></p><h2 id="回到-patch"><a href="#回到-patch" class="headerlink" title="回到__patch__"></a>回到__patch__</h2><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324223138108.png" alt="patch的剩余执行步骤"></p><p>new Vue({render: h =&gt; h(App)})经过一些列过程后，由createElm创建了一个Vnode。该Vnode没有子节点，而且是单一的子组件Vnode，并且该vnode已经创建好了组件实例和DOM元素，并且插入到了文档的body元素中。</p><p>接下来执行invokeInsertHook：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324223534090.png" alt="invokeInsertHook"></p><p>我们之前在initComponent中提到过该函数，如果不是第一次渲染，该函数会调用插入顺序队列中的每个Vnode的insert钩子。</p><p>但是，我们需要明确的是，new Vue()得到的实例在这里会直接调用队列中所有vnode的insert钩子。不对？这里很奇怪？明明new Vue（）得到的实例在此时的确是第一次渲染，为什么会调用队列中的钩子？关键在于invokeInsertHook的initial参数，如果patch方法的第一个参数只要不是undefined，isInitialPatch这个实参的值等于false，initial接受的值就为false，invokeInsertHook函数就认为本次执行不是组件根vnode的第一次渲染。</p><p>调用过插入顺序队列中所有vnode的insert钩子之后，顶级组件及其子组件的第一次渲染流程就“真正”地完成了。</p><h2 id="props和listeners的第一次注入"><a href="#props和listeners的第一次注入" class="headerlink" title="props和listeners的第一次注入"></a>props和listeners的第一次注入</h2><p>父组件和子组件通信的最主要机制就是：父组件向子组件的props上注入数据，同时监听子组件的自定义事件，子组件通过emit自定义事件向父组件发送数据。</p><p>所以我们来看一下父级组件和子组件之间的这种通信机制是如何实现的（在哪个步骤实现的）。</p><p><strong>首先，需要注意的是：</strong>父组件render函数执行时，创建某一个元素Vnode/组件Vnode时，会根据模板编译出的AST，将data传入到_createElement的第二个参数位置，data此时已经是一个真实的JS数据，包含了props、attrs、styles、class、on/nativeOn等等，只是和子组件实例中要求的内容格式“暂时”不同。</p><p><strong>接下来，当我们使用_createElement(tag, data, children)创建组件Vnode时，会进一步调用createComponent(tag, data,children)。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325103154592.png" alt="creatComponent"></p><p>createComponent有上面标注的两段逻辑，第一段是将propsData从子组件Vnode的data中提取出来，此时data.props中已经生成好了将要注入到子组件中的通信数据；第二段逻辑是把子组件Vnode的data.on中的父组件事件监听器提取出来，再将data.on赋值为data.nativeOn，data.nativeOn中保存了父组件监听子组件的原生DOM监听器。</p><p>到这里其实已经得到了全部需要用到的父向子注入的数据以及父组件对子组件的事件监听器，只是尚未规格化而已。（规格化操作是由子组件初始化时完成的）</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325103659889.png" alt="创建子组件Vnode"></p><p><strong>最后创建子组件Vnode，并且将子组件的组件构造器、propsData、listeners等等全部挂载到组件Vnode的componentOptions上。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325104347165.png" alt="子组件实例拿到父组件注入的内容"></p><p>在子组件初始化时，通过子组件在父组件Vnode树中的占位Vnode拿到了父组件注入的数据，分别挂载到$options.propsData和options._parentListeners中。</p><blockquote><p>子组件实例的options._parentVnode指向自己在父组件Vnode树中的占位Vnode。</p></blockquote><p>值得注意的是，_parentListeners中的监听器函数应该是由高阶函数返回的函数，该函数内部封装了一个父组件的函数执行，其执行过程中this指向父组件。</p><p><strong>接下来就是分别使用initEvents和initProps初始化父组件向自己注入的内容。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325111517913.png">  <img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325111708770.png" alt="image-20210325111708770"></p><blockquote><ul><li><p>如果prop的值是基本类型，且模板中对该值有依赖，修改prop的值时，会触发子组件更新。但尽量不要随意修改，修改了会导致逻辑混乱。</p></li><li><p>如果prop的值是引用类型，可以修改该值的内容。如果该值是响应式数据，且模板中对该值有依赖，则该值的内容发生改变时，子组件会重新渲染并且影响父级组件以及依赖于该值的兄弟组件。如果该值不是响应式的，修改该值的内容不仅不会影响到其他组件，也不会触发子组件更新。</p></li></ul><p>总之，在子组件中避免出现 this.prop = xxx 的操作，但是可以执行 this.prop.foo = xxx（强烈不建议这样做）。</p></blockquote><h2 id="props的patch"><a href="#props的patch" class="headerlink" title="props的patch"></a>props的patch</h2><p>一般来说，父组件对子组件的事件监听器不会发生太多变化，我们这里简单分析一下在父组件的某个状态发生变化导致父组件更新时，父组件对子组件的props会产生什么影响。</p><p>当对子组件Vnode进行patch时，patchVnode函数中有这样一段代码：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325120526393.png" alt="patchVnode"></p><p>在对text、children等内容进行patch前，patchVnode会对oldVnode和vnode的data进行patch，其中就包括了props。</p><p>如果Vnode具有prepatch钩子，则执行这个钩子。prepatch钩子一般只包含组件Vnode的prepatch钩子。组件Vnode的prepatch钩子是在createComponent创建组件Vnode时安装的四个钩子之一。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325121059597.png" alt="image-20210325121059597"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325121328153.png" alt="updateChildComponent"> </p><p>在updateChildComponent中，对子组件实例vm._props进行了更新。</p><ul><li>如果vm._props中某个属性值为非undefined或null的基本类型，该值发生改变时，会触发子组件更新。</li><li>如果vm._props中某个属性值为引用类型，该引用类型的指向没有发生改变，不会触发子组件更新。除非该引用类型的值为响应式数据且内容发生了改变，则会触发子组件更新。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python3笔记</title>
    <link href="/2021/02/19/python3/python3/"/>
    <url>/2021/02/19/python3/python3/</url>
    
    <content type="html"><![CDATA[<p> <img src="/2021/02/19/python3/python3/image-20200902103321060.png" alt="image-20200902103321060"></p><h1 id="Python3基础"><a href="#Python3基础" class="headerlink" title="Python3基础"></a>Python3基础</h1><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>作用：运行py文件（代码）</p><p>种类：</p><ul><li><p>CPython，C语言开发的官方解释器</p></li><li><p>IPython，基于CPython的一种交互式的解释器</p></li><li><p>其他</p><p><img src="/2021/02/19/python3/python3/image-20200902103623327.png" alt="image-20200902103623327"></p></li></ul><p>下载：</p><pre><code>    官方网站下载python解释器</code></pre><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>使用本机内任意的pip安装 virtualenv 和 virtualenvwrapper-win</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pip install virtualenv virtualenvwrapper-win<br></code></pre></td></tr></table></figure><ol start="2"><li>在磁盘中新建一个空文件夹，虚拟环境以后将保存在这里。例如 D:\Envs</li><li>在系统环境变量中添加  变量名：WORKON_HOME  值：D:\Envs </li></ol><h3 id="新建、查看、进入、退出"><a href="#新建、查看、进入、退出" class="headerlink" title="新建、查看、进入、退出"></a>新建、查看、进入、退出</h3><ol><li><p>查看当前已有的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ workon  <br></code></pre></td></tr></table></figure></li><li><p>新建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkvirtualenv myfirstEnv<br></code></pre></td></tr></table></figure><p>使用指定的python解释器新建虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkvirtualenv myfirstEnv2 --python [解释器的完整路径]<br></code></pre></td></tr></table></figure></li><li><p>切换到（进入）建立好的虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ workon myfirstEnv<br></code></pre></td></tr></table></figure></li><li><p>退出虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ deactivate<br></code></pre></td></tr></table></figure></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><p>单行注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注释</span><br></code></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">第一种写法</span><br><span class="hljs-string">&quot;&quot;“</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">第二种写法</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h2></li></ol><ul><li><p>由数字、字母、下划线组成</p></li><li><p>不能数字开头</p></li><li><p>不能使用内置关键字</p><p><img src="/2021/02/19/python3/python3/image-20200902154853675.png" alt="image-20200902154853675"></p></li><li><p>严格区分大小写</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2021/02/19/python3/python3/image-20200902161227614.png" alt="image-20200902161227614"></p><p>Python中，万物皆对象！万物皆对象！万物皆对象！</p><p>每个对象包含3个属性，id，type，value</p><p>id就是对象地址，可以通过内置函数id()查看对象引用的地址。</p><p>type就是对象类型，可以通过内置函数type()查看对象的类型。</p><p>value就是对象的值。</p><h3 id="不可变类型与可变类型"><a href="#不可变类型与可变类型" class="headerlink" title="不可变类型与可变类型"></a>不可变类型与可变类型</h3><p><img src="/2021/02/19/python3/python3/image-20200903133739365.png" alt="image-20200903133739365"></p><p><img src="/2021/02/19/python3/python3/image-20200903133758908.png" alt="image-20200903133758908"></p><p><img src="/2021/02/19/python3/python3/image-20200903133815481.png" alt="image-20200903133815481"></p><p><img src="/2021/02/19/python3/python3/image-20200903133831420.png" alt="image-20200903133831420"></p><h3 id="不可变-immutable-类型"><a href="#不可变-immutable-类型" class="headerlink" title="不可变(immutable)类型"></a>不可变(immutable)类型</h3><ul><li>int</li><li>float</li><li>decimal</li><li>complex</li><li>bool</li><li><strong>str</strong></li><li><strong>tuple</strong></li><li>range</li><li><strong>frozenset</strong></li><li>bytes</li></ul><h3 id="可变-mutable-类型"><a href="#可变-mutable-类型" class="headerlink" title="可变(mutable)类型"></a>可变(mutable)类型</h3><ul><li>list</li><li>dict</li><li>set</li><li>bytearray</li><li>user-defined classes (unless specifically made immutable)</li></ul><h3 id="判断数据的类型"><a href="#判断数据的类型" class="headerlink" title="判断数据的类型"></a>判断数据的类型</h3><ol><li><p>type()</p><p>type函数传入一个对象，返回对象的类型  即其class</p></li><li><p>使用type函数判断一个对象是否为指定类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 是否为int 类型 </span><br><span class="hljs-built_in">type</span>(x) == <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span><br><br><span class="hljs-comment"># 是否为string类型</span><br><span class="hljs-built_in">type</span>(x) == <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>isinstance(_obj, _class_or_tuple)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">其第一个参数为对象，第二个参数为类型名或包含多个类型名的元组。</span><br><span class="hljs-string">其返回值为布尔型。若对象的类型与参数二的类型相同则返回True。</span><br><span class="hljs-string">若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>lst = []<br>print(<span class="hljs-built_in">isinstance</span>(lst, <span class="hljs-built_in">list</span>))<br>print(<span class="hljs-built_in">isinstance</span>(lst, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>,<span class="hljs-built_in">list</span>)))<br><br>print(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">int</span>))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p><img src="/2021/02/19/python3/python3/image-20200902174834356.png" alt="image-20200902174834356"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. float() -- 将数据转换成浮点型</span><br>num1 = <span class="hljs-number">1</span><br>str1 = <span class="hljs-string">&#x27;10&#x27;</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">float</span>(num1)))  <span class="hljs-comment"># float</span><br>print(<span class="hljs-built_in">float</span>(num1))  <span class="hljs-comment"># 1.0</span><br><br>print(<span class="hljs-built_in">float</span>(str1))  <span class="hljs-comment"># 10.0</span><br><br><br><span class="hljs-comment"># 2. str() -- 将数据转换成字符串型</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(num1)))  <span class="hljs-comment"># str</span><br><br><br><span class="hljs-comment"># 3. tuple() -- 将一个序列转换成元组</span><br>list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>print(<span class="hljs-built_in">tuple</span>(list1))<br><br><br><span class="hljs-comment"># 4. list() -- 将一个序列转换成列表</span><br>t1 = (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)<br>print(<span class="hljs-built_in">list</span>(t1))<br><br><br><span class="hljs-comment"># 5. eval() -- 计算在字符串中的有效Python表达式,并返回一个对象</span><br>str2 = <span class="hljs-string">&#x27;1&#x27;</span><br>str3 = <span class="hljs-string">&#x27;1.1&#x27;</span><br>str4 = <span class="hljs-string">&#x27;(1000, 2000, 3000)&#x27;</span><br>str5 = <span class="hljs-string">&#x27;[1000, 2000, 3000]&#x27;</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str2)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str3)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str4)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str5)))<br></code></pre></td></tr></table></figure><h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>总体来说，<code>is</code>比较的是<code>id</code>是不是一样，<code>==</code>比较的是<code>type</code>和<code>value</code>是不是一样。</p><ol><li><p>对于整型、小数、字符串</p><p>此类数据类型是不可变数据类型，理论上，在不存在两个变量间相互赋值的情况下，id是一定不一样的。</p><p>但是python<code>交互编程时</code>解释器会缓存[-5,256]间的整数，在<code>脚本编程时</code>会先解析脚本，缓存重复使用的值，因此对于此类数据类型使用 <code>is</code>时会出现相等的情况（id相等返回True）</p></li><li><p>对于元组</p><p>在<code>脚本编程时</code>，两个元组t1和t2分别<code>赋以相同的值</code>，若元组值中不存在可变数据类型，则 t1和 t2 在缓存机制的影响下，id相同。若元组中存在可变数据类型，则id一定不同。</p></li><li><p>若可变类型的对象之间使用 <code>==</code>判断：</p><p>可变类型往往是容器，对两个容器使用<code>==</code>比较，需要规定如何比较。</p><p>例如列表、字典以及集合，就是对两个容器中的对应成员使用 <code>==</code>比较，成员类型应该规定了使用<code>==</code>比较的规则，否则比较失败。</p></li><li><p>判断一个对象是否为None要使用<code>is</code></p></li></ol><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 准备数据</span><br><span class="hljs-string">2. 格式化符号输出数据</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>age = <span class="hljs-number">18</span><br>name = <span class="hljs-string">&#x27;TOM&#x27;</span><br>weight = <span class="hljs-number">75.5</span><br>stu_id = <span class="hljs-number">1</span><br>stu_id2 = <span class="hljs-number">1000</span><br><br><span class="hljs-comment"># 1. 今年我的年龄是x岁 -- 整数 %d</span><br>print(<span class="hljs-string">&#x27;今年我的年龄是%d岁&#x27;</span> % age)<br><br><span class="hljs-comment"># 2. 我的名字是x -- 字符串 %s</span><br>print(<span class="hljs-string">&#x27;我的名字是%s&#x27;</span> % name)<br><br><br><span class="hljs-comment"># 3. 我的体重是x公斤 -- 浮点数 %f</span><br>print(<span class="hljs-string">&#x27;我的体重是%.3f公斤&#x27;</span> % weight)<br><br><span class="hljs-comment"># 4. 我的学号是x -- %d</span><br>print(<span class="hljs-string">&#x27;我的学号是%d&#x27;</span> % stu_id)<br><br><span class="hljs-comment"># 4.1 我的学号是001</span><br>print(<span class="hljs-string">&#x27;我的学号是%03d&#x27;</span> % stu_id)<br>print(<span class="hljs-string">&#x27;我的学号是%03d&#x27;</span> % stu_id2)<br><br><br><span class="hljs-comment"># 5. 我的名字是x，今年x岁了</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%d岁了&#x27;</span> % (name, age))<br><span class="hljs-comment"># 5.1 我的名字是x，明年x岁了</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，明年%d岁了&#x27;</span> % (name, age + <span class="hljs-number">1</span>))<br><br><br><span class="hljs-comment"># 6. 我的名字是x，今年x岁了，体重x公斤，学号是x</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%d岁了，体重%.2f公斤，学号是%06d&#x27;</span> % (name, age, weight, stu_id))<br><br><span class="hljs-comment"># 6.1我的名字是x，今年x岁了，体重x公斤</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%s岁了，体重%s公斤&#x27;</span> % (name, age, weight))<br></code></pre></td></tr></table></figure><p><strong>整数与小数的用’0’补齐</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%04d&#x27;</span> %<span class="hljs-number">123</span>) <br><span class="hljs-comment"># 0123       总共占4位，整数位3位，左侧补齐一个0</span><br><br>print(<span class="hljs-string">&#x27;%06.3f&#x27;</span> %<span class="hljs-number">3.14</span>)<br><span class="hljs-comment"># 03.140      总共占6位，保留小数3位，小数点1位，整数位1位，左侧补齐一个0</span><br><br><span class="hljs-comment"># 超出允许的列数时，按其他要求真实输出。</span><br><br>print(<span class="hljs-string">&#x27;%04.3f&#x27;</span>,<span class="hljs-number">3.14</span>)<br><span class="hljs-comment"># 3.140</span><br></code></pre></td></tr></table></figure><h3 id="f-字符串"><a href="#f-字符串" class="headerlink" title="f-字符串"></a>f-字符串</h3><p>python3.6新增，效率比上述的%s效率要高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&#x27;hello world&#x27;</span><br>print(<span class="hljs-string">f&#x27;我想说<span class="hljs-subst">&#123;str1&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment">#相当于 </span><br><br>print(<span class="hljs-string">&#x27;我想说&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(str1))<br></code></pre></td></tr></table></figure><h3 id="print结束符"><a href="#print结束符" class="headerlink" title="print结束符"></a>print结束符</h3><p><img src="/2021/02/19/python3/python3/image-20200902173925580.png" alt="image-20200902173925580"></p><p>默认end=’\n’</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><img src="/2021/02/19/python3/python3/image-20200902174120530.png" alt="image-20200902174120530"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><p>算数运算符</p></li><li><p>赋值运算符</p></li><li><p>复合赋值运算符</p></li><li><p>比较运算符</p></li><li><p>逻辑运算符</p></li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902175959148.png" alt="image-20200902175959148"></p><p><img src="/2021/02/19/python3/python3/image-20200902180046786.png" alt="image-20200902180046786"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902180152402.png" alt="image-20200902180152402"></p><p><img src="/2021/02/19/python3/python3/image-20200902180259719.png" alt="image-20200902180259719"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a和b交换值</span><br>a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">2</span><br>a,b=b,a<br>print(a,<span class="hljs-string">&#x27;:&#x27;</span>,b)<br><span class="hljs-comment"># 2:1</span><br></code></pre></td></tr></table></figure><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902181846251.png" alt="image-20200902181846251"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902181934373.png" alt="image-20200902181934373"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902182015593.png" alt="image-20200902182015593"></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if语句语法"><a href="#if语句语法" class="headerlink" title="if语句语法"></a>if语句语法</h3><p><img src="/2021/02/19/python3/python3/image-20200902193415037.png" alt="image-20200902193415037"></p><p><img src="/2021/02/19/python3/python3/image-20200902193458780.png" alt="image-20200902193458780"></p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p><img src="/2021/02/19/python3/python3/image-20200902194038565.png" alt="image-20200902194038565"></p><h3 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if elif else"></a>if elif else</h3><p><img src="/2021/02/19/python3/python3/image-20200902194326654.png" alt="image-20200902194326654"></p><h3 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h3><p><img src="/2021/02/19/python3/python3/image-20200902194842893.png" alt="image-20200902194842893"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">2</span><br>b = <span class="hljs-number">1</span><br>print(a) <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> print(b)<br><br><span class="hljs-comment"># 控制台输出 👉 2</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><font color='red' size='4'>Python中没有switch case语法</font></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>作用：控制代码重复执行</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/2021/02/19/python3/python3/image-20200902200651067.png" alt="image-20200902200651067"></p><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="/2021/02/19/python3/python3/image-20200902203452852.png" alt="image-20200902203452852"></p><h3 id="while-else"><a href="#while-else" class="headerlink" title="while else"></a>while else</h3><p><img src="/2021/02/19/python3/python3/image-20200902205225313.png" alt="image-20200902205225313"></p><p><strong>语法</strong></p><p><img src="/2021/02/19/python3/python3/image-20200902205243152.png" alt="image-20200902205243152"></p><p><strong>在while else语法结构中，break与continue退出</strong></p><p><img src="/2021/02/19/python3/python3/image-20200902205536541.png" alt="image-20200902205536541"></p><p><img src="/2021/02/19/python3/python3/image-20200902205623421.png" alt="image-20200902205623421"></p><ol start="2"><li>continue</li></ol><p><img src="/2021/02/19/python3/python3/image-20200902210952819.png" alt="image-20200902210952819"></p><h3 id="for-else"><a href="#for-else" class="headerlink" title="for else"></a>for else</h3><p>for else的使用以及与break、continue配合的表现都与while else相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>可以使用一对双引号<code>&quot;&quot;</code>、一对单引号<code>&#39;&#39;</code>、三引号<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>或<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>来标识字符串。</p><p>三引号的作用在于能够保存编辑代码时的换行符，输出时会显示原原本本的字符串格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">str1=<span class="hljs-string">&quot;&quot;&quot;i am mz,</span><br><span class="hljs-string">hello world</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>print(str1)<br><br>👇<br><span class="hljs-comment"># i am mz,</span><br><span class="hljs-comment"># hello world</span><br><br><br></code></pre></td></tr></table></figure><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>python中的字符串属于常见的序列类型之一，可以通过下标以及切片对其访问。</p><p><img src="/2021/02/19/python3/python3/image-20200903100827674.png" alt="image-20200903100827674"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 序列名[开始位置的下标:结束位置的下标:步长]</span><br><br>str1 = <span class="hljs-string">&#x27;012345678&#x27;</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">1</span>])  <span class="hljs-comment"># 234</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 24</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 234</span><br>print(str1[:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 01234 -- 如果不写开始，默认从0开始选取</span><br>print(str1[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 2345678 -- 如果不写结束，表示选取到最后</span><br>print(str1[:])  <span class="hljs-comment"># 012345678 -- 如果不写开始和结束，表示选取所有</span><br><br>负数测试<br>print(str1[::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 876543210 -- 如果步长为负数，表示倒叙选取</span><br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 567 -- 下标-1表示最后一个数据，依次向前类推</span><br><br><span class="hljs-comment"># 终极测试</span><br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>])  <span class="hljs-comment"># 567</span><br><br>!!!!!<br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 不能选取出数据：从-4开始到-1结束，选取方向为从左到右，但是-1步长：从右向左选取</span><br><span class="hljs-comment"># **** 如果选取方向(下标开始到结束的方向) 和 步长的方向冲突，则无法选取数据</span><br><br>如果想要逆序获取字符串序列<br>print(str1[-<span class="hljs-number">1</span>:-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 876</span><br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="/2021/02/19/python3/python3/image-20200903110829006.png" alt="image-20200903110829006"></p><p>字符串的常用操作方法由查找、返回新数据（由于不能修改）、判断三大类。</p><h4 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a><strong>一、查找</strong></h4><ol><li><p>find()</p><p><img src="/2021/02/19/python3/python3/image-20200903103935277.png" alt="image-20200903103935277"></p></li></ol><ol start="2"><li><p>index( )</p><p>用法与find相同，唯一不同的是当字串不存在时，index方法不会返回-1，而是<strong>会报错</strong>，</p><p> <img src="/2021/02/19/python3/python3/image-20200903104530591.png" alt="image-20200903104530591"></p></li></ol><ol start="3"><li>count()</li></ol><p><img src="/2021/02/19/python3/python3/image-20200903104442971.png" alt="image-20200903104442971"></p><h4 id="二、返回新内容"><a href="#二、返回新内容" class="headerlink" title="二、返回新内容"></a><strong>二、返回新内容</strong></h4><ol><li><p><strong>replace()  返回新的字符串 。替换掉字符串内的指定字串。</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111139313.png" alt="image-20200903111139313"></p></li></ol><p><font color='red'>由于python中字符串方法不会修改原串，如果需要修改原字符串，需要 str1=str1.replace( …..)</font></p><ol start="2"><li><strong>split()  返回一个数组。以指定字串分割字符串。</strong></li></ol><p><img src="/2021/02/19/python3/python3/image-20200903111403167.png" alt="image-20200903111403167"></p><p><img src="/2021/02/19/python3/python3/image-20200903111419469.png" alt="image-20200903111419469"></p><ol start="3"><li><p><strong>join()  以该字符串连接一个字符串序列。</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111724592.png" alt="image-20200903111724592"></p></li></ol><ol start="4"><li><p><strong>大小写相关</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111808737.png" alt="image-20200903111808737"></p></li></ol><p>   <img src="/2021/02/19/python3/python3/image-20200903111850677.png" alt="image-20200903111850677"></p><p>   <img src="/2021/02/19/python3/python3/image-20200903111909823.png" alt="image-20200903111909823"></p><p>   <img src="/2021/02/19/python3/python3/image-20200903111925783.png" alt="image-20200903111925783"></p><ol start="5"><li><p><strong>去除左右空白</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903130746820.png" alt="image-20200903130746820"></p></li></ol><ol start="6"><li><p><strong>对齐与补齐</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903130819326.png" alt="image-20200903130819326"></p><pre><code>    ![image-20200903130830475](./image-20200903130830475.png)    ![image-20200903130941185](./image-20200903130941185.png)</code></pre></li></ol><h4 id="三、判断"><a href="#三、判断" class="headerlink" title="三、判断"></a><strong>三、判断</strong></h4><p><img src="/2021/02/19/python3/python3/image-20200903131215973.png" alt="image-20200903131215973"><img src="/2021/02/19/python3/python3/image-20200903131232290.png" alt="image-20200903131232290"></p><p><img src="/2021/02/19/python3/python3/image-20200903131315678.png" alt="image-20200903131315678"></p><p><img src="/2021/02/19/python3/python3/image-20200903131330582.png" alt="image-20200903131330582"></p><ul><li><p>in 和 not in</p><p>判断是否存在某个字串</p></li></ul><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[数据<span class="hljs-number">1</span>, 数据<span class="hljs-number">2</span>, 数据<span class="hljs-number">3</span>, 数据<span class="hljs-number">4.</span>.....]<br></code></pre></td></tr></table></figure><p>列表可以一次性存储多个数据，且可以为不同数据类型。</p><h3 id="下标访问与切片"><a href="#下标访问与切片" class="headerlink" title="下标访问与切片"></a>下标访问与切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># Tom</span><br>print(name_list[<span class="hljs-number">1</span>])  <span class="hljs-comment"># Lily</span><br>print(name_list[<span class="hljs-number">2</span>])  <span class="hljs-comment"># Rose</span><br><br>print(name_list[<span class="hljs-number">0</span>::<span class="hljs-number">2</span>]) <span class="hljs-comment"># [&#x27;Tom&#x27;, &#x27;Lily&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="列表长度"><a href="#列表长度" class="headerlink" title="列表长度"></a>列表长度</h3><p>len( ==list==)</p><h3 id="判断是否存在某个元素"><a href="#判断是否存在某个元素" class="headerlink" title="判断是否存在某个元素"></a>判断是否存在某个元素</h3><ul><li>in：判断指定数据在某个列表序列，如果在返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-comment"># 结果：True</span><br>print(<span class="hljs-string">&#x27;Lily&#x27;</span> <span class="hljs-keyword">in</span> name_list)<br><br><span class="hljs-comment"># 结果：False</span><br>print(<span class="hljs-string">&#x27;Lilys&#x27;</span> <span class="hljs-keyword">in</span> name_list)<br></code></pre></td></tr></table></figure><ul><li>not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-comment"># 结果：False</span><br>print(<span class="hljs-string">&#x27;Lily&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name_list)<br><br><span class="hljs-comment"># 结果：True</span><br>print(<span class="hljs-string">&#x27;Lilys&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name_list)<br></code></pre></td></tr></table></figure><h3 id="查找元素索引"><a href="#查找元素索引" class="headerlink" title="查找元素索引"></a>查找元素索引</h3><ul><li>index()：返回指定数据所在位置的下标 。</li></ul><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.index(数据, 开始位置下标, 结束位置下标)<br></code></pre></td></tr></table></figure><ol start="2"><li>快速体验</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list.index(<span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：如果查找的数据不存在则报错。</p><p>所以在使用index前最好先判断所查找元素是否存在。或者需要处理异常。</p></blockquote><h3 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h3><ul><li>count()：统计指定数据在当前列表中出现的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list.count(<span class="hljs-string">&#x27;Lily&#x27;</span>))  <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h3 id="增加与插入"><a href="#增加与插入" class="headerlink" title="增加与插入"></a>增加与插入</h3><ul><li><strong>append ( ) 列表结尾添加一个元素</strong></li></ul><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.append(数据)<br></code></pre></td></tr></table></figure><ol start="2"><li>体验</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.append(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><p><img src="/2021/02/19/python3/python3/image-20190130160154636.png" alt="image-20190130160154636"></p><blockquote><p>列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。</p></blockquote><ol start="3"><li>注意点</li></ol><p>如果append()追加的数据是一个序列，则追加整个序列到列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.append([<span class="hljs-string">&#x27;xiaoming&#x27;</span>, <span class="hljs-string">&#x27;xiaohong&#x27;</span>])<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, [&#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><ul><li><p><strong>extend ( ) 列表结尾追加元素。可传入一个可迭代类型，将所有元素将逐一尾插</strong></p><blockquote><p> 若该数据是一个序列，则这个序列的数据逐一添加到列表。**</p></blockquote><p>语法：</p><ol><li><p>添加一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.extend(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;x&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li><li><p>添加一个序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.extend([<span class="hljs-string">&#x27;xiaoming&#x27;</span>, <span class="hljs-string">&#x27;xiaohong&#x27;</span>])<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><strong>insert ( )指定位置新增数据。</strong></li></ul><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.insert(位置下标, 数据)<br></code></pre></td></tr></table></figure></li><li><p>快速体验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;xiaoming&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><blockquote><p>插入一个序列类型时，不会对序列进行解构。会在指定位置插入该序列对象。</p></blockquote></li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p><strong>del</strong></p><blockquote><p>常用del语法删除一个变量，但同时del可以删除列表的某个元素</p></blockquote><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> 目标<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-keyword">del</span> name_list[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 结果：[&#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>pop()：删除指定下标的数据（默认为最后一个），并返回该数据。</strong></p><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.pop(下标)<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>del_name = name_list.pop(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 结果：Lily</span><br>print(del_name)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>remove()：移除列表中某个数据的第一个匹配项。</strong></p><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.remove(数据)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.remove(<span class="hljs-string">&#x27;Rose&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li><p><strong>下标修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaa&#x27;</span><br><br><span class="hljs-comment"># 结果：[&#x27;aaa&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ul><h3 id="逆置、排序、拷贝"><a href="#逆置、排序、拷贝" class="headerlink" title="逆置、排序、拷贝"></a>逆置、排序、拷贝</h3><ul><li><p><strong>逆置：reverse()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_list = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br><br>num_list.reverse()<br><br><span class="hljs-comment"># 结果：[8, 6, 3, 2, 5, 1]</span><br>print(num_list)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>排序：sort()</strong></p><ol><li><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.sort( key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：reverse表示排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）</p></blockquote></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_list = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br><br>num_list.sort()<br><br><span class="hljs-comment"># 结果：[1, 2, 3, 5, 6, 8]</span><br>print(num_list)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;]<br>ls.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;age&#x27;</span>], reverse=<span class="hljs-literal">True</span>)<br>print(ls)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>&#125;]<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>复制：copy()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_li2 = name_list.copy()<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_li2)<br></code></pre></td></tr></table></figure><blockquote><p>列表的copy方法是浅拷贝。</p></blockquote></li></ul><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h2><blockquote><p>元组是序列类型，可以存储多个元素，但元组无法被修改。</p></blockquote><p><img src="/2021/02/19/python3/python3/image-20200903165757617.png" alt="image-20200903165757617"></p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组特点：定义元组使用==小括号==，且==逗号==隔开各个数据，数据可以是不同的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多个数据元组</span><br>t1 = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><br><span class="hljs-comment"># 单个数据元组</span><br>t2 = (<span class="hljs-number">10</span>,)<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果定义的元组只有一个数据，那么这个数据后面也好添加逗号，否则数据类型为唯一的这个数据的数据类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">t2 = (<span class="hljs-number">10</span>,)<br>print(<span class="hljs-built_in">type</span>(t2))  <span class="hljs-comment"># tuple</span><br><br>t3 = (<span class="hljs-number">20</span>)<br>print(<span class="hljs-built_in">type</span>(t3))  <span class="hljs-comment"># int</span><br><br>t4 = (<span class="hljs-string">&#x27;hello&#x27;</span>)<br>print(<span class="hljs-built_in">type</span>(t4))  <span class="hljs-comment"># str</span><br></code></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>元组数据不支持修改，只支持查找，具体如下：</p><ul><li>按下标查找数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1[<span class="hljs-number">0</span>])  <span class="hljs-comment"># aa</span><br></code></pre></td></tr></table></figure><ul><li>index()：查找某个数据，如果数据存在返回对应的下标，<code>不存在时会报错</code>，语法和列表、字符串的index方法相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1.index(<span class="hljs-string">&#x27;aa&#x27;</span>))  <span class="hljs-comment"># 0</span><br></code></pre></td></tr></table></figure><ul><li>count()：统计某个数据在当前元组出现的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1.count(<span class="hljs-string">&#x27;bb&#x27;</span>))  <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><ul><li>len()：统计元组中数据的个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(<span class="hljs-built_in">len</span>(tuple1))  <span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：元组内的直接数据如果修改则立即报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>tuple1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>但是如果元组里面有可变数据类型（例如：列表），修改该元组的元素的值是被允许的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple2 = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, [<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>], <span class="hljs-number">50</span>, <span class="hljs-number">30</span>)<br>print(tuple2[<span class="hljs-number">2</span>])  <span class="hljs-comment"># 访问到列表</span><br><br><span class="hljs-comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span><br>tuple2[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaaaa&#x27;</span><br>print(tuple2)<br></code></pre></td></tr></table></figure><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>数据装包 &lt;=&gt; 拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组拆包</span><br><br>t = (<span class="hljs-string">&#x27;mazheng&#x27;</span>, <span class="hljs-number">23</span>)<br>name, age = t<br>print(name, age)<br>👇<br><span class="hljs-comment"># mazheng 23</span><br><br><br></code></pre></td></tr></table></figure><h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h2><p>字典特点：</p><ul><li>符号为==大括号==</li><li>数据为==键值对==形式出现</li><li>各个键值对之间用==逗号==隔开</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有数据字典</span><br>dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br><span class="hljs-comment"># 空字典</span><br>dict2 = &#123;&#125;<br><br>dict3 = <span class="hljs-built_in">dict</span>()<br></code></pre></td></tr></table></figure><h3 id="增加键值对"><a href="#增加键值对" class="headerlink" title="增加键值对"></a>增加键值对</h3><p>写法：==字典序列[key] = 值==</p><blockquote><p>注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br>dict1[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;Rose&#x27;</span><br><span class="hljs-comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br>print(dict1)<br><br>dict1[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-number">110</span><br><br><span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;id&#x27;: 110&#125;</span><br>print(dict1)<br></code></pre></td></tr></table></figure><blockquote><p>注意：字典为可变类型。</p></blockquote><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li>del() / del：删除字典或删除字典中指定键值对。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br><span class="hljs-keyword">del</span> dict1[<span class="hljs-string">&#x27;gender&#x27;</span>]<br><span class="hljs-comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20&#125;</span><br>print(dict1)<br></code></pre></td></tr></table></figure><ul><li>clear()：清空字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br>dict1.clear()<br>print(dict1)  <span class="hljs-comment"># &#123;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>pop(key)：根据键名取出键值对</li></ul><h3 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h3><p>写法：==字典序列[key] = 值==</p><blockquote><p>注意：如果key存在则修改这个key对应的值 ；如果key不存在则新增此键值对。</p></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li><p>按key值查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1[<span class="hljs-string">&#x27;name&#x27;</span>])  <span class="hljs-comment"># Tom</span><br>print(dict1[<span class="hljs-string">&#x27;id&#x27;</span>])  <span class="hljs-comment"># 报错</span><br></code></pre></td></tr></table></figure><blockquote><p>如果当前查找的key存在，则返回对应的值；否则则报错。</p></blockquote></li></ol><ol start="2"><li><p>get()方法</p><ul><li>语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">字典序列.get(key, 默认值)<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。</p></blockquote><ul><li>快速体验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.get(<span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment"># Tom</span><br>print(dict1.get(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">110</span>))  <span class="hljs-comment"># 110</span><br>print(dict1.get(<span class="hljs-string">&#x27;id&#x27;</span>))  <span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><ol><li><p>keys()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.keys())  <span class="hljs-comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;])</span><br></code></pre></td></tr></table></figure></li><li><p>values()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.values())  <span class="hljs-comment"># dict_values([&#x27;Tom&#x27;, 20, &#x27;男&#x27;])</span><br></code></pre></td></tr></table></figure></li><li><p>items()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.items()) <br><span class="hljs-comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;, &#x27;男&#x27;)])</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>字典对象本身也是可迭代对象，每次迭代返回一个key</strong></p></blockquote><h3 id="字典拆包"><a href="#字典拆包" class="headerlink" title="字典拆包"></a>字典拆包</h3><p><img src="/2021/02/19/python3/python3/image-20200903201210168.png" alt="image-20200903201210168"></p><p><strong>应用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将字典的所有key保存在一个列表中</span><br>d = <span class="hljs-built_in">dict</span>(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-number">0</span>: <span class="hljs-number">123</span>&#125;)<br><br>(*keys,) = d<br>print(keys,<span class="hljs-built_in">type</span>(keys))<br><span class="hljs-comment"># 👉[&#x27;name&#x27;, &#x27;age&#x27;, 0] &lt;class &#x27;list&#x27;&gt;</span><br><br>dictKeys = d.keys()<br>print(dictKeys,<span class="hljs-built_in">type</span>(dictKeys))<br><span class="hljs-comment"># 👉dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, 0]) &lt;class &#x27;dict_keys&#x27;&gt;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>创建集合使用<code>&#123;&#125;</code>或<code>set()</code>， 但是如果要创建空集合只能使用<code>set()</code>，因为<code>&#123;&#125;</code>用来创建空字典。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>集合可以去掉重复数据；</li><li>集合数据是无序的，故不支持下标</li></ol><h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><ul><li><p><strong>add()</strong></p><p>add方法传入==一个可哈希类型==的数据，并将该数据添加到集合中，重复值会被去重。</p></li><li><p><strong>update()</strong></p><p>update方法传入==一个可迭代==的数据，并将该数据的所有迭代返回值添加到集合中，重复值会被去重。==同时该方法要求传入的可迭代对象的每次迭代的返回值都是可哈希的，否则报错==</p></li></ul><blockquote><p>可哈希的数据类型，即不可变的数据结构，包括：数字、字符串、元组以及对象集objects。</p><p>不可哈希的数据类型，即可变的数据结构，包括：字典、列表、集合。</p></blockquote><blockquote><p>可迭代的数据类型，包括：字符串、列表、元组、字典、集合等。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&#x27;12345&#x27;</span><br>s1 = <span class="hljs-built_in">set</span>()<br>s2 = <span class="hljs-built_in">set</span>()<br><br>s1.add(str1)<span class="hljs-comment"># 传入可哈希类型</span><br>s2.update(str1)<span class="hljs-comment"># 传入可迭代类型</span><br><br>print(<span class="hljs-string">&#x27;s1:&#x27;</span>, s1)&gt;&gt;&gt; s1: &#123;<span class="hljs-string">&#x27;12345&#x27;</span>&#125;<br>print(<span class="hljs-string">&#x27;s2:&#x27;</span>, s2)&gt;&gt;&gt; s2: &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;<br><br> <br>s3 = <span class="hljs-built_in">set</span>()<br>dic1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">321</span>&#125;<br>s3.update(dic1)<span class="hljs-comment"># 传入可迭代类型，迭代字典返回key</span><br>print(s3)&gt;&gt;&gt;&#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li><p><strong>remove()</strong></p><p>remove方法传入一个可哈希类型的数据，删除集合中的该数据，数据不存在时==报错==。</p></li><li><p><strong>discard()</strong></p><p>discard方法传入一个可哈希类型的数据，删除集合中的该数据，数据不存在时==不报错==。</p></li><li><p><strong>pop()</strong></p><p>pop方法会取出集合中的第一个迭代值（输出时最左边的值）。</p><blockquote><p>新建一个集合以及由其他容器转来的集合，数据的排列方式各有不同。</p></blockquote></li></ul><h3 id="判断数据是否存在"><a href="#判断数据是否存在" class="headerlink" title="判断数据是否存在"></a>判断数据是否存在</h3><ul><li><strong>in：</strong>判断数据在集合序列</li><li><strong>not in：</strong>判断数据不在集合序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br><br>print(<span class="hljs-number">10</span> <span class="hljs-keyword">in</span> s1)<br>print(<span class="hljs-number">10</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1)<br></code></pre></td></tr></table></figure><h2 id="容器小结"><a href="#容器小结" class="headerlink" title="容器小结"></a>容器小结</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>容器</th><th>是否可哈希</th><th>是否可迭代</th><th>迭代返回的数据</th></tr></thead><tbody><tr><td>字符串</td><td>✔</td><td>✔</td><td>字符</td></tr><tr><td>列表</td><td></td><td>✔</td><td>元素</td></tr><tr><td>元组</td><td>✔</td><td>✔</td><td>元素</td></tr><tr><td>字典</td><td></td><td>✔</td><td>key</td></tr><tr><td>集合</td><td></td><td>✔</td><td>元素</td></tr></tbody></table><h3 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h3><blockquote><p> 公共函数要求传入一个可迭代对象，而python内置的容器都是可迭代对象。</p></blockquote><ol><li><p>len() </p><p>返回容器的长度，即可迭代的次数</p></li><li><p>max()</p><p>返回容器中的最大值，==要求容器的所有迭代值可以相互比较，否则报错==</p></li><li><p>min()</p><p>类似于max，返回容器中的最小值</p></li><li><p>enumerate()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">enumerate</span>(可迭代对象,start=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>enumerate方法第一个参数要求传入一个可迭代对象，第二个参数start为一个整数。</p><p>该方法会返回一个可迭代对象，该对象的迭代值为一个元组，元组具有固定格式：</p><p>（整数索引值，第一个参数的每个迭代值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">321</span>&#125;<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dic1,start=<span class="hljs-number">0</span>):<br>    print(t)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br><br>lis = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">for</span> index,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lis,start=<span class="hljs-number">1</span>):<br>    print(index,val)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">支持的容器类型</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">合并</td><td align="center">字符串、列表、元组</td></tr><tr><td align="center">*</td><td align="center">倍增</td><td align="center">字符串、列表、元组</td></tr><tr><td align="center">in</td><td align="center">元素是否存在</td><td align="center">字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td align="center">元素是否不存在</td><td align="center">字符串、列表、元组、字典</td></tr></tbody></table><ul><li><p> <code>*</code> 是用于==整数==和==序列类型==之间的计算，可以左边使用运算符，也可以右边使用。</p></li><li><p><code>in</code>和<code>not in</code>对于==字符串==使用是==判断子串是否存在==；</p></li><li><p><code>in</code>和<code>not in</code>对于==字典==使用是==判断键是否存在==；</p></li></ul><h3 id="容器类型转换"><a href="#容器类型转换" class="headerlink" title="容器类型转换"></a>容器类型转换</h3><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple()"></a>tuple()</h4><p>作用：将某个可迭代对象转换成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>]<br>s1 = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;<br><br>print(<span class="hljs-built_in">tuple</span>(list1))<br>print(<span class="hljs-built_in">tuple</span>(s1))<br></code></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h4><p>作用：将某个可迭代对象转换成列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br>s1 = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;<br><br>print(<span class="hljs-built_in">list</span>(t1))<br>print(<span class="hljs-built_in">list</span>(s1))<br></code></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>作用：将某个可迭代对象转换成集合，并去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>]<br>t1 = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><br>print(<span class="hljs-built_in">set</span>(list1))<br>print(<span class="hljs-built_in">set</span>(t1))<br></code></pre></td></tr></table></figure><blockquote><p>注意：若传入set方法中的可迭代对象的某个迭代值不可哈希，则会报错。</p></blockquote><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><ul><li>推导式的作用：简化代码</li><li>推导式写法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表推导式</span><br>[xx <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>()]<br><br><span class="hljs-comment"># 字典推导式</span><br>&#123;xx1: xx2 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">in</span> ...&#125;<br><br><span class="hljs-comment"># 集合推导式</span><br>&#123;xx <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> ...&#125;<br></code></pre></td></tr></table></figure><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><ol><li><p><strong>基本使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>带if语句的列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>多个for循环嵌套的列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><ol><li><p><strong>基本使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>]<br>list2 = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;man&#x27;</span>]<br><br>dict1 = &#123;list1[i]: list2[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list1))&#125;<br>print(dict1)<br><br><br>vals = [(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;mz&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">23</span>)]<br>dict2 = &#123; key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> vals &#125;<br>print(dict2)<br><span class="hljs-comment"># 输出 &#123;&#x27;name&#x27;: &#x27;mz&#x27;, &#x27;age&#x27;: 23&#125;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>带if语句的字典推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">counts = &#123;<span class="hljs-string">&#x27;MBP&#x27;</span>: <span class="hljs-number">268</span>, <span class="hljs-string">&#x27;HP&#x27;</span>: <span class="hljs-number">125</span>, <span class="hljs-string">&#x27;DELL&#x27;</span>: <span class="hljs-number">201</span>, <span class="hljs-string">&#x27;Lenovo&#x27;</span>: <span class="hljs-number">199</span>, <span class="hljs-string">&#x27;acer&#x27;</span>: <span class="hljs-number">99</span>&#125;<br><br><span class="hljs-comment"># 需求：提取上述电脑数量大于等于200的字典数据</span><br>count1 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> counts.items() <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">200</span>&#125;<br>print(count1)  <span class="hljs-comment"># &#123;&#x27;MBP&#x27;: 268, &#x27;DELL&#x27;: 201&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><ol><li><p>基本使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>set1 = &#123;i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list1&#125;<br>print(set1)  <span class="hljs-comment"># &#123;1, 4&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：集合有数据去重功能。</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    ...<br>    ...<br></code></pre></td></tr></table></figure><h3 id="先定义，再调用"><a href="#先定义，再调用" class="headerlink" title="先定义，再调用"></a>先定义，再调用</h3><p>在python中，脚本从上到下解释执行，在调用函数前应先定义。</p><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    ...<br>    [<span class="hljs-keyword">return</span>  ...]<br></code></pre></td></tr></table></figure><p>在python中函数可以不返回值、返回一个值或返回多个值</p><ol><li><p>没有return语句或使用return但不返回值</p><p>==返回None==</p></li><li><p>return返回一个值</p><p>==用一个变量接收==</p></li><li><p>return返回多个值时，会以元组的形式返回</p><p>==用一个变量接收元组、或使用元组拆包==</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><br><br>x = foo()<br>x1, x2, x3 = foo()<br>(y, *t) = foo()<br><br>print(x)<br>print(x1, x2, x3)<br>print(y, t)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h3><ul><li><p>定义函数的说明文档</p><p>==在函数代码块的第一行以三双引号开始书写函数说明==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 说明文档的位置 &quot;&quot;&quot;</span><br>    代码<br>    ......<br>    <br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">    多行说明文档</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    代码<br>    ......<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>查看函数的说明文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(函数名)<br></code></pre></td></tr></table></figure></li><li><p>举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_num</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 求和函数 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-built_in">help</span>(sum_num)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>sum_num(a,b)<br>求和函数<br></code></pre></td></tr></table></figure></li></ul><h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><p>根据作用域（变量生效的范围）可以将变量分为==局部变量==和==全局变量==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span> <span class="hljs-comment"># 全局变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    a = <span class="hljs-number">200</span> <span class="hljs-comment"># 局部变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    a = <span class="hljs-number">300</span><br>    foo()<br>    print(a)<br>    <br>print(a)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>在不加声明的情况下，python函数中对某个变量进行了定义（初始化、赋值操作），则该变量就成为了局部变量。</li><li>如果函数内不存在对某个变量的定义，但访问了该变量，则解释器会向全局作用域中查找该变量，若全局作用域中也不存在对该变量的定义，则报错。</li></ol></blockquote><p><strong>在函数中声明全局变量：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    a = <span class="hljs-number">200</span> <br>      <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a = <span class="hljs-number">200</span><br>    <br>foo()<br>print(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">100</span><br><br>bar()<br>print(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">200</span><br>    <br></code></pre></td></tr></table></figure><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p><strong>一、位置参数</strong></p><p>位置参数：调用函数时根据函数定义的形参的位置与含义来传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender</span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：在使用位置参数进行传参时，实参和形参的顺序及个数必须一致。</p></blockquote><p><strong>二、使用关键字传参</strong></p><p>函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender</span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;Rose&#x27;</span>, age=<span class="hljs-number">20</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>)<br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, age=<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。</p></blockquote><p><strong>三、参数默认值</strong></p><p>为形参提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender=<span class="hljs-string">&#x27;男&#x27;</span></span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">20</span>)<br>user_info(<span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;女&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。</p></blockquote><p><strong>四、不定长参数</strong></p><p>不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。</p><blockquote><p>无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。</p></blockquote><ol><li><p>包裹位置传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">语法：*不定长参数名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">*args</span>):</span><br>    print(args)<br><br><br><span class="hljs-comment"># (&#x27;TOM&#x27;,)</span><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>)<br><span class="hljs-comment"># (&#x27;TOM&#x27;, 18)</span><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><blockquote><p>传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组。</p><p>python编程中也常用args包裹位置不定长参数</p></blockquote></li><li><p>包裹关键字传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">语法：**不定长参数名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    print(kwargs)<br><br><br><span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span><br>user_info(name=<span class="hljs-string">&#x27;TOM&#x27;</span>, age=<span class="hljs-number">18</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">110</span>)<br></code></pre></td></tr></table></figure><blockquote><p>kwargs是一个字典类型，以key：val的形式包裹不定长参数。</p><p>python编程中也常用kwargs包裹关键字不定长参数</p></blockquote></li></ol><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式也称作匿名函数，用于简化函数的书写。</p><blockquote><p>使用场景要求：函数可有多个参数，使用一个表达式的结果作为返回值。</p></blockquote><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 参数列表:表达式<br></code></pre></td></tr></table></figure><blockquote><p>所有python函数的传参方式都适用于lambda表达式</p></blockquote><ol><li><p>无参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span>: <span class="hljs-number">100</span><br>print(fn1())<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> a: a<br>print(fn1(<span class="hljs-string">&#x27;hello world&#x27;</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">func = <span class="hljs-keyword">lambda</span> name, age: (name, age)<br>x = func(age=<span class="hljs-number">23</span>, name=<span class="hljs-string">&#x27;mz&#x27;</span>)<br>print(x)<br></code></pre></td></tr></table></figure><blockquote><p>在pep8编码规范中，不建议使用<code>functioname = lambda表达式</code>的型式定义函数。</p></blockquote></li></ol><ol start="4"><li><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> a, b, c=<span class="hljs-number">100</span>: a + b + c<br>print(fn1(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>可变参数 args</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> *args: args<br>print(fn1(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>可变参数 kwargs</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">fn1 = <span class="hljs-keyword">lambda</span> **kwargs: kwargs<br>print(fn1(name=<span class="hljs-string">&#x27;python&#x27;</span>, age=<span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure></li></ol><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ol><li><p><strong>all(==iterable==)</strong></p><p>传入一个可迭代对象，若所有迭代值为True，则返回True</p></li><li><p><strong>any</strong>(==iterable==)</p><p>传入一个可迭代对象，若存在一个值为True，则返回True</p></li><li><p><strong>dir(==object==)</strong></p><p>传入一个对象，返回对象的所有属性和方法。不传参时，返回全局变量与函数。</p></li><li><p>enumerate(==iterable,  [start = 0]==)</p><p>枚举函数，在迭代对象的时候，额外提供一个序列号的输入。</p></li><li><p>frozenset(==iterable==)</p><p>返回一个不能增加和修改的集合对象。</p></li><li><p>isinstance(==object, classname==)</p><p>判断一个对象是否是某个类的实例</p></li><li><p>issubclass(==sonclass, baseclass==)</p><p>判断一个类是否是另一个类的子类</p></li><li><p>reversed(==iterable==)</p><p>传入一个可迭代对象，返回该可迭代对象的反转对象（即迭代顺序相反）</p></li><li><p>slice(==start, end, step==)</p><p>返回一个切片对象，相当于 start: end: step</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>s = <span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>print(ls[s])<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></li></ol><h3 id="内置高阶函数-map-、filter、reduce、sorted"><a href="#内置高阶函数-map-、filter、reduce、sorted" class="headerlink" title="内置高阶函数 map 、filter、reduce、sorted"></a>内置高阶函数 map 、filter、reduce、sorted</h3><p><strong>一、map</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(func, *iterables) <span class="hljs-comment">#返回一个可迭代对象 &lt;map object&gt;</span><br></code></pre></td></tr></table></figure><p>传入一个可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span><br><br>result = <span class="hljs-built_in">map</span>(func, list1)<br><br>print(result)  &gt;&gt;&gt; &lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000013769653198</span>&gt;<br>print(<span class="hljs-built_in">list</span>(result)) &gt;&gt;&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br></code></pre></td></tr></table></figure><p>传入多个可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>dict1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">0</span>&#125;<br><br>result = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> item, key: (key, item), ls, dict1 )<br><br>print(result)  &gt;&gt;&gt; &lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000013769653198</span>&gt;<br>print(<span class="hljs-built_in">dict</span>(result)) &gt;&gt;&gt; &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、filter</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">filter</span>(func, iterable) <span class="hljs-comment">#返回一个可迭代对象 &lt;filter object&gt;</span><br></code></pre></td></tr></table></figure><p><strong>三、reduce</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br>functools.reduce(func, iterable, [initVal]) <span class="hljs-comment">#返回一个值</span><br></code></pre></td></tr></table></figure><blockquote><p>当传入可迭代对象为空时，若不指定initVal，则会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>result = functools.reduce(<span class="hljs-keyword">lambda</span> pre, cur:pre+cur, ls, <span class="hljs-number">0</span>)<br>print(result) &gt;&gt;&gt; <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>四、sorted</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>, [key , reverse=<span class="hljs-literal">False</span>])<br></code></pre></td></tr></table></figure><p>类似于列表的sort方法，返回排序后的列表, ==不会修改参数中的list==。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象三大特性：封装、继承和多态。</p><p>由于python是动态语言，天生具有多态的特性，不需要额外语法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;xxx&#x27;</span>)<br>        <br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;hengheng&#x27;</span>)<br>        <br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dospeak</span>(<span class="hljs-params">animal</span>):</span><br>    animal.speak()<br>    <br>p = Pig()<br>a = Animal()<br><br>dospeak(p)  <span class="hljs-comment"># 鸭子模型</span><br>dospeak(a)<br><br></code></pre></td></tr></table></figure><h3 id="类的定义与实例化"><a href="#类的定义与实例化" class="headerlink" title="类的定义与实例化"></a>类的定义与实例化</h3><ol><li><p>定义类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名:</span><br>    <span class="hljs-comment"># 代码</span><br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">pass</span><br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wash</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我会洗衣服&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>不由任意内置类型派生出的类，称之为经典类</p></blockquote></li><li><p>实例化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">对象名 = 类名()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建对象</span><br>haier1 = Washer()<br><br><span class="hljs-comment"># &lt;__main__.Washer object at 0x0000018B7B224240&gt;</span><br>print(haier1)<br><br><span class="hljs-comment"># haier对象调用实例方法</span><br>haier1.wash()<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>self参数</p><p>在python中定义实例方法，第一个位置传入self参数，代表实例对象本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.age = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">self</span>):</span><br>        print(self.age)<br><br>per = Person()<br>per.printAge()<br></code></pre></td></tr></table></figure></li></ol><h3 id="实例的属性"><a href="#实例的属性" class="headerlink" title="实例的属性"></a>实例的属性</h3><blockquote><p>在python中，实例对象的属性不在类内定义，但可以在类的实例方法中初始化、修改、删除实例的属性。</p></blockquote><ol><li><p>类内初始化、访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.age = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">self</span>):</span><br>        print(self.age)<br></code></pre></td></tr></table></figure></li><li><p>类外定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">per = Person()<br>per.name = <span class="hljs-string">&#x27;mz&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="类的属性（静态属性）"><a href="#类的属性（静态属性）" class="headerlink" title="类的属性（静态属性）"></a>类的属性（静态属性）</h3><p>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</p><p>类属性可以使用 <strong>类对象</strong> 或 <strong>实例对象</strong> 访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    tooth = <span class="hljs-number">10</span><br>    <br>wangcai = Dog()<br>xiaohei = Dog()<br><br>print(Dog.tooth)  <span class="hljs-comment"># 10</span><br>print(wangcai.tooth)  <span class="hljs-comment"># 10</span><br>print(xiaohei.tooth)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><blockquote><p>类属性的优点</p><ul><li><strong>记录的某项数据 始终保持一致时</strong>，则定义类属性。</li><li><strong>实例属性</strong> 要求 <strong>每个对象</strong> 为其 <strong>单独开辟一份内存空间</strong> 来记录数据，而 <strong>类属性</strong> 为全类所共有 ，<strong>仅占用一份内存</strong>，<strong>更加节省内存空间</strong>。</li></ul></blockquote><blockquote><p>注意：不能通过实例修改类的属性，如果这样操作，实则是创建了一个实例属性。</p></blockquote><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>需要用装饰器<code>@classmethod</code>来标识其为类方法，对于类方法，<strong>第一个参数必须是调用者本身（类对象）</strong>，一般以<code>cls</code>作为第一个参数。</p><blockquote><p>只有使用类名才能调用类的方法</p></blockquote><p><strong>使用场景：</strong></p><ul><li><p>当方法中 <strong>需要使用类对象</strong> (如访问私有类属性等)时，定义类方法</p></li><li><p>类方法一般和类属性配合使用</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __tooth = <span class="hljs-number">10</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tooth</span>(<span class="hljs-params">cls</span>):</span><br>        <span class="hljs-keyword">return</span> cls.__tooth<br><br>wangcai = Dog()<br>result = wangcai.get_tooth()<br>print(result)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>需要通过装饰器<code>@staticmethod</code>来进行修饰，<strong>静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）</strong>。</p><blockquote><p>使用实例与类名都能够调用静态方法</p></blockquote><p><strong>使用场景：</strong></p><ul><li>当方法中 <strong>既不需要使用实例对象</strong>(如实例对象，实例属性)，<strong>也不需要使用类对象</strong> (如类属性、类方法、创建实例等)时，定义静态方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info_print</span>():</span><br>        print(<span class="hljs-string">&#x27;这是一个狗类，用于创建狗实例....&#x27;</span>)<br><br><br>wangcai = Dog()<br><span class="hljs-comment"># 静态方法既可以使用对象访问又可以使用类访问</span><br>wangcai.info_print()<br>Dog.info_print()<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>取消不需要的参数传递</strong>，有利于 <strong>减少不必要的内存占用和性能消耗</strong></li></ul><hr><h3 id="特殊成员与魔法方法"><a href="#特殊成员与魔法方法" class="headerlink" title="特殊成员与魔法方法"></a>特殊成员与魔法方法</h3><p><strong>一、<code>__init__()</code></strong></p><p>作用：初始化对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">f&#x27;洗衣机的宽度是<span class="hljs-subst">&#123;self.width&#125;</span>&#x27;</span>)<br>        print(<span class="hljs-string">f&#x27;洗衣机的高度是<span class="hljs-subst">&#123;self.height&#125;</span>&#x27;</span>)<br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>haier1.print_info()<br><br><br>haier2 = Washer(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)<br>haier2.print_info()<br></code></pre></td></tr></table></figure><p><strong>二、<code>__str__()</code></strong></p><p>当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了<code>__str__</code>方法，那么就会打印从在这个方法中 return 的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是海尔洗衣机的说明书&#x27;</span><br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>print(haier1) &gt;&gt;&gt; 这是海尔洗衣机的说明书<br></code></pre></td></tr></table></figure><p><strong>三、<code>__del__()</code></strong></p><p>当删除对象时，python解释器也会默认调用<code>__del__()</code>方法。（析构函数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self&#125;</span>对象已经被删除&#x27;</span>)<br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">del</span> haier1<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除</span><br></code></pre></td></tr></table></figure><p><strong>四、<code>__doc__</code></strong></p><p>属性，类的说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;A的说明&quot;&quot;&quot;</span>    <span class="hljs-comment"># __doc__属性是该位置的类的说明</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_A</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;A&#x27;</span>)<br>        <br>print(A.__doc__)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>A的说明<br></code></pre></td></tr></table></figure><p><strong>五、<code>__setitem__() </code> 、<code>__getitem__()</code>、<code>__delitem__()</code></strong></p><p>可以让实例对象像字典一样使用。</p><p><strong>六、<code>__iter__()</code></strong></p><p>返回一个迭代器，使实例可以用for循环遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p><strong>七、<code>__len__()</code></strong></p><p>当对象实例传入len()函数时返回的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,<span class="hljs-built_in">len</span></span>):</span><br>        this.__len = <span class="hljs-built_in">len</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__len<br>    <br>a = A(<span class="hljs-number">10</span>)<br>print(<span class="hljs-built_in">len</span>(a))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>八、运算符重载</strong></p><p><code>__add__()</code>重载<code> +</code> 运算符</p><p><code>__sub__()</code>重载<code>-</code> 运算符</p><p><code>__mul__()</code>重载<code> *</code> 运算符</p><p><code>__div__()</code>重载<code> /</code> 运算符</p><p><code>__mod__()</code>重载<code> %</code> 运算符</p><p><code>__pow__()</code>重载<code> **</code> 运算符</p><p><code>__cmp__()</code>重载比较运算</p><p><strong>九、<code>__mro__</code></strong></p><p>继承关系，返回一个列表。</p><p>**十、<code>__getattr__()</code>和<code>__getattribute__()</code>**、</p><p>控制获取实例的属性的逻辑。</p><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>python中，子类会继承父类<strong>所有方法</strong>（实例方法、类的方法、静态方法、<strong>魔法方法</strong>）。</p><p>同时会继承父类的属性（<strong>不包括实例属性</strong>）。</p><p><strong>一、单继承</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;animal:%s&#x27;</span> % self.name)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        Animal.__init__(self, name)  <span class="hljs-comment"># 借用父类的构造函数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 重写父类的实例方法</span><br>        print(<span class="hljs-string">&#x27;horse:%s&#x27;</span> % self.name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">basespeak</span>(<span class="hljs-params">self</span>):</span><br>        Animal.speak(self)  <span class="hljs-comment"># 调用父类的实例方法</span><br><br><br>h = Horse(<span class="hljs-string">&#x27;ley&#x27;</span>)<br>h.speak()<br>h.basespeak()<br><span class="hljs-meta">&gt;&gt;&gt; </span>horse:ley<br><span class="hljs-meta">&gt;&gt;&gt; </span>animal:ley<br><br></code></pre></td></tr></table></figure><p><strong>二、多继承</strong></p><p>在python3中支持多继承，但在实际开发中，一个类往往最多继承两个类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span>():</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Donkey</span>():</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mule</span>(<span class="hljs-params">Horse,Donkey</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><hr><h3 id="实例的方法和属性的查找顺序"><a href="#实例的方法和属性的查找顺序" class="headerlink" title="实例的方法和属性的查找顺序"></a>实例的方法和属性的查找顺序</h3><blockquote><p>注意：在一个类中，类的方法、类的静态方法、类的属性、实例的属性以及实例的方法<strong>不能重名，否则会覆盖。</strong></p></blockquote><p><strong>一、方法查找</strong></p><blockquote><p><strong>MRO：方法解析顺序 python采用c3算法</strong></p></blockquote><p>由于多继承机制的存在，在python中调用实例的方法时采用<strong>c3算法</strong>进行解析查找：</p><ol><li><p>首先在实例内部查找，如果没有找到，则向父类中查找。</p></li><li><p>根据定义继承关系时的顺序，以<strong>深度优先</strong>的方式逐一查找父类。</p></li><li><p>在多个父类继承自同一个类时，<strong>采用深度优先与广度优先结合的算法</strong>。</p></li><li><p>在定义的继承关系中都没找到，最后到object中查找。</p><p>==2和3合在一起成为MRO==</p></li></ol><p>基本继承模型的实例方法查找顺序：</p><p><img src="/2021/02/19/python3/python3/image-20200908200041362.png" alt="image-20200908200041362"> <img src="/2021/02/19/python3/python3/image-20200908200146328.png" alt="image-20200908200146328">共有的祖先最后才查找</p><p>复杂继承关系拆分成基本继承关系：</p><p><img src="/2021/02/19/python3/python3/image-20200908200310621.png" alt="image-20200908200310621"></p><p><strong>二、属性查找</strong></p><p>在访问实例的属性时，首先会在实例内部查找，如果不存在，则查找类的属性。</p><p>如果还不存在，使用c3算法向上查找父类的属性（类的属性）。</p><blockquote><p>可以使用实例的<code>__dict__</code>属性查看实例自身具有的属性。 </p><p>同时可以使用<code>dir函数</code>查看通过实例可访问到的所有属性和方法。</p></blockquote><hr><h3 id="成员保护和访问限制"><a href="#成员保护和访问限制" class="headerlink" title="成员保护和访问限制"></a>成员保护和访问限制</h3><p>私有成员：</p><ol><li>属性或方法</li><li>不能被外部访问</li><li>不会被继承</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span><br>    __title = <span class="hljs-string">&#x27;myclass&#x27;</span>  <span class="hljs-comment"># 私有的类的属性</span><br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">cls</span>):</span><br>        print(cls.__title)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name     <span class="hljs-comment"># 实例的私有属性</span><br></code></pre></td></tr></table></figure><blockquote><p>python中不存在完全严格的私有成员，只是做了一层假保护。</p><p>例如 ：上述的私有的类的属性可以通过  Myclass._MyClass__title访问到。(  _类名__属性名 )</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span><br>    __title = <span class="hljs-string">&#x27;myclass&#x27;</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">cls</span>):</span><br>        print(cls.__title)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name  <span class="hljs-comment"># 实例的私有属性</span><br><br>MyClass.info()<br>print(MyClass._MyClass__title)<br>a = MyClass(<span class="hljs-string">&#x27;mz&#x27;</span>)<br>print(a._MyClass__name)<br></code></pre></td></tr></table></figure><p><strong>类与下划线：</strong></p><ol><li><code>_name</code>、<code>_name_</code>、<code>_name__</code> 是简易性的私有成员，不要在外部访问。</li><li><code>__name</code>、<code>__name_</code>是强制的私有成员，但是你依然可以蛮横地在外部危险访问。</li><li><code>__name__</code>是特殊成员，与私有性质无关，例如<code>__doc__</code>和<code>__init__</code>等。</li><li><code>name_</code>、<code>name__</code>没有任何特殊性，普通的标识符，但最好不要这么取名。</li></ol><blockquote><p>Tips：在类如 for i in range(10000):的这种循环代码块中，如果在循环体内部使用不到 i ，为了节省内存开辟内存的时间，可以使用 下划线 _ 代替 i </p></blockquote><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>作用：将方法伪装成属性，常与私有属性配合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, age</span>):</span><br>        self.__name = name<br>        self.__age = age<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__age<br><br><span class="hljs-meta">    @age.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self, val</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(val, <span class="hljs-built_in">int</span>):<br>            self.__age = val<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;请输入一个整数&#x27;</span>)<br><br><span class="hljs-meta">    @age.deleter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self.__age<br><br><br>p = People(<span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-number">24</span>)<br>print(p.age) &gt;&gt;&gt; <span class="hljs-number">24</span><br>p.age = <span class="hljs-number">18</span><br>print(p.age) &gt;&gt;&gt; <span class="hljs-number">18</span><br><span class="hljs-keyword">del</span> p.age<br>print(p.age) &gt;&gt;&gt; AttributeError:<span class="hljs-string">&#x27;People&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;_People__age&#x27;</span><br><br></code></pre></td></tr></table></figure><p><strong>property函数</strong></p><p>作用与属性装饰器相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 属性装饰器写法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._x = <span class="hljs-literal">None</span><br> <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._x<br> <br><span class="hljs-meta">    @x.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self, value</span>):</span><br>        self._x = value<br> <br><span class="hljs-meta">    @x.deleter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self._x<br></code></pre></td></tr></table></figure><p>👇👇👇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># property函数写法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._x = <span class="hljs-literal">None</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getx</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._x<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setx</span>(<span class="hljs-params">self, value</span>):</span><br>        self._x = value<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delx</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self._x<br> <br>    x = <span class="hljs-built_in">property</span>(getx, setx, delx, <span class="hljs-string">&quot;I&#x27;m the &#x27;x&#x27; property.&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> ErrorType1 <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> ErrorType2 <span class="hljs-keyword">as</span> e:   <br><span class="hljs-comment"># except ErrorType3 as e:   </span><br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;捕获异常基类,异常信息:&#x27;</span>, e)<br><span class="hljs-keyword">except</span>:<br>    print(<span class="hljs-string">&#x27;未知异常&#x27;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e: <span class="hljs-comment"># 捕获NameError</span><br>    print(e)<br><span class="hljs-keyword">except</span> (ValueError, ZeroDivisionError) <span class="hljs-keyword">as</span> e: <span class="hljs-comment"># 捕获异常分组</span><br> print(e)<br><span class="hljs-keyword">except</span>:<br>    print(<span class="hljs-string">&#x27;未知异常&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">try</span>:<br>        a = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:   <span class="hljs-comment"># 可以捕获内部没有捕获的异常</span><br>    print(e)<br>        <br></code></pre></td></tr></table></figure><h3 id="内置异常"><a href="#内置异常" class="headerlink" title="内置异常"></a>内置异常</h3><p><img src="/2021/02/19/python3/python3/image-20200908214525411.png" alt="image-20200908214525411"></p><h3 id="else与finally"><a href="#else与finally" class="headerlink" title="else与finally"></a>else与finally</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(e)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;没有异常发生&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    print(<span class="hljs-string">&#x27;无论是否发生异常，执行最后的处理&#x27;</span>)<br>    <br></code></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyError</span>(<span class="hljs-params">Exception</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, msg</span>):</span><br>        self.msg = msg<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.msg<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">&#x27;自定义异常&#x27;</span>)<br><span class="hljs-keyword">except</span> MyError <span class="hljs-keyword">as</span> e:<br>    print(e)<br></code></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h3><p><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</p><p>返回一个file-like对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(filepath,mode=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment"># f即为一个文件句柄</span><br><span class="hljs-keyword">pass</span><br>f.close()<br></code></pre></td></tr></table></figure><p><strong>mode:</strong></p><p><img src="/2021/02/19/python3/python3/image-20200908221431298.png" alt="image-20200908221431298"></p><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><ol><li><p>read()</p><p>读取所有内容</p></li><li><p>readline()</p><p>读取一行内容，返回一个字符串（二进制时是byte类型）最后一个字符是<code>\n</code></p><p>（最后一行不一定有<code>\n</code>）</p></li><li><p>readlines()</p><p>读取所有行，返回一个列表，每个元素的最后一个字符是换行符<code>\n</code></p><p>（最后一行不一定带<code>\n</code>）</p></li><li><p>tell()</p><p>返回当前文件指针距离文件开头位置的字节数。</p></li><li><p>seek()</p><p>移动文件指针</p></li></ol><blockquote><p>文件对象是一个可迭代对象，每个迭代值返回一行的内容。</p></blockquote><h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;人生苦短，我用python&#x27;</span>.encode(<span class="hljs-string">&#x27;gbk&#x27;</span>))<br>f.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/test.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>content = f.read().decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><h3 id="使用with关键字"><a href="#使用with关键字" class="headerlink" title="使用with关键字"></a>使用with关键字</h3><p>with关键字用于python的上下文管理器机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;d:\test.txt) as f:</span><br><span class="hljs-string">data = f.read()</span><br><span class="hljs-string">print(data) </span><br><span class="hljs-string">    # 不需要使用close方法，上下文管理器会帮助我们合理关闭文件</span><br></code></pre></td></tr></table></figure><p>打开多个文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath1, mode=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f1, <span class="hljs-built_in">open</span>(filepath2, mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f2:<br>    f2.write(f1.read())<br></code></pre></td></tr></table></figure><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>一个模块就是一个py文件。</p><p>分为：内置模块、第三方模块、自定义模块</p><h3 id="导入模块的方式"><a href="#导入模块的方式" class="headerlink" title="导入模块的方式"></a>导入模块的方式</h3><ol><li><p>import </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名<br><span class="hljs-comment"># 使用👇</span><br>模块名.功能/成员<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>from … import …</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能<span class="hljs-number">1</span>, 功能<span class="hljs-number">2</span>, 成员<span class="hljs-number">1.</span>..<br><span class="hljs-comment"># 使用👇</span><br>功能<span class="hljs-number">1</span>()<br>功能<span class="hljs-number">2</span>()<br>print(成员<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所有功能 </span><br><span class="hljs-comment"># ❌ 但不建议使用</span><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> * <br></code></pre></td></tr></table></figure></li><li><p>as 定义别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 模块别名<br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能 <span class="hljs-keyword">as</span> 功能别名<br></code></pre></td></tr></table></figure></li></ol><h3 id="模块的-name-属性"><a href="#模块的-name-属性" class="headerlink" title="模块的__name__属性"></a>模块的__name__属性</h3><p><code>__name__</code>是系统变量，是模块的标识符：</p><ol><li><p>模块作为入口文件时，其<code>__name__</code>属性的值为<code>__main__</code></p></li><li><p>当模块是作为导入模块时，该模块的<code>__name__</code>的值为该模块的文件名（相对于执行文件所在目录的<code>包名.模块名</code>）</p></li></ol><p>可以利用该属性，为模块添加测试信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><h3 id="绝对导入"><a href="#绝对导入" class="headerlink" title="绝对导入"></a>绝对导入</h3><p>在python的执行文件或模块中，使用类似<code>import 模块名</code>、<code>import 包名.模块名</code> 、</p><p><code>from 包名.模块名 import 内容</code>等导入语法时，就是在用绝对路径导入模块。</p><p><strong>执行绝对导入时的模块搜索顺序：</strong></p><ol><li><p>执行文件所在的目录（执行文件可以理解为入口脚本，或者main函数所在的脚本。）</p></li><li><p>PYTHONPATH的环境变量里的路径 </p><p><a href="https://blog.csdn.net/csdnhuizhu/article/details/104525634/">https://blog.csdn.net/csdnhuizhu/article/details/104525634/</a></p></li><li><p> 如果都找不到，Python会察看默认路径，在python安装时已经配置好。</p></li><li><p>虚拟环境中的第三方包路径。</p></li></ol><blockquote><p>简而言之，使用绝对导入，python会：</p><p>先从内存找，</p><p>再从sys.path中找，sys.path是一个列表，保存了上述的1-4的所有绝对路径。</p><p>一定要分清楚谁是执行文件，谁是被导入文件。</p></blockquote><h3 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h3><p>使用相对导入，就不需要考虑执行文件到底是谁了，只需要知道模块与模块之间的相对位置。</p><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> module  <span class="hljs-comment"># 导入当前目录下的module</span><br><span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入上一级目录下的module</span><br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入爷爷目录下的module</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .module <span class="hljs-keyword">import</span> content <span class="hljs-comment"># 导入当前目录下模块的内容</span><br><span class="hljs-keyword">from</span> ..dir1.module <span class="hljs-keyword">import</span> content <span class="hljs-comment"># 导入父级目录下的dir1目录下的模块中的内容</span><br><span class="hljs-keyword">from</span> ..dir1.dir2 <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入父级目录下的dir1目录下的dir2目录下的模块</span><br>...<br></code></pre></td></tr></table></figure><p>⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐</p><p><strong>相对导入的语法很强大，但是需要注意的是：</strong></p><ol><li><p>相对导入不能在执行文件中使用，只能在被导入的模块中使用。</p></li><li><p>根据相对路径的查找过程中的目录不一定得是一个python包，可以是一个普通目录。</p></li><li><p>但是，<strong>顶级包之间不能互相访问</strong>——与执行文件处于一个目录下的包是顶级包。</p><p>例如目录结构：</p><p><code>myPackage/</code></p><p>—-<code>A/</code></p><p>——–<code>__init__.py</code></p><p>——–<code>a.py</code></p><p>—-<code>B/</code></p><p>——–<code>__init__.py</code></p><p>——–<code>b.py</code></p><p>—-<code>main.py</code>  </p><p><img src="/2021/02/19/python3/python3/image-20200909221050602.png" alt="image-20200909221050602"> </p><p>执行main.py，即main.py所在目录下的A包和B包是顶级包，不能互相访问，所以a.py不能导入B包中的b.py。</p><p>如果出现顶级包之间的互相访问,python解释器会报错：</p><p><code>ValueError: attempted relative import beyond top-level package</code></p></li></ol><p>   不得已的方法：</p><pre><code>   实在是想实现顶级包之间的相互访问，就需要向sys.path添加目标模块所在的目录，再使用绝对导入来加载目标模块。</code></pre><p><font size='5'>参考文章</font><a href="https://blog.csdn.net/qq_39852676/article/details/102502320">https://blog.csdn.net/qq_39852676/article/details/102502320</a></p><p>​        </p><h3 id="模块和包的-all-属性"><a href="#模块和包的-all-属性" class="headerlink" title="模块和包的__all__属性"></a>模块和包的__all__属性</h3><p>在模块中写上一句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [content1, content2,...]<br></code></pre></td></tr></table></figure><p>表示当使用*导入该模块的所有内容时，所允许加载的内容。</p><p>在包的__init__.py中写上一句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [module1, module2,...]<br></code></pre></td></tr></table></figure><p>表示当使用*导入该模块的所有模块时，所允许加载的模块。</p><h3 id="reflect反射机制"><a href="#reflect反射机制" class="headerlink" title="reflect反射机制"></a>reflect反射机制</h3><p>使用方法：</p><ol><li><code>getattr(module, member_Str)</code> 使用字符串获取模块中的成员</li><li><code>hasattr(module, member_Str) </code>判断是否模块有该成员<ol start="3"><li><code>__import__(module_Str[,fromlist=flase])</code>  传入一个字符串，加载该字符串标识的模块</li></ol></li></ol><p>工作目录： for_teach</p><p><img src="/2021/02/19/python3/python3/image-20200908210320313.png" alt="image-20200908210320313"> </p><p>commons.py中定义了多个工具函数</p><p><img src="/2021/02/19/python3/python3/image-20200908210349150.png" alt="image-20200908210349150"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在test.py中调用commons.py中的函数</span><br><br><span class="hljs-keyword">from</span> reflect <span class="hljs-keyword">import</span> commons<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入你想要访问的页面url路径:&#x27;</span>).strip()<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hasattr</span>(commons, inp)):<br>        func = <span class="hljs-built_in">getattr</span>(commons, inp) <span class="hljs-comment"># inp是一个字符串</span><br>    func()<br><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>run()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据url路径调用指定模块中的指定函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入你想要访问的页面url路径:&#x27;</span>).strip()<br>    moduleStr, funcStr = inp.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    m = <span class="hljs-built_in">__import__</span>(module)  <span class="hljs-comment"># __import__函数可以根据字符串加载一个模块</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hasattr</span>(m, funcStr)):<br>        func = <span class="hljs-built_in">getattr</span>(commons, inp) <span class="hljs-comment"># inp是一个字符串</span><br>    func()<br><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>run()<br></code></pre></td></tr></table></figure><h1 id="python3高级"><a href="#python3高级" class="headerlink" title="python3高级"></a>python3高级</h1><h2 id="object、class以及type的关系"><a href="#object、class以及type的关系" class="headerlink" title="object、class以及type的关系"></a>object、class以及type的关系</h2><p>在python中，函数和类是一等公民。</p><p>以下的type、object、list、str等都是类，其继承关系以及实例化顺序如图：</p><p><code>&lt;class &#39;type&#39;&gt;是克隆怪，自己实例化自己，同时也实例化除object以外的其他类</code></p><p><code>除object外的其他类都继承自object类</code></p><p><code>&lt;class &#39;object&#39;&gt;是上帝，创造了一切，不继承任何父类</code></p><p><img src="/2021/02/19/python3/python3/image-20200910120312999.png" alt="image-20200910120312999"></p><blockquote><p><strong>到这里就可理解，</strong> <strong>内置函数type传入一个对象，返回的是该对象是哪个类的实例</strong></p></blockquote><h2 id="多继承时的super方法"><a href="#多继承时的super方法" class="headerlink" title="多继承时的super方法"></a>多继承时的super方法</h2><p><a href="https://blog.csdn.net/qq_26442553/article/details/81775449">https://blog.csdn.net/qq_26442553/article/details/81775449</a></p><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p><em>查阅资料</em></p><h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p><em>查阅资料</em></p><h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>迭代器是访问容器内元素的一种方式，一般用来遍历实例内部的数据。</p><p>但迭代器和下标访问不同，它提供了一种惰性访问数据的方式。</p><h3 id="关键魔法函数"><a href="#关键魔法函数" class="headerlink" title="关键魔法函数"></a>关键魔法函数</h3><p>可迭代类型的<code>__iter__()</code>，相当于需要部署该接口</p><p>迭代器类型的<code>__next__()</code>，相当于迭代器要具有一个next方法。</p><h3 id="为一个类部署迭代接口"><a href="#为一个类部署迭代接口" class="headerlink" title="为一个类部署迭代接口"></a>为一个类部署迭代接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, employees</span>):</span><br>        self.employees = employees<br>        <br><span class="hljs-comment"># 部署迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span> <br>        <span class="hljs-keyword">return</span> MyIterator(self.employees) <span class="hljs-comment"># 返回一个迭代器实例</span><br><br><br><span class="hljs-comment"># 实现一个按下标访问的迭代器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>(<span class="hljs-params">Iterator</span>):</span> <span class="hljs-comment"># 继承Iterator抽象类，必须实现抽象类中的__next__方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, lis</span>):</span><br>        self.__lis = lis<br>        self.__index = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            item = self.__lis[self.__index]<br>        <span class="hljs-keyword">except</span> IndexError:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        <span class="hljs-keyword">else</span>:<br>            self.__index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> item<br><br><br>c = Company([<span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;ley&#x27;</span>])<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> c:<br>    print(p)<br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器函数：函数里只要有yield关键字，就是一个生成器函数。</p><p><strong>生成器实现原理：</strong>   <em>查阅资料</em></p><blockquote><p>简单说是生成器对象保存了两个指针，一个指向字节码对象，一个指向保存在堆中的栈帧对象，栈帧对象中保存了<strong>当前函数运行到的字节码位置</strong>以及函数中的局部变量。由于保存了函数代码运行到的位置(已执行的字节码长度)，所以可以控制函数的暂停和运行。</p></blockquote><p><strong>应用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 斐波那契数列</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">count</span>):</span><br>    index = <span class="hljs-number">0</span><br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> index &lt; count:<br>        <span class="hljs-keyword">yield</span> a<br>        index += <span class="hljs-number">1</span><br>        a, b = b, a+b<br>    <span class="hljs-keyword">return</span> a<br><br><br>g = fib(<span class="hljs-number">10</span>)<br>print(g.gi_frame.f_lasti)<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    i = <span class="hljs-built_in">next</span>(g)<br>    print(i)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分段读取大文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myreadlines</span>(<span class="hljs-params">f, length, sep</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;f为文件句柄，length为每次读取的字节长度，sep为分隔标识字符串&quot;&quot;&quot;</span><br>    buf = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">while</span> newline <span class="hljs-keyword">in</span> buf:<br>            pos = buf.index(newline)<br>            <span class="hljs-keyword">yield</span> buf[:pos]<br>            buf = buf[pos + <span class="hljs-built_in">len</span>(newline):]<br>chunk = f.read(length)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">yield</span> buf<br>            <span class="hljs-keyword">break</span><br>    buf += chunk<br><br>        <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> myreadlines(f, <span class="hljs-number">4096</span>, <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>生成器的send方法</strong></p><p>生成器的send方法调用时相当于对生成器调用了一次next函数。</p><p>但是send方法比next函数更高级，它可以传入一个参数，作为上一次<code>yield表达式的左值</code>。</p><ol><li>send()方法的传入值由生成器外部逻辑决定，可以将上一次生成器的yield返回值作为参考。</li><li>生成器内部下一次yield的返回值，可以根据send方法传入的参数决定。</li></ol><blockquote><p>但注意的时，如果一个生成器刚刚启动（没有返回第一个值），调用send方法时必须传入None。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_generator</span>(<span class="hljs-params">init_val</span>):</span><br>    sended = init_val<br>    <span class="hljs-keyword">while</span> sended:<br>        ret = sended<br>        sended = <span class="hljs-keyword">yield</span> ret<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <br>    g = my_generator(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment"># 调用生成器函数时传入一个参数，作为第一个yield表达式的值。</span><br>    print(g.send(<span class="hljs-literal">None</span>)) <span class="hljs-comment"># 生成器刚刚启动，返回第一个值时必须传入None。</span><br>    print(g.send(<span class="hljs-string">&#x27;world&#x27;</span>))<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>world<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_generator</span>(<span class="hljs-params">dic</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> dic[<span class="hljs-string">&#x27;end&#x27;</span>]:<br>        dic = <span class="hljs-keyword">yield</span> dic[<span class="hljs-string">&#x27;val&#x27;</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    g = my_generator(&#123;<span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;val&#x27;</span>: <span class="hljs-string">&#x27;hello&#x27;</span>&#125;)<br>    print(g.send(<span class="hljs-literal">None</span>))<br>    print(g.send(&#123;<span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;val&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;))<br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式时一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><p>正则表达式的设计思想时用一种描述性的语言来给字符串定义一个规则。</p><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p><strong>一、特殊元字符</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td><code>\</code></td><td>转义字符</td></tr><tr><td><code>.</code></td><td>匹配任意一个字符，除了 \n</td></tr><tr><td><code>[]</code></td><td>匹配[]中列举的字符</td></tr><tr><td><code>[0-9]</code></td><td>数字</td></tr><tr><td><code>[a-z]</code></td><td>小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>大写字母</td></tr><tr><td><code>\d</code></td><td>匹配数字，即[0-9]</td></tr><tr><td><code>\D</code></td><td>匹配非数字</td></tr><tr><td><code>\s</code></td><td>匹配空白，即空格、制表符、换页符</td></tr><tr><td><code>\S</code></td><td>匹配非空白</td></tr><tr><td><code>\w</code></td><td>匹配单词字符，即数字、字母、下划线</td></tr><tr><td><code>\W</code></td><td>匹配非单词字符</td></tr><tr><td><code>\.</code></td><td>匹配<code>.</code></td></tr><tr><td><code>\*</code></td><td>匹配<code>*</code></td></tr><tr><td><code>\+</code></td><td>匹配<code>+</code></td></tr><tr><td><code>\?</code></td><td>匹配<code>?</code></td></tr><tr><td><code>\b</code></td><td>匹配单词边界</td></tr></tbody></table><p><strong>二、量词元字符</strong></p><table><thead><tr><th>数词</th><th>功能</th></tr></thead><tbody><tr><td><code>* </code></td><td>匹配前一个字符串出现0次或n次，即可有可无</td></tr><tr><td><code>+ </code></td><td>匹配前一个字符串出现1次或n次，即至少有1次</td></tr><tr><td><code>?</code></td><td>匹配前一个字符串出现1次或0次，即是否出现在该位置未知</td></tr><tr><td><code>&#123;m&#125;</code></td><td>匹配前一个字符出现m次</td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>匹配前一个字符出现m到n次，包括n次</td></tr><tr><td><code>&#123;m,&#125;</code></td><td>匹配前一个字符出现m到多次</td></tr></tbody></table><blockquote><p><code>?</code> 相当于{0,1}</p><p><code>+</code> 相当于{1,}</p><p><code>*</code> 相当于{0,}</p></blockquote><p><strong>三、匹配开头和结尾</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td><code>^ </code></td><td>匹配字符串开头</td></tr><tr><td><code>$</code></td><td>匹配字符串结尾</td></tr></tbody></table><blockquote><p>在中括号<code>[]</code>中，如果出现<code>^</code>，<code>^</code>修饰的后面字符作为排除字符。</p><p>注意：在中括号内部，需要排除的字符要写在可匹配字符的前面。</p></blockquote><p><strong>四、匹配分组</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>`</td><td>`</td></tr><tr><td><code>() </code></td><td>将括号中的规则作为一个分组, 例如：`r’@(126</td></tr><tr><td><code>\分组号</code></td><td>使用指定的分组.当规则被重复使用时，可将其放在小括号内作为分组，再匹配时，用<code>\分组号</code>匹配该分组。例如<code>r&#39;&lt;(div)&gt;.*&lt;/\1&gt;&#39;</code>可匹配一个div标签（<code>div</code>是由<code>()</code>括起来的第一个分组）。<br><code>r&#39;&lt;(div)&gt;&lt;(span)&gt;&lt;/\2&gt;&lt;(/\1)&gt;&#39;</code>可匹配<code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></td></tr><tr><td><code>(?P&lt;name&gt;)    </code></td><td>给分组起别名</td></tr><tr><td><code>(?P=name)</code></td><td>引用别名为name的分组</td></tr></tbody></table><p>分组别名的使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment">#           定义分组别名使用分组别名</span><br><span class="hljs-comment">#    👇👇</span><br>pattern = <span class="hljs-string">r&#x27;&lt;(?P&lt;d&gt;div)&gt;&lt;(?P&lt;s&gt;span)&gt;hello world&lt;/(?P=s)&gt;&lt;/(?P=d)&gt;&#x27;</span><br>target = <span class="hljs-string">&#x27;&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;&#x27;</span><br><br>result = re.match(pattern, target)<br><br>print(result.group()) &gt;&gt;&gt; &lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;<br><br><span class="hljs-comment"># 使用分组号</span><br>print(result.group(<span class="hljs-number">1</span>)) &gt;&gt;&gt; div<br>print(result.group(<span class="hljs-number">2</span>)) &gt;&gt;&gt; span<br><br><span class="hljs-comment"># 使用分别名</span><br>print(result.group(<span class="hljs-string">&#x27;d&#x27;</span>)) &gt;&gt;&gt; div<br>print(result.group(<span class="hljs-string">&#x27;s&#x27;</span>)) &gt;&gt;&gt; span<br></code></pre></td></tr></table></figure><p>启发：打印分组信息的作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pattern = <span class="hljs-string">r&#x27;.*@(126|163|qq)\.com&#x27;</span><br>target = <span class="hljs-string">&#x27;mzLeman@126.com&#x27;</span><br>result = re.match(pattern, target)<br>print(<span class="hljs-string">&#x27;邮箱代号：%s&#x27;</span> % result.group(<span class="hljs-number">1</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>邮箱代号：<span class="hljs-number">126</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配</title>
    <link href="/2021/01/23/CSS/mobile_adapt/"/>
    <url>/2021/01/23/CSS/mobile_adapt/</url>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="设备屏幕相关概念"><a href="#设备屏幕相关概念" class="headerlink" title="设备屏幕相关概念"></a>设备屏幕相关概念</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>对角线的物理长度，单位英寸，1英寸等于2.54厘米。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕的像素点数</p><ul><li>高清：1920 * 1080</li><li>4K：也叫QHD或UHD（超高清），最小分辨率为3840 * 2160</li></ul><p>iphone6/7/8 分辨率为 1334 * 750，iphone6+/7+/8+的分辨率为1920 * 1080。</p><blockquote><p>我们在书写设备分辨率参数时，往往较大数字写在前面。对于PC来说，横向较长，所以第一个参数指代的时宽度。而对于手机和平板而言，纵向较长，所以第二个参数才指代的是宽度。</p></blockquote><h3 id="DPI-PPI"><a href="#DPI-PPI" class="headerlink" title="DPI/PPI"></a>DPI/PPI</h3><p>Dots Per Inch / Pixels Per Inch，即屏幕上每英寸的像素数量，也就是像素密度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">DPI</span><span class="hljs-operator">/</span><span class="hljs-variable">PPI</span> <span class="hljs-operator">=</span> 屏幕对角线分辨率 <span class="hljs-operator">/</span> 屏幕尺寸<br></code></pre></td></tr></table></figure><h3 id="物理像素与逻辑像素"><a href="#物理像素与逻辑像素" class="headerlink" title="物理像素与逻辑像素"></a>物理像素与逻辑像素</h3><ol><li>物理像素指的是屏幕设备的一个物理发光单元，每个发光点是由红绿蓝进行组合从而可以显示不同的颜色。</li><li>在前端开发中，逻辑像素就是CSS像素。<code>一个逻辑像素可能对应多个物理像素</code>。</li></ol><blockquote><p>我们常说的分辨率就是设备在长和宽方向物理像素的个数。</p></blockquote><h3 id="设备独立像素-DIP"><a href="#设备独立像素-DIP" class="headerlink" title="设备独立像素 DIP"></a>设备独立像素 DIP</h3><p>设备独立像素（DIP，device-independent pixel），即<code>独立于设备的逻辑上衡量像素的单位</code>，<code>是对逻辑像素更加官方的、概念化的描述</code>。在<code>移动Web开发中</code>，就是指的是<code>CSS的逻辑像素</code>。</p><h3 id="设备像素比-DPR-⭐"><a href="#设备像素比-DPR-⭐" class="headerlink" title="设备像素比 DPR ⭐"></a>设备像素比 DPR ⭐</h3><p>设备像素比（Device Pixel Ratio）是默认<code>缩放为100%情况下</code>，<code>物理像素与逻辑像素的比值</code>。</p><blockquote><p>在移动端，手机和平板很少调节分辨率，即调节逻辑像素的大小。所以DPR就比较固定，就有了两倍屏、三倍屏的说法。</p></blockquote><hr><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口可以理解为设备或文档对象的逻辑尺寸。</p><p>前端ppk大神认为，移动设备上有三个viewport（视口）。</p><p>但可以换句话说，可以缩放的浏览器中都具有三个视口概念，分别是 布局视口、视觉视口、理想视口。</p><h3 id="1-布局视口-layout-viewport"><a href="#1-布局视口-layout-viewport" class="headerlink" title="1. 布局视口 layout viewport"></a>1. 布局视口 layout viewport</h3><p>布局视口可以理解为文档对象的逻辑尺寸，单位为逻辑像素（CSS像素）。</p><p><code>在PC端上，布局视口宽度默认等于浏览器窗口的宽度。</code>而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。</p><p>由于历史原因，一些<code>移动设备的浏览器</code>具有<code>默认的布局视口宽度</code>（单位CSS像素）：</p><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229180124466.png" alt="image-20201229180124466"> </p><p>获取布局视口的DOM API：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.documentElement.clientWidth)</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229170641389.png" alt="image-20201229170641389"> </p><h3 id="2-理想视口-ideal-viewport"><a href="#2-理想视口-ideal-viewport" class="headerlink" title="2. 理想视口 ideal viewport"></a>2. 理想视口 ideal viewport</h3><p>理想视口是与设备相关的，是布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时（<code>逻辑尺寸，即有多少个逻辑像素</code>），才是理想视口，此时文档对象宽度与屏幕宽度相同。</p><p>移动设备一般具有固定的DPR，即在缩放100%时，用多少个物理像素显示一个逻辑像素，在Web开发中就是用多少个物理像素去显示一个CSS像素。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">理想视口宽度 <span class="hljs-operator">=</span> 移动设备横向分辨率 <span class="hljs-operator">/</span> <span class="hljs-variable">DPR</span><br></code></pre></td></tr></table></figure><p> 获取理想视口的DOM API：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.screen.width);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229170613912.png" alt="image-20201229170613912"> </p><h3 id="3-视觉视口-visual-viewport"><a href="#3-视觉视口-visual-viewport" class="headerlink" title="3. 视觉视口 visual viewport"></a>3. 视觉视口 visual viewport</h3><p>用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。<code>不管用户如何缩放，都不会影响到布局视口的宽度。</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">视觉视口的宽度 <span class="hljs-operator">=</span> 理想视口宽度 <span class="hljs-operator">/</span> 缩放比例<br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229172033985.png" alt="image-20201229172033985"> </p><hr><h2 id="利用meta标签控制视口"><a href="#利用meta标签控制视口" class="headerlink" title="利用meta标签控制视口"></a>利用meta标签控制视口</h2><p>移动设备的默认布局视口往往大于理想视口，此时就会在横向出现滚动条才能完整的容纳页面。<code>我们需要的是将页面的布局视口设置为理想视口</code>，这就改轮到meta标签出场了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该meta标签的作用是让layout viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让layout viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的布局视口默认值，也就是说会出现横向滚动条。</p><p>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。</p><p><font color="red">meta viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的。</font></p><p>在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：</p><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>正整数或device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或device-height</td><td>定义视口的高度，单位为像素，一般不用</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须小于或等于maximum-scale设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须大于或等于minimum-scale设置</td></tr><tr><td>user-scalable</td><td>yes / no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><p>这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。</p><hr><h3 id="width属性"><a href="#width属性" class="headerlink" title="width属性"></a>width属性</h3><p>width属性用于设置页面的布局视口宽度，属性值不带单位，默认单位为像素。</p><p>其<code>默认值</code>在不同浏览器中不同，但<code>大多数为980</code>。</p><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229180124466.png" alt="image-20201229180124466"> </p><p>但需要注意的是（以下结论都基于Chrome的测试工具）：</p><ol><li><p><code>当只设置width属性值，而不指定initial-scale属性值时，大多数浏览器会自动缩放。</code></p><p>如果width属性值大于理想视口宽度，则视觉视口放大为width的值，计算得到scale小于1.0；</p><p>如果width属性值小于理想视口宽度，则视觉视口缩小为width的值，计算得到scale大于1.0；</p><p>这么做的目的是让设备屏幕把完整的页面呈现出来（页面横向塞满屏幕，计算得到scale），此时：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">布局视口宽度 <span class="hljs-operator">=</span> 视觉视口宽度 <span class="hljs-operator">=</span>  理想视口宽度 <span class="hljs-operator">/</span> 缩放比例<br></code></pre></td></tr></table></figure><blockquote><p>设置width而不指定initial-scale时， 设置minimum-scale = 1.0会能够阻止浏览器放大视觉视口，设置maximum-scale = 1.0 能够阻止浏览器缩小视觉视口。（这里有点绕，可以联想下放大镜）</p></blockquote></li><li><p>将width属性值设置为<code>device-width</code>时，大多数浏览器都能把页面的布局视口宽度变为当前设备的理想视口宽度。</p><blockquote><p>但在iphone和ipad上，无论是竖屏还是横屏，<code>device-width</code>宽度都是竖屏时理想视口的宽度。</p></blockquote></li></ol><hr><h3 id="initial-scale属性"><a href="#initial-scale属性" class="headerlink" title="initial-scale属性"></a>initial-scale属性</h3><p>initial-scale属性用于设置页面初始的缩放比例，缩放比例为<code>理想视口</code>与<code>视觉视口</code>的比值。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">即：<span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> <span class="hljs-variable">idealViewport</span> <span class="hljs-operator">/</span> <span class="hljs-variable">visualViewport</span><br></code></pre></td></tr></table></figure><p><strong>但需要注意的是（以下结论都基于Chrome的测试工具）：</strong></p><ol><li>当只指定<code>initial-scale属性</code>，而不设置<code>width属性</code>时，浏览器会将<code>布局视口宽度</code>设置为视觉视口宽度，以将页面正好铺满屏幕。<strong>可以认为这是一条定律。</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathmetic">布局视口宽度 &#x3D; 设备理想视口宽度 &#x2F; initial-scale<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>当指定<code>initial-scale = 1</code>，而<code>不设置width属性</code>时，大部分浏览器会将<code>布局视口宽度</code>设置为<code>设备理想视口宽度</code>。<strong>这是由推导得来的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathmatic">因为 initial-scale &#x3D; 1<br>所以 视觉视口 &#x3D; 理想视口 ÷ 1.0 &#x3D; 理想视口<br>又因为 没有设置width<br>所以 视觉视口 &#x3D; 布局视口<br>所以 视觉视口 &#x3D; 布局视口 &#x3D; 理想视口<br></code></pre></td></tr></table></figure><blockquote><p>但是WP7系统的IE浏览器中使用横屏时，当指定initial-scale = 1，而不指定width属性时，理应的结果应该是视觉视口等于理想视口时，但偏偏此时的布局视口宽度是竖屏时的理想视口宽度。</p></blockquote></li></ol><ol start="3"><li><p>❗ 当设置<code>initial-scale=1 </code>且同时<code>设置width属性</code>时，如果由<code>理想视口除以init-scale计算得到的视觉视</code>大于<code>width</code>，则<code>width会被浏览器重置为视觉视口</code>。（如果计算得到的视觉视口小于布局视口，就不会出现问题，只是会出现滚动条）原因是 👇</p><pre><code>&gt; 如果视觉视口大于布局视口，就存在逻辑上的问题。</code></pre><blockquote><p>比如说，我iphone8设备理想视口为375px，页面init-scale设置为0.75，那么视觉视口等于375/0.75 = 500px，若width设置为375或device-width，也就是出现了视觉视口大于布局视口的情况。</p><p>那浏览器就纳闷了，你要让我显示500px范围宽的页面，但你告诉我页面实际上只有375px宽，不是奇了怪了吗？所以当视觉视口大于布局视口时，布局视口宽度width会被重置成视觉视口宽度，这应该是浏览器的策略，用于避免显示上的逻辑问题。</p></blockquote></li></ol><hr><h3 id="width-device-width-initial-scale-1"><a href="#width-device-width-initial-scale-1" class="headerlink" title="width=device-width, initial-scale=1"></a>width=device-width, initial-scale=1</h3><p><strong>目的</strong>：</p><p>让我们写的页面在水平方向上恰好与各个设备的屏幕严丝合缝，需要将页面布局视口设置为设备理想视口。</p><p><strong>但是</strong>：</p><ul><li>只设置<code>width = device-width</code> 苹果移动设备横屏时会有bug</li><li>只设置<code>init-scale = 1</code> WP7系统IE浏览器横屏会有bug</li></ul><p><strong>终极方案</strong>：</p><p>将<code>meta:vp标签</code>的属性值设置为<code>width=device-width, initial-scale=1</code>就不仅能够将页面的布局视口自动设置为各个移动设备的理想视口，还能够同时兼容iphone、ipad的Safari以及WP7 IE浏览器的横屏问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="移动端屏幕宽度适配方案"><a href="#移动端屏幕宽度适配方案" class="headerlink" title="移动端屏幕宽度适配方案"></a>移动端屏幕宽度适配方案</h2><h3 id="1-固定大小-px"><a href="#1-固定大小-px" class="headerlink" title="1. 固定大小 px"></a>1. 固定大小 px</h3><ul><li><p>按照最小的屏幕宽度进行布局，让主题内容居中，这样做能保证排版不会发生错误。</p><blockquote><p>大屏幕时两边会存在留白。</p></blockquote></li><li><p>配合媒体查询，在大屏幕时进行布局修改，适当减小两边留白。</p></li></ul><h3 id="2-百分比"><a href="#2-百分比" class="headerlink" title="2. 百分比"></a>2. 百分比</h3><ul><li>高度固定</li><li>border-box</li></ul><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>根据设备屏幕的理想视口动态控制rem大小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* phone.js */</span><br><span class="hljs-comment">/* 在设计稿上是n像素，在写css时就是0.01n rem */</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, win</span>) </span>&#123; <br>   <span class="hljs-keyword">let</span> rem;<br>   <span class="hljs-keyword">let</span> designWidth = <span class="hljs-number">750</span>;  <span class="hljs-comment">// 根据设计稿进行设置</span><br>   <span class="hljs-keyword">let</span> ratio = <span class="hljs-number">100</span>; <span class="hljs-comment">// ratio为人为放大的比例，防止rem小于浏览器限制的最小尺寸，同时要使计算方便。</span><br>   <span class="hljs-keyword">const</span> html = doc.documentElement,<br>         resizeEvt = <span class="hljs-string">&#x27;orientationchange&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>? <span class="hljs-string">&#x27;orientationchange&#x27;</span> : <span class="hljs-string">&#x27;resize&#x27;</span>;<br>    <br>   win.addEventListener(resizeEvt, cb, <span class="hljs-literal">false</span>);<br>   doc.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, cb, <span class="hljs-literal">false</span>);<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span> (<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">const</span> _deviceWidth = html.clientWidth; <span class="hljs-comment">// 获取布局视口大小,meta标签设置的device-width</span><br>     <span class="hljs-keyword">if</span>( !_deviceWidth ) <span class="hljs-keyword">return</span>;<br>     <span class="hljs-keyword">if</span>( _deviceWidth &gt;= <span class="hljs-number">750</span> ) &#123;  <span class="hljs-comment">// device-width&gt;=750，平板或者桌面</span><br>         rem = <span class="hljs-string">&#x27;100px&#x27;</span>; <span class="hljs-comment">// 平板或者桌面rem设置为100px;</span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         rem = ratio * _deviceWidth  / designWidth + <span class="hljs-string">&#x27;px&#x27;</span>;<br>     &#125;<br>     html.style.fontSize = rem;<br>   &#125;<br>    <br>&#125;)(<span class="hljs-built_in">document</span>, <span class="hljs-built_in">window</span>);<br><br></code></pre></td></tr></table></figure><h3 id="4-vw适配"><a href="#4-vw适配" class="headerlink" title="4. vw适配"></a>4. vw适配</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><br><span class="hljs-comment">计算公式 rem = ratio * 100 / designWidth</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15.625vw</span>; <span class="hljs-comment">/* 设计稿为640， 放大100倍*/</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13.333333vw</span>; <span class="hljs-comment">/* 设计稿为750， 放大100倍 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">9.259259vw</span>; <span class="hljs-comment">/* 设计稿为1080，放大100倍*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动端盒子布局常用方法"><a href="#移动端盒子布局常用方法" class="headerlink" title="移动端盒子布局常用方法"></a>移动端盒子布局常用方法</h2><h3 id="1-弹性盒子"><a href="#1-弹性盒子" class="headerlink" title="1. 弹性盒子"></a>1. 弹性盒子</h3><h3 id="2-百分比-1"><a href="#2-百分比-1" class="headerlink" title="2. 百分比"></a>2. 百分比</h3><h3 id="3-尺寸大小单位用rem"><a href="#3-尺寸大小单位用rem" class="headerlink" title="3. 尺寸大小单位用rem"></a>3. 尺寸大小单位用rem</h3>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS中client-offset-scroll等属性的区别</title>
    <link href="/2021/01/06/CSS/client-offset-scroll/"/>
    <url>/2021/01/06/CSS/client-offset-scroll/</url>
    
    <content type="html"><![CDATA[<h1 id="client-offset-scroll等属性的区别"><a href="#client-offset-scroll等属性的区别" class="headerlink" title="client-offset-scroll等属性的区别"></a>client-offset-scroll等属性的区别</h1><h2 id="需要记的边角料小结论"><a href="#需要记的边角料小结论" class="headerlink" title="需要记的边角料小结论"></a>需要记的边角料小结论</h2><p><strong>以下内容都基于将自己写的小Demo在浏览器内进行测试后得到的结论：</strong></p><ul><li><p>⭐ 接下来要讨论的client、offset、scroll前缀的属性，其属性值都不带单位，默认单位为css像素。</p></li><li><p>PC端，如果页面中某个元素出现滚动条，滚动条的宽度默认是由各个浏览器决定的。Chrome中是17px。</p></li><li><p>不确定❓ 移动端，滚动条好像不占宽度 ❓</p></li><li><p>对于开启了绝对定位的元素，left和right属性都为auto时，left值可以认为等于包含块的padding-left。top同理</p></li></ul><h2 id="client前缀的四个属性"><a href="#client前缀的四个属性" class="headerlink" title="client前缀的四个属性"></a>client前缀的四个属性</h2><h3 id="clientWidth和clientHeight"><a href="#clientWidth和clientHeight" class="headerlink" title="clientWidth和clientHeight"></a>clientWidth和clientHeight</h3><p>这两个属性是所有DOM元素的自有属性，包括html标签<code>(document.documentElement对象)</code>。</p><p>简单来说，这两个属性表示DOM元素的<code>可视区域的横向尺寸和纵向尺寸</code>。</p><p><strong>对一般DOM元素而言：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">可视区域长度 <span class="hljs-operator">=</span> 左右<span class="hljs-variable">padding</span> <span class="hljs-operator">+</span> 内容区宽度 <span class="hljs-operator">-</span> 纵向滚动条宽度<span class="hljs-punctuation">(</span>若存在滚动条，<span class="hljs-variable">Chrome</span>默认<span class="hljs-number">17</span><span class="hljs-variable">px</span>。否则为<span class="hljs-number">0</span><span class="hljs-variable">px</span><span class="hljs-punctuation">)</span><br><br>可视区域高度 <span class="hljs-operator">=</span> 上下<span class="hljs-variable">padding</span> <span class="hljs-operator">+</span> 内容区高度 <span class="hljs-operator">-</span> 横向滚动条宽度<span class="hljs-punctuation">(</span>若存在滚动条，<span class="hljs-variable">Chrome</span>默认<span class="hljs-number">17</span><span class="hljs-variable">px</span>。否则为<span class="hljs-number">0</span><span class="hljs-variable">px</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="html的clientWidth和clientHeight"><a href="#html的clientWidth和clientHeight" class="headerlink" title="html的clientWidth和clientHeight"></a>html的clientWidth和clientHeight</h3><p><strong>对于html标签而言，<code>可视区域的定义比较特殊</code>：</strong></p><p>❗  <code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeght</code>是整个DOM参考的最外层盒子尺寸，即为html元素设置尺寸的值为一个百分比时，参考的是自己的clientWidth和clientHeight属性。</p><p><em>一般来说也不会为html元素设置border、margin、padding，所以可以认为html宽度为父容器的百分之百，即默认情况下 html.width  = clientWidth。</em></p><ul><li>⭐移动端</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span> <span class="hljs-operator">=</span> 布局视口宽度<br><br><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientHeight</span> <span class="hljs-operator">=</span> 布局视口高度 <br></code></pre></td></tr></table></figure><blockquote><p>布局视口高度可以在meta viewport标签中通过height属性设置。如果只指定viewport的width和init-scale分别为一个数字，而不指定height，则 布局视口高度 = 布局视口宽度 × 设备屏幕纵横比例</p></blockquote><ul><li>⭐PC端</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">可视区域宽度 <span class="hljs-operator">=</span> 浏览器窗口中页面区域宽度（浏览器视口） <span class="hljs-operator">-</span> <span class="hljs-variable">html</span>自己的纵向滚动条宽度<br><br>可视区域高度 <span class="hljs-operator">=</span> 浏览器窗口中页面区域高度（浏览器视口） <span class="hljs-operator">-</span> <span class="hljs-variable">html</span>自己的横向滚动条高度<br></code></pre></td></tr></table></figure><p><em>只有当html的scrollHeight和scrollWidth大于浏览器视口（html.clientHeight、html.clientWidth）才会出现属于html元素的滚动条</em></p><blockquote><p>注意：是浏览器显示页面区域，而非整个屏幕，因为浏览器一般都会有菜单、选项卡、地址栏等区域。</p><p>❓由于选项卡、地址栏之类浏览器控件的存在，所以在<strong>移动端</strong> document.ducomentElement.clientHeight只代表布局视口高度，不能代表浏览器窗口中网页页面区域的高度。</p></blockquote><ol><li><p>对于body标签而言：</p><p>body标签也属于一般的块级DOM元素，其可视区域为padding+content，只不过他的父元素为html标签对象。</p><p>body标签默认宽度为html的100%, 高度由内容撑开。</p></li></ol><h3 id="clientLeft和clientTop"><a href="#clientLeft和clientTop" class="headerlink" title="clientLeft和clientTop"></a>clientLeft和clientTop</h3><p>这两个属性是所由DOM元素的自有属性，其属性值分别等于DOM元素的左边框宽度和上边框宽度（不带单位px）。</p><h2 id="offset前缀的五个属性"><a href="#offset前缀的五个属性" class="headerlink" title="offset前缀的五个属性"></a>offset前缀的五个属性</h2><h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><ol><li><p>除html、body以外的元素：</p><p>offsetParent指向第一个开启定位的祖先元素，如果没有开启定位的祖先元素，则包含块为body元素</p></li><li><p>html、body元素的offsetParent属性值为null</p></li><li><p>开启固定定位的元素的offsetParent属性值为null</p></li></ol><blockquote><p>❗ offsetParent不同于之前学的包含块的概念。</p><p>其实可以认为开启固定定位的offsetParent是浏览器视口，因为开启固定定位的元素的offsetLeft和offsetTop是基于浏览器视口计算偏移量的。</p></blockquote><h3 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a>offsetWidth和offsetHeight</h3><p><code>offsetWidth</code>和<code>offsetHeight</code>分别表示<strong>DOM元素的盒模型横向、纵向尺寸</strong>。</p><p>对于所有DOM元素（包括html、body），offsetWidth和offsetHeight属性值计算方法如下：</p><p>offsetWidth = 左右boder + 左右padding + contentWidth</p><p>offsetHeight = 上下boder + 上下padding + contentHeight</p><h3 id="html的offsetWidth和offsetHeight"><a href="#html的offsetWidth和offsetHeight" class="headerlink" title="html的offsetWidth和offsetHeight"></a>html的offsetWidth和offsetHeight</h3><blockquote><p>最特殊的盒子一定是html，因为他是最外面的盒子。那么html的盒模型尺寸怎么算 ❓</p></blockquote><p>⭐ <strong>html盒模型的计算方法：</strong></p><p><font color="red">前提：html没有设置margin、border、padding，一般也不会设置</font></p><ul><li><p>宽度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetWidth</span> <span class="hljs-operator">=</span> <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">width</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 设置为 <span class="hljs-variable">n</span> <span class="hljs-variable">px</span>时，其内容区宽度就为<span class="hljs-variable">n</span> <span class="hljs-variable">px</span>。<br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 设置为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> 时，其内容区宽度为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> × <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 默认为 <span class="hljs-variable">auto</span> 时，<span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetWidth</span> <span class="hljs-operator">=</span> <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span><br></code></pre></td></tr></table></figure></li><li><p>高度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">height</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 设置为 <span class="hljs-variable">n</span> <span class="hljs-variable">px</span>时，其内容区高度就为<span class="hljs-variable">n</span> <span class="hljs-variable">px</span>。<br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 设置为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> 时，其内容区高度为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> × <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientHeight</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 默认为 <span class="hljs-variable">auto</span> 时，其内容区高度为由<span class="hljs-variable">body</span>撑开。<br></code></pre></td></tr></table></figure></li></ul><h3 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h3><p>offsetLeft和offsetTop属性表示DOM元素相对于offsetParent可视区域左边界、上边界的偏移量，不带单位px。</p><p>简单来说，offsetParent可视区域的左边界、上边界就是offsetParent内边距的外侧。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 举例1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    *&#123;<br>        padding: 0;<br>        margin: 0;<br>    &#125;<br>    body &#123;<br>        padding-left: 10px;<br>        padding-top: 10px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.box</span> &#123;</span><br>        width: 200px;<br>        height: 200px;<br><span class="css">        <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.content</span> &#123;</span><br>        width: 100px;<br>        height: 100px;<br>        margin-left: 50px;<br>        margin-top: 50px;<br>        background-color: pink<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- ⭐此时div.content的offsetLeft和offsetTop为61 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210105202533732.png" alt="image-20210105202533732"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 举例2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    *&#123;<br>        padding: 0;<br>        margin: 0;<br>    &#125;<br>    body &#123;<br>        padding-left: 10px;<br>        padding-top: 10px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.box</span> &#123;</span><br>        position: relative;<br>        width: 200px;<br>        height: 200px;<br><span class="css">        <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000</span>;</span><br>        padding: 10px;<br>        background-color: grey;<br>        background-clip: content-box;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.content</span> &#123;</span><br>        position: absolute;<br><span class="css">        <span class="hljs-selector-tag">left</span><span class="hljs-selector-pseudo">:50px</span>;</span><br>        width: 100px;<br>        height: 100px;<br>        margin-left: 50px;<br>        margin-top: 50px;<br>        background-color: pink<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>        <span class="hljs-comment">&lt;!-- ⭐此时div.content的offsetLeft和offsetTop为100 </span><br><span class="hljs-comment">等于left + margin-left，因为绝对定位定位原点是div.box的padding左上角</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210105202429426.png" alt="image-20210105202429426"> </p><blockquote><p>html、body元素的offsetLeft和offsetTop值在不同浏览器中计算方法不同。（火狐和Chrome就不相同）</p></blockquote><blockquote><p>❗ 注意：当为body、html设置了padding、border等情况时，offsetParent为body的元素的offsetLeft和offsetTop值会和意想的不一样，所以尽量不要为body和html设置padding和margin还有border。</p></blockquote><h2 id="scroll前缀的四个属性"><a href="#scroll前缀的四个属性" class="headerlink" title="scroll前缀的四个属性"></a>scroll前缀的四个属性</h2><p>scrollWidth和scrollHeight这两个属性用来获取指定元素<code>内容层的真实宽度和高度</code>。</p><blockquote><p>“内容层”不是内容区，是一个抽象概念。</p></blockquote><h3 id="scrollHeight和scrollHeight"><a href="#scrollHeight和scrollHeight" class="headerlink" title="scrollHeight和scrollHeight"></a>scrollHeight和scrollHeight</h3><p><strong>MDN官方解释</strong>：</p><p>The <strong><code>Element.scrollHeight</code></strong> read-only property is a measurement of the height of an element’s content, including content not visible on the screen due to overflow.</p><p>翻译：Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的不可见内容。</p><p>The <strong><code>Element.scrollWidth</code></strong> read-only property is a measurement of the width of an element’s content, including content not visible on the screen due to overflow.</p><p>翻译：Element.scrollHeight 这个只读属性是一个元素内容宽度的度量，包括由于溢出导致的不可见内容。</p><p><strong>以scrollHeight为例：</strong></p><ol><li><p><strong><code>scrollHeight </code>的值等于该元素在不使用滚动条的情况下为了适应视口中所有内容所需的最小高度（包括padding，不包括border、margin和滚动条）。</strong> </p></li><li><p><strong>没有垂直滚动条的情况下（没有设置height或没有溢出的情况发生），scrollHeight值与元素视图填充所有内容所需要的最小值<code>clientHeight</code>相同。包括元素的padding，但不包括元素的border、margin、scrollHeight和滚动条，也包括 <code>::before</code>和 <code>::after</code>这样的伪元素。</strong></p></li></ol><p><strong>scrollHeight的计算方法：</strong></p><ol><li>Chrome中：</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">隐藏的高度 <span class="hljs-operator">=</span> 可见的后代元素在布局之后溢出该元素内容区的最大高度<br><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">top</span> <span class="hljs-operator">+</span> <span class="hljs-variable">contentHeight</span> <span class="hljs-operator">+</span> 隐藏内容的高度 <span class="hljs-operator">+</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">bottom</span><br></code></pre></td></tr></table></figure><ol start="2"><li>火狐、Edge：</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">top</span> <span class="hljs-operator">+</span> <span class="hljs-variable">contentHeight</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">Max</span><span class="hljs-punctuation">(</span>隐藏内容的高度<span class="hljs-operator">,</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">bottom</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><blockquote><p>感觉Chrome更为合理。</p><p>火狐和Edge在隐藏区域的高度小于padding-bottom时是无法滚动的。</p></blockquote><h3 id="scrollTop和scrollLeft"><a href="#scrollTop和scrollLeft" class="headerlink" title="scrollTop和scrollLeft"></a>scrollTop和scrollLeft</h3><p><code>scrollTop</code>：对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，即在出现了纵向滚动条的情况下，滚动条拉动的距离。</p><p><code>scrollLeft</code>：对象的最左边到对象在当前窗口显示的范围内的左边的距离，即在出现了横向滚动条的情况下，滚动条拉动的距离。</p><p><strong>以scrollTop为例：</strong></p><p>该值等于当前容器的内容区顶部那条线</p><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210106211636474.png" alt="image-20210106211636474"> </p><p>❗ <strong>最佳实践</strong>：判断一个容器box是否正好滚动到了某个后代元素盒模型顶部（border-top）</p><ol><li><p>容器box开启定位,，如 position: relative</p></li><li><p>后代元素child不存在其他的开启定位的中间祖先元素，其offsetParent指向box</p></li><li><p>box.scrollTop = child.offsetTop - box.padding-top ⭐⭐（因为offsetTop是相对于offsetParent的padding）</p><blockquote><p>注意，一些布局在容器相对靠下位置的后代元素是永远不会滑动到容器内容区顶部的。</p></blockquote></li></ol><p>❗  <strong>最佳实践：</strong>元素滑到底了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">-</span> <span class="hljs-variable">scrollTop</span> <span class="hljs-operator">==</span> <span class="hljs-variable">clientHeight</span><br></code></pre></td></tr></table></figure><p>❗ <strong>最佳实践</strong>：对可能会发生纵向滚动的页面设置样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">overflow-y</span>: scroll; <span class="hljs-comment">/* 一开始就加上滚动条，防止滚动条的出现和消失影响body.width的计算值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>❗ <strong>最佳实践</strong>：不允许页面整体发生滚动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h2><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210106211714854.png" alt="image-20210106211714854"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核</title>
    <link href="/2020/12/29/CSS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <url>/2020/12/29/CSS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h1><h2 id="五大浏览器"><a href="#五大浏览器" class="headerlink" title="五大浏览器"></a>五大浏览器</h2><ul><li>IE (Internet Explorer)</li><li>火狐 (Firefox)</li><li>谷歌浏览器 (Chrome)</li><li>苹果浏览器 (Safari)</li><li>欧朋浏览器 (Opera)</li></ul><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h3 id="内核的组成"><a href="#内核的组成" class="headerlink" title="内核的组成"></a>内核的组成</h3><p>浏览器内核可以分成两部分:</p><ol><li>渲染引擎，其职责有：<ul><li>取得网页的内容（HTML、XML、图像等）</li><li>整理讯息（例如加入CSS等）</li><li>计算网页的显示方式</li></ul></li><li>JS引擎，其职责为：<ul><li>解析JavaScript语言，执行JavaScript脚本来实现网页的动态效果。</li></ul></li></ol><blockquote><p>最开始渲染引擎和JS引擎没有区分的很明确，后来JS引擎越来越独立，<code>内核就倾向于只指渲染引擎。</code></p></blockquote><h3 id="主流内核"><a href="#主流内核" class="headerlink" title="主流内核"></a>主流内核</h3><ol><li><p>Trident</p><p>代表作：IE</p></li><li><p>Gecko</p><p>代表作：火狐</p></li><li><p>Webkit</p><p>代表作：Safari + 旧版Chrome</p></li><li><p>Blink</p><p>代表作：Opera + 新版Chrome</p></li></ol><h3 id="国产浏览器内核"><a href="#国产浏览器内核" class="headerlink" title="国产浏览器内核"></a>国产浏览器内核</h3><ol><li><code>搜狗浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li><li><code>QQ浏览器</code>  Trident（兼容模式）+ Webkit(高速模式)</li><li><code>UC浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li><li><code>360浏览器</code> IE + Chrome双内核</li><li><code>百度浏览器</code> IE内核</li><li><code>猎豹浏览器</code> IE+Chrome双内核</li><li><code>世界之窗浏览器</code> IE内核</li><li><code>遨游浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li></ol><h3 id="手机操作系统自带浏览器的内核"><a href="#手机操作系统自带浏览器的内核" class="headerlink" title="手机操作系统自带浏览器的内核"></a>手机操作系统自带浏览器的内核</h3><ul><li><p>Android：使用率最高的是Webkit，即使大部分国产手机厂商宣称系统浏览器用的是自己的内核，但也属于Webkit二次开发。</p></li><li><p>IOS：一般是Safari的Webkit。</p></li><li><p>WP7：一般是IE的Trident。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js笔记</title>
    <link href="/2020/12/24/Vue/vue/"/>
    <url>/2020/12/24/Vue/vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>Vue是一个渐进式JavaScript框架。</p><p>高级功能和特点：</p><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><p><strong>Vue.js的Hello world</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello world&quot;</span></span><br>        &#125; <br>        &#125;);<br><span class="handlebars"><span class="xml">        <span class="hljs-comment">&lt;!-- 新建一个Vue对象，在构造函数中传入options对象--&gt;</span></span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font size="4" color="red">Vue采用声明式编程，不同于jQuery以及原生JS操作DOM的命令式编程</font></p><p><img src="/2020/12/24/Vue/vue/image-20200811204642611.png" alt="image-20200811204642611"> </p><h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><img src="/2020/12/24/Vue/vue/image-20200811163236900.png" alt="image-20200811163236900"></p><h2 id="Options对象"><a href="#Options对象" class="headerlink" title="Options对象"></a>Options对象</h2><ul><li><p><strong>el：</strong></p><p>类型：string | HTMLElement</p><p>作用：决定Vue实例会管理哪一个DOM对象</p></li><li><p><strong>data：</strong></p><p>类型：Object | Function</p><p>作用：Vue实例对应的数据对象</p></li><li><p><strong>methods</strong>：</p><p>类型：｛key : Function｝</p><p>作用：定义属于Vue实例的一些方法，可以在其他地方调用，也可以在指令中使用。</p></li><li><p><strong>computed：</strong></p><p>计算属性</p><p>类型：{key : Function}</p><p>作用：定义一些计算属性值供使用。<font color="red">计算属性具有缓存机制，如果计算属性使用的数据没有被修改，则计算属性不会计算多次，当访问该计算属性时，直接从缓存中取值。</font></p><p>==由于缓存机制的存在，当页面中显示的内容只是需要对数据进行简单变换时，尽量使用计算属性，而不是使用函数计算==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>书籍购物车的总价格:&#123;&#123;totalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">el:<span class="hljs-string">&quot;h2&quot;</span>,</span><br>data:&#123;<br>books:[<br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;代码大全&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;现代操作系统&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">50</span>&#125;</span><br>]<br>&#125;,<br>computed:&#123;<br><span class="javascript">totalPrice:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>    &#125;<br>            /*<br>            也可以使用ES6方法的简写<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">totalPrice</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>            &#125;<br>            */<br>&#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color='red'>computed中的计算属性底层的原理 可能 是使用了Proxy</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">comuputed:&#123;<br>    <span class="hljs-comment">//totalPrice:handler</span><br>    totalPrice:&#123;<br>        get&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br>                    pre+=cur.price;<br>                    <span class="hljs-keyword">return</span> pre;<br>                   &#125;,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//get:function()&#123;....&#125;</span><br>        <span class="hljs-comment">//还可以设置set方法</span><br>    &#125;<br>&#125;<span class="hljs-comment">//这种写法同样可以。</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>filters：</strong></p><p>类型：Function</p><p>作用：允许传入一个value，对该值进行过滤或附加处理，返回新的值。</p><p>使用： value | filterFunctionName </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;grade | assessment&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>data:&#123;<br>grade:&#x27;A&#x27;<br>&#125;<br>filters:&#123;<br>assessment(value)&#123;<br>if(value===&#x27;A&#x27;) return &#x27;优秀&#x27;;<br>else   return &#x27;其他&#x27;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/12/24/Vue/vue/image-20200819182643832.png" alt="image-20200819182643832"> </p></li><li><p><strong>components</strong>：</p><p>类型：Object</p><p>作用：定义局部组件</p></li><li><p><strong>watch：</strong></p><p>类型：Object</p><p>作用：监听data中的数据以及props中的通信属性的变化。</p></li><li><p><strong>生命周期函数</strong>：</p><p>如：beforeCreate、created、Mounted、Destroyed…..</p></li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="/2020/12/24/Vue/vue/lifecycle.png"> </p><h2 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;,Mazheng<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--Mustache语法不仅仅可以写变量，还可以写表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27;&#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--另一种写法,不会忽略语法变量之间的空格，会忽略语法变量两端的空格--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <br>    <br>    <br>    <span class="hljs-comment">&lt;!--数值表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>总价：&#123;&#123;price * 2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="文本指令"><a href="#文本指令" class="headerlink" title="文本指令"></a>文本指令</h3><ol><li><p><strong>v-once</strong> </p><p>布尔属性，数据渲染一次后就不再保持绑定，内容不会再随数据改变。</p></li><li><p><strong>v-html</strong></p><p>v-html=”==data==”，会将字符串类型的字面量、变量或表达式当做html内容进行渲染。</p><p>（覆盖标签内原有的内容）。</p></li><li><p>**v-text **</p><p>v-text=”==data==”，会将字符串类型的字面量、变量或表达式作为使用该指令的dom元素的文本（覆盖标签内原有的内容）。</p></li><li><p><strong>v-pre</strong></p><p>v-pre布尔指令，会将标签中包裹的内容原原本本的展示。（忽略mustache语法）</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>hahaha<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-comment">&lt;!--会覆盖hahaha v-text不如mustache语法灵活--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>引入vue<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">       el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>       data:&#123;<br><span class="handlebars"><span class="xml">           message:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&quot;</span></span><br>       &#125; <br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h3><p>防止闪动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br><span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  在vue解析后会将v-cloak属性去掉  --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h3><pre><code>v-bind指令用于将DOM元素的属性值与数据绑定。语法糖 ==使用冒号代替v-bind==</code></pre><ol><li><p><strong>动态绑定a元素的href属性以及img元素的src属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">div#app<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>div#app<br><br>app=new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>imgURL:https://XXXXX.img,<br>aHref:https://www.baidu.com<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>动态绑定HTML元素的class属性</strong></p><ul><li><p>对象写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;属性名1:boolean,属性名2:boolean&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--与既有的class属性共存,v-bind使用语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>👇<br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--isLine为false--&gt;</span><br><br><span class="hljs-comment">&lt;!--v-bind:class取函数返回值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!--总之,v-bind绑定class的对象写法，属性值的形式为 &quot;Obeject&quot;  --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            isActive:<span class="hljs-literal">true</span>,</span><br><span class="javascript">            isLine:<span class="hljs-literal">false</span></span><br>        &#125;<br>        <br>        methods:&#123;<br>        getClasses ()&#123;<br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">active</span>:<span class="hljs-built_in">this</span>.isActive,<span class="hljs-attr">line</span>:<span class="hljs-built_in">this</span>.isLine&#125;;<span class="hljs-comment">//返回一个对象</span></span><br>    &#125;<br>    &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>数组写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--语法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--list为一个含有字符串类型元素的数组--&gt;</span><br><br><span class="hljs-comment">&lt;!--例子--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[class1,class2,...classN]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>data:&#123;<br>class1:&#x27;active&#x27;,<br>class2:&#x27;red&#x27;<br>&#125;<br><br>methods:&#123;<br>getClasses()&#123;<br>return [this.class1,this.class2];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p><strong>动态绑定样式</strong></p><ul><li><p>对象写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;css属性名:属性值(string类型)...&#125;&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     css属性名只能使用驼峰命名法!!!!!!</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;color:&#x27;red&#x27;,fontSize:&#x27;16px&#x27;&#125;&quot;</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;backgroundColor:backColor&#125;&quot;</span>&gt;</span><br>    <br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    backColor:&#x27;#fff&#x27;<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>数组写法（是基于对象写法）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...Obejects]&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[style1,style2]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...styles]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <br><br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    style1:&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,<br>    style2:&#123;color:&#x27;red&#x27;&#125;<br>styles:[&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,&#123;color:&#x27;red&#x27;&#125;]<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h3><p>   语法糖   ==用@代替v-on== </p><p>   <strong>基本使用</strong>：v-on:==事件名.修饰符== =”函数/单句表达式/Object”</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count--&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>add()&#123;<br>this.count++;<br>&#125;,<br>decrease()&#123;<br>this.count--;<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>   <strong>事件响应函数的传参问题</strong></p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--实参和形参匹配时的正常调用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf&quot;</span>&gt;</span>没有实参和形参,当函数不带参数时，可省略括号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf()&quot;</span>&gt;</span>没有实参和形参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;y-printf(&quot;</span><span class="hljs-attr">hello</span>&quot;,&quot; <span class="hljs-attr">world</span>!&quot;)&quot;&gt;</span>处理两个参数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--实参和形参不匹配时的处理策略--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf(123)&quot;</span>&gt;</span>有形参，输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=123--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf&quot;</span>&gt;</span>有形参，但不输入实参，且不带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=$event,会把事件对象当做第一个参数传入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf()&quot;</span>&gt;</span>有形参，但不输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=undefined--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf($event)&quot;</span>&gt;</span>有形参，输入实参$event，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--val=$event 强制输入事件对象--&gt;</span><br>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>printf()&#123;<br>console.log(&quot;hello world&quot;);<br>&#125;,<br>x-printf(val)&#123;<br>console.log(val);<br>&#125;<br>y-printf(val,event)&#123;<br>console.log(val,event);<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>   <strong>修饰符</strong>：</p><ul><li><p><strong>.stop</strong>  取消事件冒泡</p><p>@click.stop=”==fun==”</p></li><li><p><strong>.prevent</strong> 取消默认行为</p><p>@click.prevent=”==fun==” 取消dom元素的默认行为</p></li><li><p>**.键盘键号   **</p><p>@keyup.enter=”==fun==” 指定当enter键松开时的行为</p><p>@keyup.13=”==fun==”      enter的代号为13</p></li><li><p>**.native **    监听组件根元素的原生事件</p></li><li><p>**.once **  只触发一次该事件</p><p>@click.once=”==fun==”</p></li></ul><hr><h3 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h3><p><strong>具有条件判断指令的标签，如果逻辑条件不符合，不会存在于DOM树中</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;score&gt;=90&quot;</span>&gt;</span><br>    成绩：优秀<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;score&gt;=60&quot;</span>&gt;</span><br>    成绩：及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    成绩：不及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>    成绩:&#123;&#123;grade&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>data:&#123;<br>score:70<br>&#125;<br>computed:&#123;<br>grade()&#123;<br>if(this.score&gt;=90) return &quot;优秀&quot;;<br>else if (this.score&gt;=60) return &quot;及格&quot;;<br>else return &quot;不及格&quot;;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h3><p>v-show=”false”时，标签存在于DOM树中，但会添加内联样式 display:none</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>当需要在显示与隐藏之间切换很频繁时，使用v-show指令</p></li><li><p>当只有一次切换，或元素互斥存在时，使用v-if</p></li></ul><hr><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>可以使用v-for指令遍历数组和JS普通对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--根据需要，在Vue里可以使用类似&quot;元祖&quot;的语法遍历数组的元素及索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>&gt;</span>&#123;&#123; `$&#123;index&#125;.$&#123;item&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--遍历对象的属性值、属性名及属性名的索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val,key,index) in obj&quot;</span>&gt;</span>&#123;&#123; `$&#123;key&#125;:$&#123;val&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">在v-for绑定的数据可能存在动态修改的情况时（如动态增加删除一个元素），建议为标签添加一个key属性，key的属性值应能唯一标识数据中的各个元素。添加key属性可以提高dom动态渲染性能。</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>==Vue是响应式的，当数据变化时，Vue会检测到数据的变化，并反应到视图上。==</p><p>==我们常用v-for指令绑定数组数据，Vue中包含了一组观察数组变化的方法。==</p><p>==当调用数组某些方法改变元素时，会触发视图的更新==</p><pre><code>包括：所有改变数组自身的方法(pop,push,unshift,sort,reverse等等)注意：使用下标改变数组元素的方法不会被Vue监听到，&lt;font color=&quot;red&quot;&gt;数据会发生改变，但视图不会发生改变。&lt;/font&gt;❌  lis[0]=xxx;✔  Vue.set(lis,&#39;0&#39;,xxx)    **使用Vue的set方法改变对象的属性值会被检测到，并反应到视图上**</code></pre><hr><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>==要求：当点击一个li时，该li的color为红色，其他为默认颜色==</p><p><img src="/2020/12/24/Vue/vue/image-20200816153838359.png" alt="image-20200816153838359"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.active</span>&#123;</span><br>            color: red;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:currentIndex===index&#125;&quot;</span></span><br><span class="hljs-tag">             @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;beActive(index)&quot;</span></span><br><span class="hljs-tag">         &gt;</span><br>         &#123;&#123;`$&#123;index&#125;.$&#123;item&#125;`&#125;&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                lis:[<span class="hljs-string">&#x27;mazheng&#x27;</span>,<span class="hljs-string">&#x27;ley&#x27;</span>],</span><br><span class="javascript">                currentIndex:<span class="hljs-number">0</span>         <span class="hljs-comment">//使用currentIndex记录上次点击的元素索引</span></span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">beActive</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.currentIndex=index;</span><br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="/2020/12/24/Vue/vue/image-20200816171940331.png" alt="image-20200816171940331"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        table&#123;<br>            width: 600px;<br>            border-collapse: collapse;<br>        &#125;<br>        th,td&#123;<br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span> 10<span class="hljs-selector-tag">px</span>;</span><br>            text-align: left;<br>            border: 1px black solid;<br>        &#125;<br>        th&#123;<br>            background-color: silver;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>出版日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>购买数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in books&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>《&#123;&#123;item.title&#125;&#125;》<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.releaseDate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> &#123;&#123;item.price | showPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--当书籍数量小于等于1时，按钮不可用--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;item.num &lt;= 1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decOne(index)&quot;</span>&gt;</span><br>                            -<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                        &#123;&#123;item.num&#125;&#125;<br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addOne(index)&quot;</span>&gt;</span><br>                            +<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeBook(index)&quot;</span>&gt;</span><br>                            移除<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br>                books:[<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;算法导论&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-06&#x27;</span>,</span><br>                        price:85,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;UNIX编程艺术&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-02&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;代码大全&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2008-10&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;<br>                ]<br>            &#125;,<br><span class="javascript">            filters:&#123;  <span class="hljs-comment">//过滤器。跟计算属性类似，但是调用的方法不太一样</span></span><br><span class="handlebars"><span class="xml">                //<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span> | showPrice&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     使用&quot; | &quot;调用过滤器,左边为参数</span></span><br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">showPrice</span>(<span class="hljs-params">price</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-string">`￥<span class="hljs-subst">$&#123;price.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span>;</span><br>                &#125;<br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">addOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num+=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">decOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num-=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">removeBook</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books.splice(index,<span class="hljs-number">1</span>);</span><br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><p>实现表单元素的双向绑定。绑定的数据主要用于自定义的ajax请求，也可以供其他功能使用。</p><p>如果表单元素仍然使用表单提交请求，则请求发送的仍然是表单元素的value值，跟v-model绑定的数据并无关系。</p><p>==1.与文本类表单元素结合使用==</p><p>将input的value和message变量进行绑定。文本框改变value，message的值也随之改变。改变message的值，文本框中的内容也随之改变。（双向绑定）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//只使用v-model绑定数据，但不使用name标识表单元素，这种表单元素不会被表单提交（因为没有name属性）<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原理</strong></p><p>v-model其实是一个语法糖，它的背后本质是包含两个操作：</p><ol><li><p>监听表单元素的特征事件，根据情况更新绑定的数据</p></li><li><p>监测数据的变化，更新表单元素的属性值 如value checked…（属性值的改变会体现到视图上）。</p><p> 例如：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//使用两个命令的组合实现input标签的v-model的功能<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><u>textarea标签与input标签类似可以使用v-model指令实现上述功能</u></p><p>==2.与单选按钮结合使用==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--应当为每个单选按钮设置value属性--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这类没有name属性的radio不会随表单提交--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">radioVal:<span class="hljs-number">0</span>   <span class="hljs-comment">// 初始值为0，代表默认第一个按钮选中。数字、字符串都可以。</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>==3.与checkbox结合使用==</p><ul><li><p>单个复选框，宜使用v-model绑定一个bool类型的变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isChecked&quot;</span>&gt;</span><br>//当选中时，isChecked值会为true,不选中时为false<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">isChecked=<span class="hljs-literal">false</span>   <span class="hljs-comment">//isChecked默认值设为false，代表默认不选中</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>多个复选框（绑定同一个数据），宜使用v-model绑定一个<strong>空数组,**或</strong>具有初始值的数组**。</p><p><font color="red">（可以为数组指定初始元素，以表示默认选中的复选框，但初始元素的值应出自默认选中复选框的value。因为checkbox取消选中时只会删除数组中的响应value，而不会删除不存在于所有复选框value中的其他值。即初始化数组时，初始元素若不存在于所有value中，则会始终存在于绑定的数组里）</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>] <span class="hljs-comment">//默认选中第一个复选框</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in origins&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span> &#123;&#123;item&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br>        balls:[],<br><span class="javascript">        origins:[<span class="hljs-string">&#x27;basketball&#x27;</span>,<span class="hljs-string">&#x27;football&#x27;</span>,<span class="hljs-string">&#x27;badminton&#x27;</span>]<span class="hljs-comment">//从后台获取</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><u>checkbox标签中使用v-model属性，会使checked属性失效。复选框是否<strong>默认</strong>选中，只与v-model绑定的数据有关。</u></p><p>==4.与select标签结合使用==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--单选select--&gt;</span> 类似于radio button<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ball&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">basketball</span>&quot;&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">football</span>&quot;&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">badminton</span>&quot;&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        ball:<span class="hljs-string">&quot;basketball&quot;</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--多选select,添加multiple布尔属性--&gt;</span> 类似于checkbox<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">basketball</span>&quot;&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">football</span>&quot;&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">badminton</span>&quot;&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>]</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修饰符</strong></p><ol><li><p>lazy修饰符，常与input text标签使用</p><p>作用：让标签在失去焦点或在input中敲回车时才更新数据</p><p>（默认情况下，v-model是在input事件发生时立刻更新数据，lazy可以减少更新次数）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>number修饰符，常与input text标签使用</p><p>作用：获取input text标签内的value，转为number类型后再更新数据，即v-model绑定的数据会是number类型</p><p>（input text的value永远是string类型）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;marks&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>trim修饰符，常与input Text标签使用</p><p>作用：获取input text的value，去除首尾的空格后再更新数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><img src="/2020/12/24/Vue/vue/image-20200817190948735.png" alt="image-20200817190948735"></p><p><img src="/2020/12/24/Vue/vue/image-20200818104015488.png" alt="image-20200818104015488">  </p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><img src="/2020/12/24/Vue/vue/image-20200818104048034.png" alt="image-20200818104048034">  </p><p>全局组件可以在多个不同的Vue实例中使用。但<font color="red">Vue实例才是根组件</font>，因为全局组件必须在Vue实例中才能使用。</p><ol><li><p><strong>调用Vue.extend()方法<font color="red">创建组件构造器</font></strong></p><p>👇</p><ol start="2"><li><strong>调用Vue.component()方法<font color="red">注册组件</font></strong></li></ol><p>👇</p><ol start="3"><li><strong>在Vue实例或其他组件内<font color="red">使用组件</font></strong></li></ol></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--全局组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用全局组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>        <br><span class="javascript">        <span class="hljs-comment">//---------------------------------------------------------</span></span><br>        <br><span class="javascript"> <span class="hljs-comment">//创建组件构造器对象</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> cpnC=Vue.extend(option);  <span class="hljs-comment">//传入该对象，创建组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//注册全局组件，注册后cpn标签就可以在vue的实例以及各个组件内使用了</span></span><br>        <br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,cpnC);<span class="hljs-comment">//注册全局组件。第一个参数是组件标签名，第二个参数是组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-comment">&lt;!--注册全局组件的简写方式--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> P element <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">          &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>          template:template<br>      &#125;<br>      <br><span class="javascript">Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,option); <span class="hljs-comment">//将extendOptions对象直接传入，而不是组件构造器对象</span></span><br>      <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ol><li><p>创建模板</p><p>👇</p></li><li><p>创建extendOptions对象</p><p>👇</p></li><li><p>在Vue实例或父组件中注册</p><p>👇</p></li><li><p>在Vue实例或父组件中使用</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--局部组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用局部组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;;<br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>            components:&#123;<br><span class="javascript">            cpn:option            <span class="hljs-comment">//在components属性中注册组件</span></span><br>        &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h3><p><font color="red">子组件本质上就是局部组件</font></p><p><font color="red">祖先组件和后代组件之间不能越级使用，除非后代组件在祖先组件中注册过</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn1</span>&gt;</span> <span class="hljs-comment">&lt;!--父组件的使用--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> temp2=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`;</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn2=Vue.extend(&#123;</span><br>        template:temp2<br>    &#125;);<br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> temp1=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span>  <span class="hljs-comment">&lt;!--子组件的使用--&gt;</span>  </span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   `;        </span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=Vue.extend(&#123;</span><br>        template:temp1,<br>        components:&#123;<br>            cpn2<br>        &#125;<br>    &#125;);<br><br><br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br><span class="javascript">            cpn1     <span class="hljs-comment">//挂载cpn1父组件</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用传入extendOptions直接注册组件--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=&#123;</span><br>        template:`<br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`,</span></span><br>        components:&#123;<br>            cpn2:&#123;<br>                template:`<br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span></span><br>            &#125;<br>        &#125;<br>    &#125;;<br>    <br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br>            cpn1<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="模板的抽离"><a href="#模板的抽离" class="headerlink" title="模板的抽离"></a>模板的抽离</h3><ol><li><p>第一种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-template&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp1&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp1&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>第二种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp2&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h3><p>组件拥有自己的数据，组件中<strong>不能直接访问</strong>父级组件以及子组件的数据。</p><p>组件的extendOptions中的data属性的属性值必须是Function，这个Function是一个工厂函数，返回一个对象，对象中包含组件自己的数据。</p><p>（利用工厂函数的特点，即每次返回一个新的包含数据的对象，来防止相同组件数据相互干扰）</p><p><img src="/2020/12/24/Vue/vue/image-20200818150856104.png" alt="image-20200818150856104"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">            template: <span class="hljs-string">&#x27;#temp2&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">            data: <span class="hljs-function">() =&gt;</span> (&#123;  <span class="hljs-comment">//用小括号把返回的对象扩起来，防止解析成代码块</span></span><br><span class="javascript">                message: <span class="hljs-string">&#x27;hello world&#x27;</span></span><br>            &#125;)<br>        &#125;)<br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                message:<span class="hljs-string">&#x27;hello Vue&#x27;</span></span><br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><p>==<font size="4">一、父传子：在子组件props属性挂载通信属性</font>== </p><p>子组件的props属性挂载通信属性，父组件使用子组件时，在子组件标签中使用v-bind为通信属性绑定父组件的数据，在子组件中通信属性的同名变量就获取到了父组件传来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:message-c</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--   驼峰命名法→连字符   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;today&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;console.log(messageC)&quot;</span>&gt;</span>通信<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            <br>        &#125;),<br><span class="javascript">        props:[<span class="hljs-string">&#x27;messageC&#x27;</span>,<span class="hljs-string">&#x27;today&#x27;</span>]</span><br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">由于dom标签中不区分大小写，当props挂载的通信属性名有大写字母时，应注意：</font></p><ol><li><p>使用驼峰命名法时（第一个字符小写，后面单词首字母大写），v-bind绑定的组件标签属性的属性名使用<strong>连字符写法</strong>。例如，上面的demo中 messageC   ,在绑定该属性时使用了  v-bind:message-c 。若子组件属性标签中绑定”messageC”，则默认传的通信属性实际为 “messagec”。</p></li><li><p>若通信属性第一个字母大写，则v-bind绑定的子元素标签属性名第一个字母大小写都可以。</p></li></ol><p><u>归纳：通信属性名第一个字母不要大写，尽量使用一个单词命名通信属性。若使用驼峰命名法，v-bind绑定时在大写字母前使用连字符。</u></p><p><strong>props属性的写法</strong></p><ol><li><p>数组写法</p><p>由于数组写法功能没有对象写法强大，所以较少使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">props:[&#x27;messageC&#x27;,&#x27;today&#x27;]<br></code></pre></td></tr></table></figure></li><li><p>对象写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//指定通信属性的类型  type</span><br>props:&#123;<br>    messageC: <span class="hljs-built_in">String</span>,<br>    today: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">Number</span>,<br>    books: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>], <span class="hljs-comment">//指定Array或String类型</span><br>    owner: <span class="hljs-built_in">Object</span><br>&#125;<br><br><span class="hljs-comment">//指定默认值  default 当指定Object以及Array类型的默认值时，default应是一个工厂函数返回默认值</span><br><span class="hljs-comment">//要想子组件在一开始时使用default中的默认值，则父组件传来的数据初始值应为undefinded</span><br>props:&#123;<br>    messageC:&#123;<br>        type: <span class="hljs-built_in">String</span>,<br>        <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;hello wolrd&#x27;</span><br>    &#125;<br>    books:&#123;<br>        type: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>]<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>    &#125;<br>    owner:&#123;<br>        type: <span class="hljs-built_in">Object</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指定必须传入 required</span><br>props:&#123;<br>    books:&#123;<br>        type: <span class="hljs-built_in">Array</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>        required: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义验证函数 validator</span><br><br></code></pre></td></tr></table></figure></li></ol><ul><li><p><strong>props属性挂载的通信属性（变量），从设计的初衷来看，应该是只读属性。</strong></p><p><strong>所以在组件里避免有代码可以修改通信属性的值。</strong></p></li><li><p><strong>通信属性的值和父组件的数据是动态绑定的，一旦父组件数据发生改变，会立刻传递给子组件。</strong></p></li></ul><p>==<font size="4">二、子传父：发射（emit）自定义事件</font>== </p><p>1.子组件监听DOM事件（如click），在事件响应函数中处理逻辑，然后发射自定义事件并传入通信数据。</p><p>👇</p><p>2.父组件在子组件的标签内监听自定义事件并接收通信数据。自定义事件的响应函数不需要传参。</p><p><font color="red">（虽然没有使用括号调用，但自定义事件的响应函数不会像dom事件一样默认传入事件对象，因为自定义事件没有事件对象。）</font></p><p><font color="red" size="5">注意：由于dom标签无法识别大小写，在没有使用Vue cli的情况下，自定义事件名不允许出现大写字母。例如 不允许出现”clickLi”这种事件名</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">clickli</span>=<span class="hljs-string">&quot;getClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--  父组件监听子组件的自定义事件clickli   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in categories&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;myClick(item.id,item.name)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--事件响应函数--&gt;</span><br>            &#123;&#123;item.name&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   </span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            categories:[<br>                &#123;<br>                    id:1,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;mz&#x27;</span></span><br>                &#125;,<br>                &#123;<br>                    id:2,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;ley&#x27;</span></span><br>                &#125;<br>            ]<br>        &#125;),<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">myClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;clickli&#x27;</span>,id,name);  <span class="hljs-comment">//发生自定义事件，这里传入了两个通信数据id和name。</span></span><br>            &#125;<br>        &#125;<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">getClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(id,name);</span><br>            &#125;<br>        &#125;<br>        <br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>实现父子组件之间的双向通信。</p><p>在父组件的输入框输入要传递的数据，在子组件的文本框显示。</p><p>在子组件的输入框输入要传递的数据，在父组件的文本框显示。</p><p>在子组件的watch属性中定义要监听的数据的同名函数，以监听子组件数据的变化，并发送给父组件。</p><p><img src="/2020/12/24/Vue/vue/image-20200819181030339.png" alt="image-20200819181030339"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            向子传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>            子组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ctoday&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;today&quot;</span> @<span class="hljs-attr">cinput</span>=<span class="hljs-string">&quot;getCtoday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                向父传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;inputDate&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--懒监听--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                父组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                today:<span class="hljs-string">&#x27;2020-08-19&#x27;</span>,</span><br><span class="javascript">                ctoday:<span class="hljs-string">&#x27;&#x27;</span>,</span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">getCtoday</span>(<span class="hljs-params">value</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.ctoday=value;</span><br>                &#125;<br>            &#125;,<br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            inputDate:<span class="hljs-string">&#x27;&#x27;</span></span><br>                        &#125;<br>                    &#125;,<br>                    props:&#123;<br>                        today:&#123;<br><span class="javascript">                            type:<span class="hljs-built_in">String</span></span><br>                        &#125;<br>                    &#125;,<br>                    watch:&#123;<br><span class="javascript">                        <span class="hljs-comment">//在watch中定义inputDate的同名函数，监听该数据的变化，处理逻辑</span></span><br><span class="javascript">                        <span class="hljs-function"><span class="hljs-title">inputDate</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123; </span><br><span class="javascript">                            <span class="hljs-built_in">console</span>.log(oldValue,<span class="hljs-string">&#x27;=&gt;&#x27;</span>,newValue);</span><br><span class="javascript">                            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;cinput&#x27;</span>,newValue);</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件之间的直接访问"><a href="#父子组件之间的直接访问" class="headerlink" title="父子组件之间的直接访问"></a>父子组件之间的直接访问</h3><p>==一、父组件直接访问子组件==</p><p>在父组件中，可以通过this.$children或this.$refs拿到所有子组件。</p><ul><li><p>$children属性是一个数组，可以像this.$children[index]的型式通过下标拿到子组件对象。（不常用）</p></li><li><p>$refs属性是一个对象，子组件标签中设置ref属性标识自己，父组件可以通过this.$refs[ref]的形式获取特定的子组件对象。（更常用）</p></li></ul><p>可访问到的子组件内容：几乎所有内容（数据、方法）。</p><p>==二、子组件直接访问父组件==</p><p>在子组件中，可以通过this.$parent拿到父组件对象。</p><p>同时可以使用this.$root直接拿到Vue实例对象。（Vue实例是根组件）</p><p>由于组件之间耦合度不应该太高，所以很少在子组件中访问父组件。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><strong>基本使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>以下是一个插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>插槽默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li><p>在组件的模板中留下slot标签标识插槽</p></li><li><p>插槽中可以留有默认内容</p></li><li><p>使用时在组件标签内为插槽填充内容</p></li></ul><p><strong>具名插槽</strong></p><p>定义：具有name属性的slot标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <br><br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>            左插槽的div<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左插槽的span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>为组件的各个插槽标签填写name属性，标识具名插槽。</li><li>在使用组件时，在组件标签内为插槽填充内容，各个内容（html标签）的slot属性标明要往哪个插槽添加内容。</li><li>可以为同一个插槽添加多条内容（标签），具有相同slot属性的内容会全部添加到同一个插槽中。</li><li>如果添加的内容（标签）没有slot属性，则添加到所有不具名的插槽中。</li></ul><p><strong>作用域插槽</strong></p><p>应用情景：在父组件中为子组件的插槽中添加内容，但内容中需要访问子组件的内容。</p><p>旧版Vue方法：</p><ol><li><p>子组件模板中在作用域插槽绑定子组件数据，语法为 :data1=”==子组件数据1==” :data2=”==子组件数据2==”。data1、data2可以改各种任意名字，前面使用v-bind，代表作用域插槽中的变量名。</p></li><li><p>要想使用作用域插槽，必须使用template标签来替换插槽中的内容。</p></li><li><p>template标签中为slot-slope属性赋值，值为作用域对象变量名，之后便可以使用该对象拿到作用域插槽中的子组件数据。</p><template  slot="s1" slot-scope="s1scope">    <span></span>    <span></span></template></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;s1scope&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;s1scope.lans.join(&#x27;-&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">:lans</span>=<span class="hljs-string">&quot;languages&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;lan in languages&quot;</span>&gt;</span><br>                    &#123;&#123;lan&#125;&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            languages:[<span class="hljs-string">&#x27;C#&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>]</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新版Vue的写法：</p><p>使用v-slot指令代替原本的slot属性+slot-scope属性。</p><p>v-slot:==插槽的name===”==作用域对象变量名==”</p><template  v-slot:s1="s1scope">    <span></span>    <span></span></template><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:s1</span>=<span class="hljs-string">&quot;s1scope&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;s1scope.lans.join(&#x27;-&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">:lans</span>=<span class="hljs-string">&quot;languages&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;lan in languages&quot;</span>&gt;</span><br>                    &#123;&#123;lan&#125;&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            languages:[<span class="hljs-string">&#x27;C#&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>]</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>At its core,webpack is a static module bundler for modern JavaScript applications.</p><p>webpack是一个现代的JS应用的静态模块打包工具。</p><p><strong>核心：让我们可能进行模块化开发，并帮助处理模块间的依赖关系。</strong></p><p>而且不仅仅是js文件，css、图片、json等等在webpack中都可以被当做模块来使用。</p><p>支持AMD、CMD、CommonJS以及ES6模块化规范。</p><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><ul><li><p>依赖于Node环境。Node版本&gt;8.9。</p></li><li><p>全局安装webpack </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack@3.6.0 -g<br></code></pre></td></tr></table></figure></li><li><p>局部安装（开发时依赖）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack@3.6.0 --save-dev<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ol><li><p>在项目目录新建文件夹</p><p>dist    发布</p><p>src     源码</p></li><li><pre><code class="bash">webpack ./src/main.js ./dist/bundle.js<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>   根据main.js中的依赖，去打包所有需要的模块。<br><br><br><br>------<br><br><span class="hljs-comment">### webpack.config.js与package.json</span><br><br><br><br>**webpack的配置**<br><br>需求：设置默认的入口文件，执行webpack命令时打包该文件。<br><br>```javascript<br><span class="hljs-regexp">//</span>webpack.config.js  配置webpack的文件<br><br>const NodePath=require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br>module.exports=&#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<span class="hljs-regexp">//</span>默认的入口文件，路径可以是相对路径<br>    output:&#123;<br>        path:NodePath.join(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>),<span class="hljs-regexp">//</span>输出文件的目录，必须使用绝对路径<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span><span class="hljs-regexp">//</span>输出的文件名<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol><p><strong>将webpack命令与npm命令绑定映射</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200827231027114.png" alt="image-20200827231027114"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>相当于执行了 webpack指令，同时只有这样配置并使用该指令，才会优先使用局部（本地）中的webpack。（node_modules的bin目录下的控制台指令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">webpack<br></code></pre></td></tr></table></figure><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>依赖于Node环境，并全局安装webpack</li><li>npm intsall -g @vue/cli</li></ol><p>以上是安装脚手架3的步骤，如果需要兼容脚手架2的语法，需要额外执行第三条：</p><ol start="3"><li>npm install -g @vue/cli-init</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试</span><br>vue --version<br></code></pre></td></tr></table></figure><h3 id="使用cli2初始化一个项目"><a href="#使用cli2初始化一个项目" class="headerlink" title="使用cli2初始化一个项目"></a>使用cli2初始化一个项目</h3><ol><li><pre><code class="dos">vue init webpack $项目名称   👉会在当前目录创建同名文件夹<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>![image<span class="hljs-number">-20200828201856002</span>](./image<span class="hljs-number">-20200828201856002.</span>png)<br><br><br><br>### 使用cli3初始化一个项目<br><br><span class="hljs-number">1.</span> ```dos<br>   vue create $项目名称<br></code></pre></td></tr></table></figure>![image-20200922221753466](./image-20200922221753466.png)</code></pre></li></ol><hr><h2 id="Vue-router-前端路由"><a href="#Vue-router-前端路由" class="headerlink" title="Vue-router 前端路由"></a>Vue-router 前端路由</h2><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><p>后端渲染阶段</p><p>👇   +ajax</p><p>前后端分离阶段</p><p>👇   +前端路由</p><p>SPA 单页面富应用阶段</p><p><strong>如何实现前端路由？</strong></p><p>要实现前端路由，需要解决两个核心：</p><ul><li>如何改变 URL 却不引起页面刷新？</li><li>如何检测 URL 变化了？</li></ul><p>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p><ol><li><h5 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h5><ul><li>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新。</li><li>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过<code>&lt;a&gt;</code>标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件</li></ul></li><li><h5 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h5><ul><li>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li></ul></li></ol><p>==参考资料：==[<a href="https://www.cnblogs.com/lguow/p/10921564.html]">https://www.cnblogs.com/lguow/p/10921564.html]</a></p><hr><h3 id="vue-router-安装与基本使用"><a href="#vue-router-安装与基本使用" class="headerlink" title="vue-router 安装与基本使用"></a>vue-router 安装与基本使用</h3><p><img src="/2020/12/24/Vue/vue/image-20200829225840412.png" alt="image-20200829225840412"></p><p>目录结构：</p><p>project</p><p>—components目录</p><p>——Home.vue    //组件</p><p>——About.vue   //组件</p><p>—router目录</p><p>——index.js    //路由配置文件</p><p>—main.js</p><p>—App.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># main.js<br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>   <span class="hljs-comment">//根组件</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index.js&#x27;</span>  <span class="hljs-comment">//可省略index.js</span><br><br>Vue.config.productionTip=<span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router:router,  <span class="hljs-comment">//挂载路由</span><br>    render:<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>h(App)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p><img src="/2020/12/24/Vue/vue/image-20200829231314899.png" alt="image-20200829231314899"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># index.js<br><br><span class="hljs-comment">//事先准备好Home和About两个组件</span><br><br><span class="hljs-comment">/*路由组件与路由的映射 </span><br><span class="hljs-comment">/home  👉  Home.vue</span><br><span class="hljs-comment">/about 👉  About.vue</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span> <br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About.vue&#x27;</span><br><br><br><span class="hljs-comment">// 1.通过Vue.use(插件)，安装插件</span><br>Vue.use(VueRouter);<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>]<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &#x2F;&#x2F;router-link是由vue-router注册的全局组件，控制前端路由。默认会渲染为一个a标签<br>        &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;    <br>        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;&lt;&#x2F;router-link&gt;<br>        <br>        &#x2F;&#x2F;router-view是占位组件，可显示前端路由绑定的组件<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br>    <br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p><img src="/2020/12/24/Vue/vue/image-20200830144015434.png" alt="image-20200830144015434"></p><h3 id="默认路由（路由重定向）"><a href="#默认路由（路由重定向）" class="headerlink" title="默认路由（路由重定向）"></a>默认路由（路由重定向）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <span class="hljs-comment">//   根目录重定向到&#x27;/home&#x27;</span><br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="hash与HTMl5的history模式"><a href="#hash与HTMl5的history模式" class="headerlink" title="hash与HTMl5的history模式"></a>hash与HTMl5的history模式</h3><p>在不刷新页面的前提下，改变URL有两种方式：</p><p>1.改变url的hash（锚点），本质上是改变location对象的hash属性。（location.hash=xxx）</p><p>2.使用HTML5的history模式中的API。</p><pre><code>BOM中使用栈结构保存访问资源的历史记录，并使用一个指针指向当前的URL。</code></pre><ul><li>history.pushState( { } , ‘’ ,’home’)    ==’/home’ 压栈==</li><li>history.back( )              ==指针下移==</li><li>history.forward( )         ==指针上移==</li><li>history.go(n)                 ==指针跳转==</li><li>history.replaceState({ },’’, ‘home’)      ==’/home’ 替换栈顶==</li></ul><h3 id="在vue-router中使用history模式"><a href="#在vue-router中使用history模式" class="headerlink" title="在vue-router中使用history模式"></a>在vue-router中使用history模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>                    <span class="hljs-comment">//在创建路由对象时，配置history模式。默认值为&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h3><ol><li><p><strong>to属性</strong></p><p>用于声明式前端路由跳转，to属性指定跳转的绝对path、query以及hash。</p><p>&lt;router-link ==to===”/home”&gt;     &lt;/ router-link&gt;</p></li></ol><ol start="2"><li><p><strong>tag属性</strong></p><p>用于指定router-link标签最终被渲染成的dom标签类型，默认情况下会被渲染成a标签。</p><p>&lt;router-link to=”/home” ==tag===”button”&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>replace布尔属性</strong></p><p>在url跳转时使用history.replace方法，替换BOM历史记录栈结构的栈顶记录。</p><p>&lt;router-link to=”/home” tag=”button” ==replace==&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>active-class属性</strong></p><p>用于指定router-link渲染出的标签在活跃（被点击）时的class属性值。默认为router-link-active。</p><p><img src="/2020/12/24/Vue/vue/image-20200830165640888.png" alt="image-20200830165640888"></p><p>👇</p><p>&lt;router-link to=”/home” tag=”button” ==active-class=”active”==&gt;   &lt;/ router-link&gt;</p><p><img src="/2020/12/24/Vue/vue/image-20200830165558560.png" alt="image-20200830165558560"></p></li></ol><p>   <em>在路由对象中全局修改所有router-link的active-class：</em></p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>,<br>    linkActiveClass:<span class="hljs-string">&#x27;active&#x27;</span>  <span class="hljs-comment">//修改linkActiveClass属性</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="router和-route"><a href="#router和-route" class="headerlink" title="$router和$route"></a>$router和$route</h3><p><strong>一、区别</strong></p><p><code>this.$router</code>是VueRouter的实例。</p><p>当导航到不同url，可以使用<code>this.$router.push</code>方法，这个方法则会向history栈里面添加一条记录，当点击浏览器回退按钮或者<code>this.$router.back()</code>就会回退之前的url。</p><p><code>this.$route</code>相当于当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如name,path,query,params等。</p><p><strong>二、联系</strong></p><p><code>$router</code>和<code>$route</code>是Vue原型对象上的属性，而所有组件都是Vue类的实例，所以我们能通过组件的隐式原型链访问到这两个属性。</p><p><strong>三、常见使用</strong></p><p><code>this.$router</code></p><ol><li><p>push方法</p><p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>是等同的，会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.push(path)<br></code></pre></td></tr></table></figure></li><li><p>go方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//页面路由跳转 前进或者后退</span><br><span class="hljs-built_in">this</span>.$router.go(n)<br></code></pre></td></tr></table></figure></li><li><p>replace方法</p><p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的记录，并置为history栈顶。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.replace(path)<br></code></pre></td></tr></table></figure></li></ol><p><code>this.$route</code></p><p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p><ol><li><p>$route.path<br>   字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</p></li><li><p>$route.params<br>   一个 key/value 对象，包含了 动态片段 和 全匹配片段，<br>   如果没有路由参数，就是一个空对象。</p></li><li><p>$route.query<br>   一个 key/value 对象，表示 URL 查询参数。<br>   例如，对于路径 /foo?user=1，则有 $route.query.user == 1，<br>   如果没有查询参数，则是个空对象。</p></li><li><p>$route.hash<br>   当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</p></li><li><p>$route.fullPath<br>   完成解析后的 URL，包含查询参数和 hash 的完整路径。</p></li><li><p>$route.matched<br>   数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p></li><li><p>$route.name  当前路径名字</p></li><li><p>$route.meta 路由元信息</p></li></ol><h3 id="编程式前端路由跳转"><a href="#编程式前端路由跳转" class="headerlink" title="编程式前端路由跳转"></a>编程式前端路由跳转</h3><p>即通过代码调用api跳转路由。</p><p>而在router-link标签中通过to属性跳转路由称作声明式前端路由跳转，其本质还是调用了$router.push方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &lt;button @click&#x3D;&quot;clickhome&quot;&gt;去主页&lt;&#x2F;button&gt;  &#x2F;&#x2F;使用按钮而不是router-link<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>        router:router,<br>        methods:&#123;<br>            clickHome()&#123;<br>                &#x2F;&#x2F;调用组件的$router的push方法跳转路由<br>                &#x2F;&#x2F;相当于执行了history.pushState(&#39;&#x2F;home&#39;)<br>                &#x2F;&#x2F;相应的还有$router.replace(path)方法<br>                this.$router.push(&#39;&#x2F;home&#39;);    <br>                &#x2F;&#x2F;this.$router.replace(&#39;&#x2F;home&#39;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><strong>Vue官方解析</strong></p><p><code>router.push(location, onComplete?, onAbort?)</code></p><p><strong>注意</strong>：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>push/replace方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&#x27;home&#x27;</span>)<br><br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br><br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;123&#x27;</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user/123</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/123</span><br><span class="hljs-comment">// 这里的 params 不生效</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>push方法中的<code>path</code>可以是相对路径。例如：</p><ol><li><p>若当前<code>path</code>为<code>/user</code>,则使用<code>$router.push(&#39;./user/mz&#39;)</code>可以跳转到<code>/user/mz</code>。</p><p>原因是<code>/user</code>的当前目录仍然为==根目录 /== 。</p></li><li><p>若当前path为<code>/user/</code>,则使用<code>$router.push(&#39;./mz&#39;)</code>就能跳转到<code>/user/mz</code></p></li></ol><p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p><p><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，你需要使用 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 来响应这个变化 (比如抓取用户信息)。</p><p><strong>坑</strong>🕳：</p><p><font color='red'>在vue-router中，使用$router.push/replace时会检查是否重复跳转至当前所在路由，如果是，则会抛出异常，但不影响功能使用</font></p><p>解决方法：</p><p>方法1.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"># 在router目录下的index.js (路由文件最后加载以下代码片段)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    let router = new VueRouter(&#123;...&#125;)</span><br><span class="hljs-comment">    ....</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> originalPush = VueRouter.prototype.push; <span class="hljs-comment">//解决push方法的bug</span><br>VueRouter.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-keyword">const</span> originalReplace = VueRouter.prototype.replace;  <span class="hljs-comment">//解决replace方法的bug</span><br>VueRouter.prototype.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalReplace.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-comment">// export default router</span><br></code></pre></td></tr></table></figure><p>方法2.</p><pre><code>下载指定版本的vue-router  </code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i vue-router@<span class="hljs-number">3</span>.<span class="hljs-number">0</span> --save<br></code></pre></td></tr></table></figure><p>[<a href="https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1%5D">https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1]</a></p><h3 id="动态路由与路由参数"><a href="#动态路由与路由参数" class="headerlink" title="动态路由与路由参数"></a>动态路由与路由参数</h3><p>==（以动态二级路由为例）==</p><p>动态路由的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>  <span class="hljs-comment">//导入User组件</span><br><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>    path:<span class="hljs-string">&#x27;/user&#x27;</span>,<br>        component:Login,<br>        children:[<br>            &#123;<br>                name:<span class="hljs-string">&#x27;userInfo1&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;:userId&#x27;</span>,<br>                component:User<br>            &#125;<br>        ]<br>    &#125;,<br>    <br>    &#123;<br>        name:<span class="hljs-string">&#x27;userInfo2&#x27;</span><br>        path:<span class="hljs-string">&#x27;/user/:userId&#x27;</span>, <span class="hljs-comment">//二级路由，只有当userId占位处不为空串时，才匹配该条路由</span><br>        component:User<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>一级路由组件向二级路由传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Login.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;login&quot;&gt;<br>        <br>        &lt;!-- 指定跳转的完整绝对路径 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        &lt;!--相当于👇--&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;path:&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&#125;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        <br>        <br>        &lt;!-- 指定跳转到名为userInfo2的路由，并设置参数 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;name:&#39;userInfo&#39;,params:&#123;userId&#125;&#125;&quot;&gt;登录2&lt;&#x2F;router-link&gt;<br>        <br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>二级路由组件获取路由参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue"># User.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;user&quot;&gt;<br>        &lt;div&gt;头像&lt;&#x2F;div&gt;<br>        &lt;!-- 获取当前路由中的参数  $route.params  --&gt;<br>        &lt;h2&gt;id:&lt;span&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;&#x2F;span&gt;  <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        name:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:App,<br>        <span class="hljs-comment">//开始嵌套</span><br>        children:[                 <span class="hljs-comment">//在路由配置对象中的children属性，可以设置子路由</span><br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /home</span><br>                name:<span class="hljs-string">&#x27;homepage&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,       <span class="hljs-comment">//子路由配置中，路径使用相对路径 </span><br>                component:Home<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /user/...</span><br>                name:<span class="hljs-string">&#x27;userinfo&#x27;</span>,      <span class="hljs-comment">//为路由设置name属性 唯一标识该条路由</span><br>                path:<span class="hljs-string">&#x27;user/:userId&#x27;</span>,  <span class="hljs-comment">// 子路由配置中，使用动态路由</span><br>                component:User<br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p><code>路由的嵌套只是用一种结构化的方式配置前端路由信息，将逻辑上有层次关系的路由放在一起，但相应的路由组件不存在绝对的层次化渲染关系。</code></p><p><code>子路由对应的component如何显示，只与该路由是在哪一个组件中跳转有关，子路由组件在该组件中的router-view中显示。</code></p><p><font color='red'>为了避免组件渲染后的层次关系混乱，父级路由对应的组件与子路由对应的组件也应该具有相应的父子关系。</font></p><h3 id="路由组件懒加载"><a href="#路由组件懒加载" class="headerlink" title="路由组件懒加载"></a>路由组件懒加载</h3><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><p>在Vue Cli的默认配置情况下，所有的开发组件vue文件 (包括main.js)会被打包到一个app.js中，这就使得该js文件十分庞大。</p><p>(除了app.js会被第一时间请求外，还有第三方包的打包文件vendor.js以及模块化底层支撑的文件manifest.js会被第一时间请求至前端)</p><p>在使用组件懒加载后，每个懒加载的组件会被单独打包到一个js文件中（而不是app.js），浏览器会根据前端路由，按需向服务器请求组件的js打包文件。</p><p><img src="/2020/12/24/Vue/vue/image-20200901110233735.png" alt="image-20200901110233735"></p><p><img src="/2020/12/24/Vue/vue/image-20200901110610641.png" alt="image-20200901110610641"></p><p><strong>基本语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> Home=<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>)<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;<br>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>参考资料：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p><p><strong>一、全局导航守卫（钩子）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"># router 👉 index.js<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:Index,<br>        meta:&#123;    <span class="hljs-comment">//在元数据meta中保存一些路由信息</span><br>            title:<span class="hljs-string">&#x27;首页&#x27;</span><br>        &#125;<br>        children:[<br>            &#123;<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,<br>                component:Home,<br>                meta:&#123;<br>                    title:<span class="hljs-string">&#x27;主页&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>        <br>    &#125;<br>];<br><br><span class="hljs-keyword">let</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">/* beforeEach方法加载前置守卫 */</span><br>router.beforeEach( guard:<span class="hljs-built_in">Function</span> );  <span class="hljs-comment">//钩子（守卫）的用法类似于中间件，可挂载多个钩子</span><br><br><span class="hljs-comment">/*afterEach方法加载后置钩子*/</span><br>router.afterEach(hook:<span class="hljs-built_in">Function</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 前置钩子（守卫）要传入三个参数，分别为：</p><ol><li><p>to：Route对象 ，将要跳转到的下一个活跃路由</p></li><li><p>from： Route对象，当前的活跃路由，即$route对象</p></li><li><p>next ：Function  下一个钩子函数，必须使在钩子内调用一下 next( )</p><pre><code>后置钩子要传入两个参数，分别为to  和from。</code></pre></li></ol><p>​      </p><p><strong>案例：在跳转到各条路由时更新标签页的标题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    <br>    <span class="hljs-built_in">console</span>.log(to);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">from</span>);<br>    <br>    <span class="hljs-built_in">document</span>.title=to.meta.title;<br>   <br>    <span class="hljs-comment">//document.title=to.matched[0].meta.title </span><br>   <span class="hljs-comment">//matched是一个数组，保存了所有匹配的路由</span><br>    <br>    next();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>二、路由独享守卫</strong></p><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><p><strong>三、组件内的守卫</strong></p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB</a></p><p><strong>四、完整的导航解析流程</strong></p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B</a></p><h3 id="keep-alive包裹router-view"><a href="#keep-alive包裹router-view" class="headerlink" title="keep-alive包裹router-view"></a>keep-alive包裹router-view</h3><p><code>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染（维持生命周期）。</code></p><p>使用keep-alive包裹一个需要反复使用的一个组件，可以避免组件在不活跃时被销毁，在活跃时被新建。同时该组件会具有新的生命周期函数actived和deactived。</p><p><strong>案例：组件在失活时记录组件状态，组件重新活跃时返回至上一状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Home.vue<br># &lt;keep-alive&gt;标签包裹了Home.vue的父级组件中的&lt;router-view&gt;<br><br>&lt;template&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;Home&#39;,<br>        data()&#123;<br>            return &#123;<br>                path:&#39;&#x2F;home&#39;<br>            &#125;<br>        &#125;,<br>        actived()&#123;<br>            this.$router.replace(this.path);   &#x2F;&#x2F;返回至失活前的状态<br>        &#125;,<br>        beforeRouteLeave(to,from,next)&#123;         &#x2F;&#x2F;组件内的后置勾子<br>            this.path&#x3D;this.$route.path;<br>            next();<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;    <br></code></pre></td></tr></table></figure><p><strong>keep-alive标签的exclude和include属性</strong></p><p>keep-alive标签可以利用exclude与include属性指定排除或包含哪些组件的生命周期会被维持，属性值为逗号分隔的字符串，对应组件定义时的name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;<br>&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;<br>    &lt;router-view&#x2F;&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p> <img src="/2020/12/24/Vue/vue/image-20200926103349466.png" alt="image-20200926103349466"></p><p><img src="/2020/12/24/Vue/vue/image-20200926103508601.png" alt="image-20200926103508601"></p><blockquote><p>在Vuex中保存的状态（数据）是响应式的。</p></blockquote><p><strong>应用场景👇</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926103551896.png" alt="image-20200926103551896"></p><p><strong>单个组件的状态管理:</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926104012022.png" alt="image-20200926104012022"></p><blockquote><p>Vue已经帮我们做好了单个页面的状态管理，即组件的数据是比较独立的，可以通过各种Action的回调函数去修改State（数据），并通过响应式去更新View。</p><p>但如果是多个界面（组件）的状态管理就可能需要Vuex。</p></blockquote><p><strong>Vuex的基本思想：</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926104500158.png" alt="image-20200926104500158"></p><p><img src="/2020/12/24/Vue/vue/image-20200926104627320.png" alt="image-20200926104627320"></p><h3 id="什么情况下应该使用Vuex？"><a href="#什么情况下应该使用Vuex？" class="headerlink" title="什么情况下应该使用Vuex？"></a>什么情况下应该使用Vuex？</h3><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8">store 模式</a>就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vuex --save<br></code></pre></td></tr></table></figure><p>在 Vue 的单页面应用中使用，需要使用<code>Vue.use(Vuex)</code>调用插件。</p><p>之后新建一个Vuex.Store实例，将其注入到Vue根实例中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  getter: &#123;<br>    doneTodos: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;,<br>  mutations: &#123;<br>    increment (state, payload) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">addCount</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-comment">// 可以包含异步操作</span><br>      <span class="hljs-comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 注入到根实例</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br>  store,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>  components: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后通过mutations改变状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在项目中使用Vuex，常常在src目录下创建store文件夹统一管理Vuex的单一状态树的内容。</p></blockquote><hr><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>State，Getter，Mutation，Action，Module，</code></p><p><strong>Vuex 主要有四部分：</strong></p><ol><li>state：包含了<code>store</code>中存储的各个状态。</li><li>getter: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。</li><li>mutation: 一组方法，是改变<code>store</code>中状态的执行者，<strong>只能是同步操作</strong>。</li><li>action: 一组方法，其中可以<strong>包含异步操作</strong>,但只允许通过提交mutations修改状态。</li></ol><hr><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 使用 <code>state</code> 来存储应用中需要共享的状态。</p><p>在根组件（Vue实例）以及子组件中使用<code>this.$store.state</code>访问共享状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; Cpn.vue<br>&#x2F;*<br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0,<br>obj: &#123;name: &#39;mz&#39;, age: 23&#125;<br>&#125;<br>&#125;)<br><br>*&#x2F;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;h2&gt; &#123;&#123;count&#125;&#125; &lt;&#x2F;h2&gt; <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>        name: &#39;Cpn&#39;,<br>        computed: &#123;<br>            count()&#123;<br>                return this.$store.state.count  &#x2F;&#x2F; 访问state中的count<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>在state初始化时就已经定义的数据以及数据的属性才会被添加到响应式系统。</p><p>( 在Vue中所有需要响应式的数据都是这样 )</p><p>所以通过this.$store.state.obj[‘xxx’]的方式为数据添加额外的属性值时，虽然数据确实变化了，但不会更新View。</p><p>此时，需要通过Vue.set方法来修改状态的属性，可以确保数据是响应式的。</p><p>Vue.set(obj, propName, value)</p><p>删除状态的属性需要通过Vue.delete方法实现响应式。</p><p>Vue.delete(obj, propName)</p></blockquote><hr><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>类似于 Vue 中的 计算属性（可以认为是 store 的计算属性），getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>getter 方法接受<code>state</code>作为其第一个参数，<code>state</code>参数即Store对象中的state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>getter 方法接受<code>getters</code>作为其第二个参数，<code>getters</code>参数即Store对象中的getters：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done);<br>    &#125;,<br>    doneTodosCount: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> getters.doneTodos.length;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>在组件中访问getters：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">cpnDoneTodos</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodos;<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">cpnDoneTodosCount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodosCount;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>getter方法返回一个函数，实现给getter传参：</strong></p><p>这种做法在对 store 里的数组进行查询时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getters: &#123;<br>  <span class="hljs-comment">// ...</span><br>  getTodoById: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id === id)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在组件中为getter返回的函数传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$store.getters.getTodoById(<span class="hljs-number">2</span>) <span class="hljs-comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>在Vuex中约定必须通过mutation修改状态，不允许通过<code>$store.state.xxx = xxx</code>的形式直接修改。（虽然这样没什么可怕的后果，只是通过mutation修改能保存修改日志与状态快照）</p><blockquote><p><code>state</code>和<code>getter</code>都是状态值本身，<code>mutations</code>才是改变状态的执行者。</p><p><strong>注意：<code>mutations</code>只能是同步地更改状态。</strong></p></blockquote><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">1</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 变更状态</span><br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在组件中提交mutation，并执行回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>commit</code>方法中第一个参数可以是<code>事件类型名(String)</code>；</p><p>第二个参数是传递的<code>载荷</code>，可以作为实参传递给mutation的回调函数，第二个参数<code>是可选的</code>。</p><blockquote><p>提交mutation时，不可以像发送action一样能够获取mutation回调函数的返回值。</p><p>即在mutation的回调函数中返回值是无意义的。</p></blockquote><p><strong>规范地提交mutation并传参：</strong></p><p>在规范中，mutation的回调函数支持传入第二个参数payload，作为载荷。载荷中可以保存向mutation回调函数传递的实参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br>        state.count += payload.n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的形式1：提交mutation的事件类型，传递载荷，触发回调函数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;); 👉 传递的实参的值： &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 推荐的形式2：使用对象风格的提交方式，传递参数名与值   </span><br><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>    type: <span class="hljs-string">&#x27;increment&#x27;</span>, 👉 传递的实参的值： &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br>    n: <span class="hljs-number">1</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>向提交简单参数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, n</span>)</span> &#123;<br>        state.count += n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不能再通过对象风格来传递参数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>总结： 在向mutation传递参数时，需要回调函数与提交方式的配合。</p></blockquote><hr><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>想要<strong>异步地更改状态</strong>，就需要使用<code>action</code>。<code>action</code>并不直接改变<code>state</code>，而是发起<code>mutation</code>。</p><blockquote><p>action既可以异步地提交mutation，也可以同步提交，但更主要的是利用它来异步修改状态</p></blockquote><p><strong>注册一个简单的 action：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>          context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>发起简单的action：</strong></p><p>发起<code>action</code>的方法形式和发起<code>mutation</code>一样，只是换了个名字<code>dispatch</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>Actions 支持同样的载荷方式和对象方式<code>进行分发</code>并<code>传递参数</code>：</strong></p><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 context 对象为什么不是 store 实例本身了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations:&#123;<br>      <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span>&#123;<br>          state.count += payload.n<br>      &#125;  <br>    &#125;,<br>actions: &#123;<br>      <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context, payload</span>)</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>            context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, payload)  <span class="hljs-comment">// 实参的类型要与mutation中的形参一致</span><br>         &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐使用载荷的方式向action传参</span><br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-comment">// 不建议使用下面这种对象风格的方式，因为payload形参的type不再是mutation的type，需要进行调整</span><br><span class="hljs-built_in">this</span>.$store.dispatch(&#123;<br>    type: <span class="hljs-string">&#x27;asyncIncrement&#x27;</span>,<br>    n: <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>可见，向action或mutation传参，以载荷的方式更直观，同时能避免差错。</p></blockquote><p><strong>对context进行解构：</strong></p><p>实践中，我们会经常用到 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>context具有store 实例的相同方法和属性，包括commit, dispatch, getters, state。</p><p>此外还具有rootGetters以及rootState；</p><p>这些属性和方法都可以进行解构获取。</p><p><img src="/2020/12/24/Vue/vue/image-20200926153828952.png" alt="image-20200926153828952"> </p></blockquote><h4 id="Action处理异步的正确使用方式"><a href="#Action处理异步的正确使用方式" class="headerlink" title="Action处理异步的正确使用方式"></a>Action处理异步的正确使用方式</h4><p>想要使用<code>action</code>处理异步工作很简单，只需要将异步操作放到<code>action</code>中执行（如上面代码中的<code>setTimeout</code>）。</p><p>要想在异步操作完成后继续进行相应的流程操作，有两种方式:</p><ol><li><p>在action中返回一个Promise</p><p><code>store.dispatch</code>返回相应<code>action</code>的执行结果，而当action的处理函数返回的是一个Promise实例时，就可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>   在另外一个 action 中也可以：</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  <span class="hljs-comment">// ...</span><br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>      commit(<span class="hljs-string">&#x27;someOtherMutation&#x27;</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>利用<code>async/await</code> 进行组合action。代码更加简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><br>actions: &#123;<br>  <span class="hljs-keyword">async</span> actionA (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())<br>  &#125;,<br>  <span class="hljs-keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span><br>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个 <code>$store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS字符串常用方法</title>
    <link href="/2020/12/24/JavaScript/js-string/"/>
    <url>/2020/12/24/JavaScript/js-string/</url>
    
    <content type="html"><![CDATA[<h1 id="JS字符串常用方法"><a href="#JS字符串常用方法" class="headerlink" title="JS字符串常用方法"></a>JS字符串常用方法</h1><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>返回字符串的长度</p><h2 id="查找子串索引"><a href="#查找子串索引" class="headerlink" title="查找子串索引"></a>查找子串索引</h2><h3 id="indexOf-substr-start-0"><a href="#indexOf-substr-start-0" class="headerlink" title="indexOf (substr, [ start = 0 ])"></a>indexOf (<em>substr</em>, [ <em>start</em> = 0 ])</h3><p><code>indexOf</code>方法搜索并(如果找到)返回字符串中搜索到的字符或子字符串的索引。如果没有找到，则返回<code>-1</code>。<code>start</code>是一个可选参数，指定字符串中开始搜索的位置，默认值为<code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//indexOf(char/substring)</span><br><span class="hljs-keyword">var</span> sentence=<span class="hljs-string">&quot;Hi, my name is Sam!&quot;</span><br><span class="hljs-keyword">if</span> (sentence.indexOf(<span class="hljs-string">&quot;Sam&quot;</span>)!=-<span class="hljs-number">1</span>)<br>alert(<span class="hljs-string">&quot;Sam is in there!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="lastIndexOf-substr-start-length-1"><a href="#lastIndexOf-substr-start-length-1" class="headerlink" title="lastIndexOf (substr, [ start = length-1] )"></a>lastIndexOf (<em>substr</em>, [ <em>start</em> = length-1] )</h3><p><code>lastIndexOf()</code> 方法返回指定文本在字符串中最后一次出现的索引, 如果未找到，则返回<code>-1</code>。 “<code>start</code>”是一个可选参数，指定字符串中开始搜索的位置, 默认值为<code>string.length-1</code>。若指定<code>start</code>，则在<code>0~start</code>之间的子串中查找目标子串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//lastIndexOf(substr, [start])</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;javascript rox&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myString.lastIndexOf(<span class="hljs-string">&#x27;r&#x27;</span>));<br><span class="hljs-comment">//output: 11</span><br></code></pre></td></tr></table></figure><h2 id="子串切片"><a href="#子串切片" class="headerlink" title="子串切片"></a>子串切片</h2><h3 id="charAt-index"><a href="#charAt-index" class="headerlink" title="charAt (index)"></a>charAt (<em>index</em>)</h3><p><code>charAt(x)</code>返回字符串中<code>x</code>位置的字符，下标从 <code>0</code> 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//charAt(x)</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;jQuery FTW!!!&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myString.charAt(<span class="hljs-number">7</span>));<br><span class="hljs-comment">//output: F</span><br></code></pre></td></tr></table></figure><h3 id="slice-start-end-length"><a href="#slice-start-end-length" class="headerlink" title="slice (start, [ end = length ])"></a>slice (<em>start</em>, [ <em>end</em> = length ])</h3><p><code>slice()</code> 方法可提取字符串的某个部分，返回一个新的字符串。包括字符串从 <code>start</code> 开始（包括 start）到 <code>end</code> 结束（不包括 <code>end</code>）为止的所有字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//slice(start, end)</span><br><span class="hljs-keyword">var</span> text=<span class="hljs-string">&quot;excellent&quot;</span><br>text.slice(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;exce&quot;</span><br>text.slice(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;ce&quot;</span><br></code></pre></td></tr></table></figure><h3 id="substr-start-len-length"><a href="#substr-start-len-length" class="headerlink" title="substr (start, [ len = length ])"></a>substr (<em>start</em>, [ <em>len</em> = length ])</h3><p><code>substr()</code> 方法可在字符串中抽取从 <code>start</code> 下标开始的指定数目的字符。返回一个新的字符串，包含从 <code>start</code>（包括 start 所指的字符） 处开始的 <code>length</code> 个字符。如果没有指定 <code>length</code>，那么返回的字符串包含从 <code>start</code> 到该字符串的结尾的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//substr(from, to)</span><br><span class="hljs-keyword">var</span> text=<span class="hljs-string">&quot;excellent&quot;</span><br>text.substr(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;exce&quot;</span><br>text.substr(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;cell&quot;</span><br></code></pre></td></tr></table></figure><h3 id="substring-from-to-length"><a href="#substring-from-to-length" class="headerlink" title="substring (from, [ to = length ])"></a>substring (<em>from</em>, [ <em>to</em> = length ])</h3><p><code>substring()</code> 方法用于<code>返回</code>一个字符串中介于两个指定下标之间的字符，方返回的子串包括 <code>start</code> 处的字符，但不包括 <code>to</code> 处的字符，<code>to</code> 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//substring(from, [to])</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;javascript rox&#x27;</span>;<br>myString = myString.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log(myString)<br><span class="hljs-comment">//output: javascript</span><br></code></pre></td></tr></table></figure><h3 id="slice、substr、substring三个方法的区别"><a href="#slice、substr、substring三个方法的区别" class="headerlink" title="slice、substr、substring三个方法的区别"></a>slice、substr、substring三个方法的区别</h3><ol><li>slice和substring参数分别为(起始位置索引值，结束位置索引值)，substr的参数则为(起始位置索引值，截取长度)；</li><li>slice不能颠倒参数顺序，substring可以；<ul><li>slice方法中，<code>start</code> 不可以大于等于 <code>end</code>，否则返回空串。</li><li>substring方法中，<code>from</code>若大于等于<code>to</code>，但返回的结果为<code>[to, from)</code>范围内的子串。</li></ul></li><li>slice和substring的参数为负时，结果不同。<ul><li>slice方法允许参数为负，<code>负参数与length相加</code>得到实际的形参值。<code>如果相加结果仍为负数，则等效为0。</code></li><li>substring方法不允许参数为负，<code>负实参</code>的形参值为<code>0</code>。</li></ul></li></ol><h2 id="内容检测"><a href="#内容检测" class="headerlink" title="内容检测"></a>内容检测</h2><blockquote><p>以下方法都是对searchString大小写敏感的。</p></blockquote><h3 id="includes-searchString-position-0"><a href="#includes-searchString-position-0" class="headerlink" title="includes (searchString, [ position = 0 ])"></a>includes (<em>searchString</em>, [ <em>position</em> = 0 ])</h3><p><code>includes()</code> 方法用于检查字符串是否包含指定的字符串或字符。<code>position</code>为从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//endsWith()</span><br><span class="hljs-keyword">var</span> mystr = <span class="hljs-string">&quot;List of javascript functions&quot;</span>;<br><span class="hljs-keyword">var</span> n = mystr.endsWith(<span class="hljs-string">&quot;functions&quot;</span>);<br><span class="hljs-comment">//output: True</span><br></code></pre></td></tr></table></figure><h3 id="startsWith-searchString-postion-0"><a href="#startsWith-searchString-postion-0" class="headerlink" title="startsWith (searchString, [ postion = 0 ])"></a>startsWith (<em>searchString</em>, [ <em>postion</em> = 0 ])</h3><p><strong>参数</strong></p><ul><li><p><code>searchString</code></p><p>要搜索的子字符串。</p></li><li><p><code>position</code> 可选</p><p>在 <code>str</code> 中搜索 <code>searchString</code> 的开始位置，默认值为 0。</p></li></ul><p><strong>返回值</strong></p><p>如果在字符串的开头找到了给定的字符则返回**<code>true</code><strong>；否则返回</strong><code>false</code>**。</p><h3 id="endsWith-searchString-len-length"><a href="#endsWith-searchString-len-length" class="headerlink" title="endsWith ( searchString, [ len = length] )"></a>endsWith ( <em>searchString</em>, [ <em>len</em> = length] )</h3><p><code>endWith</code>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</p><p><strong>参数</strong></p><ul><li><p><code>searchString</code></p><p>要搜索的子字符串。</p></li><li><p><code>length</code> 可选</p><p>在字符串的前length个字符中进行判断。默认值为 <code>str.length</code>。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;Cats are the best!&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(str1.endsWith(<span class="hljs-string">&#x27;best&#x27;</span>, <span class="hljs-number">17</span>));<br><span class="hljs-comment">// expected output: true</span><br><br><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;12345&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str2.endsWith(<span class="hljs-string">&#x27;34&#x27;</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// length = 4</span><br><span class="hljs-comment">// expected output: true</span><br><br></code></pre></td></tr></table></figure><blockquote><p>注意： 以上两个方法名是end<font color = 'red'>s</font>With 以及 start<font color = 'red'>s</font>With</p></blockquote><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase ()"></a>toUpperCase ()</h3><h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase ()"></a>toLowerCase ()</h3><p>返回一个新的字符串。</p><h2 id="填充与修剪"><a href="#填充与修剪" class="headerlink" title="填充与修剪"></a>填充与修剪</h2><blockquote><p>注意： 以下方法只会返回新字符串，不会修改原字符串。</p></blockquote><h3 id="padStart-targetLength-padString"><a href="#padStart-targetLength-padString" class="headerlink" title="padStart (targetLength [, padString])"></a>padStart (<em>targetLength</em> [, <em>padString</em>])</h3><p>该方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。</p><p><strong>参数</strong></p><p><code>targetLength</code></p><p>当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p><code>padString</code> 可选</p><p>填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 <code>&quot; &quot;</code>（U+0020），<code>即空格</code>。</p><p><strong>返回值</strong></p><p>在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。</p><h3 id="padEnd-targetLength-padString"><a href="#padEnd-targetLength-padString" class="headerlink" title="padEnd (targetLength [, padString])"></a>padEnd (<em>targetLength</em> [, <em>padString</em>])</h3><p>用法与padStart类似</p><h3 id="trim-、trimEnd-、trimStart"><a href="#trim-、trimEnd-、trimStart" class="headerlink" title="trim()、trimEnd()、trimStart()"></a>trim()、trimEnd()、trimStart()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;   Hello world!   &#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(greeting);<br><span class="hljs-comment">// expected output: &quot;   Hello world!   &quot;;</span><br><br><span class="hljs-built_in">console</span>.log(greeting.trim());<br><span class="hljs-comment">// expected output: &quot;Hello world!&quot;;</span><br><br><span class="hljs-built_in">console</span>.log(greeting.trimStart());<br>expected output: <span class="hljs-string">&quot;Hello world!   &quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(greeting.trimEnd());<br><span class="hljs-comment">// expected output: &quot;   Hello world!&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="拼接与分割"><a href="#拼接与分割" class="headerlink" title="拼接与分割"></a>拼接与分割</h2><h3 id="concat-str2-…strN"><a href="#concat-str2-…strN" class="headerlink" title="concat(str2, [, …strN])"></a>concat(<em>str2</em>, [, <em>…strN</em>])</h3><p><strong>参数</strong></p><ul><li><p><code>str2 [, ...strN]</code></p><p>需要连接到 <code>str</code> 的字符串。</p></li></ul><p><strong>返回值</strong></p><p>一个新的字符串，包含参数所提供的连接字符串。</p><p><strong>描述</strong></p><p><code>concat</code> 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 <code>concat</code> 方法并不影响原字符串。</p><p>如果参数不是字符串类型，它们在连接之前将会被转换成字符串。</p><h3 id="repeat-count"><a href="#repeat-count" class="headerlink" title="repeat(count)"></a>repeat(<em>count</em>)</h3><p><code>repeat()</code> 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//repeat()</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;Welcome to Edureka&quot;</span>;<br><span class="hljs-built_in">console</span>.log(string.repeat(<span class="hljs-number">2</span>));<br><span class="hljs-comment">//output: Welcome to EdurekaWelcome to Edureka</span><br></code></pre></td></tr></table></figure><blockquote><p>注意： 以上方法只会返回新字符串，不会修改原字符串。</p></blockquote><h3 id="split-separator-‘’-limit-INFINIT"><a href="#split-separator-‘’-limit-INFINIT" class="headerlink" title="split([ separator = ‘’ ], [ limit = INFINIT ] )"></a>split([ <em>separator = ‘’</em> ], [ <em>limit = INFINIT</em> ] )</h3><p><strong>参数</strong></p><ul><li><p><code>separator</code></p><p>指定表示每个拆分应发生的点的字符串。<code>separator</code> 可以是一个字符串或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>。</p><ol><li>如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。</li><li>如果分隔符为空字符串，则将str转换为字符数组。</li><li>如果分隔符出现在字符串的开始或结尾，或两者都分开，分别返回的数组以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。</li></ol></li><li><p><code>limit</code></p><p>一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。</p></li></ul><p><strong>返回值</strong></p><p>返回源字符串以分隔符出现位置分隔而成的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> </p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><blockquote><p>注意：以下方法只会将替换的结果返回，不会改变原字符串。</p></blockquote><h3 id="replace-substr-newSubStr"><a href="#replace-substr-newSubStr" class="headerlink" title="replace( substr, newSubStr)"></a>replace( <em>substr</em>, <em>newSubStr</em>)</h3><p><strong>参数</strong></p><ul><li><p><code>substr </code>(pattern)</p><p>一个将被 <code>newSubStr</code> 替换的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</p></li><li><p><code>newSubStr</code> (replacement)</p><p>用于替换掉第一个参数在原字符串中的匹配部分的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。</p></li></ul><p><strong>返回值</strong></p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p><strong>描述</strong></p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><h3 id="replaceAll-substr-replacement"><a href="#replaceAll-substr-replacement" class="headerlink" title="replaceAll (substr, replacement )"></a>replaceAll (substr, <em>replacement</em> )</h3><p>该方法返回一个新字符串，即使substr不是一个正则表达式，新字符串所有与 <code>substr</code> 相同的部分都会被<code>replacement</code> 替换。</p><blockquote><p>注意，在Node环境中，Node.js 15.0以上版本才支持此方法</p></blockquote><p><strong>参数</strong></p><ul><li><p><code>substr </code></p><p>一个将被 <code>newSubStr</code> 替换的 字符串。</p></li><li><p><code>newSubStr</code> (replacement)</p><p>用于替换掉第一个参数在原字符串中的匹配部分的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。</p></li></ul><p><strong>返回值</strong></p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p><strong>描述</strong></p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw"></a>String.raw</h2><p>在JS中，<code>String.raw</code>后面跟上一个<code>反引号</code>括起的字符串，其作用类似于python中的 <code>r</code>修饰符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python</span><br>s1 = <span class="hljs-string">r&#x27;c:\home&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>.raw <span class="hljs-string">`c:\home`</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS正则表达式</title>
    <link href="/2020/12/23/JavaScript/js-regexp/"/>
    <url>/2020/12/23/JavaScript/js-regexp/</url>
    
    <content type="html"><![CDATA[<h1 id="JS正则相关"><a href="#JS正则相关" class="headerlink" title="JS正则相关"></a>JS正则相关</h1><p><strong>Regular Expression：RegExp</strong></p><h2 id="创建JS正则表达式对象"><a href="#创建JS正则表达式对象" class="headerlink" title="创建JS正则表达式对象"></a>创建JS正则表达式对象</h2><ol><li><p><code>/正则表达式/修饰符</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\d+$/mg</span>;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><code>使用构造函数</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;正则表达式的字符串形式&#x27;</span>, [修饰符])<br><span class="hljs-comment">// 例：</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;^\\d+$&#x27;</span>, <span class="hljs-string">&#x27;gm&#x27;</span>);<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw<span class="hljs-string">`^\d+$`</span>, <span class="hljs-string">&#x27;gm&#x27;</span>);<br>或<br><span class="hljs-keyword">let</span> pattern = <span class="hljs-string">&#x27;^\\d+$&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw <span class="hljs-string">`<span class="hljs-subst">$&#123;pattern&#125;</span>`</span>, <span class="hljs-string">&#x27;gm&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(reg);<br><span class="hljs-comment">// 输出👉 /^d+$/gm</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="量词元字符"><a href="#量词元字符" class="headerlink" title="量词元字符"></a>量词元字符</h2><table><thead><tr><th>元字符</th><th>匹配出现次数</th></tr></thead><tbody><tr><td><code>*</code></td><td>0到多次</td></tr><tr><td><code>+</code></td><td>1到多次</td></tr><tr><td><code>?</code></td><td>0或1次</td></tr><tr><td><code>&#123;n&#125;</code></td><td>出现n次</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>出现n到m次，包含m</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>出现n到多次</td></tr></tbody></table><h2 id="特殊元字符"><a href="#特殊元字符" class="headerlink" title="特殊元字符"></a>特殊元字符</h2><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>转义符，<code>\\</code>匹配一个反斜杠</td></tr><tr><td><code>.</code></td><td>匹配除<code>\n</code>以外的任意单个字符</td></tr><tr><td><code>^</code></td><td>匹配字符串开头位置</td></tr><tr><td><code>$</code></td><td>匹配字符串结尾位置</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\d</code></td><td>匹配0~9之间的一个数字字符</td></tr><tr><td><code>\D</code></td><td>匹配除0~9之外的一个字符</td></tr><tr><td><code>\w</code></td><td>匹配数字、字母、下划线中的任意一个字符</td></tr><tr><td><code>\W</code></td><td>匹配除了数字、字母、下划线外的一个字符</td></tr><tr><td><code>\s</code></td><td>匹配空白字符，包括<code>\n</code>,<code>\r回车</code>,<code>\f换页</code>,<code>\t</code>,<code>\v</code>等</td></tr><tr><td><code>\S</code></td><td>匹配除空白字符以外的一个字符</td></tr><tr><td><code>\b</code></td><td>匹配单词边界位置</td></tr><tr><td><code>[xyz]</code></td><td>匹配中括号内的一个字符</td></tr><tr><td><code>[^xyz]</code></td><td>中括号内带<code>^</code>表示匹配中括号内以外的一个字符</td></tr><tr><td><code>[0-9]</code></td><td>匹配一个0~9数字，还可以写<code>[0-35-9]</code>用于排除一个数字</td></tr><tr><td><code>[a-zA-Z]</code></td><td>匹配一个英文字母，还可以写<code>[a-cD-Z]</code>等指定范围内的字母</td></tr><tr><td><code>\特殊含义字符</code></td><td><code>\.</code>匹配<code>.</code>，此外还有<code>\*</code>  <code>\+</code>  <code>\?</code> <code>\^</code> <code>\$</code> <code>\&#123;</code> <code>\&#125;</code> <code>\(</code> <code>\)</code></td></tr><tr><td>( x | y )</td><td>匹配左右中的一种规则，`</td></tr><tr><td><code>\数字num</code></td><td>匹配从左到右第num个分组</td></tr></tbody></table><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th>修饰符</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td><code>i</code></td><td>ignoreCase</td><td>忽略大小写</td></tr><tr><td><code>g</code></td><td>global</td><td>全局匹配，消除懒惰性</td></tr><tr><td><code>m</code></td><td>multiline</td><td>多行匹配，主要是修改<code>^</code>和<code>$</code>在正则表达式中的作用，让它们分别表示行首和行尾。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;This is an\n antzone good&quot;</span>;<br><span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/an$/</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//以上代码不能够匹配字符串&quot;an&quot;，尽管&quot;an&quot;后面已经换行了，但是并没有采用多行匹配，所以不是字符串行的结尾。</span><br><br><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;This is an\n antzone good&quot;</span>;<br><span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/an$/m</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//以上代码可以匹配字符串&quot;an&quot;，因为采用了多行匹配。</span><br></code></pre></td></tr></table></figure><h2 id="用括号进行分组"><a href="#用括号进行分组" class="headerlink" title="用括号进行分组"></a>用括号进行分组</h2><p><strong>使用索引进行反向引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/&lt;([a-z]+)&gt;.*&lt;\/\1&gt;/</span>;  <span class="hljs-comment">// `\1`可以匹配第一个分组</span><br><span class="hljs-built_in">console</span>.log(reg.exec(str));<br><span class="hljs-comment">//输出👇</span><br>[<br>  <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br>  index: <span class="hljs-number">0</span>,<br>  input: <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  groups: <span class="hljs-literal">undefined</span><br>]<br></code></pre></td></tr></table></figure><p><strong>使用分组名进行反向引用</strong></p><blockquote><p>命名捕获分组自身的语法是 <code>(?&lt;name&gt;pattern)</code>，比普通的分组多了一个 <code>?&lt;name&gt; </code>字样，其中 name 的起法就和你平时起变量名一样即可（不过在这里关键字也可用）。</p><p>反向引用一个命名分组的语法是 <code>\k&lt;name&gt;</code>，注意命名分组同样可以通过数字索引来反向引用。</p><p>比如： <code>/(?&lt;foo&gt;a)\k&lt;foo&gt;\1/.test(&quot;aaa&quot;) // true</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/&lt;(?&lt;group1&gt;[a-z]+)&gt;.*&lt;\/\k&lt;group1&gt;&gt;/</span>;  <span class="hljs-comment">// \k&lt;group1&gt;可以匹配分组名为group1的分组</span><br><span class="hljs-built_in">console</span>.log(reg.exec(str));<br><span class="hljs-comment">// 输出👇</span><br>[<br>  <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br>  index: <span class="hljs-number">0</span>,<br>  input: <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  groups: [<span class="hljs-built_in">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">group1</span>: <span class="hljs-string">&#x27;div&#x27;</span> &#125; <span class="hljs-comment">// group1分组保存在了exec返回值的groups属性中</span><br>]<br></code></pre></td></tr></table></figure><h2 id="括号的更多作用"><a href="#括号的更多作用" class="headerlink" title="括号的更多作用"></a>括号的更多作用</h2><ol><li><p><strong>提高优先级</strong></p><p>特别是在与<code>|</code>配合使用时，提高优先级避免歧义。</p></li><li><p><strong>分组匹配</strong></p><p>在括号内的规则被视为一个分组，在分组捕获时能够提取到分组中的内容。</p></li><li><p><strong>只匹配不捕获</strong></p><p>即<code>(?:)</code>，只提高优先级，但不会在分组捕获时被捕获</p></li><li><p><strong>正向预查（定义指定右边界）</strong></p><p>即<code>(?=合法边界pattern)</code></p></li><li><p><strong>负向预查（定义排除右边界）</strong></p><p>即<code>(?!不合法边界pattern)</code></p></li><li><p><strong>正向预查（定义指定左边界）</strong></p><p>即<code>(?&lt;=指定边界pattern)</code></p></li><li><p><strong>逆、反向预查（定义排除左边界）</strong></p><p>即<code>(?&lt;!排除边界pattern)</code></p></li></ol><p><a href="https://www.cnblogs.com/wjw-blog/p/7526994.html">正向预查和反向预查</a></p><p>日常工作当中，大多数IDE自带的查找工作都能满足大多数需要。</p><p>加上正则匹配简直如虎添翼。匹配个邮箱，电话号什么的不在话下。有时候我们可能会遇到稍微特殊的场景。</p><p>文本：</p><p>Windows 1.03 and Windows 2.0 fisrt Released in 1985 and 1987 respectively.<br>Windows 95 and Windows 98 are the successor.<br>Then Windows 2000 and Windows Xp Windows appeared.<br>Windows Vista is the Latest version of the family.</p><p><strong>例如上面这一段话，有几个场景：</strong></p><ul><li><p>我们想匹配 Windows 后面是数字版本号的Windows 和这些字符。如 Windows 1.03 等等。</p><p>用<code>?: </code>捕获不匹配， 即 Windwos (?:[\d.]+\b)如下图，这是直接匹配结果 , 匹配出了Windows 1.03,Windows 2.0, Windows 95,Windows 98,Windows 2000,但是没有匹配到Windows Xp, Windows Vista,等</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222134739502.png" alt="image-20201222134739502"> </p></li></ul><ul><li><p>我们只想匹配满足这些条件的’Window’ ，但不包括后面的字符。</p><p>用<code>(?= pattern)</code> 即 <code>Windows (?=[\d.]+\b) </code>他把Windows的空格也匹配了。这一过程就是==正向预查==。</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222135004359.png" alt="image-20201222135004359"> </p></li></ul><ul><li><p>如果我想匹配这些Windows 字段，它==后面跟的不是数字或者版本号==，</p><p>我改用<code>(?!pattern)</code>即<code>Windows (?![\d.]+\b)</code>这一过程叫做==反向预查==, 它匹配后面跟着不满足pattern（ [\d.]+\b) 的Windows。</p></li></ul><ul><li><p>我想匹配Windows前面是数字的Windows</p><p>我们用 <code>(?&lt;=[\d].) Windows</code>这叫==正向预查定义左边界==(<code>&lt;</code>左箭头就说明了是从右往左，即负向)，他们匹配Windows==前面是一个或者多个数字==的’Windows’.</p><p>如图这里只匹配到了 和11挨着的 Windows。</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222135430010.png" alt="image-20201222135430010"> </p></li></ul><ul><li><p>我想匹配Windows前面不是数字的Windows。我想匹配 Windows 前面不是数字的Windows ，通常叫做==负向预查定义左边界==</p><p>用<code>(?&lt;![0-9.]+) Windows</code>匹配前面不是数字和<code>.</code>的<code> Windows</code>（注意前面带一个空格）</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222141416785.png" alt="image-20201222141416785"> </p><p>而使用<code>(?&lt;![0-9.]+\b\s\b)Windows</code>还会匹配字符串开头的Windows。</p></li></ul><blockquote><p>正向预查可以理解成 自定义右边界，这个边界位于匹配内容正向（右侧）。</p><p>负向预查可以理解成 自定义左边界，这个边界位于匹配内容的负向（左侧）。</p><p>正向、负向预查又可以分别可以定义满足条件的边界条件以及需要排除的边界情况。</p></blockquote><p><font color="red">更需要注意的是： 正向预查和反向预查不消耗字符，也不会捕获，尤其是正向预查。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例说明：</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/windows(?=\b\s[0-9.]+)/g</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;windows 8.1 windows&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(reg.test(str));<br><span class="hljs-built_in">console</span>.log(reg.lastIndex);<br><span class="hljs-comment">//输出👉 true</span><br><span class="hljs-comment">//输出👉 7</span><br></code></pre></td></tr></table></figure><h2 id="懒惰性"><a href="#懒惰性" class="headerlink" title="懒惰性"></a>懒惰性</h2><p>非全局匹配的正则表达式在匹配字符串时具有懒惰性，即只会匹配从左到右第一个匹配项。</p><p>解决方法：创建正则表达式时加上<code>g</code>修饰符。（此时global属性值为true）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出 👉 [&quot;123&quot;, index: 0, input: &quot;123abc321&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 加上g修饰</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出 👉 [&quot;123&quot;, ”321“]</span><br></code></pre></td></tr></table></figure><h2 id="贪婪性"><a href="#贪婪性" class="headerlink" title="贪婪性"></a>贪婪性</h2><p>存在量词元字符的正则表达式进行匹配时，会尽可能多地匹配量词前的普通/特殊元字符，此策略称为正则匹配的==贪婪性==。</p><p>取消贪婪性：在量词后面加<code>?</code>修饰量词，就会匹配最少量的普通/特殊元字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+?/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//输出👉 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span><br><br></code></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><ul><li><p><code>RegExp.prototype.test()</code></p><p>如果不匹配，则返回false；</p><p>如果传入的字符串匹配正则，则返回true；</p><blockquote><p>hack：test方法其实也可以用于捕获，上一条匹配的字符串保存在RegExp函数对象的lastInput属性中，上一条捕获到的匹配项保存在lastMatch属性中，捕获到的分组分别保存在$1~$9属性中，所以用test方法最多能捕获9个分组。</p></blockquote></li></ul><h2 id="正则捕获"><a href="#正则捕获" class="headerlink" title="正则捕获"></a>正则捕获</h2><ul><li><p><code>RegExp.prototype.exec()</code></p><p>如果无法匹配，则返回null；</p><p>如果匹配：</p><ul><li><p>如果this.global === false，即懒惰匹配，则返回一个数组，数组索引为0的元素是匹配到的第一个字符串，剩余索引元素为分组捕获的内容。此外该数组还具有index，input以及groups属性。</p></li><li><p>如果this.global === true，即全局匹配，则返回一个数组，该数组为基于this.lastIndex的==下一条==匹配内容，同样索引为0的是匹配到的字符串，剩余索引元素为分组捕获的内容。==当this.lastIndex大于等于字符串参数的长度时，返回null，并重置this.lastIndex =0。==</p><blockquote><p>注意：</p><p>在全局匹配下，在非必要情况下，避免直接操作RegExp对象的lastIndex属性。</p><p>非全局匹配时，修改RegExp对象的lastIndex属性不起作用，仍然懒惰地返回第一个匹配项。</p></blockquote></li></ul></li></ul><h2 id="字符串的match方法"><a href="#字符串的match方法" class="headerlink" title="字符串的match方法"></a>字符串的match方法</h2><p><strong><code>str.match(regexp)</code></strong></p><p><strong>参数</strong></p><p><strong>regexp：</strong></p><p>一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 。如果你没有给出任何参数并直接使用match() 方法 ，你会得到一 个包含空字符串的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> ：[“”] 。</p><p><strong>返回值</strong></p><ul><li><p>如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回分组捕获的信息。</p></li><li><p>如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（<code>Array</code>），即正则表达式对象exec方法返回的内容。 在这种情况下，返回的项目将具有如下所述的其他属性。</p><p>附加属性</p><ul><li><code>groups</code>: 一个捕获组数组 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（如果没有定义命名捕获组）。</li><li><code>index</code>: 匹配的结果的开始位置</li><li><code>input</code>: 搜索的字符串.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\&#123;([0-9]+)\&#125;/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;123&#125;abc&#123;456&#125;&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出👉 [ &#x27;&#123;123&#125;&#x27;, &#x27;&#123;456&#125;&#x27; ]   无法捕获分组中的数字</span><br></code></pre></td></tr></table></figure><h2 id="字符串的matchAll方法"><a href="#字符串的matchAll方法" class="headerlink" title="字符串的matchAll方法"></a>字符串的matchAll方法</h2><p><strong><code>str.matchAll(regexp)</code></strong></p><p><strong>参数</strong></p><p><strong>regexp：</strong></p><p>正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <code>RegExp</code> 。</p><blockquote><p> RegExp必须是设置了全局模式<code>g</code>的形式，否则会抛出异常<code>TypeError</code>。</p></blockquote><p><strong>返回值</strong></p><p>一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。</p><p><strong>强大之处：</strong></p><p>使用 <code>matchAll</code> 可以通过如下方式获取分组捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [...str.matchAll(regexp)];<br><br>array[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test2&#x27;, length: 4]</span><br>array[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, length: 4]</span><br></code></pre></td></tr></table></figure><p>在 <code>matchAll</code> 出现之前，通过在循环中调用 <code>regexp.exec()</code> 来获取所有匹配项信息（regexp 需使用 <code>/g</code> 标志）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<br><span class="hljs-keyword">let</span> match;<br><br><span class="hljs-keyword">while</span> ((match = regexp.exec(str)) !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Found <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span> start=<span class="hljs-subst">$&#123;match.index&#125;</span> end=<span class="hljs-subst">$&#123;regexp.lastIndex&#125;</span>.`</span>);<br>  <span class="hljs-comment">// expected output: &quot;Found football start=6 end=14.&quot;</span><br>  <span class="hljs-comment">// expected output: &quot;Found foosball start=16 end=24.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 <code>matchAll</code> ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用 <code>/g</code> 标志）。使用 <code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>, <code>array spread</code>, 或者 <code>Array.from()</code> 可以更方便实现功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<br><span class="hljs-keyword">const</span> matches = str.matchAll(regexp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matches) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Found <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span> start=<span class="hljs-subst">$&#123;match.index&#125;</span> end=<span class="hljs-subst">$&#123;match.index + match[<span class="hljs-number">0</span>].length&#125;</span>.`</span>);<br>&#125;<br><span class="hljs-comment">// expected output: &quot;Found football start=6 end=14.&quot;</span><br><span class="hljs-comment">// expected output: &quot;Found foosball start=16 end=24.&quot;</span><br><br><span class="hljs-comment">// matches iterator is exhausted after the for..of iteration</span><br><span class="hljs-comment">// Call matchAll again to create a new iterator</span><br><span class="hljs-built_in">Array</span>.from(str.matchAll(regexp), <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// Array [ &quot;football&quot;, &quot;foosball&quot; ]</span><br></code></pre></td></tr></table></figure><p>⭐⭐<code>matchAll</code> 内部做了一个 regexp 的复制，所以不像 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">regexp.exec</a>, <code>lastIndex</code> 在字符串扫描时不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;[a-c]&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br>regexp.lastIndex = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-built_in">Array</span>.from(str.matchAll(regexp), <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;regexp.lastIndex&#125;</span> <span class="hljs-subst">$&#123;m[<span class="hljs-number">0</span>]&#125;</span>`</span>);<span class="hljs-comment">//👈没有改变实参regexp的内容</span><br><span class="hljs-comment">// Array [ &quot;1 b&quot;, &quot;1 c&quot; ]</span><br></code></pre></td></tr></table></figure><h2 id="字符串的replace方法"><a href="#字符串的replace方法" class="headerlink" title="字符串的replace方法"></a>字符串的replace方法</h2><p><strong><code>str.replace(regexp, newSubStr | function)</code></strong></p><p><strong>参数</strong></p><ul><li><p>regexp</p><p>一个RegExp对象或者其字面量，该正则所匹配的内容会被第二个参数的返回值替换掉。</p></li><li><p>newSubStr</p><p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。==该字符串中可以内插一些特殊的变量名==。</p></li><li><p>function</p><p>一个用来创建新字符串的函数，==正则匹配多少次，该函数就调用多少次==。==该函数的返回值将替换掉每次正则匹配的内容==。</p></li></ul><p><strong>返回值：</strong> 一个部分或全部匹配由替代模式所取代的新的字符串。</p><blockquote><p>如果regexp没有<code>g</code>修饰，则至多执行一次匹配替换。</p></blockquote><p><strong>特殊变量名</strong></p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td><code>$$</code></td><td>插入一个 “$”。</td></tr><tr><td><code>$&amp;</code></td><td>插入匹配的子串。</td></tr><tr><td>$`</td><td>插入当前匹配的子串左边的内容。</td></tr><tr><td><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容。</td></tr><tr><td><code>$n</code></td><td>假如第一个参数是 <code>RegExp</code>对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始。如果不存在第 n个分组，那么将会把匹配到到内容替换为字面量。比如不存在第3个分组，就会用“$3”替换匹配到的内容。</td></tr><tr><td><code>$&lt;Name&gt;</code></td><td>这里*<code>Name</code>* 是一个分组名称。如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例1</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;2020-12-22&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^([0-9]&#123;4&#125;)-([0-9]&#123;1,2&#125;)-([0-9]&#123;1,2&#125;)$/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&#x27;$1年$2月$3日&#x27;</span>));<br><span class="hljs-comment">//输出👉 2020年12月22日</span><br><br><span class="hljs-comment">// 还可以这样做,对分组命名再引用</span><br>reg = <span class="hljs-regexp">/^(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;1,2&#125;)-(?&lt;day&gt;[0-9]&#123;1,2&#125;)$/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&#x27;$&lt;year&gt;年$&lt;month&gt;月$&lt;day&gt;日&#x27;</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例2</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;aaa123bbb&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/[0-9]+/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&quot;-$`-$&#x27;-&quot;</span>));<br><span class="hljs-comment">// 输出👉 aaa-aaa-bbb-bbb</span><br></code></pre></td></tr></table></figure><blockquote><p>个人感觉：在newSubStr使用 $` 和 $’  ，一般不会配合全局匹配正则表达式使用。</p></blockquote><p><strong>在第二个参数中使用function</strong></p><p>使用<code>str.replace(regExp, function(...args) &#123;......&#125;)</code>时</p><p>function的形参分别对应regExp.exec(str)返回数组中的每一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc 321eee&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([0-9]+)([a-z]+)/g</span>;<br>str = str.replace(reg, <span class="hljs-function">(<span class="hljs-params">matched, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(matched);<br>    <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span>+$<span class="hljs-number">2.</span>toUpperCase()<br>&#125;);<br><span class="hljs-built_in">console</span>.log(str);<br><span class="hljs-comment">// 输出👇</span><br>123abc<br>321eee<br><span class="hljs-string">&quot;123ABC 321EEE&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="字符串的replaceAll方法"><a href="#字符串的replaceAll方法" class="headerlink" title="字符串的replaceAll方法"></a>字符串的replaceAll方法</h2><p>replaceAll方法在第一个参数为<code>RegExp对象</code>时的功能与replace方法基本一致。</p><p>但有不同点：</p><p><code>replace</code>方法的第一个参数可以没有<code>g</code>修饰，相应地最多执行一次替换操作。而<code>replaceAll</code>方法第一个参数没有<code>g</code>修饰，则会抛出异常<code>TypeError</code>。</p><h2 id="字符串的split方法"><a href="#字符串的split方法" class="headerlink" title="字符串的split方法"></a>字符串的split方法</h2><p><strong><code>str.split(regExp)</code></strong></p><p><strong>参数</strong></p><ul><li>regExp 一个正则表达式对象</li></ul><p><strong>返回值</strong></p><p>返回一个数组，数组各元素是由所有匹配到的子串分割后得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/-+/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123-foo---bar&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.split(reg));<br><span class="hljs-comment">//输出👉 [ &#x27;123&#x27;, &#x27;fafas&#x27;, &#x27;413123&#x27; ]</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：输入到split方法中的正则表达式，在非必要情况下避免使用分组，否则可能出现意想不到的情况。</p><p>例如下面的情况：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(-+)/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123-foo---bar&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.split(reg));<br><span class="hljs-comment">// 输出👉 [ &#x27;123&#x27;, &#x27;-&#x27;, &#x27;foo&#x27;, &#x27;---&#x27;, &#x27;bar&#x27; ] </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/23/hello-world/"/>
    <url>/2020/12/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
