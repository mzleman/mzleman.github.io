<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>css面试题</title>
    <link href="/2021/08/23/CSS/css-note/"/>
    <url>/2021/08/23/CSS/css-note/</url>
    
    <content type="html"><![CDATA[<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><h3 id="浮动的作用"><a href="#浮动的作用" class="headerlink" title="浮动的作用"></a>浮动的作用</h3><p>浮动主要作用是使元素可以按顺序水平排列，制作一些水平方向的布局效果。</p><h3 id="浮动可选值"><a href="#浮动可选值" class="headerlink" title="浮动可选值"></a>浮动可选值</h3><p><code>float: none;</code> 默认</p><p><code>float: left;</code></p><p><code>float: right;</code></p><h3 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h3><ol><li><p>浮动的元素会向父元素内容区的左边界或右边界对齐，多个连续的浮动元素会依次排列。</p><p><code>float:left;</code>时，从左至右，从上至下依次排列。</p><p><code>float:right;</code>时，从右至左，从上至下依次排列。</p><blockquote><p>默认情况下，浮动元素在水平方向不会从父元素中溢出</p></blockquote></li><li><p>元素浮动后，元素性质会发生改变。</p><blockquote><p>不论是内联元素、块元素还是其他元素，表现一致。</p></blockquote><ul><li>内容区宽度和高度默认由内容撑开。</li><li>设置width和height有效。</li><li>设置margin、padding、border都有布局效果。</li><li>文档流水平方向等式不再要求成立。</li></ul></li><li><p>浮动元素与前一个兄弟元素的关系。</p><ul><li><p>如果前一个元素也发生浮动，不论前一个元素的浮动方向是否与自己相同，都会尝试与前一个浮动元素同在一行（只要父元素一行内的剩余宽度足够）。如果该行剩余宽度不足够，则换行浮动。</p><blockquote><p>剩余宽度足够的标准是：</p><p>剩余宽度 &gt;= 该元素的margin + border + padding + content  ⭐<font color='red'> 要考虑左右margin</font></p></blockquote></li><li><p>如果前一个元素没有发生浮动，不论前一个元素是内联元素、块元素还是行内块元素，则会在前一个元素的下一行进行浮动。</p><blockquote><p>❗ 注意点：</p><p>(1) 如果前一个未浮动元素是内联元素且包裹文字，则浮动元素会在第一行文字的下方开始浮动。且，如果前一个内联元素中的文字发生了换行，后一个浮动元素默认不会覆盖前一个元素的文字。</p><p>(2) 如果前一个未浮动元素设置了margin-bottom，则后一个浮动元素要考虑前一个元素的该外边距，再换行浮动。</p></blockquote></li></ul></li><li><p>浮动元素与后一个兄弟元素的关系。</p><p>主要是指如果前一个元素浮动而后一个元素不浮动，则后一个元素上移，因为浮动元素脱离了文档流。</p></li></ol><h2 id="margin-collapsing"><a href="#margin-collapsing" class="headerlink" title="margin collapsing"></a>margin collapsing</h2><h3 id="现象概述"><a href="#现象概述" class="headerlink" title="现象概述"></a>现象概述</h3><p><code>margin collapsing</code>翻译后可以叫“外边距折叠”或“外边距坍塌”。</p><p>CSS布局中有一个现象，就是两个或多个<font color='red'>块元素之间</font>或<font color='red'>块元素与内联元素之间</font>的上外边距(<code>margin-top</code>)和下外边距(<code>margin-bottom</code>)有时会合并（折叠）为单个边距，其大小视情况而定，这种现象称之为“外边距折叠”。</p><blockquote><p>经过在Chrome中测试，块元素与行内块元素之间不发生外边距重叠。❓</p></blockquote><h3 id="四种基本折叠情景"><a href="#四种基本折叠情景" class="headerlink" title="四种基本折叠情景"></a>四种基本折叠情景</h3><p><strong>基本前提：</strong><font color='red'>只考虑块元素、内联元素，不考虑行内块元素。</font>因为在Chrome中测试，行内块元素与其他兄弟元素之间不发生外边距折叠。</p><h4 id="1-相邻兄弟元素之间的外边距折叠"><a href="#1-相邻兄弟元素之间的外边距折叠" class="headerlink" title="1.  相邻兄弟元素之间的外边距折叠"></a><strong>1.  相邻兄弟元素之间的外边距折叠</strong></h4><p>前一个元素的<code>margin-bottom</code>和后一个元素的<code>margin-bottom</code>会发生折叠现象。</p><ul><li>如果二者的相邻外边距都为正，则折叠后的外边距取较大值。</li><li>如果二者的相邻外边距一正一负数，则折叠后的外边距取两者之和。</li><li>如果二者的相邻外边距都是负数，则折叠后的外边距取两者的较小值（绝对值更大的负数）。</li></ul><blockquote><p>相邻的兄弟元素必然处于同一BFC中，一般情况都会发生外边距的重叠。除非相邻兄弟元素中有发生浮动或者绝对定位。</p></blockquote><h4 id="2-父元素和其第一个相邻的文档流中的子元素之间的外边距穿透"><a href="#2-父元素和其第一个相邻的文档流中的子元素之间的外边距穿透" class="headerlink" title="2. 父元素和其第一个相邻的文档流中的子元素之间的外边距穿透"></a>2. 父元素和其第一个相邻的文档流中的子元素之间的外边距穿透</h4><p><font color='red'>如果一个父元素和其某个子元素同时满足以下条件：</font></p><ol><li><p>父级元素没有<code>border-top、padding-top</code>，或者其计算宽度为0；</p></li><li><p>在父元素文档流中的该子元素前，没有哥哥节点在垂直方向上占据空间；</p><ul><li>情况1：前面没有任何哥哥元素节点和文本节点。</li><li>情况2：前面有哥哥元素节点，但它们都不具有垂直向的尺寸。</li><li>情况3：前面有哥哥元素节点，但它们脱离了文档流（浮动、绝对定位）。</li></ul></li><li><p>在父元素最上方与该子元素之间，没有不占空间的BFC块级格式化上下文。⭐</p><blockquote><p>简单理解为，BFC不会被穿透。</p></blockquote></li><li><p>该子元素前面没有元素设置了<code>clear</code>样式而确实隐式增加了一个非零的<code>margin-top</code>。</p></li><li><p>该子元素设置了<code>margin-top</code>且非零。</p></li></ol><p><font color='red'>则子元素的上外边距会穿透父容器</font>。</p><p><strong>案例1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>        width: 200px;<br>        height: 200px;<br>        background-color: red;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.top</span> &#123;</span><br>        margin-top: 100px;<br>        width: 100px;<br>        height: 100px;<br>        background-color: green;<br>        float: left;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.mid</span> &#123;</span><br><span class="css">        <span class="hljs-selector-tag">margin-top</span>: 50<span class="hljs-selector-tag">px</span>;   <span class="hljs-comment">/* 第一个文档流中子元素的上外边距 */</span></span><br>        width: 100px;<br>        height: 100px;<br>        background-color: blue;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/08/23/CSS/css-note/image-20210712135024373.png" alt="image-20210712135024373"> </p><p><strong>案例2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      background-color: red;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.mid</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      background-color: pink;<br>      margin-top: 50px;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span>mid<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712144217093.png" alt="image-20210712144217093"></p><h4 id="3-父元素和其最后一个相邻的文档流中的子元素之间的外边距穿透"><a href="#3-父元素和其最后一个相邻的文档流中的子元素之间的外边距穿透" class="headerlink" title="3. 父元素和其最后一个相邻的文档流中的子元素之间的外边距穿透"></a>3. 父元素和其最后一个相邻的文档流中的子元素之间的外边距穿透</h4><p><font color='red'>如果一个父元素和其某个子元素同时满足以下条件：</font></p><ol><li><p>父级元素没有<code>border-bottom、padding-bottom</code>，或者其计算宽度为0；</p></li><li><p>父元素没有设置<code>height</code>和<code>min-height</code>，即父元素的高度默认由内容撑开。</p></li><li><p>在该子元素之后，后面没有弟弟元素在垂直方向上占据空间：</p><ul><li>情况1：后面没有任何哥哥元素节点和文本节点。</li><li>情况2：后面有哥哥元素节点，但它们都不具有垂直向的尺寸。</li><li>情况3：后面有哥哥元素节点，但它们脱离了文档流（浮动、绝对定位）。</li></ul></li><li><p>在该子元素与父元素最后的中间区域（HTML结构），没有不占空间的BFC块级格式化上下文。⭐</p><blockquote><p>简单理解为，BFC不会被穿透。</p></blockquote></li><li><p>在该子元素之后没有元素因为设置<code>clear</code>样式而隐式增加了一个非零的<code>margin-top</code>。</p></li><li><p>该子元素设置了<code>margin-bottom</code>且非零。</p></li></ol><p><font color='red'>则该子元素的下外边距会穿透父元素。</font></p><p><strong>案例1：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.top</span> &#123;</span><br>      margin-bottom: 50px;<br>      background-color: grey;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.top-inner</span> &#123;</span><br>      background-color: pink;<br>      width: 100px;<br>      height: 100px;<br>      margin-bottom: 100px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.mid</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      background-color: orange;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top-inner&quot;</span>&gt;</span>top-inner<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span>mid<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712140352165.png" alt="image-20210712140352165"> </p><p><strong>案例2</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br>    <br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      background-color: red;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.top</span> &#123;</span><br>      margin-bottom: 100px;<br>      background-color: sandybrown;<br>      width: 100px;<br>      height: 100px;<br>    &#125;<br><br>    footer &#123;<br>      background-color: rebeccapurple;<br>      width: 200px;<br>      height: 200px;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span>top<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712144540571.png" alt="image-20210712144540571"></p><h4 id="4-空的块元素自身上下外边距的折叠"><a href="#4-空的块元素自身上下外边距的折叠" class="headerlink" title="4. 空的块元素自身上下外边距的折叠"></a>4. 空的块元素自身上下外边距的折叠</h4><p>如果同时满足以下条件：</p><ol><li><p>该元素是一个<font color='red'>块元素</font>或<code>display: block;</code>。</p></li><li><p>该元素是空的，即没有子元素也没有文本。</p><blockquote><ul><li><p><font color='red'>空的内联元素不起布局作用；</font></p></li><li><p><font color='red'>空的行内块元素上下外边距不会折叠，而都会起作用。</font></p></li></ul></blockquote></li></ol><p>则如果该元素设定了<code>margin-top</code>和<code>margin-bottom</code>，则它自身的上下外边距会发生折叠。</p><p><strong>案例1</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.top</span> &#123;</span><br>      margin-top: 50px;<br><span class="css">      <span class="hljs-selector-tag">margin-bottom</span>: 100<span class="hljs-selector-tag">px</span>;   <span class="hljs-comment">/* ⭐ 50px的上外边距和100px的下外边距折叠为100px的单个外边距 */</span></span><br><span class="css">      <span class="hljs-comment">/* display: block; */</span></span><br>    &#125;<br><span class="css">    <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.mid</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      background-color: pink;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span>mid<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712141641077.png" alt="image-20210712141641077"> </p><h3 id="四种基本情景的叠加"><a href="#四种基本情景的叠加" class="headerlink" title="四种基本情景的叠加"></a>四种基本情景的叠加</h3><p>上述四种基本的外边距折叠情景还会具有叠加效应。</p><p>比如 父元素的孙子元素的外边距穿透等等，到了具体情况进行具体分析。</p><p><strong>案例1  嵌套的上外边距</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.outer</span> &#123;</span><br>      background-color: red;<br>      width: 200px;<br>      height: 200px;<br><span class="css">      <span class="hljs-selector-tag">margin-top</span>: 50<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/* 父元素的上外边距 */</span></span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.mid</span> &#123;</span><br>      background-color: green;<br>      width: 100px;<br>      height: 100px;<br><span class="css">      <span class="hljs-selector-tag">margin-top</span>: 100<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/* 儿子元素的上外边距 */</span></span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.inner</span> &#123;</span><br>      background-color: blue;<br>      width: 50px;<br>      height: 50px;<br><span class="css">      <span class="hljs-selector-tag">margin-top</span>: 150<span class="hljs-selector-tag">px</span>; <span class="hljs-comment">/* 孙子元素的上外边距 */</span></span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712150719763.png" alt="image-20210712150719763"> </p><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> BFC（Block Formatting Context）格式化上下文,指一个独立的渲染区域或者说是一个隔离的独立容器。</p><p>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部，同时外部元素也不会干扰内部的布局关系。</p><h3 id="开启BFC的元素和方式"><a href="#开启BFC的元素和方式" class="headerlink" title="开启BFC的元素和方式"></a>开启BFC的元素和方式</h3><ol><li><p>根元素<html>标签默认创建一个BFC。⭐⭐</p></li><li><p>浮动的元素会创建一个BFC。⭐⭐</p></li><li><p>绝对定位和固定定位的元素创建一个BFC，<code>postion</code>属性为<code>absolute</code>或<code>fixed</code>。⭐⭐</p></li><li><p>行内块元素（或元素的 <code>display</code>为 <code>inline-block</code>）。⭐⭐</p></li><li><p>表格单元格<td>标签（或元素的<code>display</code>为<code>table-cell</code>）。⭐⭐</p></li><li><p>其他表格元素隐式创建的表格单元格，如<table>标签、<tr>标签、<tbody>标签、<thead>标签、<tfoot>标签都会隐式地创建表格单元格（或元素的<code>display</code>属性为<code>table、table-row、table-row-group、table-header-group、table-footer-group</code>）</p></li><li><p><code>overflow</code>样式值不为<code>visible</code>和<code>clip</code>的元素。⭐⭐</p></li><li><p>弹性元素，即弹性盒子的直接子元素（<code>display</code>属性值为<code>flex</code>或<code>inline-flex</code>的元素的直接子元素）。</p></li><li><p>网格元素，即网格盒子的直接子元素（<code>display</code>属性值为<code>grid</code>或<code>inline-grid</code>的元素的直接子元素）。</p></li><li><p>…..</p></li></ol><blockquote><p><strong>注意：</strong></p><ol><li><p><code>display: flex/grid; </code>的元素本身创建的是<code>flex formatting context</code>和<code>grid formatting context</code>，而<code>flex items</code>和<code>grid items</code>会默认创建一个BFC，除非<code>flex items</code>和<code>grid items</code>自己主动创建其他类型的上下文。</p></li><li><p>根据MDN的解释，<code>display: table;</code>的元素本身没有创建一个BFC，而是其内部默认会有一个<code>tbody</code>，<code>tbody</code>创建了属于自己的BFC。</p></li></ol></blockquote><h3 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h3><h4 id="suppress-margin-collapsing"><a href="#suppress-margin-collapsing" class="headerlink" title="suppress margin collapsing"></a>suppress margin collapsing</h4><p>翻译：抑制外边距的折叠。</p><p><strong>具体应用：</strong></p><ol><li><p>开启BFC的父容器，其子元素以及后代元素的外边距不会穿透父容器。</p><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.outer</span> &#123;</span><br>      background-color: red;<br>      width: 200px;<br>      height: 200px;<br><span class="css">      <span class="hljs-comment">/* margin-top: 50px; */</span></span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.son1</span> &#123;</span><br>      display: table-cell;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.son2</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      margin-top: 50px;<br>      background-color: skyblue;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son2&quot;</span>&gt;</span>son2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712160059804.png" alt="image-20210712160059804"> </p></li></ol><ol start="2"><li><p>在两个兄弟块元素或块元素与内联元素之间创建一个空的BFC，可以阻止 它们外边距折叠。</p><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.outer</span> &#123;</span><br>      background-color: red;<br>      width: 400px;<br>      height: 400px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.son1</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      margin-bottom: 50px;<br>      background-color: springgreen;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.son3</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      margin-top: 50px;<br>      background-color: skyblue;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.bfc</span> &#123;</span><br><span class="css">      <span class="hljs-selector-tag">display</span>: <span class="hljs-selector-tag">table-cell</span>;  <span class="hljs-comment">/* 创建一个bfc，分隔开两个div */</span></span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son1&quot;</span>&gt;</span>son1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bfc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;son3&quot;</span>&gt;</span>son2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="contain-internal-floats"><a href="#contain-internal-floats" class="headerlink" title="contain internal floats"></a>contain internal floats</h4><p>我们知道，一般情况下如果一个父元素内的所有元素发生浮动，则父容器会发生高度塌陷的现象。</p><p>而开启BFC的元素有一个特点就是计算高度时会考虑浮动元素，因此我们利用BFC的这一特性来防止高度塌陷。</p><h4 id="exclude-external-floats"><a href="#exclude-external-floats" class="headerlink" title="exclude external floats"></a>exclude external floats</h4><p>开启BFC的元素不会被外部的浮动元素覆盖，我们常利用这一特性制作特殊的布局结构。</p><p><strong>1. 两栏布局</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      height: 800px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br>      width: 200px;<br>      height: 100%;<br>      float: left;<br>      background-color: steelblue;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br>      height: 100%;<br>      overflow: hidden;<br>      background-color: tan;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>浮动的左边栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边的自适应宽度区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712205909677.png" alt="image-20210712205909677"></p><p><strong>2. 三栏布局</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br>      height: 800px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br>      width: 200px;<br>      height: 100%;<br>      float: left;<br>      background-color: steelblue;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.mid</span> &#123;</span><br>      height: 100%;<br>      overflow: hidden;<br>      background-color: tan;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br>      width: 200px;<br>      height: 100%;<br>      float: right;<br>      background-color: pink;<br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>浮动的左边栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>浮动的右边栏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mid&quot;</span>&gt;</span>中间的宽度自适应区域<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/2021/08/23/CSS/css-note/image-20210712210144983.png" alt="image-20210712210144983"></p><h2 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 position</h2><h3 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h3><ol><li>static 默认值</li><li>fixed 固定定位</li><li>relative 相对定位</li><li>absolute 绝对定位</li><li>sticky 粘滞定位</li></ol><h3 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h3><p>元素开启固定定位的特点：</p><ol><li><p>元素脱离文档流，不论是何种元素，元素性质发生以下改变：</p><ul><li>宽度、高度默认由内容撑开。</li><li>设置width、height有效。</li><li>上下左右margin、padding都起到布局作用。</li></ul></li><li><p>元素的定位原点在浏览器布局视口的左上角。</p><blockquote><p>需要好好理解的一句话：如果一个元素开启固定定位，则首先对其他元素进行布局。<font color='red'>但如果该定位元素不设置</font><code>left/right/top/bottom</code>，则该元素会布局在它原本在文档流中的位置（相对于未开启定位前的包含块），并提高层级后进行显示。</p></blockquote></li><li><p>元素的显示层级会提升一层。</p></li><li><p>最大的特点：由于定位原点是视口的左上角，所以不论页面如何滚动，该元素的位置都不会发生改变。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>      margin: 0;<br>      padding: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-id">#div1</span> &#123;</span><br>      width: 100px;<br>      height: 100px;<br>      background-color: grey;<br>      position: fixed;<br>    &#125;<br><span class="css">    <span class="hljs-selector-id">#div2</span> &#123;</span><br>      width: 200px;<br>      height: 200px;<br>      background-color: yellow;<br>      margin-top: 50px;<br><span class="css">      <span class="hljs-comment">/* position: fixed; */</span></span><br>    &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h3><p>元素开启相对定位的特点：</p><ol><li><p>元素不会脱离文档流，元素的性质不会发生改变（块还是块、内联还是内联）。</p></li><li><p>元素定位的原点是其原来位置（文档流中/浮动后的位置）。</p><blockquote><p>开启相对定位的元素不论怎么移动，其盒模型所占的空间（包括margin）仍然会被保留。</p><p><font color='red'>浮动后的元素也可以开启相对定位</font>，设置它的left（假如left &gt; 0），则它会带动其右侧的浮动元素，一起向右移动。设置它的right（假如right &gt; 0），则它会带动其左侧的浮动元素，一起向左移动。</p></blockquote></li><li><p>元素的显示层级会提升一层。</p></li></ol><h3 id="绝对定位-absolute⭐"><a href="#绝对定位-absolute⭐" class="headerlink" title="绝对定位  absolute⭐"></a>绝对定位  absolute⭐</h3><p>元素开启绝对定位的特点：</p><ol><li><p>元素脱离文档流，不论是何种元素，元素性质发生以下改变：</p><ul><li>宽度、高度默认由内容撑开。</li><li>设置width、height有效。</li><li>上下左右margin、padding都起到布局作用。</li></ul></li><li><p><font color='red'>元素的定位原点在其包含块的左上角</font>。对于开启绝对定位的元素，其包含块是最近一个<code>position</code>属性不为<code>static</code>的祖先元素，如果没有任何祖先元素开启定位，则其包含块为初始包含块，即浏览器布局视口。</p><blockquote><p><strong>记忆点1</strong>：对于没有开启绝对定位、固定定位的元素，其包含块可以理解为各个元素<code>offsetParent</code>属性指向的节点。</p><ul><li>一般情况下，包含块（<code>offsetParent</code>)是离自身最近的祖先块元素。</li><li>对于表格内部<code>tbody、tr、td、th</code>等元素，包含块（<code>offsetParent</code>)是其外层的<code>table</code>元素。</li><li><code>body</code>、<code>html</code>元素的包含块（<code>offsetParent</code>）是空。</li></ul><p><strong>记忆点2</strong>：如果一个元素开启绝对定位，则首先对其他元素进行布局。<font color='red'>但如果该定位元素不设置</font><code>left/right/top/bottom</code>，则该元素会布局在它原本在文档流中的位置（相对于未开启定位前的包含块），并提高层级后进行显示。👈 类似于固定定位。</p></blockquote></li><li><p>元素的显示层级会提升一层。</p></li><li><p>元素产生新的水平方向的布局等式，以及垂直布局等式。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">left</span><span class="hljs-operator">+</span><span class="hljs-variable">marginLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">borderLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">paddingLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">width</span><span class="hljs-operator">+</span><span class="hljs-variable">paddingRight</span><span class="hljs-operator">+</span><span class="hljs-variable">borderRight</span><span class="hljs-operator">+</span><span class="hljs-variable">marginRight</span><span class="hljs-operator">+</span><span class="hljs-variable">right</span><br><span class="hljs-operator">=</span> 包含块可视区域宽度<span class="hljs-variable">clientWidht</span> <br><span class="hljs-operator">=</span> 包含块<span class="hljs-variable">width</span> <span class="hljs-operator">+</span> 包含块<span class="hljs-variable">padding</span> <span class="hljs-operator">-</span> 滚动条宽度<br><br>其中默认值：<br><span class="hljs-variable">left</span><span class="hljs-operator">:</span> <span class="hljs-variable">auto</span><span class="hljs-operator">;</span> ⭐<br><span class="hljs-variable">margin</span><span class="hljs-operator">-</span><span class="hljs-variable">left</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-operator">;</span> ⭐<br><span class="hljs-variable">border</span><span class="hljs-operator">-</span><span class="hljs-variable">left</span><span class="hljs-operator">:</span> <span class="hljs-variable">none</span><span class="hljs-operator">;</span><br><span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">left</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-operator">;</span><br><span class="hljs-variable">width</span><span class="hljs-operator">:</span> <span class="hljs-variable">auto</span><span class="hljs-operator">;</span> ⭐<br><span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">right</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-operator">;</span><br><span class="hljs-variable">border</span><span class="hljs-operator">-</span><span class="hljs-variable">right</span><span class="hljs-operator">:</span> <span class="hljs-variable">none</span><span class="hljs-operator">;</span><br><span class="hljs-variable">margin</span><span class="hljs-operator">-</span><span class="hljs-variable">right</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-operator">;</span> ⭐<br><span class="hljs-variable">right</span><span class="hljs-operator">:</span> <span class="hljs-variable">auto</span><span class="hljs-operator">;</span> ⭐<br></code></pre></td></tr></table></figure><p>(1) 如果发生过度约束，即9个值都设定一个自定义值，且等式两边不相等，则<code>right</code>进行自适应调整。</p><p>(2) 如果<code>left</code>和<code>right</code>都为<code>auto</code>，则首先<code>left</code>的值调整为<font color='red'>包含块padding-left</font>，然后考虑：</p><ul><li>如果<code>width</code>为<code>auto</code>，则绝对定位元素的宽度默认由内容撑开。</li><li><code>right</code>的值计算方法：包含块可视区域大小 - 其他8个值。</li></ul><p>(3) 如果<code>left = auto</code>，<code>right ≠ auto</code>，则：</p><ul><li>如果<code>width</code>为<code>auto</code>，则绝对定位元素的宽度默认由内容撑开。</li><li><code>left</code>的值计算方法：包含块可视区域大小 - 其他8个值。</li></ul><p>(4) 如果<code>right = auto</code>，<code>left ≠ auto</code>，则：</p><ul><li>如果<code>width</code>为<code>auto</code>，则绝对定位元素的宽度默认由内容撑开。</li><li><code>right</code>的值计算方法：包含块可视区域大小 - 其他8个值。</li></ul><blockquote><p>如果<code>left/right</code>至少有一个为<code>auto</code>，且将<code>margin-left</code>或<code>margin-right</code>设置为<code>auto</code>的话，则<code>margin-left</code>和<code>margin-right</code>的<code>auto</code>不起作用，会被置为零。</p></blockquote><p>(5) 如果<code>left ≠ auto</code>且<code>right ≠ auto</code>，则：</p><ul><li><p><code>width、margin-left、margin-right</code>至少一个为<code>auto</code>，类似于文档流中的水平方向布局等式：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">marginLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">borderLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">paddingLeft</span><span class="hljs-operator">+</span><span class="hljs-variable">width</span><span class="hljs-operator">+</span><span class="hljs-variable">paddingRight</span><span class="hljs-operator">+</span><span class="hljs-variable">borderRight</span><span class="hljs-operator">+</span><span class="hljs-variable">marginRight</span><br><span class="hljs-operator">=</span> 包含块内容区宽度<span class="hljs-variable">clientWidth</span> <span class="hljs-operator">-</span> <span class="hljs-variable">left</span> <span class="hljs-operator">-</span> <span class="hljs-variable">right</span><br></code></pre></td></tr></table></figure></li><li><p>9个值都不为<code>auto</code>，如果发生过度约束，如（1）.</p></li></ul></li></ol><h3 id="粘性定位-sticky"><a href="#粘性定位-sticky" class="headerlink" title="粘性定位 sticky"></a>粘性定位 sticky</h3><p>粘性定位目前主要拿来做吸顶效果，开启粘性定位元素的特点：</p><ol><li>元素不会脱离文档流，元素的性质不会发生改变。</li><li>不论元素偏移到何处，原来占据的空间会被保留。</li><li>粘性定位的定位原点是第一个可滚动祖先的内容区左上角。</li><li>粘性定位的元素只会在包含块中显示⭐。</li></ol><blockquote><p>注意点：</p><ul><li>粘性定位元素的包含块的<code>overflow</code>属性值不可以是除<code>visible</code>以外的值，否则不会有粘性效果，只会等价于开启了相对定位<code>relative</code>。</li><li>粘性定位元素必须指定<code>top/bottom/left/right</code>中的一个值，否则只会等价于开启了相对定位。</li></ul></blockquote><h3 id="元素层级-z-index"><a href="#元素层级-z-index" class="headerlink" title="元素层级 z-index"></a>元素层级 z-index</h3><p>前提：元素的<code>position</code>属性值不是<code>static</code>，即元素开启了定位。</p><p>可以通过设置<code>z-index</code>属性来指定元素的层级，<code>z-index</code>样式的值为一个整数（一般为非负整数），数值也越大表示优先在最上层显示。</p><p>注意：</p><ol><li><p>若两个或多个不存在祖先-后代关系的元素的<code>z-index</code>值相同，则优先显示在HTML代码中靠后的元素。</p></li><li><p>绝大多数情况下，祖先元素永远不会盖住后代元素，即使后代元素<code>z-index</code>小于祖先元素的<code>z-index</code>。</p><blockquote><p>❗特例：后代元素<code>z-index</code>设置为负数，而祖先元素没有设置<code>z-index</code>。</p></blockquote></li></ol><h2 id="字体、行高、文本对齐、换行"><a href="#字体、行高、文本对齐、换行" class="headerlink" title="字体、行高、文本对齐、换行"></a>字体、行高、文本对齐、换行</h2><h3 id="添加字体"><a href="#添加字体" class="headerlink" title="添加字体"></a>添加字体</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;myfont&#x27;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/static/font/myfont.ttf&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;truetype&quot;</span>),<span class="hljs-comment">/* 👈多个url中用逗号隔开 */</span><br>         <span class="hljs-comment">/* format可以省略，其作用在于明确告知浏览器字体类型*/</span><br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/static/font/myfont.woff2&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;woff2&quot;</span>), <br>         <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/static/font/myfont.woff1&quot;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;woff1&quot;</span>); <span class="hljs-comment">/* 👈 最后一个url后记得用分号结尾 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><p>该样式用于设置元素的字体类型，是可继承样式⭐。</p><p>常用的默认值：</p><ol><li>serif   👈衬线字体</li><li>sans-serif   👈 非衬线字体</li><li>monospace   👈 等宽字体</li></ol><p><code>font-family</code>可以指定多个值，多个值之间用逗号隔开，优先生效靠前的，最后一个可选值一般是上述的默认值之一（因为被所有机器的上的浏览器所支持）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: myfont, <span class="hljs-string">&quot;Microsoft Yahei&quot;</span>, 宋体, sans-serif; <span class="hljs-comment">/* 字体名中有空格时，用引号包裹 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字体颜色和大小"><a href="#字体颜色和大小" class="headerlink" title="字体颜色和大小"></a>字体颜色和大小</h3><p><code>color</code>：设置字体颜色，准确来说color是前景色。可继承样式⭐。</p><p><code>font-size</code>：设置字体大小。可继承样式⭐。</p><h3 id="行高-line-height"><a href="#行高-line-height" class="headerlink" title="行高 line-height"></a>行高 line-height</h3><p><code>line-height</code>是可继承样式 ⭐，对于块元素和内联元素设置<code>line-height</code>有不同的含义：</p><ol><li>块元素设置行高，是指一行文本占用的实际高度，其样式会被后代元素继承。</li><li>内联元素设置行高，是指自身一行文本所占用的实际高度，但与其盒模型大小无关，<font color='red'>如果其值大于自己包含块的行高，则会撑起自身所在行框的行高。</font></li></ol><p><code>line-height</code>的样式值可以为  20px、1em、1rem 等尺寸，也可以设置为一个数（代表是<code>font-size</code>的多少倍，即省略了单位em）。</p><p><strong>⭐要点：</strong></p><p>设置元素的<code>font-size</code>属性实际上设置的是字体框的高度，而非真是的字符高度（字符高度可能大于也可能小于字体框高度）。</p><p>行高<code>line-height</code>会在字体框的上下平均分配。</p><p>———————————————————- ↓ 行高顶部</p><p><font color='red'>—————————–</font>  ↓ 字体框顶部 </p><pre><code>                                `font-size`                  `line-height`</code></pre><p><font color='red'>—————————–  </font>↑ 字体框底部 </p><p>———————————————————-↑  行高底部 </p><p><strong>⭐行高的特殊作用：</strong></p><ol><li>当对块元素设置<code>line-height = height</code>时，块元素内的单行文字会垂直居中。</li><li>行间距 = <code>line-height</code> - <code>font-size</code>，因此可以利用上面这个等式调整行间距。</li></ol><h3 id="简写属性-font"><a href="#简写属性-font" class="headerlink" title="简写属性 font"></a>简写属性 font</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">                                 👇 必须写在倒数第二个       👇 必须写在倒数第一个<br><span class="hljs-selector-tag">font</span>: <span class="hljs-selector-attr">[font-weight, font-style]</span>, <span class="hljs-selector-tag">font-size</span><span class="hljs-selector-attr">[/line-height]</span>, <span class="hljs-selector-tag">font-family</span>;<br>   默认<span class="hljs-selector-tag">normal</span>    默认<span class="hljs-selector-tag">normal</span>   默认16<span class="hljs-selector-tag">px</span>    默认<span class="hljs-selector-tag">normal</span>          <br></code></pre></td></tr></table></figure><p><code>font-weight</code>：默认值normal，可选值<code>bold</code>或<code>100-900</code>九个级别。</p><p><code>font-style</code>：默认值normal，可选值<code>italic</code>。</p><blockquote><p>❗ 注意：</p><p>在简写属性中，<code>font-weight、font-style、line-height</code>如果不写的话则采用默认值，会覆盖之前独立设置的相应样式值。</p></blockquote><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><p><code>text-align</code>属性一般设置在块元素上，其定义该块元素的行内内容（例如文字）如何相对于自身对齐。</p><p><code>text-align</code> 并不控制块元素自己的对齐，只控制它的行内内容的对齐。</p><p>该样式是可继承样式⭐。</p><p>可选值：</p><ol><li>left 左对齐，默认值</li><li>right 右对齐</li><li>center 居中对齐</li><li>justify 两端对齐</li></ol><h3 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h3><p><code>vertical-align</code>是用于设置行内元素的行框与父元素行框对齐的方式。</p><blockquote><p>行框是指元素<code>line-height</code>样式值形成的框。</p></blockquote><p><font color='red'><code>vertical-align</code>只能对行内元素、表格单元格元素生效，</font>不能用它垂直对齐块级元素。</p><p><strong>可选值：</strong></p><ol><li><p>baseline  基线对齐，默认值</p></li><li><p>top  子元素行框顶端与父元素行框顶端对齐</p></li><li><p>middle 子元素文本基线与父元素文本中的“X”字符中心点高度对齐（一般不用，只在表格单元格中有使用）。</p></li><li><p>bottom 子元素行框底端与父元素行框底端对齐</p></li></ol><p>—————————  行高顶部</p><p><font color='red'>—————————  </font>字体框顶部</p><p><font color='cornflowerblue'>————————— </font> 字体框基线</p><p><font color='red'>—————————  </font>字体框底部</p><p>—————————  行高底部</p><p><strong>可以实现的效果：</strong></p><ul><li><p>条件1：子元素<code>line-height</code>等于父元素<code>line-height</code></p><p>条件2：子元素<code>vertical-align</code>等于<code>bottom/top</code></p><p>效果：子元素文本在父元素行框内垂直居中。</p></li></ul><ul><li><p>条件1：子元素<code>line-height</code>等于自己的<code>font-size</code></p></li><li><p>条件2：子元素<code>vertical-align</code>等于<code>top/bottom</code></p><p>效果：子元素文本贴在父元素行框上边缘或下边缘。</p></li></ul><p><strong>用于解决一个bug：</strong></p><p>前提：当使用div或其他块元素中包裹一个img标签，且div高度由img撑开</p><p>现象：由于img为替换元素，img底部为图片的基线，而<code>vertical-align</code>默认为<code>baseline</code>，这就导致img底部将和div的行框基线对齐，div被img撑开的实际高度大于img高度，出现一个外层边缘。</p><p>解决办法：</p><p>方法1，可以将img标签的<code>vertical-align</code>设置为<code>top</code>或<code>bottom</code></p><p>放法2，可以将div的高度写死为img的高度。</p><h3 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h3><p><code>white-space</code>在CSS中的作用比较杂，不同<code>white-space</code>样式值会有不同的控制效果。</p><p><strong>可选值：</strong></p><ol><li>normal 👈默认值</li><li>nowrap</li><li>pre</li><li>pre-wrap</li><li>pre-line</li></ol><table><thead><tr><th>可选值</th><th>对连续空白字符的处理策略</th><th>对回车符\r的处理策略</th><th>是否软换行（文本超出父元素宽度时是否自动换行）</th></tr></thead><tbody><tr><td><code>nomal        </code></td><td>压缩成一个空格</td><td>视为一个空白字符</td><td>是</td></tr><tr><td><code>nowrap                </code></td><td>压缩成一个空格</td><td>视为一个空白字符</td><td>否</td></tr><tr><td><code>pre</code></td><td>保留所有空白字符</td><td>视为一个文本换行标志</td><td>否</td></tr><tr><td><code>pre-wrap      </code></td><td>保留所有空白字符</td><td>视为一个文本换行标志</td><td>是</td></tr><tr><td><code>pre-line</code></td><td>压缩成一个空格</td><td>视为一个文本换行标志</td><td>是</td></tr></tbody></table><blockquote><p><strong>根据需求选择合适的样式值：</strong></p><ol><li>如果需要一个段落的文本保持单行显示，则使用<code>nowrap</code>。</li><li>如果需要文本和HTML代码中一致，所见即所得，则使用<code>pre</code>。</li><li><code>pre-line</code>和<code>pre-wrap</code>需要根据具体情况进一步择取。</li></ol></blockquote><h3 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h3><p>该样式值主要用于控制<font color='red'>软换行</font>时，对单词进行打断的策略。</p><p><strong>可选值：</strong></p><ol><li><code>normal</code> ，👈 默认值，每个浏览器有自己默认的软换行策略，比如：<ul><li>在英文单词内不打断，如果一行末尾不够放下一个单词，则软换行显示。</li><li>空格、连字符用于分割英文单词，可以在这两个字符后软换行。</li><li>可以在任意的中文字符后面软换行。</li></ul></li><li><code>break-all</code>，可以打断任意的单词，即可以在任何字符后面软换行。</li><li><code>keep-all</code>，中日韩文字等同于英文字符，作为单词的一部分，再按<code>normal</code>处理。</li></ol><h3 id="overflow-wrap-word-wrap"><a href="#overflow-wrap-word-wrap" class="headerlink" title="overflow-wrap/word-wrap"></a>overflow-wrap/word-wrap</h3><p>该样式值主要针对超长单词进行软换行控制。</p><p><strong>overflow-wrap</strong>是CSS标准样式名，而<strong>word-wrap</strong>是其非标准别名，二者是同一样式，但尽量用标准的名字。</p><p><strong>可选值：</strong></p><ol><li><code>normal</code>，超长单词会溢出父元素。</li><li><code>break-word</code>，会对超长单词进行折断换行。</li></ol><h2 id="background相关"><a href="#background相关" class="headerlink" title="background相关"></a>background相关</h2><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h3><p><strong>作用：</strong>设置背景色</p><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><p><strong>作用1：</strong>设置背景图片的链接。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/static/img.png&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>当背景图片大小和背景图片布局范围一样大时，则图片正常显示。</li><li>当背景图片尺寸 ＞ 背景图片布局范围时，则有部分无法正常显示。</li><li>当背景图片尺寸 ＜ 背景图片布局范围时，则图片根据<code>background-repeat</code>的规则判断是否平铺。</li></ol></blockquote><p><strong>作用2：</strong>设置渐变色背景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">linear-gradient</span>(...);<br><span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">repeating-gradient</span>(...);<br><span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">radial-gradient</span>(...);<br><span class="hljs-selector-tag">background-image</span>: <span class="hljs-selector-tag">repeating-radial-gradient</span>(...);<br></code></pre></td></tr></table></figure><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h3><p><strong>作用：</strong>设置背景图片是否平铺以及平铺方向</p><p><strong>可选值：</strong></p><ol><li><code>repeat</code> ，👈 默认值，沿着x、y两个方向平铺</li><li><code>repeat-x</code>，只沿着x方向平铺</li><li><code>repeat-y</code>，只沿着y方向平铺</li><li><code>no-repeat</code>，不平铺</li></ol><h3 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h3><p><strong>作用：</strong>设置背景图片位置偏移原点、九宫格定位参考范围、百分比尺寸的参考尺寸。</p><table><thead><tr><th>可选值</th><th>background-position定位原点</th><th>background-position九宫格定位参考范围</th><th>background-size百分比参考尺寸</th></tr></thead><tbody><tr><td><code>border-box</code></td><td>border外侧左上角</td><td>border+padding+content</td><td>border+padding+content</td></tr><tr><td><code>padding-box </code></td><td>padding外侧左上角</td><td>padding+content</td><td>padding+content</td></tr><tr><td><code>content-box </code></td><td>内容区左上角</td><td>content</td><td>content</td></tr></tbody></table><blockquote><p>默认值是<code>padding-box</code>。</p></blockquote><h3 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h3><p><strong>作用：</strong>用于裁剪背景色和背景图片的可见区域。</p><p><strong>可选值：</strong></p><ol><li><code>padding-box</code>，👈 默认值</li><li><code>border-box</code></li><li><code>content-box</code></li></ol><h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><p><strong>作用：</strong>用于设置背景图片的位置</p><p><strong>用法：</strong><code>background-position: 水平方向偏移量 垂直方向偏移量;</code></p><p><strong>默认值：</strong><code>background-postion: left top;</code></p><p>一、九宫格定位</p><p>水平方向可选：left、center、right</p><p>垂直方向可选：top、center、right</p><p>如果只写水平方向，则垂直方向默认为center。</p><p>二、偏移量定位</p><p>background-position: 水平偏移量， 垂直偏移量；</p><p>例如：background-position:  -50px, 50px;</p><p>三、百分比定位  （❗ 比较特殊）  </p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background-position</span>: 50%, 50%; 👉 背景图片水平垂直居中，相当于<span class="hljs-selector-tag">center</span>、<span class="hljs-selector-tag">center</span><br><br><span class="hljs-selector-tag">background-position</span>: 0,  0;  👉 <span class="hljs-selector-tag">left</span>，<span class="hljs-selector-tag">top</span><br><br><span class="hljs-selector-tag">background-position</span>: 0, 50%; 👉 <span class="hljs-selector-tag">left</span>, <span class="hljs-selector-tag">center</span><br><br><span class="hljs-selector-tag">background-position</span>: 0, 100%; 👉 <span class="hljs-selector-tag">left</span>, <span class="hljs-selector-tag">bottom</span>;<br></code></pre></td></tr></table></figure><p>原理：⭐</p><p>左偏移量 = （布局宽度 - 图片宽度）× 水平方向百分比</p><p>上偏移量 = （布局宽度 - 图片宽度）× 垂直方向百分比</p><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><p><strong>作用：</strong>设置背景图片大小</p><p><strong>用法：</strong><code>background-size: 水平尺寸大小 垂直尺寸大小;</code></p><p><strong>默认值：</strong><code>background-size: auto auto;</code> 👈 背景图片原始大小</p><blockquote><p>如果只写水平方向尺寸，垂直方向尺寸默认为auto。</p></blockquote><p>一、偏移量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background-size</span>: 100<span class="hljs-selector-tag">px</span> 50<span class="hljs-selector-tag">px</span>;<br><span class="hljs-selector-tag">background-size</span>: <span class="hljs-selector-tag">-50px</span> 50<span class="hljs-selector-tag">px</span>;<br></code></pre></td></tr></table></figure><p>二、百分比</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">background-size</span>: <span class="hljs-selector-tag">auto</span> 100%; 👉 等价于<span class="hljs-selector-tag">background-size</span>: <span class="hljs-selector-tag">cover</span>;<br><span class="hljs-selector-tag">background-size</span>: 100% <span class="hljs-selector-tag">auto</span>; 👉 等价于<span class="hljs-selector-tag">background-size</span>: <span class="hljs-selector-tag">contain</span>;<br></code></pre></td></tr></table></figure><blockquote><p>根据<code>background-origin</code>的取值，判断百分比参照尺寸。</p></blockquote><h3 id="background-简写属性"><a href="#background-简写属性" class="headerlink" title="background 简写属性"></a>background 简写属性</h3><p>background: <u>color</u>  <u>image</u>  <u>repeat</u>  <u>position/size</u>    <u>origin</u>   <u>clip</u><br>                         ①      ②          ③             ④                ⑤       ⑥</p><ul><li>①~④与⑤、⑥之间没有书写顺序要求。</li><li>①~⑥都可写可不写，如果不写则采用默认值。</li><li>④中，position必须写在size前面，用“/”隔开，要写size必须先写position。</li><li>⑤origin必须写在⑥clip前面，用“空格”隔开，如果clip和origin的值不相同，则要写clip必须先写origin，如果clip和origin的值相同，则⑤和⑥可以只写一个。</li></ul><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h3><p>可选值：</p><ol><li><p><code>scroll</code> 👈 默认值</p><p>元素的背景图片会随着该元素在页面中的滚动而滚动，但是不会随着自身滚动条的滚动而滚动。</p></li><li><p><code>local</code></p><p>元素的背景图片会随着自身滚动条的滚动而滚动，但是不会随着该元素在页面中的滚动而滚动。</p><p>另一个区别于scroll的点是：<code>background-postion</code>的<font color='red'>百分比定位的参照尺寸发生了变化</font>，<code>background-attachment: local;</code>时的百分比参照尺寸是元素<font color='red'>background-origin规定的尺寸 + 可滚动尺寸</font>。</p></li><li><p><code>fixed</code></p><p>元素的背景图片相对于页面布局视口进行定位，而与元素的位置无关。即<code>background-position</code>此时设定的偏移量是相对于视口而言的。</p><p><font color='red'>但是该元素的背景图片只能在该元素范围内显示，如果背景图片最终的布局位置不被该元素所占有，则背景图片不显示在页面上。（部分或全部）</font></p></li></ol><h2 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h2><p>引入弹性盒子的目的：提供一种更加有效的方式来对一个容器内的子元素进行排列、对齐和分配空白空间。</p><p>弹性盒子组成：弹性容器 + 弹性元素</p><h3 id="display-flex-inline-flex"><a href="#display-flex-inline-flex" class="headerlink" title="display: flex/inline-flex;"></a>display: flex/inline-flex;</h3><ul><li>元素通过<code>display: flex;</code>成为块级弹性容器。</li><li>元素通过<code>display: inline-flex;</code>成为行内弹性容器。</li><li>弹性元素是指弹性容器的所有直接子元素。（既包括块元素，也包括行内元素，但不包括脱离文档流的子元素）</li><li>一个元素既可以是弹性元素，也同时可以是弹性容器。弹性元素默认情况下会创建一个BFC。</li></ul><h3 id="弹性容器"><a href="#弹性容器" class="headerlink" title="弹性容器"></a>弹性容器</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><strong>作用：</strong>指定弹性容器中弹性元素的排列方式、伸缩方向，该方向为弹性盒子的主轴方向，另一个方向（垂直/水平）成为辅轴方向。</p><p><strong>可选值：</strong></p><ol><li><code>row</code> 👈 默认值</li><li><code>row-reverse </code>  👈 S型软换行</li><li><code>column</code></li><li><code>column-reverse</code></li></ol><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>设置主轴方向剩余尺寸不够存放下一个弹性子元素时是否自动换行。</p><p><strong>可选值：</strong></p><ol><li><code>nowrap</code> 👈 默认值，不换行</li><li><code>wrap</code> 换行</li><li><code>wrap-reverse</code> S型换行</li></ol><blockquote><p>如果指定换行，则flex-shrink将不再起作用。</p></blockquote><h4 id="flex-flow-简写属性"><a href="#flex-flow-简写属性" class="headerlink" title="flex-flow 简写属性"></a>flex-flow 简写属性</h4><p><strong>作用：</strong>flex-direction和flex-wrap的简写属性</p><p><strong>默认值：</strong><code>flex-flow: row nowrap;</code></p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><strong>作用：</strong>设置主轴方向上空白的分配方式。</p><p><strong>可选值：</strong></p><ol><li><code>flex-start</code>，👈默认值，主轴方向上，元素尽可能有序靠前，空白在所有元素之后。</li><li><code>flex-end</code>，主轴方向上，元素尽可能按序靠后布局，空白在所有元素之前。</li><li><code>center</code>，主轴方向上，所有元素居中，空白平均分布到所有元素两侧。</li><li><code>space-around</code>，主轴方向上，空白平均分配到每个元素两侧，元素与元素之间距离是元素与父容器之间距离的两倍。</li><li><code>space-between</code>，主轴方向上，空白平均分配到元素与元素之间，元素与父容器之间无间隙。</li><li><code>space-evently</code>，主轴方向上，空白平均分配到元素与元素、元素与父容器之间，元素与元素之间距离等于元素与父容器之间距离。</li></ol><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><strong>作用：</strong>如果辅轴方向上有空白，该属性用于设置在允许弹性元素换行时，辅轴方向上空白的分配方式。</p><p>⭐<font color='red'>该样式起作用的前提是</font>：<code>flex-wrap</code>的属性值不为<code>nowrap</code>。</p><p><strong>可选值：</strong></p><blockquote><p>假设flex-direction的值为: row，flex-wrap的值不是nowrap时，则一行弹性元素所占的高度称为行框。</p><p>行框的高度由一行弹性子元素中高度最高的弹性子元素为准。</p></blockquote><ol><li><code>normal </code>，👈 默认值，辅轴方向上的空白平均分配到每个行框的下方。</li><li><code>flex-start</code>，辅轴方向上，所有行框尽量靠上，空白分配到所有行框的下方。</li><li><code>flex-end</code>，辅轴方向上，所有行框尽量靠下，空白分配到所有行框的上方。</li><li><code>center</code>，辅轴方向上，所有行框居中，空白平均分配到所有行框的上方和下方。</li><li><code>space-around</code>，辅轴方向上，空白平均分配到所有行框两侧，行框与行框之间的空白距离是行框与父容器之间距离的两倍。</li><li><code>space-between</code>，辅轴方向上，空白平均分配到所有行框之间，行框与父容器之间没有空白。</li><li><code>space-evently</code>，辅轴方向上，空白平均分配到所有行框以及行框和父容器之间，行框与行框之间的空白距离等于行框与父容器之间的距离。</li></ol><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><strong>作用：</strong>设置同一行框或同一列框上的弹性元素对齐方式。</p><p><strong>可选值：</strong></p><ol><li><code>stretch</code>，👈 默认值，将辅轴方向上尺寸样式为<code>auto</code>的元素进行拉伸，以<code>flex-direction: row;</code>为例<ul><li>如果不配合<code>flex-wrap: wrap;</code>和<code>align-content</code>样式使用，则<code>height: auto;</code>的弹性子元素高度<font color='red'>会拉满整个行框高度+空白区域。</font></li><li>如果配合<code>flex-wrap: wrap;</code>以及<code>align-content:normal;</code>使用，则<code>height: auto;</code>的弹性子元素高<font color='red'>度会拉满整个行框高度+空白区域。</font></li><li>如果配合<code>flex-wrap: wrap;</code>以及除了<code>normal</code>以外的其他<code>align-content</code>的属性值使用时，则<code>height: auto;</code>的弹性子元素高度<font color='red'>只会拉满整个行框高度</font>。</li></ul></li><li><code>flex-start</code>，同一行框内的弹性子元素上方对齐。</li><li><code>flex-end</code>，同一行框内的弹性子元素底端对齐。</li><li><code>center</code>，同一行框内的弹性子元素居中对齐。</li><li><code>baseline</code>，同一行框内的弹性子元素与父容器的本行基线对齐。</li></ol><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><strong>作用</strong>：为弹性盒子中所有的弹性子元素设置相同的flex-grow。</p><p><strong>默认值：</strong><code>flex-grow: 0;</code></p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>作用：</strong>为弹性盒子中所有的弹性子元素设置相同的flex-shrink。</p><p><strong>默认值：</strong><code>flex-shrink: 1;</code></p><blockquote><p>注意，当弹性容器的<code>flex-wrap</code>样式值不为<code>nowrap</code>时，所有的<code>flex-shrink</code>将不起作用。</p></blockquote><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><strong>作用：</strong>为弹性盒子中所有的弹性子元素设置相同的flex-basis。</p><p><strong>默认值：</strong><code>flex-basis: auto;</code></p><h3 id="flex-简写属性"><a href="#flex-简写属性" class="headerlink" title="flex 简写属性"></a>flex 简写属性</h3><p><strong>作用：</strong>为弹性盒子中的所有子元素设置相同的flex-grow、flex-shrink和flex-basis。</p><p><strong>默认值：</strong><code>flex: 0 1 auto;</code></p><h3 id="弹性元素"><a href="#弹性元素" class="headerlink" title="弹性元素"></a>弹性元素</h3><h4 id="flex-grow-1"><a href="#flex-grow-1" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><strong>作用：</strong>弹性元素在主轴方向上的增长系数。弹性元素所在行框所有弹性元素的原始尺寸之和<font color='red'>小于</font>父容器内容区尺寸时，拉伸弹性元素。</p><p><strong>默认值：</strong><code>flex-grow: 0;</code></p><p><strong>每个弹性元素主轴方向拉伸量的计算方法：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">增长量 <span class="hljs-operator">=</span> 该元素所在的行框空白量 <span class="hljs-operator">*</span> <span class="hljs-variable">flex</span><span class="hljs-operator">-</span><span class="hljs-variable">grow</span> <span class="hljs-operator">/</span> 该行框内所有弹性元素的<span class="hljs-variable">flex</span><span class="hljs-operator">-</span><span class="hljs-variable">grow</span>之和<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，即使一个弹性元素在主轴方向上的原始尺寸等于零，在设置flex-grow大于0时，它也会分配到空白。</p></blockquote><h4 id="flex-shrink-1"><a href="#flex-shrink-1" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><strong>作用：</strong>弹性元素在主轴方向上的压缩系数。弹性元素所在行框所有弹性元素的原始尺寸之和<font color='red'>大于</font>父容器内容区尺寸时，压缩弹性元素。</p><p><strong>默认值：</strong><code>flex-shrink: 0;</code></p><p><strong>每个弹性元素主轴方向压缩量的计算方法：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">压缩量<span class="hljs-operator">=</span>该元素所在行框的总溢出量<span class="hljs-operator">*</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">(</span><span class="hljs-variable">flex</span><span class="hljs-operator">-</span><span class="hljs-variable">shrink</span><span class="hljs-operator">*</span>元素原始宽度<span class="hljs-punctuation">)</span><span class="hljs-operator">/</span>行框内所有元素的 <span class="hljs-variable">flex</span><span class="hljs-operator">-</span><span class="hljs-variable">shrink</span><span class="hljs-operator">*</span>元素宽度 之和<span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，即使一个弹性元素在主轴方向上的原始尺寸等于零，那么它就不会被压缩。</p></blockquote><h4 id="flex-basis-1"><a href="#flex-basis-1" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><strong>作用：</strong>设置元素在主轴上的原始尺寸。</p><p><strong>默认值：</strong><code>flex-basis: auto;</code></p><p><strong>和元素width的关系</strong></p><ol><li>弹性元素的<code>flex-basis</code>为<code>auto</code>时，弹性元素的原始宽度<font color='red'>由width决定</font>。</li><li>弹性元素的<code>flex-basis</code>为大于0的值时，弹性元素的原始宽度由<code>flex-basis</code>决定，<font color='red'>无视width。</font></li><li>弹性元素的<code>flex-basis</code>为0时，<font color='red'>弹性元素的原始宽度默认由内容撑开</font>，<font color='red'>无视width。</font></li></ol><h4 id="flex-简写属性-1"><a href="#flex-简写属性-1" class="headerlink" title="flex 简写属性"></a>flex 简写属性</h4><p>可以使用一个，两个或三个值来指定 <code>flex</code>属性。</p><p><strong>单值语法</strong>: 值必须为以下其中之一</p><ul><li>一个<font color='red'>无单位数</font>：它会被当作<code>flex:&lt;number&gt; 1 0;</code> <code>&lt;flex-shrink&gt;</code>的值被假定为1，然后<code>&lt;flex-basis&gt;</code> 的值被假定为<code>0</code>。❗ </li><li>一个<font color='red'>有效的宽度</font><code>width</code>值：它会被当作 <code>&lt;flex-basis&gt;的值。</code></li><li>关键字<code>none</code>，<code>auto</code>或<code>initial</code>.</li></ul><p><strong>双值语法</strong>: 第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。第二个值必须为以下之一：</p><ul><li>一个无单位数：它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li><li>一个有效的宽度值: 它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li></ul><p><strong>三值语法:</strong></p><ul><li>第一个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-grow&gt;</code> 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作 <code>&lt;flex-shrink&gt;</code> 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>&lt;flex-basis&gt;</code> 的值。</li></ul><blockquote><p>建议：三个都写。⭐</p></blockquote><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>弹性盒子内所有的百分比参考尺寸都是父容器该方向上内容区的尺寸。❓</li></ol><h3 id="使用弹性盒子将子元素水平垂直居中"><a href="#使用弹性盒子将子元素水平垂直居中" class="headerlink" title="使用弹性盒子将子元素水平垂直居中"></a>使用弹性盒子将子元素水平垂直居中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html">👇 基本结构<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-id">#dad</span> &#123;</span><br>        width: 1000px;<br>        height: 1000px;<br>        display: flex;<br>    &#125;<br><span class="css">    <span class="hljs-selector-id">#son</span> &#123;</span><br>        width: 100px;<br>        height: 100px;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dad&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*方法1*/</span><br><span class="hljs-selector-id">#son</span> &#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><br><span class="hljs-comment">/*方法2*/</span><br><span class="hljs-selector-id">#dad</span> &#123;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br><br><span class="hljs-comment">/*方法3*/</span><br><span class="hljs-selector-id">#dad</span> &#123;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">flex-wrap</span>: wrap;<br>    <span class="hljs-attribute">align-content</span>: center;<br>&#125;<br><br><span class="hljs-comment">/*方法4*/</span><br><span class="hljs-selector-id">#dad</span> &#123;<br>    <span class="hljs-attribute">justify-content</span>: center;<br>    <span class="hljs-attribute">flex-wrap</span>: wrap;<br>    <span class="hljs-attribute">align-content</span>: space-around;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用弹性盒子将子元素水平垂直居中对齐至少有四种方法，还可以将这四种进行组合，衍生出更多方法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js面试题相关内容</title>
    <link href="/2021/07/21/JavaScript/mianshiti/"/>
    <url>/2021/07/21/JavaScript/mianshiti/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript操作符"><a href="#JavaScript操作符" class="headerlink" title="JavaScript操作符"></a>JavaScript操作符</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h3 id="指数操作符-ES7"><a href="#指数操作符-ES7" class="headerlink" title="指数操作符 ES7"></a>指数操作符 ES7</h3><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>理解： 正常运行模式（混杂模式） → <code>&quot;use strict;&quot;</code>严格模式</p><p>目的 / 作用：</p><ol><li>消除JavaScript语法的不严谨、不合理的地方，减少一些怪异行为。</li><li>消除JavaScript语法的不安全隐患，为代码的运行保驾护航。</li></ol><p>语法和行为的改变：</p><ol><li>变量在使用之前必须声明，且在一个作用域（词法环境）内只能声明一次。</li><li>禁止开发人员定义的函数在运行时，其<code>this</code>指向全局对象。在<code>this</code>丢失时，值为<code>undefined</code>。</li><li>为<code>eval</code>函数的运行代码创建局部作用域，<code>eval</code>函数内声明的变量不可以在外界访问。</li><li>对象不能有重名属性。</li><li>….</li></ol><h2 id="作用域、执行上下文、执行栈、闭包"><a href="#作用域、执行上下文、执行栈、闭包" class="headerlink" title="作用域、执行上下文、执行栈、闭包"></a>作用域、执行上下文、执行栈、闭包</h2><h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3><p><font color='red'>词法环境类似于作用域的概念，JavaScript采用的是词法作用域。</font></p><blockquote><p><strong><code>ECMAScript2015</code>规范中对词法环境的描述如下</strong>：</p><p><strong>原文：</strong></p><p>A <em>Lexical Environment</em> is a specification type used to define the association of <em>Identifiers</em> to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an <a href="https://262.ecma-international.org/6.0/#sec-environment-records">Environment Record</a> and a possibly null reference to an <em>outer</em> Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a <em>FunctionDeclaration</em>, a <em>BlockStatement</em>, or a <em>Catch</em> clause of a <em>TryStatement</em> and a new Lexical Environment is created each time such code is evaluated.</p><p><strong>分句翻译：</strong></p><ul><li>词法环境是用来定义 基于词法嵌套结构的<code>ECMAScript</code>代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。</li><li>一个词法环境由环境记录（<code>Environment Record</code>）和一个可能为<code>null</code>的对外部词法环境的引用（<code>outer</code>）组成。</li><li>一般来说，词法环境都与特定的<code>ECMAScript</code>代码语法结构相关联，例如<strong>函数声明</strong>、代码块（for+let/with语句…）、<code>TryCatch</code>中的<code>Catch</code>从句，并且每次解释执行这类代码结构时都会创建新的词法环境。</li></ul><p><strong>注意：</strong></p><p>函数声明（定义）时就发生了词法环境的创建，区别于函数执行上下文中的词法环境组件和变量环境组件。</p></blockquote><h4 id="词法环境的分类"><a href="#词法环境的分类" class="headerlink" title="词法环境的分类"></a>词法环境的分类</h4><p>👇 <font color='cornflowerblue'>这是自己归纳的，不是官方说法</font></p><p><strong>词法环境</strong>是一个抽象类型，根据<font color='red'>创建时机</font>的不同，可分为多种具体类型：</p><ul><li><p><strong>全局词法环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。在一个JavaScript程序中只会有一个全局词法环境实例，在全局的<code>ECMAScript</code>代码执行之前就被创建。。</p><blockquote><p>全局环境中的环境记录器(Environment Record)由一个声明环境记录器和一个对象环境记录器构成。</p><p>它的声明环境记录器部分保存着对全局的变量与自定义的函数绑定。</p><p>它的对象环境记录器部分被<font color='red'>绑定到全局对象</font>（在浏览器环境中window对象），因此它拥有对内建的 Object/Array/Math等标识的绑定。</p><p>全局环境的外部环境引用是 <strong>null</strong>。</p></blockquote></li><li><p><strong>函数词法环境</strong>是在函数声明（定义）时实例化的词法环境类型。</p><blockquote><p>函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局词法环境，或者任何包含此内部函数的外部函数的外部词法环境。</p></blockquote></li><li><p><strong>模块词法环境</strong>是在一个<code>ES6</code>模块中创建的词法环境，包含对一些<code>import</code>的变量的绑定，其外层词法环境是全局词法环境。</p></li><li><p><strong>Block词法环境</strong>，例如执行<code>for + let</code>循环的代码块时，或是执行<code>with</code>代码块时，就会实例化一个Block类型的词法环境。</p><blockquote><p>注意，<code>for + var</code>循环的代码块执行时不会创建一个新的词法环境，<code>for + var</code>结构会为这段代码所属的词法环境添加一个新的绑定。</p></blockquote></li><li><p><strong>Catch词法环境</strong>，执行<code>try catch</code>结构中的<code>catch</code>从句时，会实例化一个此类型的词法环境。</p><blockquote><p><code>catch(e)&#123;...&#125;</code>会创建一个新的词法环境，词法环境中有标识符为<code>e</code>的绑定，同时也会有对catch结构代码块内声明的变量的绑定。</p></blockquote></li></ul><h4 id="词法环境的构成"><a href="#词法环境的构成" class="headerlink" title="词法环境的构成"></a>词法环境的构成</h4><p>在词法环境的内部有两个组件：</p><p>(1) 环境记录器 ：<code>Environment Record</code>。</p><blockquote><p>可以理解为相应代码块内的所有变量声明、函数声明（代码块若为函数还包括其形参）都储存于此<br>对应网上博客中疯传的变量对象VO和活动对象AO。</p></blockquote><p> (2) 对外部环境的引用 ：<code>outer</code>指针。</p><h4 id="环境记录器（environment-records）"><a href="#环境记录器（environment-records）" class="headerlink" title="环境记录器（environment records）"></a>环境记录器（environment records）</h4><p>简单来说<strong>环境记录器</strong>是一种持有<strong>标识符—变量映射</strong>的结构。这里的标识符指的是变量/函数的名字，而变量是对基本类型数据、一般对象、函数类型对象的原始数据的引用。</p><p><code>ES 2015规范</code>中提到：环境记录器是一个抽象类，它有两个基本的子类（声明式环境记录器和对象式环境记录器）和一个特殊的子类（全局环境记录器）</p><p><strong>环境记录器的子类：</strong></p><ol><li><p>声明式环境记录器 <code>declarative environment records</code>。</p><blockquote><p>声明式环境记录是用来定义那些直接将标识符与语言值绑定的ES语法元素，例如var，const，let，class，module，import以及函数声明等。</p><p>声明式环境记录有函数环境记录（Function Environment Record）和模块环境记录（Module Environment Record）两种特殊类型。</p></blockquote></li><li><p>对象式环境记录器 <code>object environment records</code>。</p><blockquote><p>每个对象式环境记录都与一个对象相关联，这个对象叫做对象式环境记录的<code>binding object</code>。可以理解为对象式环境记录就是基于这个<code>binding object</code>，以对象属性的形式进行标识符绑定，标识符与<code>binding object</code>的属性名一一对应。</p><p>是对象就可以动态添加或者删除属性，所以对象环境记录不存在不可变绑定。</p><p>对象式环境记录用来定义那些将标识符与某些对象属性相绑定的ES语法元素，例如with语句、全局var声明和全局函数声明。</p></blockquote></li><li><p>全局环境记录器 <code>global environment records</code>。</p><blockquote><ul><li><p>全局环境记录逻辑上来说是单个记录，但是实际上可以看作是对一个<code>对象式环境记录</code>组件和一个<code>声明式环境记录</code>组件的封装。</p></li><li><p>之前说过每个<code>对象式环境记录</code>都有一个<code>binding object</code>，全局环境记录的<code>对象式环境记录</code>的<code>binding object</code>就是全局对象，在浏览器内，全局的<code>this</code>及<code>window</code>绑定都指向全局对象。全局环境记录的<code>对象式环境记录</code>组件，绑定了所有内置全局属性、全局的函数声明以及全局的<code>var</code>声明。所以这些绑定我们可以通过<code>window.xx</code>或<code>this.xx</code>获取到。</p></li><li><p>全局代码的其他声明（如<strong>let、const、class</strong>等）则绑定在<code>声明式环境记录</code>组件内，由于<code>声明式环境记录</code>组件并不是基于简单的对象形式来实现绑定，所以这些声明我们并<strong>不能通过全局对象的属性来访问</strong>。</p></li></ul></blockquote></li></ol><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts">GlobalExectionContext = &#123;<br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;null&gt;</span><br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;Global or outer function environment reference&gt;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="外部词法环境的引用（outer）"><a href="#外部词法环境的引用（outer）" class="headerlink" title="外部词法环境的引用（outer）"></a>外部词法环境的引用（outer）</h4><p>首先要说明两点：</p><ol><li>全局环境的外部词法环境引用为<code>null</code>。</li><li>一个词法环境可以作为多个词法环境的外部环境。例如全局声明了多个函数，则这些函数词法环境的外部词法环境引用都指向全局环境。</li></ol><p>外部词法环境的引用将一个词法环境和其外部词法环境链接起来，外部词法环境又拥有对其自身的外部词法环境的引用。这样就形成一个链式结构，这里我们称其为<strong>环境链</strong>（即ES6之前的作用域链），全局环境是这条链的顶端。</p><p>环境链的存在是为了标识符的解析，通俗的说就是查找变量。首先在当前环境查找变量，找不到就去外部环境找，还找不到就去外部环境的外部环境找，以此类推，直到找到，或者到环境链顶端（全局环境）还未找到则抛出<code>ReferenceError</code>。</p><p><strong>标识符解析</strong>：在环境链中解析变量（绑定）的过程，</p><p>我们使用伪代码来模拟一下标识符解析的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">ResolveBinding(name[, LexicalEnvironment]) &#123;<br>    &#x2F;&#x2F; 如果传入词法环境为null(即一直解析到全局环境还未找到变量)，则抛出ReferenceError<br>    if (LexicalEnvironment &#x3D;&#x3D;&#x3D; null) &#123;<br>        throw ReferenceError(&#96;$&#123;name&#125; is not defined&#96;)<br>    &#125;<br><br>    &#x2F;&#x2F; 首次查找，将当前词法环境设置为解析环境<br>    if (typeof LexicalEnvironment &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;<br>        LexicalEnvironment &#x3D; currentLexicalEnvironment<br>    &#125;<br><br>    &#x2F;&#x2F; 检查环境的环境记录中是否有此绑定<br><br>    let isExist &#x3D; LexicalEnvironment.EnviromentRecord.HasBinding(name)<br><br>    &#x2F;&#x2F; 如果有则返回绑定值，没有则去外层环境查找<br><br>    if （isExist） &#123;<br>        return LexicalEnvironment.EnviromentRecord[name]<br>    &#125; else &#123;<br>        return ResolveBinding(name, LexicalEnvironment.outer)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>执行上下文是一个抽象概念，可以理解为评估和执行JavaScript代码的环境，每段JavaScript代码都运行在某一个执行上下文环境中。执行全局代码、函数调用最开始都会创建一个执行上下文。</p><p>执行上下文有以下组件：</p><ol><li><code>Code Evaluation State</code></li><li><code>Function</code></li><li><code>Realm</code></li><li><code>LexicalEnvironment</code></li><li><code>VariableEnvironment</code></li></ol><h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><ol><li><p><strong>全局执行上下文。</strong>这是默认或者说是基础的上下文，任何不在函数内部的代码都在全局上下文中。全局执行上下文创建时会执行一些操作，其中包括：</p><ul><li>创建一个全局对象（浏览器环境下为window，node环境下为global）。</li><li>并且设置<code>this</code>指向这个全局对象。</li></ul><blockquote><p>（不论何种JavaScript运行环境）一个程序中，只会有一个全局执行上下文。</p></blockquote></li><li><p><strong>函数执行上下文。</strong>每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，在函数被调用时创建的。</p></li><li><p><strong>Eval函数执行上下文。</strong>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</p></li></ol><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p><strong>执行栈，</strong>也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来<strong>存储和管理</strong>代码运行时创建的<strong>所有执行上下文</strong>。</p><ul><li>当一个JavaScript程序运行时，JavaScript引擎第一时间创建一个<font color='red'>全局执行上下文</font>并将其<font color='red'>压入栈底</font>。</li><li>每当一个<font color='red'>函数被调用</font>时，该函数的执行上下文<font color='red'>压栈</font>，函数<font color='red'>执行完毕时</font>执行上下文<font color='red'>出栈</font>。</li><li>一旦<font color='red'>所有代码执行完毕</font>，JavaScript 引擎从当前栈中移除全局执行上下文（浏览器环境下，页面如果不关闭，全局执行上下文会永远保存）。</li></ul><h4 id="执行上下文的创建阶段"><a href="#执行上下文的创建阶段" class="headerlink" title="执行上下文的创建阶段"></a>执行上下文的创建阶段</h4><p>全局代码或函数执行时，JavaScript引擎会创建相应的执行上下文，在执行上下文的创建阶段会发生三件事：</p><ol><li><strong>this绑定</strong></li><li>创建**词法环境组件 **<code>LexicalEnvironment</code></li><li> 创建<strong>变量环境组件</strong><code>VaribleEnviroment</code></li></ol><p>所以执行上下文在概念上表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">ExecutionContext &#x3D; &#123;<br>  ThisBinding &#x3D; &lt;this value&gt;,<br>  LexicalEnvironment &#x3D; &#123; ... &#125;,<br>  VariableEnvironment &#x3D; &#123; ... &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="This-绑定"><a href="#This-绑定" class="headerlink" title="This 绑定"></a>This 绑定</h4><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p><p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123;<br>  baz: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>foo.baz();   <span class="hljs-comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span><br>             <span class="hljs-comment">// 对象 &#x27;foo&#x27; 调用</span><br><span class="hljs-keyword">let</span> bar = foo.baz;<br><br>bar();       <span class="hljs-comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span><br>             <span class="hljs-comment">// 没有指定引用对象</span><br></code></pre></td></tr></table></figure><h4 id="词法环境组件和变量环境组件"><a href="#词法环境组件和变量环境组件" class="headerlink" title="词法环境组件和变量环境组件"></a>词法环境组件和变量环境组件</h4><p><strong>词法环境组件和变量环境组件的区别：</strong></p><ol><li><p><strong>作用上的区别：</strong></p><p>前者被用来存储函数声明和变量（<code>function</code>、<code>let</code> 、 <code>const</code>、<code>class</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p></li><li><p><strong>结构上的区别：</strong></p><ul><li>前者是一个类似于<strong>小型栈</strong>的结构（相比于执行栈，是小型的），在执行上下文的创建阶段，里面只有一个词法环境对象，而在执行上下文的执行阶段，这个栈中可能存储多个词法环境对象（如遇到代码块、catch从句、with代码块时会添加新的词法环境对象进去）。</li><li>而在一个执行上下文中，后者只保存一个词法环境对象，即保存<code>var</code>声明的变量绑定（在函数的可执行代码中，在任何地方用<code>var</code>声明的变量都会在执行上下文预处理阶段保存到变量词法组件中）。</li></ul></li></ol><p><a href="https://blog.csdn.net/feral_coder/article/details/106447013">参考文章链接 https://blog.csdn.net/feral_coder/article/details/106447013</a></p><h4 id="执行上下文的执行阶段"><a href="#执行上下文的执行阶段" class="headerlink" title="执行上下文的执行阶段"></a>执行上下文的执行阶段</h4><p>在此阶段，伴随着代码的执行，JavaScript引擎不断更新执行上下文中的内容，直到代码执行完毕。</p><p>执行过程中，如果遇到局部代码块（包括with、for、if）时，JS引擎会创建新的词法环境，并将其添加到当前执行上下文的词法环境组件的栈顶，当代码块执行完毕，词法环境出栈。</p><p>当前执行上下文中调用某个函数，则当前执行上下文会被挂起，JS引擎会为函数调用创建新的执行上下文，这个新的执行上下文压入执行栈并成为新的当前执行上下文。</p><p>当前执行上下文中的所有代码执行完毕，JS引擎会将当前执行上下文出栈，并继续执行栈顶的执行上下文代码。</p><h3 id="代码预处理"><a href="#代码预处理" class="headerlink" title="代码预处理"></a>代码预处理</h3><p><font color='red'>代码预处理的表现为变量声明提升。但需要注意的是，代码预处理是以词法环境为单位的，而不是以执行上下文为单位的。一个函数拥有一个函数级别的词法环境，一个代码块同样拥有一个块级别的词法环境。</font></p><p>可能你已经注意到函数执行上下文创建时，<code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，因此处于未初始化状态。而 <code>var</code> 定义的变量被设成了 <code>undefined</code>，且声明的函数得到初始化，函数变量指向具体的内存地址。这就是所谓的<strong>变量声明提升</strong>。</p><blockquote><p>虽然通过函数声明定义的函数会一开就完全存储在环境中，但是通过函数表达式定义的函数变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。尽管由<code>let</code>和<code>const</code>声明的变量没有初始化值，且存在暂时性死区，但是JavaScript引擎确实对这些变量声明做了预处理。</p></blockquote><p><strong>函数中代码执行的步骤：</strong></p><ul><li><p>在函数执行之前，先扫描出<font color='red'>函数层级</font>的<code>let、const</code>声明的变量以及所有级别的<code>var</code>声明的变量（包括函数局部代码块中的<code>var</code>声明），对他们进行预处理。</p></li><li><p>然后再扫描当前函数代码中全局的函数声明（非严格模式下也会扫描函数局部代码块中的函数声明），对函数声明进行预处理。</p></li><li><p>当函数声明和变量声明发生命名冲突时，对函数声明的预处理会覆盖对变量声明的预处理。</p></li><li><p>执行函数代码，遇到新的<font color='red'>局部代码块</font>时，进行新一轮预处理操作。</p></li><li><p>函数所有代码执行完毕。</p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包这个概念挖的越深就越难理解，涉及到函数、执行上下文、词法环境（作用域）、垃圾回收等一系列概念。</p><p>而且当前人们对闭包的定义各不相同。</p><h4 id="MDN对闭包的解释"><a href="#MDN对闭包的解释" class="headerlink" title="MDN对闭包的解释"></a><code>MDN</code>对闭包的解释</h4><blockquote><p>Consider the following code example:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeFunc</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Mozilla&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123;<br> alert(name);<br>&#125;<br><span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">var</span> myFunc = makeFunc();<br>myFunc();<br></code></pre></td></tr></table></figure><p>Running this code has exactly the same effect as the previous example of the <code>init()</code> function above. What’s different (and interesting) is that the <code>displayName()</code> inner function is returned from the outer function <em>before being executed</em>.</p><p>At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function’s execution. Once <code>makeFunc()</code> finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.</p><p>The reason is that functions in JavaScript form closures. <strong>A <em>closure</em> is the combination of a function and the lexical environment within which that function was declared.</strong> This environment consists of any local variables that were in-scope at the time the closure was created. In this case, <code>myFunc</code> is a reference to the instance of the function <code>displayName</code> that is created when <code>makeFunc</code> is run. <strong>The instance of <code>displayName</code> maintains a reference to its lexical environment, within which the variable <code>name</code> exists.</strong> For this reason, when <code>myFunc</code> is invoked, the variable <code>name</code> remains available for use, and “Mozilla” is passed to <code>alert</code>.</p></blockquote><p><strong><em>闭包</em>是一个函数和声明该函数的词法环境的组合。</strong></p><p><font color='cornflowerblue'>我觉得这个词法环境👆更像是一个删减版的词法环境，但能够确定的是一个函数保存着对声明该函数时的词法环境的引用。</font></p><h4 id="Chrome对闭包的定义"><a href="#Chrome对闭包的定义" class="headerlink" title="Chrome对闭包的定义"></a>Chrome对闭包的定义</h4><p>Chrome浏览器似乎已经成为了前端的标准，那么在Chrome浏览器中，是如何判定闭包的呢？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">function test() &#123;<br>  var a = 1;<br>  function increase() &#123;<br>    debugger;<br>    var b = 2;<br>    a++;<br>    return a;<br>  &#125;;<br>  increase();<br>&#125;<br>test();<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-f1d0c322e4d505d20d18129ef4f91207_720w.jpg" alt="img"></p><p>我把debugger置于内部函数<code>increase</code>中，调试时我们直接看右侧的高亮部分，可以发现，Scope中存在一个Closure（闭包），Closure的名称是外部函数<code>test</code>的函数名，闭包中的变量<code>a</code>是在函数<code>test</code>中定义的，而变量<code>b</code>是作为本地变量处于<code>Local</code>中。</p><p>PS: 关于本地变量，可以参见**<a href="https://link.zhihu.com/?target=http://es5.github.io/%23x10.4.3">localEnv</a>**。</p><p>假设我在外部函数<code>test</code>中再定义一个变量<code>c</code>，但是在内部函数<code>increase</code>中不引用它，会怎么样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>; <span class="hljs-comment">// c不在闭包中</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increase</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">debugger</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    a++;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;;<br>  increase();<br>&#125;<br>test();<br></code></pre></td></tr></table></figure><p>经验证，内部函数<code>increase</code>执行时，变量<code>c</code>没有在闭包中。</p><p>我们还可以验证，如果内部函数<code>increase</code>不引用任何外部函数<code>test</code>中的变量，就不会产生闭包。</p><p>所以到这里，我们可以下这样一个结论，<strong>闭包产生的必要条件</strong>是：</p><ol><li>存在函数嵌套；</li><li>嵌套的内部函数必须引用在外部函数中定义的变量；</li><li>嵌套的内部函数必须被执行。</li></ol><p><strong>似乎Chrome认为<code>外部函数名+外部函数执行后残留下的词法环境</code>构成闭包。</strong></p><h4 id="我对闭包形成机制的理解"><a href="#我对闭包形成机制的理解" class="headerlink" title="我对闭包形成机制的理解"></a>我对闭包形成机制的理解</h4><p>一个函数执行上下文在执行完后（退出执行栈），在它执行过程中声明的某些变量可以以闭包的形式被保留，而不会被垃圾回收器回收。原因是外层执行上下文中仍然间接地（通过内层函数）保持对该变量的引用。闭包像是使得内层函数的词法环境链上多了一个特殊节点。</p><p>👆 <font color='cornflowerblue'>这个跟Chrome的观点类似</font></p><p>由于ES5中没有块级作用域，所以只有函数闭包❓</p><p>ES6中有了块级作用域，会使得闭包有了新的类型？块级闭包❓</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ret;<br>    <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>        ret = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>            <span class="hljs-built_in">console</span>.log(foo);<span class="hljs-comment">// 在此打断点会发现，ret()执行过程中，多了一层Block类型的词法环境</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = foo();<br>fn(); <span class="hljs-comment">// 输出 bar</span><br><br></code></pre></td></tr></table></figure><h4 id="1-说说对闭包的理解？"><a href="#1-说说对闭包的理解？" class="headerlink" title="1. 说说对闭包的理解？"></a>1. 说说对闭包的理解？</h4><p>MDN的解释是闭包是函数与声明该函数的词法环境的组合（函数保存着对声明该函数词法环境的引用）。</p><p>Chrome中查看闭包，发现闭包像是一层残留的词法环境。</p><blockquote><p>但之所以其中的变量值保留了下来而没有被垃圾回收期回收，是因为内层函数有对声明该函数词法环境的引用，同时该内层函数对象被外部执行上下文的词法环境记录器保存。</p></blockquote><h4 id="2-为什么说所有函数都是闭包？"><a href="#2-为什么说所有函数都是闭包？" class="headerlink" title="2.为什么说所有函数都是闭包？"></a>2.为什么说所有函数都是闭包？</h4><p>从定义上来说，闭包不是一种函数，而是函数与声明该函数的词法环境的组合。</p><p>如果非要解释，那就是任何函数创建时，都会在该函数对象上保存对声明该函数词法环境的引用，但这种引用不是引用词法环境的全部内容，而是部分内容，这其中就涉及到垃圾回收策略。</p><h2 id="this、apply、call、bind"><a href="#this、apply、call、bind" class="headerlink" title="this、apply、call、bind"></a>this、apply、call、bind</h2><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><ol><li><p>函数没有显式的宿主时，this指向全局对象（在严格模式下this的值为undefined）。</p></li><li><p>当函数存在宿主（以方法的形式调用），this指向该宿主对象。</p></li><li><p>当函数是构造函数（以new的方式调用），this指向新实例化的对象。</p></li><li><p>当函数不是箭头函数，且用apply、call、bind方法绑定了宿主对象，则函数调用时this指向该宿主对象。</p></li><li><p>函数是箭头函数，根据函数声明时的词法环境判断this。</p></li></ol><h3 id="ES6写法模拟apply、call、bind"><a href="#ES6写法模拟apply、call、bind" class="headerlink" title="ES6写法模拟apply、call、bind"></a>ES6写法模拟apply、call、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义apply</span><br><span class="hljs-built_in">Function</span>.prototype.myapply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(args)) &#123;<br>    <span class="hljs-keyword">if</span> (args === <span class="hljs-literal">null</span> || args === <span class="hljs-literal">undefined</span>) &#123;<br>      args = [];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;The second argument must be an Array&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ctx === <span class="hljs-literal">undefined</span> || ctx === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>(...args);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctx !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123; <span class="hljs-comment">// 只可能是引用类型，null已经被前一个if判断语句剔除</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not an Object&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;__fn__&#x27;</span>);<br>  <span class="hljs-built_in">Object</span>.defineProperty(ctx, fnSymbol, &#123;<br>    value: <span class="hljs-built_in">this</span>,<br>    configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 让该属性能够被删除,configurable默认为false</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> result = ctx[fnSymbol](...args);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性前&#x27;</span>, <span class="hljs-built_in">Reflect</span>.ownKeys(ctx));<br>  <span class="hljs-comment">// Reflect.deleteProperty(ctx, fnSymbol);</span><br>  <span class="hljs-keyword">delete</span> ctx[fnSymbol];<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性后&#x27;</span>, <span class="hljs-built_in">Reflect</span>.ownKeys(ctx));<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 自定义call</span><br><span class="hljs-built_in">Function</span>.prototype.mycall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.myapply(ctx, args);<br>&#125;<br><br><span class="hljs-comment">// 自定义bind</span><br><span class="hljs-built_in">Function</span>.prototype.mybind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, ...partialArgs</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> args = partialArgs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>    <span class="hljs-keyword">return</span> self.myapply(ctx, args);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>));<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;myapply测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.myapply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mycall测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.mycall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mybind测试：&#x27;</span>);<br><span class="hljs-keyword">const</span> fn = add.mybind(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><h3 id="ES5写法模拟apply、call、bind"><a href="#ES5写法模拟apply、call、bind" class="headerlink" title="ES5写法模拟apply、call、bind"></a>ES5写法模拟apply、call、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义apply</span><br><span class="hljs-built_in">Function</span>.prototype.myapply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || [], <br>      argsString = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (!(args <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;The second argument must be an Array&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>    argsString += <span class="hljs-string">&#x27;args[&#x27;</span> + i + <span class="hljs-string">&#x27;],&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (ctx === <span class="hljs-literal">undefined</span> || ctx === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 方法1 new Funciton ⭐ 更加安全</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;fn&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>, <span class="hljs-string">&#x27;return fn(&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>)(fn, args);<br>      <br>    <span class="hljs-comment">// 方法2 eval函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;fn(&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctx !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(ctx + <span class="hljs-string">&#x27;is not an Object&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> mountProp = <span class="hljs-string">&#x27;__fn__&#x27;</span>, temp;<br>  <span class="hljs-keyword">if</span> (ctx[mountProp]) &#123;<br>    temp = ctx[mountProp];<br>  &#125;<br>  <span class="hljs-built_in">Object</span>.defineProperty(ctx, mountProp, &#123;<br>    value: fn,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">false</span>,<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性前的this对象&#x27;</span>, ctx);<br>    <br>  <span class="hljs-comment">/*========== 执行ctx[mountProp]，并得到返回的数据==========*/</span><br>  <span class="hljs-comment">// 方法1. new Function ⭐ 更加安全</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>      <span class="hljs-string">&#x27;ctx&#x27;</span>, <span class="hljs-comment">// 参数1</span><br>      <span class="hljs-string">&#x27;args&#x27;</span>, <span class="hljs-comment">// 参数2</span><br>      <span class="hljs-string">&#x27;mountProp&#x27;</span>, <span class="hljs-comment">// 参数3</span><br>      <span class="hljs-string">&#x27;return ctx[mountProp](&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-comment">// 函数体代码</span><br>  )(ctx, args, mountProp);<br>  <br>    <br>  <span class="hljs-comment">// 方法2. eval</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;ctx[mountProp](&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  <br>  <br>  <span class="hljs-keyword">delete</span> ctx[mountProp];<br>  <span class="hljs-keyword">if</span> (temp) &#123;<br>    ctx[mountProp] = temp;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性后的this对象&#x27;</span>, ctx);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 自定义call</span><br><span class="hljs-built_in">Function</span>.prototype.mycall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> args = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.myapply(ctx, args);<br>&#125;<br><br><span class="hljs-comment">// 自定义bind</span><br><span class="hljs-built_in">Function</span>.prototype.mybind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125; <br>  <span class="hljs-keyword">var</span> partialArgs = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) partialArgs.push(<span class="hljs-built_in">arguments</span>[i]);<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> args = partialArgs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>    <span class="hljs-keyword">return</span> self.myapply(ctx, args);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;myapply测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.myapply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mycall测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.mycall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mybind测试：&#x27;</span>);<br><span class="hljs-keyword">const</span> fn = add.mybind(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure><h2 id="原型链、类、继承"><a href="#原型链、类、继承" class="headerlink" title="原型链、类、继承"></a>原型链、类、继承</h2><h3 id="原型链示意图"><a href="#原型链示意图" class="headerlink" title="原型链示意图"></a>原型链示意图</h3><p><img src="/2021/07/21/JavaScript/mianshiti/image-20210622171532346.png" alt="image-20210622171532346"></p><p>其中还缺三条紫色线：Object分别实例化 Function.prototype、Object.prototype、Person.prototype。</p><p>最主要的核心逻辑：<code>Function = new Function()</code>导致<code>Function.constructor === Function</code>。</p><p><strong>要点</strong></p><ol><li><p>JavaScript语言内部，当创建一个函数时，会相应地生成该函数的原型对象，并且函数的<code>prototype</code>属性指向该原型对象，而该原型对象<code>constructor</code>属性指向函数。</p><blockquote><p>函数的<code>prototype</code>以及原型对象的<code>constructor</code>属性是不可枚举的、不可修改、不可删除的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br> writable: <span class="hljs-literal">false</span>,<br> enumerable: <span class="hljs-literal">false</span>,<br> configurable: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>当使用<code>new</code>关键字加构造函数的形式创建对象时，JavaScript会实例化一个对象，实例化步骤：</p><ul><li>创建一个空对象，该空对象的<code>__proto__</code>属性指向构造函数的原型对象。</li><li>借用构造函数，为该空对象赋属性值。</li><li>返回这个新创建并经过处理的对象。</li></ul></li><li><p>万物皆对象，所有原型对象、函数、普通JavaScript对象都是<code>Object</code>类型的实例。</p></li><li><p><code>Object</code>构造函数是<code>Function</code>类型的实例，<code>Function</code>也是<code>Function</code>类型的实例。</p><p>即存在这样的逻辑：<code>Object = new Function(...); Function = new Function()</code>;</p></li><li><p>所有函数对象（包括<code>Function、Object</code>）都有一个显式原型和一个隐式原型。它们的显式原型<code>prototype</code>指向各自的原型对象，而函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>。</p></li></ol><h3 id="ES5的类与继承写法"><a href="#ES5的类与继承写法" class="headerlink" title="ES5的类与继承写法"></a>ES5的类与继承写法</h3><p>在<code>ES5</code>中，JavaScript不提供<strong>类</strong>的标准语法，需要通过“构造函数”的方式来模仿类型机制。</p><p>在<code>ES5</code>中，JavaScript不提供<strong>继承</strong>的标准语法，需要通过“组合继承”的方式来模仿继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">组合继承 &#x3D; 借用父类构造函数 + 原型继承<br>          👆 继承父类属性    👆 继承父类的方法<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Father.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  Father.call(<span class="hljs-built_in">this</span>, name);<br>&#125;<br><br>Son.prototype = <span class="hljs-keyword">new</span> Father();<br><span class="hljs-built_in">Object</span>.defineProperty(Son.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;<br>  value: Father,<br>&#125;)<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;mz&#x27;</span>);<br>s.sayHi();<br></code></pre></td></tr></table></figure><h3 id="ES6的类与继承语法"><a href="#ES6的类与继承语法" class="headerlink" title="ES6的类与继承语法"></a>ES6的类与继承语法</h3><p><code>class</code>是<code>ES6</code>引入的一个关键字，<strong>其用法基本上等同于<code>ES5</code>中的组合继承</strong>，所以class关键字的引入并没有为JavaScript添加新的继承模型，而是仅仅作为一个<strong>语法糖</strong>被使用，因此JavaScript中的class和其他面向对象语言中的class是两码事。</p><p><strong>类的成员定义：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>        <span class="hljs-comment">// 在构造函数中定义实例属性</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is an static method&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 静态属性</span><br>Human.staticProp = <span class="hljs-string">&#x27;...&#x27;</span>; <span class="hljs-comment">//❗ 在ES2015规范中，类的静态属性定义在类外（类内不存在定义静态属性的语法）</span><br></code></pre></td></tr></table></figure><p><strong>继承：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chinese</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, hometown</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name, age);<br>    <span class="hljs-built_in">this</span>.hometown = hometown;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">greeting</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.sayHi();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I am from <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.hometown&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.describle();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要点：</p><ol><li><p><code>ES2015</code>规范中，允许使用<code>extends</code>关键字实现<font color='red'>单继承</font>。此时会实例化一个父类对象，作为子类的原型对象（修改子类的<code>prototype</code>）。同时<font color='red'>删除</font>父类对象本来拥有的所有属性，然后再将该对象的<code>constructor</code>属性（不可枚举、不可修改、不可删除的属性）指向子类。</p></li><li><p>在子类的构造函数中，可以使用<code>super</code>方法显式调用父类的构造函数并传入父类构造函数所需要的参数。子类构造函数中调用<code>super</code>方法，会借用父类的构造函数为子类实例属性赋值。</p><blockquote><p>从要点1和要点2看出，<code>ES2015</code>规范提供的类的标准语法，实际上是组合继承的语法糖。</p></blockquote></li><li><p>子类会继承父类的实例方法、静态方法、静态属性。</p></li><li><p>子类的实例方法中可以通过<code>super</code>调用父类的实例方法，同时父类实例方法调用时<code>this</code>指向子类实例。</p></li><li><p>子类的静态方法中可以通过<code>super</code>调用父类的静态方法，同时父类静态方法调用时<code>this</code>指向子类。</p><blockquote><p>注意，子类静态方法中不能通过<code>super</code>访问父类实例方法；</p><p>同理，子类实例方法中不能通过<code>super</code>访问父类静态方法</p></blockquote></li><li><p>子类中可以重写父类的方法，对其进行覆盖。</p><blockquote><p>区别于方法重载，JS中没有重载。</p></blockquote></li></ol><h3 id="最新的类的语法"><a href="#最新的类的语法" class="headerlink" title="最新的类的语法"></a>最新的类的语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-comment">// ⭐ 可以显式地定义实例属性，也可以进行默认值赋值。</span><br>    name = <span class="hljs-string">&#x27;John Doe&#x27;</span>; <br>    age;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>        <span class="hljs-comment">// 在构造函数中定义实例属性</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is an static method&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ⭐ 静态属性 </span><br><span class="hljs-keyword">static</span> staticProp = <span class="hljs-string">&#x27;...&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote><p><code>typeof</code>运算符总会返回一个字符串。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// typeof 数字 👉 &#x27;number&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span>); <br><br><span class="hljs-comment">// typeof 字符串 👉 &#x27;string&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// typeof 布尔值 👉 &#x27;boolean&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// typeof undefined 👉 &#x27;undefined&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);<br><br><span class="hljs-comment">// typeof null 👉 &#x27;object&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// typeof 引用类型数据（包括数组） 👉 &#x27;object&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> &#123;&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []);<br><br><span class="hljs-comment">// typeof Symbol值 👉 &#x27;symbol&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br></code></pre></td></tr></table></figure><h4 id="判断-undefined和null"><a href="#判断-undefined和null" class="headerlink" title="=== 判断 undefined和null"></a>=== 判断 undefined和null</h4><p>可以用 <code>===</code>来判断一个数据是否为<code>undefined</code>和<code>null</code>，原因是<code>===</code>判断相等的前提是类型相等，而和<code>undefined</code>和<code>null</code>同类型的只有他们本身。</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><code>A instanceof B</code>返回<code>true</code>的条件是：B的显示原型对象等于A或在A的隐式原型链上。</p><p>通常用于判断某个对象是不是某个类的实例。</p><blockquote><p>要求：</p><ol><li><p>A 必须是一个引用类型对象，不可以是 Number、String、Boolean、undefined、null、Symbol类型的数据，否则返回false</p></li><li><p>B 必须是一个构造函数/类（也可以是一个对象，但不实 用），否则报错。</p></li></ol></blockquote><h4 id="使用Object-prototype-toString"><a href="#使用Object-prototype-toString" class="headerlink" title="使用Object.prototype.toString"></a>使用Object.prototype.toString</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数字</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">123</span>)) <span class="hljs-comment">// &#x27;[object Number]&#x27;</span><br><br><span class="hljs-comment">// 字符串</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&#x27;&#x27;</span>)) <span class="hljs-comment">// &#x27;[object String]&#x27;</span><br><br><span class="hljs-comment">// 布尔型</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// &#x27;[object Boolean]&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// &#x27;[object Boolean]&#x27;</span><br><br><span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// &#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// &#x27;[object Null]&#x27;</span><br><br><span class="hljs-comment">// 普通JS对象</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;)); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br><br><span class="hljs-comment">// 数组</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call([])); <span class="hljs-comment">// &#x27;[object Array]&#x27;</span><br><br><span class="hljs-comment">// Symbol</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>))); <span class="hljs-comment">// &#x27;[object Symbol]&#x27;</span><br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(Person)); <span class="hljs-comment">// &#x27;[object Function]&#x27;</span><br><br><span class="hljs-comment">// 类的实例</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(p)); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br><br>p[<span class="hljs-built_in">Symbol</span>.toStringTag] = <span class="hljs-string">&#x27;Person&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(p)); <span class="hljs-comment">// &#x27;[object Person]&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="显式的类型转换"><a href="#显式的类型转换" class="headerlink" title="显式的类型转换"></a>显式的类型转换</h3><h4 id="各类型数据强制转换为Number⭐"><a href="#各类型数据强制转换为Number⭐" class="headerlink" title="各类型数据强制转换为Number⭐"></a>各类型数据强制转换为Number⭐</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.布尔型 转 Number </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// 👉 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;false:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// 👉 0</span><br><br><span class="hljs-comment">// 2.undefined 转 Number </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;undefined:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// 👉 NaN</span><br><br><span class="hljs-comment">// 3.null 转 Number </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;null:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// 👉 0</span><br><br><span class="hljs-comment">// 4.Symbol 转 Number ❌不允许转</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Symbol:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>))); <span class="hljs-comment">// ❌ 报错，Symbol类型不允许转换为Number</span><br><br><br><span class="hljs-comment">// 5.字符串 转 Number  </span><br><span class="hljs-comment">// 5.1 空串</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;空字符串:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>)) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 5.2 只包含数字（包括前面带正负号和多个0）</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;+123&#x27;</span>)) <span class="hljs-comment">//  👉 123</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;000123&#x27;</span>)) <span class="hljs-comment">// 👉 123</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>)) <span class="hljs-comment">// 👉 123</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;-123&#x27;</span>)) <span class="hljs-comment">// 👉 -123</span><br><span class="hljs-comment">// 5.3 字符串可以解析为有效地浮点数格式（包含前面带有正负号以及多个0）</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>))  <span class="hljs-comment">// 👉 1.23</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;.23&#x27;</span>)) <span class="hljs-comment">// 👉 0.23</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;-00.23&#x27;</span>)) <span class="hljs-comment">// 👉 -0.23</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;+0000.23&#x27;</span>)) <span class="hljs-comment">// 👉 0.23</span><br><span class="hljs-comment">// 5.4 字符串可以解析未有效的二进制、八进制、十六进制数（忽略字母大小写）</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0b101&#x27;</span>)) <span class="hljs-comment">// 👉 5</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0B101&#x27;</span>)) <span class="hljs-comment">// 👉 5</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0o71&#x27;</span>)) <span class="hljs-comment">// 👉 57 </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0x1A&#x27;</span>)) <span class="hljs-comment">// 👉 26</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0x1a&#x27;</span>)) <span class="hljs-comment">// 👉 26</span><br><span class="hljs-comment">// 5.5 除5.1~5.4之外，其他格式的字符串转为Number型会输出NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123s&#x27;</span>)) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;.23.4&#x27;</span>)) <span class="hljs-comment">// 👉 NaN</span><br><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">⭐⭐ 以下为引用类型数据转换为Number的规则：⭐⭐</span><br><span class="hljs-comment">+ 如果引用类型数据target有valueOf()方法，且该方法返回一个“非引用类型”的数据data（包括NaN），</span><br><span class="hljs-comment">  则Number(target) = Number(data)。❗ 注：默认情况下，对象和数组的valueOf方法返回自身。</span><br><span class="hljs-comment">+ 如果引用类型数据target没有valueOf()方法，或者该方法仍然返回一个引用类型数据，</span><br><span class="hljs-comment">  则调用target的toString()方法得到s，Number(target) = Number(s)。</span><br><span class="hljs-comment">+ 如果target既不包含valueOf()方法，又不包含toString()方法（一般不会）,</span><br><span class="hljs-comment">  则试图将target转为Number时会报错。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">❗ 注：以下6~7均符合上述规则的描述。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 6.普通JS对象 转 Number </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;空对象:&#x27;</span>, <span class="hljs-built_in">Number</span>(&#123;&#125;));  <span class="hljs-comment">// 👉 NaN</span><br><br><span class="hljs-comment">// 7. 数组 转 Number</span><br><span class="hljs-comment">// 7.1 空数组</span><br>consolle.log(<span class="hljs-built_in">Number</span>([])) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 7.2 数组中只有一个元素，其值为undefined或null，则此数组转换为Number，返回值为0</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">undefined</span>])) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">null</span>])); <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 7.3 数组中只有一个元素，其值为布尔型，则此数组转换为Number，返回值为NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">false</span>])) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">true</span>])) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-comment">// 7.4 数组中只有一个元素，其值为一个数字、字符串、JS对象，则对此数组转换为Number等价于对第一个元素转换</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>])) <span class="hljs-comment">// 👉 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([-<span class="hljs-number">100</span>])) <span class="hljs-comment">// 👉 -100</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;&#x27;</span>])) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;+0123&#x27;</span>])) <span class="hljs-comment">// 👉 123</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;12.3&#x27;</span>])) <span class="hljs-comment">// 👉 12.3</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;0b101&#x27;</span>])) <span class="hljs-comment">// 👉 5</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;12.3xxxx&#x27;</span>])) <span class="hljs-comment">// 👉 NaN</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([&#123;&#125;])) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-comment">// 7.5 数组中有多个元素，即数组长度大于1时，此数组转换为Number，返回NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-number">123</span>, <span class="hljs-number">3213</span>])) <span class="hljs-comment">// 👉 NaN</span><br><br></code></pre></td></tr></table></figure><h4 id="各类型数据强制转为Boolean⭐"><a href="#各类型数据强制转为Boolean⭐" class="headerlink" title="各类型数据强制转为Boolean⭐"></a>各类型数据强制转为Boolean⭐</h4><p><strong>虚值</strong></p><p>在JavaScript中，有6个虚值。如果将其中任何一个字符串转换为Boolean，它将变为<code>false</code> 。</p><ol><li>false本身</li><li>0</li><li>undefined</li><li>null</li><li>NaN</li><li>“”（空字符串）</li></ol><blockquote><p><strong>任何不为虚值</strong>的都会被<code>Boolean</code>转换为<code>true</code>。</p></blockquote><h4 id="各类型数据的toString方法⭐"><a href="#各类型数据的toString方法⭐" class="headerlink" title="各类型数据的toString方法⭐"></a>各类型数据的toString方法⭐</h4><p>JavaScript中有七种数据类型，除<code>undefined</code>和<code>null</code>外，其他五种数据类型都具有<code>toString</code>方法（数字、字符串、布尔值数据会装箱后再调用该方法）。</p><p>因此，除<code>undefined</code>和<code>null</code>以外的<strong>任何数据</strong>调用<code>toString</code>方法都是在<strong>原型链上查找该方法</strong>并调用。</p><ol><li><p><code>Number.prototype.toString()</code></p><p><code>toString</code>方法很简单地将数字转为字符串形式返回，但数字类型的<code>toString</code>方法可以<strong>传递一个参数</strong>，用于指定用进制数（默认为10，还可以指定2、8、16等）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>num.toString();                   <span class="hljs-comment">//&quot;10&quot;</span><br>num.toString(<span class="hljs-number">2</span>);                  <span class="hljs-comment">//&quot;1010&quot;</span><br>num.toString(<span class="hljs-number">8</span>);                  <span class="hljs-comment">//&quot;12&quot;</span><br>num.toString(<span class="hljs-number">10</span>);                 <span class="hljs-comment">//&quot;10&quot;</span><br>num.toString(<span class="hljs-number">16</span>);                 <span class="hljs-comment">//&quot;a&quot;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>String.prototype.toString()</code></p><p>返回字符串本身。</p></li></ol><ol start="3"><li><p><code>Boolean.prototype.toString()</code></p><p>返回<code>&#39;true&#39;</code>或<code>&#39;false&#39;</code>。</p></li></ol><ol start="4"><li><p><code>Array.prototype.toString()</code></p><p>返回一个字符串，该字符串为数组中所有元素调用<code>toString</code>方法后用逗号<code>,</code>相连的结果。</p><blockquote><p>⭐<strong>注意</strong>：</p><p>如果数组中有元素的值为<code>undefined</code>或<code>null</code>，则该元素位置上为空字符串<code>&#39;&#39;</code>代替。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-literal">undefined</span>].toString() <span class="hljs-comment">// 结果为 &#x27;&#x27;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>].toString() <span class="hljs-comment">// 结果为 &#x27;1,&#x27;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].toString() <span class="hljs-comment">// 结果为 &#x27;1,,2&#x27;</span><br></code></pre></td></tr></table></figure></blockquote></li></ol><ol start="5"><li><p><code>Object.prototype.toString()</code> ⭐⭐</p><blockquote><p>对于 <code>Object.prototype.toString()</code> 方法，会返回一个形如 <code>&quot;[object XXX]&quot;</code> 的字符串。如果在对象的原型链上， <code>toString()</code> 方法未被重写，就会返回如上面形式的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">(&#123;&#125;).toString();     <span class="hljs-comment">// =&gt; &quot;[object Object]&quot;</span><br><span class="hljs-built_in">Math</span>.toString();     <span class="hljs-comment">// =&gt; &quot;[object Math]&quot;</span><br></code></pre></td></tr></table></figure><p>但是，大多数对象，<code>toString()</code> 方法都是重写了的，这时，需要用 <code>call()</code> 或 <code>Reflect.apply()</code> 等方法来调用。</p></blockquote><p><strong>所以我们更关注的是<code>Object.prototype.toString.call(target)</code>的返回值情况。</strong></p><p>(1) 若target参数为 <code>null</code> 或 <code>undefined</code>，直接返回<code>&#39;[object Null]&#39;</code>或<code>&#39;[object Undefined]&#39;</code></p><p>(2) 若target参数不为 <code>null</code> 或 <code>undefined</code>，则将参数转为对象，再作判断。对于原始类型，转为对象的方法即装箱。</p><p>(3) 转为对象后，取得该对象的 <code>[Symbol.toStringTag]</code> 属性值（可能会遍历原型链）作为 <code>tag</code>，如无该属性，或该属性值不为字符串类型，则依下表取得 <code>tag</code>, 然后返回 <code>&#39;[object &#39; + tag + &#39;]&#39;</code> 形式的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Boolean 类型，tag 为 &quot;Boolean&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>);     <span class="hljs-comment">// =&gt; &quot;[object Boolean]&quot;</span><br><br><span class="hljs-comment">// Number 类型，tag 为 &quot;Number&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>);        <span class="hljs-comment">// =&gt; &quot;[object Boolean]&quot;</span><br><br><span class="hljs-comment">// String 类型，tag 为 &quot;String&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&quot;&quot;</span>);       <span class="hljs-comment">// =&gt; &quot;[object String]&quot;</span><br><br><span class="hljs-comment">// Array 类型，tag 为 &quot;Array&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call([]);       <span class="hljs-comment">// =&gt; &quot;[object Array]&quot;</span><br><br><span class="hljs-comment">// Arguments 类型，tag 为 &quot;Arguments&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;<br>&#125;)());                                    <span class="hljs-comment">// =&gt; &quot;[object Arguments]&quot;</span><br><br><span class="hljs-comment">// Function 类型， tag 为 &quot;Function&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);    <span class="hljs-comment">// =&gt; &quot;[object Function]&quot;</span><br><br><span class="hljs-comment">// Error 类型（包含子类型），tag 为 &quot;Error&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());     <span class="hljs-comment">// =&gt; &quot;[object Error]&quot;</span><br><br><span class="hljs-comment">// RegExp 类型，tag 为 &quot;RegExp&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-regexp">/\d+/</span>);           <span class="hljs-comment">// =&gt; &quot;[object RegExp]&quot;</span><br><br><span class="hljs-comment">// Date 类型，tag 为 &quot;Date&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());      <span class="hljs-comment">// =&gt; &quot;[object Date]&quot;</span><br><br><span class="hljs-comment">// 其他类型，tag 为 &quot;Object&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;&#125;);    <span class="hljs-comment">// =&gt; &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>已经部署了Symbol.toStringTag的类型有：Map、Set、WeakMap、WeakSet、JSON、Math、Symbol等。</p></blockquote></li></ol><ol start="6"><li><p><code>Symbol.prototype.toString</code></p><p>Symbol类型的<code>toString</code>方法会返回一个型如<code>&#39;Symbol(&#39; + tag + &#39;)&#39;</code>的字符串。</p><p>而<code>tag</code>是对Symbol数据构建时第一个参数调用<code>toString</code>方法后的字符串。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;mz&#x27;</span>).toString()) <span class="hljs-comment">// 👉 &#x27;Symbol(mz)&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(&#123;&#125;).toString()) <span class="hljs-comment">// 👉 &#x27;Symbol([object Object])&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="7"><li><p><code>Function.prototype.toString</code></p><p>返回函数代码。</p></li></ol><ol start="8"><li><p><code>RegExp.prototype.toString</code></p><p>返回正则表达式对象的pattern字符串。 </p></li></ol><h4 id="各数据类型强制转换为String"><a href="#各数据类型强制转换为String" class="headerlink" title="各数据类型强制转换为String"></a>各数据类型强制转换为String</h4><p>String函数可以将参数转换为字符串类型后返回。</p><p>如果有参数对象具有<code>toString()</code>方法，调用该方法；⭐</p><p>而只有<code>undefined</code>和<code>null</code>没有<code>toString()</code>方法，所以如果是undefined，返回<code>&#39;undefined&#39;</code>；如果是null，返回<code>&#39;null&#39;</code>。</p><h3 id="隐式的类型转换"><a href="#隐式的类型转换" class="headerlink" title="隐式的类型转换"></a>隐式的类型转换</h3><p>在JavaScript中，明确地将某种类型数据转换成另一种类型的数据称为显式转换，相反则称为隐式类型转换。</p><p>显式类型转换地方法有很多，包括<code>Number()、Boolean()、String()、toString()、parseInt()、parseFloat()</code>等等。</p><p>隐式类型转换包括<code>运算符</code>、<code>JS逻辑语句</code>。</p><h4 id="运算符导致的隐式类型转换"><a href="#运算符导致的隐式类型转换" class="headerlink" title="运算符导致的隐式类型转换"></a>运算符导致的隐式类型转换</h4><h5 id="1-一元递增递减操作符"><a href="#1-一元递增递减操作符" class="headerlink" title="1. 一元递增递减操作符"></a>1. 一元递增递减操作符</h5><p>递增<code>++</code> 、 递减<code>--</code> 运算符不仅适用于整数，还可以用于字符串、布尔值、浮点数值、普通对象、数组、函数等等，其隐式转换规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;任意的数据类型&#x27;</span><br># 对于value的递增操作，有以下三种情况 <br>++value;value++;<br>f(++value);<br>f(value++)<br><br><span class="hljs-comment">// 情况1：value++和++value等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>value += <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 要点2：f(value++)的最新结果等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>f(value);<br>value += <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 要点3：f(++value)的最新结果等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>value += <span class="hljs-number">1</span>;<br>f(value);<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = [<span class="hljs-number">123</span>]<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出 123，而不是[123] ⭐⭐</span><br><span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">// 输出 124</span><br><br><span class="hljs-keyword">let</span> value = [<span class="hljs-number">123</span>]<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出124</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 2</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出 0</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 1</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">undefined</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 NaN</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出3.14</span><br><span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 输出4.14</span><br><br><span class="hljs-keyword">let</span> value = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(value++) <span class="hljs-comment">// 输出NaN，因为NaN + 1 = NaN</span><br></code></pre></td></tr></table></figure><p>递减操作符与递增操作符同理，不再赘述。</p><h5 id="2-一元加减操作符"><a href="#2-一元加减操作符" class="headerlink" title="2. 一元加减操作符"></a>2. 一元加减操作符</h5><p>一元加号（<code>+</code>）放在数字前面，作为一个表达式，其值为数字本身。</p><p>一元加号（<code>+</code>）放在非数字类型的数据前面，作为一个<strong>表达式</strong>，其值为强制转换为Number的结果。</p><p>一元减号（<code>-</code>）放在数字前面，作为一个表达式，其值为数字的相反数。</p><blockquote><p>注意 <code>-0 === +0</code>为<code>true</code>，<code>-NaN === NaN</code>为<code>false</code>。</p></blockquote><p>一元加号（<code>-</code>）放在非数字类型的数据前面，作为一个<strong>表达式</strong>，其值为强制转换为Number的结果再取相反数。</p><h5 id="3-加法-⭐"><a href="#3-加法-⭐" class="headerlink" title="3. 加法 ⭐"></a>3. 加法 ⭐</h5><p>(1) 两个操作数中<font color='red'>只要有其中之一为字符串</font>，则认为这个<code>+</code>二元运算符是一个<font color='red'>拼串</font>操作。两个操作数会被<code>String()</code>函数强制转换为字符串类型，再执行拼串，作为表达式的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-number">123</span>);                <span class="hljs-comment">// 👉 输出 &#x27;123&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> + <span class="hljs-string">&#x27;abc&#x27;</span>);            <span class="hljs-comment">// 👉 输出 &#x27;nullabc&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;333&#x27;</span>)             <span class="hljs-comment">// 👉 输出 &#x27;true333&#x27;</span><br></code></pre></td></tr></table></figure><p>(2) 两个操作数中存在引用类型，则会尝试先调用该引用类型的<code>valueOf</code>方法得到返回值，如果<code>valueOf</code>方法不存在或该方法仍然返回一个引用类型数据，则调用该对象的<code>toString</code>方法得到返回值，作为引用类型数据原位置上的操作数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(&#123;&#125; + <span class="hljs-string">&#x27;xxx&#x27;</span>);             <span class="hljs-comment">// 👉 输出 &#x27;[object Object]xxx&#x27;</span><br><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] + <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// 👉 输出 &#x27;1,2,3undefined&#x27;</span><br><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;,<br>&#125;<br><span class="hljs-built_in">console</span>.log(obj1 + obj2);  <span class="hljs-comment">// 👉 输出3</span><br><br><br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + obj); <span class="hljs-comment">// 👉 输出 &#x27;1[objet Object]&#x27;</span><br><br></code></pre></td></tr></table></figure><p>(3) <font color='red'>其他情况下</font>，<code>+</code>二元运算符是一个<font color='red'>加法</font>操作。两个操作数会被<code>Number()</code>函数强制转换为两个数字，再执行加法运算，作为表达式的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> + <span class="hljs-number">123</span>);        <span class="hljs-comment">// 👉 输出 NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">3</span>);               <span class="hljs-comment">// 👉 输出 4</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>);              <span class="hljs-comment">// 👉 输出 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> + <span class="hljs-number">100</span>);             <span class="hljs-comment">// 👉 输出 100</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>特殊的加法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JS中有两个无穷大，+Infinity和-Infinity，+Infinity和Infinity等价的。</span><br><span class="hljs-comment">// Infinity === Infinity 为true， -Infinity === -Infinity 为true</span><br><span class="hljs-literal">Infinity</span> + <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">Infinity</span><br>-<span class="hljs-literal">Infinity</span> + (-<span class="hljs-literal">Infinity</span>) = -<span class="hljs-literal">Infinity</span><br><span class="hljs-literal">Infinity</span> + (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">NaN</span> ⭐<br><br><span class="hljs-comment">// 任何数 与 NaN 计算的结果都为NaN</span><br><span class="hljs-literal">NaN</span> + <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">NaN</span>  <br><br><span class="hljs-comment">// JS中有-0和+0，+0和0是等价的，-0 === +0为true</span><br><span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> + (-<span class="hljs-number">0</span>) = <span class="hljs-number">0</span><br>(-<span class="hljs-number">0</span>) + (-<span class="hljs-number">0</span>) = -<span class="hljs-number">0</span> ⭐<br></code></pre></td></tr></table></figure></blockquote><h5 id="4-减法"><a href="#4-减法" class="headerlink" title="4. 减法"></a>4. 减法</h5><p>二元减法操作符比较简单，如果操作符两侧的操作数不为数字类型，则使用<code>Number()</code>将其强制转换为数字类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> - <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 -3</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>特殊的减法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">Infinity</span> - <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">NaN</span><br>(-<span class="hljs-literal">Infinity</span>) - (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">NaN</span><br><span class="hljs-literal">Infinity</span> - (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">Infinity</span><br>(-<span class="hljs-literal">Infinity</span>) - <span class="hljs-literal">Infinity</span> = -<span class="hljs-literal">Infinity</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span> - <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br>-<span class="hljs-number">0</span> - -<span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> - (-<span class="hljs-number">0</span>) = <span class="hljs-number">0</span><br>(-<span class="hljs-number">0</span>) - <span class="hljs-number">0</span> = -<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="5-乘性运算"><a href="#5-乘性运算" class="headerlink" title="5.  乘性运算"></a>5.  乘性运算</h5><p>乘性运算包括二元乘法操作符<code>*</code>、二元除法操作符<code>/</code>、二元取模操作符<code>%</code>，这三个操作符也很简单，只要两侧操作数不是数字类型，则强制将其转为数字类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span> * [<span class="hljs-number">3</span>]);  <span class="hljs-comment">// 👉 输出 24</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">999</span> / <span class="hljs-string">&#x27;333&#x27;</span>); <span class="hljs-comment">// 👉 输出 3</span><br></code></pre></td></tr></table></figure><h5 id="6-关系操作符⭐"><a href="#6-关系操作符⭐" class="headerlink" title="6. 关系操作符⭐"></a>6. 关系操作符⭐</h5><p>在JavaScript高级程序设计中，关系操作符有四个，分别是<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>，由关系操作符和两个操作数组成的表达式的值是一个布尔值。</p><p>(1) 如果操作符两侧的操作数都是数字，则执行数值比较。</p><p>(2) 如果操作符两侧的操作数都是字符串，则逐个比较字符串中对应位置字符的编码（应该是Unicode）。</p><p>(3) 如果只有一个操作数为数字，另一个不是，则使用<code>Number()</code>将另一个操作数转换为数字后执行比较。</p><p>(4) 如果操作数中有<code>true</code>、<code>false</code>、<code>undefined</code>、<code>null</code>，则先使用<code>Number()</code>将其转换成数字后再与另一个操作数比较。</p><p>(5) 如果两个操作数中有一个引用类型数据<code>refVal</code>，而另一个操作数不是数字，则调用<code>refVal</code>的<code>valueOf()</code>方法得到返回值<code>data</code>后再与另一个操作数比较。如果<code>refVal</code>不存在<code>valueOf()</code>方法或<code>valueOf()</code>方法仍然返回一个引用类型数据，则调用<code>refVal</code>的<code>toString()</code>方法得到字符串<code>s</code>，将<code>s</code>与另一个操作数进行比较。</p><p>(6) 关系操作符的操作数不允许出现Symbol类型数据，如出现，会报错。</p><blockquote><p>其实可以简单理解为：</p><ol><li>如果两个操作数都是数字，则直接执行比较。</li><li>如果两个操作数都是字符串，则进行字符串比较。</li><li>其他情况两个操作数都要转换为数字。</li></ol><p>注意，任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举例</span><br><span class="hljs-string">&#x27;123&#x27;</span> &lt; <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// true (2)</span><br><span class="hljs-string">&#x27;ab &#x27;</span> &gt; <span class="hljs-string">&#x27;ab&#x27;</span> <span class="hljs-comment">// true (2)</span><br><br><span class="hljs-string">&#x27;&#x27;</span> &lt; <span class="hljs-number">1</span>  <span class="hljs-comment">// true (3)</span><br><br><span class="hljs-literal">true</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-comment">// true (4)</span><br><span class="hljs-literal">false</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-comment">// false (4)</span><br><span class="hljs-literal">false</span> &gt;= <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// true (4)</span><br><span class="hljs-literal">null</span> &lt; <span class="hljs-number">1</span> <span class="hljs-comment">// true (4)</span><br><br><span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">100</span> <span class="hljs-comment">// false (4)因为undefined转为数字为NaN</span><br>undefind &lt;= <span class="hljs-number">100</span> <span class="hljs-comment">// false (4)因为undefined转为数字为NaN</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>    toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;obj&#x27;</span><br>    &#125;<br>&#125;<br>obj &gt; <span class="hljs-number">123</span>  <span class="hljs-comment">// false (3):123是数字，则将obj转为Number会返回NaN</span><br>obj &gt; <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// true (5):obj为引用类型，而&#x27;123&#x27;不是数字，obj调用toString方法会返回&#x27;obj&#x27;,&#x27;obj&#x27; &gt; &#x27;123&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="7-等于和不等于"><a href="#7-等于和不等于" class="headerlink" title="7. 等于和不等于"></a>7. 等于和不等于</h5><p><strong><code>==</code>和<code>!=</code>在比较两个操作数的过程中，可能会对操作数进行隐式的强制类型转换后再比较。</strong></p><p>(1) 如果两个操作数中存在<code>null</code>或<code>undefined</code>，则只有<code>undefined == undefined</code>、<code>null == null</code>、<code>undefined == null</code>会返回<code>true</code>。❗ 在执行等号或不等号时，<code>undefined</code>和<code>null</code>都不会进行类型转换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">null</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><span class="hljs-comment">// ⭐ 因此，根据这条规则，只要判断一个数是否等于 undefined，就能判断该值是否为undefined或null。</span><br></code></pre></td></tr></table></figure><p>(2.1) 如果<font color='red'>两个操作数都是数字</font>，则执行正常的数值比较。</p><blockquote><p>如果操作数中存在<code>NaN</code>，则任何涉及<code>NaN</code>的等于操作符都返回<code>false</code>，不等于操作符都返回<code>true</code>。</p></blockquote><p>(2.2) 如果<font color='red'>两个操作数都是字符串</font>，则比较两个字符串各个位置上的字符是否相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;abc&#x27;</span> != <span class="hljs-string">&#x27;abc &#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;123&#x27;</span> == <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(2.3) 如果<font color='red'>两个操作数都是布尔值</font>，则正常执行布尔值的比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">true</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(2.4) 如果<font color='red'>两个操作数都是引用类型</font>，则只有当两个操作数指向同一个引用类型数据时，才返回<code>true</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;&#125;, obj2 = &#123;&#125;;<br>obj1 == obj2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>(3.1) 如果<font color='red'>一个操作数是数字，另一个操作数不是数字</font>，则使用<code>Number()</code>将其转换为数字后再执行比较。⭐</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">123</span> == <span class="hljs-string">&#x27;+123&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">8</span> == <span class="hljs-string">&#x27;0b1000&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> == <span class="hljs-literal">null</span> <span class="hljs-comment">// false 遵守第一条</span><br></code></pre></td></tr></table></figure><p>(3.2) 如果<font color='red'>一个操作数是布尔值，另一个不是布尔值</font>，则使用<code>Number()</code>将二者都转为数字后再比较。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> != <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(3.3) 如果<font color='red'>一个操作数是引用类型，另一个不是引用类型</font>， 则会先尝试调用该对象的<code>valueOf()</code>方法得到返回值<code>value</code>，如果该对象不存在<code>valueOf()</code>方法或<code>data</code>仍然是引用类型数据，则再尝试调用该对象的<code>toString()</code>方法得到返回值<code>s</code>。得到<code>value</code>或<code>s</code>后，按照其他规则再与另外一个操作数进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br>    &#125;<br>&#125;<br>obj1 == <span class="hljs-string">&#x27;[object Object]&#x27;</span> <span class="hljs-comment">// true</span><br>obj2 == <span class="hljs-number">123</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>(4) 如果两个操作数中<font color='red'>存在Symbol类型的数据</font>，<font color='red'>Symbol类型数据只与自己相等</font>，其他情况都返回<code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>), s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>s1 == s2 <span class="hljs-comment">// false</span><br>s1 == s1 <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h5 id="8-全等和不全等"><a href="#8-全等和不全等" class="headerlink" title="8. 全等和不全等"></a>8. 全等和不全等</h5><p>全等操作符<code>===</code>要求两个操作数“类型相同，值也相同”的情况下才返回<code>true</code>。</p><h4 id="JavaScript语句中的隐式类型转换"><a href="#JavaScript语句中的隐式类型转换" class="headerlink" title="JavaScript语句中的隐式类型转换"></a>JavaScript语句中的隐式类型转换</h4><h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p><code>if（condition）statement1 else statement2</code></p><p>其中的<code>condition</code>（条件）可以是任意表达式，而且对这个表达式求值的结果不一定是布尔值。</p><p><code>ECMAScript</code>会自动调用<code>Boolean()</code>转换函数将这个表达式结果转换为一个布尔值。</p><p>如果对condition求值的结果是<code>true</code>，则执行<code>satement1</code>，如果对condition求值的结果是<code>false</code>，则执行<code>statement2</code>。</p><h5 id="while-和-do-while-语句"><a href="#while-和-do-while-语句" class="headerlink" title="while 和 do while 语句"></a>while 和 do while 语句</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>（expression）statement<br><br><span class="hljs-keyword">do</span>&#123;<br><br>　　statement<br><br>&#125;<span class="hljs-keyword">while</span>（expression）<br></code></pre></td></tr></table></figure><p>⭐ 同if语句，会对<code>expression</code>强制转换为<code>Boolean</code>。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript的数据类型分为基本数据类型和引用数据类型。</p><p>对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的<font color='red'>深浅拷贝都是对于引用数据类型而言的</font>。</p><p><strong>浅拷贝：</strong>浅拷贝的意思就是只复制引用（指针），而未复制真正的值（指针指向的内存空间）。</p><p><strong>深拷贝：</strong>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p><p><strong>实现深拷贝的思路：</strong></p><p>目前实现深拷贝的方法不多，主要是两种 👇</p><ol><li>组合使用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li><li>利用递归来实现每一层都重新创建对象并赋值</li></ol><h3 id="JSON-stringify-JSON-parse"><a href="#JSON-stringify-JSON-parse" class="headerlink" title="JSON.stringify + JSON.parse"></a>JSON.stringify + JSON.parse</h3><p>在简单情况下，<code>JSON.parse(JSON.stringify(target))</code>能够实现对一个引用类型数据的深拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> originArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> cloneArray = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(originArray));<br><span class="hljs-built_in">console</span>.log(cloneArray === originArray); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> originObj = &#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-attr">c</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-attr">d</span>:&#123;<span class="hljs-attr">dd</span>:<span class="hljs-string">&#x27;dd&#x27;</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> cloneObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(originObj));<br><span class="hljs-built_in">console</span>.log(cloneObj === originObj); <span class="hljs-comment">// false</span><br><br>cloneObj.a = <span class="hljs-string">&#x27;aa&#x27;</span>;<br>cloneObj.c = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];<br>cloneObj.d.dd = <span class="hljs-string">&#x27;doubled&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(cloneObj); <span class="hljs-comment">// &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;</span><br><span class="hljs-built_in">console</span>.log(originObj); <span class="hljs-comment">// &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span><br></code></pre></td></tr></table></figure><p>但是在以下情况中，该方法不能完全实现引用类型数据的深拷贝：</p><ol><li>源对象是普通JavaScript对象，其中有<code>Symbol</code>类型的属性名时，用上述方法复制出的对象不具有这些属性。</li><li>源对象是普通JavaScript对象，其中有<code>Symbol</code>类型的、<code>Function</code>类型的、<code>undefined</code>类型的属性值时，用上述方法复制出的对象不具有这些属性。</li><li>源对象是数组，数组中有<code>Symbol</code>类型、<code>Function</code>类型、<code>undefined</code>类型的元素时，复制出的数组在相应位置上的元素为<code>null</code>。</li><li>源对象是数组，数组中的引用类型数据有上述1~3情况的，上述方法不能够完整复制出源数组对象。</li></ol><blockquote><p>⭐ 原因：</p><p><code>json</code>格式数据的属性名必须是字符串，属性值只允许①字符串 ②数字 ③布尔值 ④null ⑤数组 ⑥json。</p><p><code>json</code>格式数据还可以是包含上述①~⑥类型数据的数组。</p></blockquote><h3 id="递归深拷贝"><a href="#递归深拷贝" class="headerlink" title="递归深拷贝"></a>递归深拷贝</h3><blockquote><p>深拷贝的功能代码要考虑需求：</p><ol><li>是否考虑Symbol属性</li><li>是否拷贝不可枚举属性</li><li>是否考虑循环引用</li><li>是否考虑派生对象的复制（要求保持原型链）</li><li>是否考虑函数的深拷贝</li></ol></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"># 最简单的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-built_in">Array</span>.isArray(target)? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，不考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Object</span>.keys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloned[key] = deepClone(target[key]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br><br># 考虑函数深拷贝、派生对象的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">$&#123;target.toString()&#125;</span>`</span>);<br>        fn.name = target.name;<br>        <span class="hljs-keyword">return</span> fn;<br>    &#125;<br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，不考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Object</span>.keys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloned[key] = deepClone(target[key]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js"># 考虑函数深拷贝、派生对象、Symbol属性以及不可枚举属性的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 注意对象的方法简写方式会导致该方法的toString()结果不包含&#x27;function&#x27;这个关键字</span><br>        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^(?&lt;FunctionName&gt;[_a-zA-Z]\w*)\s*\(\s*\)/</span>;<br>        <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + target.toString().replace(reg, <span class="hljs-string">`function $&lt;FunctionName&gt;()`</span>));<br>        seen.set(target, fn);<br>        <span class="hljs-keyword">return</span> fn;<br>      &#125;  <br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Reflect</span>.ownKeys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>       <span class="hljs-comment">// Reflect.getOwnPropertyDescriptor每次返回一个新的描述对象</span><br>       <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(target, key); <br>       descriptor.value = deepClone(descriptor.value);<br>       <span class="hljs-built_in">Reflect</span>.defineProperty(cloned, key, descriptor);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br><br># 考虑循环引用的版本，利用hash表<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制</span><br>    <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<br>    <span class="hljs-keyword">return</span> __deepClone__(target);<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__deepClone__</span>(<span class="hljs-params">target</span>) </span>&#123;<br>        <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>        <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 考虑函数复制</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (seen.has(target)) <span class="hljs-keyword">return</span> seen.get(target);<br>            <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^(?&lt;FunctionName&gt;[_a-zA-Z]\w*)\s*\(\s*\)/</span>;<br>            <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + target.toString().replace(reg, <span class="hljs-string">&#x27;function $&lt;FunctionName&gt;()&#x27;</span>));<br>            seen.set(target, fn);<br>            <span class="hljs-keyword">return</span> fn;<br>        &#125;        <br>        <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>        <br>        <span class="hljs-comment">// 开始考虑数组和对象</span><br>        <span class="hljs-keyword">if</span> (seen.has(target)) <span class="hljs-keyword">return</span> seen.get(target);<br>        <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>        <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>        <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>        <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>seen.set(target, cloned);<br>        <span class="hljs-comment">// 以下开始遍历属性，考虑Symbol属性以及不可枚举属性的深拷贝</span><br>        <span class="hljs-built_in">Reflect</span>.ownKeys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>           <span class="hljs-comment">// Reflect.getOwnPropertyDescriptor每次返回一个新的描述对象</span><br>           <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(target, key); <br>           descriptor.value = __deepClone__(descriptor.value);<br>           <span class="hljs-built_in">Reflect</span>.defineProperty(cloned, key, descriptor);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>作用：处理JavaScript中的异步代码，避免回调地狱。</p><h3 id="创建一个Promise对象"><a href="#创建一个Promise对象" class="headerlink" title="创建一个Promise对象"></a>创建一个Promise对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    执行异步操作,</span><br><span class="hljs-comment">    异步操作成功时，使用resolve(result)将结果挂载到p上</span><br><span class="hljs-comment">    异步操作失败时，使用reject(reason)将失败信息挂载到p上</span><br><span class="hljs-comment">    */</span><br>&#125;) <br></code></pre></td></tr></table></figure><blockquote><p>根据业务逻辑，创建一个Promise对象时有一个同步执行过程以及一个至多个异步任务的启动和执行。</p><p>当其中任何一个执行过程调用了<code>resolve</code>或<code>reject</code>时，该Promise的内容（状态和值）就不再发生变化。</p></blockquote><h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><p><code>Promise</code>对象的<code>[[PromiseStatus]]</code>属性能够表示该promise对象的状态，有三个可能值分别代表三种不同的状态。</p><p><code>pending</code> 👉 未决（同步或异步操作仍然在执行）</p><p><code>fulfilled</code> 👉 接受（同步、异步操作执行成功时调用<code>resolve</code>的结果）</p><p><code>rejected</code> 👉 拒绝 （同步、异步操作执行失败时调用<code>reject</code>的结果）</p><h3 id="Promise的链式调用（then与catch）"><a href="#Promise的链式调用（then与catch）" class="headerlink" title="Promise的链式调用（then与catch）"></a>Promise的链式调用（then与catch）</h3><p><code>promiseInstance.then(onResolved[, onRejected])</code></p><h4 id="then方法参数"><a href="#then方法参数" class="headerlink" title="then方法参数"></a>then方法参数</h4><p>该方法可以接收一个参数（<code>onResolved</code>）或两个参数（<code>onResolved、onRejected</code>）。</p><ul><li><p><code>onResolved</code>是调用<code>then</code>方法的Promise对象的状态改变为<code>fulfilled</code>状态时会执行的回调。JavaScript会将该Promise对象的<code>[[PromiseValue]]</code>属性值传递给<code>onResolved</code>回调函数并同步执行（相对于当前任务）。</p></li><li><p><code>onRejected</code>是调用<code>then</code>方法的Promise对象的状态改变为<code>rejected</code>状态时会执行的回调。JavaScript会将该对象的<code>[[PromiseValue]]</code>属性值传递给<code>onRejected</code>回调函数并同步执行（相对于当前任务）。</p></li></ul><h4 id="then方法返回值"><a href="#then方法返回值" class="headerlink" title="then方法返回值"></a>then方法返回值</h4><p>Promise对象的then方法会<font color='red'>返回一个Promise对象</font>，以实现Promise的链式效果。</p><p>以下开始分析<code>let r = p.then(onResolved, onRejected)</code>的返回值情况：</p><ol><li><p>如果执行到<code>p.then</code>时，<code>p</code>为<code>pending</code>状态，则<code>r</code>的值为<code>pending</code>状态的新Promise对象。<strong>但是<code>r</code>此时与<code>p</code>产生了关联</strong>，如果将来<code>p</code>的状态发生改变时（<code>[[PromiseStatus]]</code>和<code>[[PromiseValue]]</code>），<code>r</code>的状态也会相应发生改变。</p><ul><li><p>如果将来的某个时间点，p的状态由<code>pending</code>转为了<code>fulfilled</code>，则JavaScript会将<code>p.then</code>方法调用时传入的<code>onResolved</code>函数加入微任务队列，并且将<code>p</code>的<code>[[PromiseValue]]</code>作为实参传给该函数。</p></li><li><p>如果将来的某个时间点，p的状态由<code>pending</code>转为了<code>rejected</code>，则JavaScript会将<code>p.then</code>方法调用时传入的<code>onRejected</code>函数加入微任务队列，并且将<code>p</code>的<code>[[PromiseValue]]</code>作为实参传给该函数。</p></li><li><p>当<code>p</code>的状态确定时，<code>p</code>如果为<code>fulfilled</code>，<code>r</code>的状态由<code>onResolved</code>决定；如果<code>p</code>为<code>rejected</code>，<code>r</code>的状态由<code>onRejected</code>决定。因此我们设<code>handler = onResolved/onRejected</code>，再进行分析：</p><p>(1) 如果<code>handler</code>为空（<code>undefined</code>或<code>null</code>），则<code>r</code>的状态是对<code>p</code>的状态的深拷贝。⭐</p><p>(2) 如果<code>handler</code>返回一个值，则<code>r</code>转为<code>fulfilled</code>，且<code>r</code>的“value”为<code>handler</code>的返回值。</p><p>(3) 如果<code>handler</code>不返回任何值，则<code>r</code>转为<code>fulfilled</code>，且<code>r</code>的“reason”为<code>undefined</code>。</p><p>(4) 如果<code>handler</code>返回一个<code>fulfilled</code>的Promise对象，则<code>r</code>的状态是对该Promise对象状态的深拷贝。</p><p>(5) 如果<code>handler</code>返回一个<code>rejected</code>的Promise对象，则<code>r</code>的状态是对该Promise对象状态的深拷贝。</p><p>(6) 如果<code>handler</code>返回一个<code>pending</code>的Promise对象，则<code>r</code>的状态与该Promise对象产生关联。</p><p>(7) 如果<code>handler</code>在执行过程中发生异常，则<code>r</code>转为<code>rejected</code>，且<code>r</code>的“reason”为抛出的异常对象。</p><blockquote><p><strong>MDN原文：</strong></p><h3 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value">Return value</a></h3><p>Once a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> is fulfilled or rejected, the respective handler function (<code>onFulfilled</code> or <code>onRejected</code>) will be called <strong>asynchronously</strong> (scheduled in the current thread loop). The behavior of the handler function follows a specific set of rules. If a handler function:</p><ul><li>returns a value, the promise returned by <code>then</code> gets resolved with the returned value as its value.</li><li>doesn’t return anything, the promise returned by <code>then</code> gets resolved with an <code>undefined</code> value.</li><li>throws an error, the promise returned by <code>then</code> gets rejected with the thrown error as its value.</li><li>returns an already fulfilled promise, the promise returned by <code>then</code> gets fulfilled with that promise’s value as its value.</li><li>returns an already rejected promise, the promise returned by <code>then</code> gets rejected with that promise’s value as its value.</li><li>returns another <strong>pending</strong> promise object, the resolution/rejection of the promise returned by <code>then</code> will be subsequent to the resolution/rejection of the promise returned by the handler. Also, the resolved value of the promise returned by <code>then</code> will be the same as the resolved value of the promise returned by the handler.</li></ul></blockquote></li></ul></li><li><p>如果执行到<code>p.then</code>时，<code>p</code>已经为<code>fulfilled</code>状态，则<code>r</code>的状态是对<code>p</code>的深拷贝。</p></li><li><p>如果执行到<code>p.then</code>时，<code>p</code>已经为<code>rejected</code>状态，则<code>r</code>的状态是对<code>p</code>的深拷贝。</p></li></ol><h4 id="then方法的多次调用"><a href="#then方法的多次调用" class="headerlink" title="then方法的多次调用"></a>then方法的多次调用</h4><p> <code>then</code> 方法可以被同一个 <code>promise</code> 对象调用多次</p><ul><li><p>当 <code>promise</code> 成功状态时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</p></li><li><p>当 <code>promise</code> 失败状态时，所有 <code>onRejected</code> 需按照其注册顺序依次回调</p></li></ul><h4 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h4><p><code>catch</code>方法只传入一个参数<code>onRejected</code>。该方法其实是<code>then</code>方法的语法糖🍬。</p><p><code>p.catch(onRejected)</code>等同于<code>p.then(null, onRejected)</code>。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>综合上述讲解与分析，可以发现通常为了更好地利用<code>Promise.prototype.then</code>的链式效果，我们在中间过程的<code>onResolved</code>和<code>onRejected</code>回调函数中都会返回一个Promise对象，然后在该Promise对象中定义中间过程逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br> &#125;); <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) = &gt; &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br> &#125;);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <br>&#125;);  <span class="hljs-comment">// 所以 p 一般情况是 catch方法返回的pending状态的Promise对象。</span><br></code></pre></td></tr></table></figure><hr><h3 id="处理多个Promise"><a href="#处理多个Promise" class="headerlink" title="处理多个Promise"></a>处理多个Promise</h3><p><strong>1.</strong><code>Promise.all(promiseInstances)</code></p><p><strong>参数</strong></p><p>Promise.all 函数允许传入一个包含多个Promise对象的数组。</p><p><strong>返回值</strong></p><p>Promise.all 函数会返回一个新的Promise对象<code>r</code>，<code>r</code>与传入的实参数组中所有的Promise对象产生关联。只有当实参数组中<font color='red'>所有的Promise对象状态确定</font>时，<code>r</code>的状态才会由<code>pending</code>变为<code>fulfilled</code>或者<code>rejected</code>。</p><p>(1) 当实参数组中所有的Promise对象变为<code>fulfilled</code>时，<code>r</code>才会转为<code>fulfilled</code>，其<code>value</code>为一个数组，数组中按顺序保存了实参数组中每一个Promise对象的<code>value</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p1 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p2 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p3 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br>.then(<span class="hljs-function">(<span class="hljs-params">[value1, value2, value3]</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(value1, value2, value3);<br>        &#125;)<br></code></pre></td></tr></table></figure><p>(2) 当实参数组中所有的Promise对象的其中之一变为<code>rejected</code>时，<code>r</code>立即转为<code>rejected</code>，其<code>reason</code>为实参数组中第一个被<code>rejected</code>的Promise对象的<code>reason</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p1 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p2 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> reject(<span class="hljs-string">&#x27;p3 reason&#x27;</span>), <span class="hljs-number">2000</span>); <span class="hljs-comment">// 👈 rejected</span><br>&#125;)<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br>.then(<span class="hljs-function">(<span class="hljs-params">[value1, value2, value3]</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ⭐ 当有一个Promise失败时，不会执行onResolved </span><br>            <span class="hljs-built_in">console</span>.log(value1, value2, value3);<br>        &#125;)<br>.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(reason);<br>        &#125;)<br></code></pre></td></tr></table></figure><p><strong>2.</strong><code>Promise.race()</code></p><p><strong>参数</strong></p><p>Promise.race 函数允许传入一个包含多个Promise对象的数组。</p><p><strong>返回值</strong></p><p>Promise.race 函数会返回一个新的Promise对象<code>r</code>，<code>r</code>与传入的实参数组中所有的Promise对象产生关联。只要当实参数组中的<font color='red'>其中一个Promise对象状态确定</font>时，<code>r</code>的状态就会由<code>pending</code>变为<code>fulfilled</code>或者<code>rejected</code>。</p><p>(1) 当实参数组中<font color='red'>第一个确定状态的</font>Promise对象变为<code>fulfilled</code>时，<code>r</code>的状态就会转为<code>fulfilled</code>。</p><p>(2) 当实参数组中<font color='red'>第一个确定状态的</font>Promise对象的其中之一变为<code>rejected</code>时，<code>r</code>的状态立即转为<code>rejected</code>。</p><h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isFunction = <span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>;<br><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      FUlFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>      REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-keyword">let</span> pushIntoMicroQueue;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> queueMicrotask !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;              <span class="hljs-comment">// 好像最新的浏览器和Node都支持该函数</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use queueMicrotask to create Microtask&#x27;</span>)        <br>  pushIntoMicroQueue = queueMicrotask;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;     <span class="hljs-comment">// 最新的浏览器支持</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use MutationObserver to create Microtask&#x27;</span>);<br>  pushIntoMicroQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123; <br>    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>),<br>          config = &#123; <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">() =&gt;</span> &#123;<br>      task();<br>      observer.disconnect();<br>      observer = <span class="hljs-literal">null</span>;<br>      dummyNode = <span class="hljs-literal">null</span>;<br>    &#125;);<br>    observer.observe(dummyNode, config);<br>    dummyNode.style = <span class="hljs-string">&#x27;display: none;&#x27;</span>; <span class="hljs-comment">// 触发MutationObserser的回调</span><br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// Node环境下使用process.nextTick创建微任务</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use process.nextTick to create Microtask&#x27;</span>);          <br>  pushIntoMicroQueue = process.nextTick;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">handler</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isFunction(handler)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)<br>    &#125;<br>    <span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>._status = PENDING;<br>    <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>._onResolvedQueue = [];<br>    <span class="hljs-built_in">this</span>._onRejectedQueue = [];<br>    <span class="hljs-keyword">try</span> &#123;<br>      handler(<span class="hljs-built_in">this</span>._resolve.bind(<span class="hljs-built_in">this</span>), <span class="hljs-built_in">this</span>._reject.bind(<span class="hljs-built_in">this</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (e)&#123;<br>      <span class="hljs-built_in">this</span>._reject(e);<br>      <span class="hljs-comment">// ========= 打印一些错误信息，便于调试 ========</span><br>      <span class="hljs-comment">// console.warn(e); </span><br>      <span class="hljs-comment">// ===========================================  </span><br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">_flushOnResolvedQueue</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> task;<br>    <span class="hljs-keyword">while</span> (task = <span class="hljs-built_in">this</span>._onResolvedQueue.shift()) &#123;<br>      task(value);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._onRejectedQueue.length = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">_flushOnRejectedQueue</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> task;<br>    <span class="hljs-keyword">while</span> (task = <span class="hljs-built_in">this</span>._onRejectedQueue.shift()) &#123;<br>      task(reason);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._onResolvedQueue.length = <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">_resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// promise的状态只更改一次</span><br>    <span class="hljs-built_in">this</span>._status = FUlFILLED;<br>    <span class="hljs-built_in">this</span>._value = value;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;  <span class="hljs-comment">// 支持resolve一个promise的情况</span><br>      value.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">this</span>._resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">this</span>._reject(r));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      pushIntoMicroQueue(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 👈 核心是将清空promise任务队列的函数加入到JS引擎的微任务队列</span><br>        <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>._flushOnResolvedQueue(value);<br>      &#125;);<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">_reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// promise的状态只更改一次</span><br>    <span class="hljs-built_in">this</span>._status = REJECTED;<br>    <span class="hljs-built_in">this</span>._value = reason;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._chained) &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Uncaught (in MyPromise)&#x27;</span>, <span class="hljs-built_in">this</span>._value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      pushIntoMicroQueue(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 👈 核心是将清空promise任务队列的函数加入到JS引擎的微任务队列</span><br>        <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>._flushOnRejectedQueue(reason);<br>      &#125;);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ⭐ 最核心的then方法，其实还是发布订阅模式。</span><br>  <span class="hljs-comment">// 新的promise是订阅者，调用then的promise是发布者。</span><br>  <span class="hljs-comment">// resolve或reject相当于trigger，只会发布这两种通知</span><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onResolved, onRejected</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; _status, _value, _flushed&#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <br>      <span class="hljs-keyword">const</span> onResolvedWrapper = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onResolved)) &#123;<br>          resolve(value);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onResolved(value);<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(res);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> onRejectedWrapper = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onRejected)) &#123;<br>          reject(reason);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onRejected(reason);<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(res);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// ⭐⭐</span><br>      <span class="hljs-keyword">switch</span> (_status) &#123;  <br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FUlFILLED:<br>          <span class="hljs-keyword">if</span> (_flushed) onResolvedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// catch方法是then方法的语法糖</span><br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);<br>  &#125;<br>    <br>  <span class="hljs-comment">// ⭐ finally方法，其特性与then(onFinally, onFinally)有区别，所以单独实现</span><br>  <span class="hljs-function"><span class="hljs-title">finally</span>(<span class="hljs-params">onFinally</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; _status, _value, _flushed &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> onResolvedWrapper = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onFinally();<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">ignoredValue</span> =&gt;</span> resolve(value), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(value);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>  <br>      <span class="hljs-keyword">const</span> onRejectedWrapper = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onFinally();<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">ignoredValue</span> =&gt;</span> reject(reason), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reject(reason);<br>          &#125;          <br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <br>      <span class="hljs-keyword">switch</span> (_status) &#123;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FUlFILLED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果参数是MyPromise实例，直接返回这个实例，避免额外增加一个中间promise。</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) <span class="hljs-keyword">return</span> value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(reason))<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> n = promises.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> _counter = <span class="hljs-number">0</span>, _values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 如果数组中有元素不是Promise，则将其包装为Fulfilled的Promise</span><br>        <span class="hljs-keyword">if</span> (!(promises[i] <span class="hljs-keyword">instanceof</span> MyPromise)) &#123;<br>          promises[i] = MyPromise.resolve(promises[i]);<br>        &#125;<br>        promises[i].then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>          _values[_counter++] = v;<br>          <span class="hljs-keyword">if</span> (_counter === n) &#123;<br>            resolve(_values);<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>          reject(r);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> n = promises.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 如果数组中有元素不是Promise，则将其包装为Fulfilled的Promise</span><br>        <span class="hljs-keyword">if</span> (!(promises[i] <span class="hljs-keyword">instanceof</span> MyPromise)) &#123;<br>          promises[i] = MyPromise.resolve(promises[i]);<br>        &#125;<br>        promises[i].then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>          resolve(v);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>          reject(r);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="headerlink" title="event loop  事件循环"></a>event loop  事件循环</h2><p>本质：调度任务（函数）的模型、策略。</p><h3 id="JS为什么被设计为单线程执行？"><a href="#JS为什么被设计为单线程执行？" class="headerlink" title="JS为什么被设计为单线程执行？"></a>JS为什么被设计为单线程执行？</h3><p>JS设计之初，主要用于操作DOM，这决定了它只能是单线程执行的，否则会带来很复杂的问题。</p><p>例如，如果有两个线程，一个线程在某个DOM节点上添加内容，另一个节点删除了这个节点，就会带来同步问题。</p><h3 id="Web-Worker没有改变JS单线程本质"><a href="#Web-Worker没有改变JS单线程本质" class="headerlink" title="Web Worker没有改变JS单线程本质"></a>Web Worker没有改变JS单线程本质</h3><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，<font color='red'>但是子线程完全受主线程控制，且不得操作DOM</font>。所以，这个新标准并没有改变JavaScript单线程的本质。</p><h3 id="单线程的问题与任务队列"><a href="#单线程的问题与任务队列" class="headerlink" title="单线程的问题与任务队列"></a>单线程的问题与任务队列</h3><p>但是单线程也意味着所有任务都需要依次排队执行，这也会带来问题，例如网络请求会阻塞后续任务的执行，例如I/O操作也会造成阻塞。</p><p>所以JS就将代码分成了同步操作和异步操作，异步操作不阻塞同步代码，主线程会将其委托给底层的线程池，如果该操作在后台完成了，其回调会添加到任务队列，主线程空闲时将轮询任务队列并执行其中的回调。</p><blockquote><p>在JavaScript中，不论是浏览器环境还是Node环境，主线程既是任务的消费者（执行全局代码、同步函数与异步回调），也扮演轮询的角色（在空闲时轮询任务队列）。</p></blockquote><h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>“任务”可以理解为需要被同步执行的一段代码。</p><p>任务可以分为宏任务与微任务，在宏任务和微任务代码执行过程中可能又执行新的异步操作。</p><p><strong>宏任务包括：</strong></p><ol><li>浏览器环境下HTML文档中依赖的全部script脚本。</li><li>setTimeout、setInterval、setImmediate（Node环境）。</li><li>DOM事件的回调</li><li>页面UI渲染</li></ol><blockquote><p>⭐ 注意：</p><p>在浏览器环境下，<code>setTimeout(cb, 0)</code>等价于<code>setTimeout(cb, 4)</code>。</p><p>在Node.js环境下，<code>setTimeout(cb, 0)</code>等价于<code>setTimeout(cb, 1)</code>。</p><p>解释：原因在于如果设置延迟是0，含义相当于是同步执行，所以设置一个定时器到期的最小值（过一小会后执行）。</p></blockquote><p><strong>微任务包括：</strong></p><ol><li>Promise.prototype.resolve以及Promise.prototype.reject触发的“清空Promise任务队列”的任务。</li><li>创建MutationObeserver时传入的回调，会在DOM元素触发监听内容时执行。</li><li>Object.observe（已经废弃）</li><li>process.nextTick（Node环境）</li><li>H5中的web worker回调</li></ol><h3 id="浏览器环境下的事件循环模型"><a href="#浏览器环境下的事件循环模型" class="headerlink" title="浏览器环境下的事件循环模型"></a>浏览器环境下的事件循环模型</h3><p>浏览器环境下，为了协调网页事件（event）、用户交互（user interaction）、脚本执行（script）、页面渲染（rendering）、网络请求（newworking）等，必须使用<code>event loop</code>技术（类似于GUI编程中的消息循环）。</p><p>网页事件：<code>PostMessage❓</code>、<code>MutationObserver</code>等</p><p>用户交互：<code>click</code>、<code>scroll</code>等DOM事件的响应函数</p><p>页面渲染：创建、更新渲染树后进行绘图渲染</p><p>脚本执行：HTML文件中依赖的JS脚本</p><p>网络请求：<code>AJAX</code>、外链下载与处理</p><h3 id="Node-js-中的事件循环模型"><a href="#Node-js-中的事件循环模型" class="headerlink" title="Node.js 中的事件循环模型"></a>Node.js 中的事件循环模型</h3><h4 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h4><blockquote><p>Node.js官方文档中对Event Loop的介绍：</p><p><em>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.</em></p><p><em>Since most modern kernels are multi-threaded, they can handle multiple operations executing in the background. When one of these operations completes, the kernel tells Node.js so that the appropriate callback may be added to the <strong>poll</strong> queue to eventually be executed. We’ll explain this in further detail later in this topic.</em></p></blockquote><p>事件循环是Node.js实现异步IO的关键。尽管JavaScript是单线程执行的，但通过尽可能将一些（费时费力的）操作卸载到操作系统内核。</p><p>由于现代操作系统内核大多数是多线程的，它们可以在后台执行这些操作，并在合适的时机通知Node.js，<font color='red'>从而将相应的回调添加到Node.js的轮询队列中等待被主线程执行。</font></p><p><img src="/2021/07/21/JavaScript/mianshiti/image-20210708153456296.png" alt="主线程、后台线程池、任务队列"> </p><h4 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">   ┌───────────────────────────┐<br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │     pending callbacks     │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤  connections, │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │           check           │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br></code></pre></td></tr></table></figure><p><strong>Phases Overview</strong></p><ul><li><strong>timers</strong>: this phase executes callbacks scheduled by <code>setTimeout()</code> and <code>setInterval()</code>.</li><li><strong>pending callbacks</strong>: executes I/O callbacks deferred to the next loop iteration.</li><li><strong>idle, prepare</strong>: only used internally.</li><li><strong>poll</strong>: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and <code>setImmediate()</code>); node will block here when appropriate.</li><li><strong>check</strong>: <code>setImmediate()</code> callbacks are invoked here.</li><li><strong>close callbacks</strong>: some close callbacks, e.g. <code>socket.on(&#39;close&#39;, ...)</code>.</li></ul><p>Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down cleanly if there are not any.</p><h4 id="自己归纳的运行机制模型"><a href="#自己归纳的运行机制模型" class="headerlink" title="自己归纳的运行机制模型"></a>自己归纳的运行机制模型</h4><p><img src="/2021/07/21/JavaScript/mianshiti/image-20210708200904878.png" alt="image-20210708200904878"></p><p>⭐<strong>要点：</strong></p><ul><li><p>上述所有回调函数都是宏任务，最新版的Node.js中所有微任务的执行表现与浏览器环境下一致，即会在每个宏任务执行完之后轮询微任务队列，直到没有微任务为止，才执行下一个宏任务。</p></li><li><p>进入Timer阶段和Check阶段，如果队列为空，则直接进入下一阶段。</p></li><li><p>在进入Poll阶段前要进行两个检查，是否Timers队列中有新的回调？Check队列中是否已经有回调？</p></li><li><p>假如进入Poll阶段后，Poll队列中没有任务，且Timer Queue队列没有新的任务，且确实有异步操作在后台线程池执行，则主线程会在Poll阶段阻塞一段时间（同样有个最大时间阈值）。</p></li><li><p>其中最重要的就是进入Poll阶段后，假设此时Poll队列中有k个回调函数，执行1~k个回调都有可能（根据Node.js计算的阻塞在此阶段的时长阈值），然后在队列清空前，提前进入Check阶段，所以容易表现出怪异的测试用例，例如下面这个案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pause</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Date</span>.now() - start &gt;= ms) <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第1次读取完文件&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>  setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2&#x27;</span>)); <span class="hljs-comment">// immediate2和readFile2、3相对执行顺序不定</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2&#x27;</span>), <span class="hljs-number">0</span>);<br>&#125;)<br><br>pause(<span class="hljs-number">3</span>);<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第2次读取完文件:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>&#125;)<br><br>pause(<span class="hljs-number">3</span>);<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第3次读取完文件:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1&#x27;</span>), <span class="hljs-number">0</span>);<br>setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1&#x27;</span>));<br><br><br>pause(<span class="hljs-number">50</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;全局代码执行完毕:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="和浏览器环境最大的区别"><a href="#和浏览器环境最大的区别" class="headerlink" title="和浏览器环境最大的区别"></a>和浏览器环境最大的区别</h4><ol><li><p>对于浏览器的宏任务队列，该宏任务队列唯一，哪个异步操作先完成，其回调（宏任务）就先加入到宏任务队列，优先被主线程执行。</p></li><li><p>对于Node环境，其宏任务队列不唯一，包括Timer Queue、Poll Queue、Check Queue等，每个宏任务队列进行<code>flush</code>时有自己的特性，同时，不同的宏任务之间有优先级关系。</p><ul><li>Timer Queue是在原队列上进行flush。</li><li>Poll Queue有最长flush时间的限制。</li><li>Check Queue是对原队列进行浅拷贝后进行flush。</li></ul></li><li><p>对于不同版本的Node环境，微任务的执行时机不太一致，但最新版的Node的微任务执行实际好像表现得和浏览器环境一致。❓</p></li></ol><h2 id="JavaScript字符串操作"><a href="#JavaScript字符串操作" class="headerlink" title="JavaScript字符串操作"></a>JavaScript字符串操作</h2><h3 id="encodeURI和encodeURIComponent区别"><a href="#encodeURI和encodeURIComponent区别" class="headerlink" title="encodeURI和encodeURIComponent区别"></a>encodeURI和encodeURIComponent区别</h3><p><strong>编码范围</strong></p><ul><li><p><code>encodeURI</code>方法**<em>不会**</em>对下列字符编码： ASCII字母、数字、<code>~!@#$&amp;*()=:/,;?+&#39;</code>。</p></li><li><p><code>encodeURIComponent</code>方法**<em>不会**</em>对下列字符编码：ASCII字母、数字、<code>~!*()&#39;</code>。</p></li></ul><blockquote><p>所以<code>encodeURIComponent</code>比<code>encodeURI</code>编码的范围更大。</p><p>主要区别是<code>encodeURIComponent</code>会将<code>/?#=&amp;</code>等URL中常用的特殊字符进行编码。</p><p>实际例子来说，<code>encodeURIComponent</code>会把 <code>http://  </code>编码成 <code>http%3A%2F%2F</code>而<code>encodeURI</code>却不会。</p></blockquote><p><strong>应用场景</strong></p><ul><li><p>如果需要编码整个URL，而且URL中不存在URL语义范围外的特殊字符使用时，那么用<code>encodeURL</code>，相应地解码时使用<code>decodeURI</code>。</p><blockquote><p>例如 <code>encodeURI(&quot;http://www.cnblogs.com/season-huang/some other thing&quot;);</code></p><p>编码后会变为 <code>&quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;</code>。</p><p>其中空格被编码成了<code>%20</code>，除此之外，当URL的path部分存在中文时，也可以使用此方法。</p></blockquote></li><li><p>如果需要编码URL中的参数的时候，那么<code>encodeURIComponent</code>是最好的方法。</p><blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> param = <span class="hljs-string">&quot;http://www.cnblogs.com/season-huang/&quot;</span>; <span class="hljs-comment">//param为参数</span><br>param = <span class="hljs-built_in">encodeURIComponent</span>(param);<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;http://www.cnblogs.com?next=&quot;</span> + param;<br><span class="hljs-built_in">console</span>.log(url) <span class="hljs-comment">//&quot;http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到查询字符串中的参数值内的<code>/</code>需要被编码，因为这个参数值虽然是一个URL，但只是作为参数传递给后端服务器。<code>encodeURIComponent</code>对查询字符串的key和value进行编码时可以保证其中不存在可能破坏URL结构的特殊字符。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Node.js模块与包</title>
    <link href="/2021/07/19/Node/node%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"/>
    <url>/2021/07/19/Node/node%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h1><p>在Node.js中，一个<code>JS</code>文件就是一个模块，包也可以叫做模块。</p><p>模块化规范中的模块可以理解为<font color='red'>JS文件和包</font>。</p><p>但是<code>CommonJS</code>还可以导入<code>JSON</code>、<code>.node</code>文件。</p><h2 id="模块分类与导入规则"><a href="#模块分类与导入规则" class="headerlink" title="模块分类与导入规则"></a>模块分类与导入规则</h2><p><strong>1. 核心模块</strong></p><blockquote><p>其实叫做内置包更为准确。</p></blockquote><p><code>require(builtInPackageName)</code></p><p><strong>2.  本地文件模块</strong></p><p><code>require(path)</code> ，则按照指定路径查找。path应当为 ./  或 ../  开头的相对路径，以及绝对路径(包括以”/“开头的根目录绝对路径)。</p><ul><li>若path为相对路径，相对路径设置的值只和<font color='red'>当前执行的js文件位置有关(当前执行上下文)</font>。且当想要使用相对路径加载本目录下的JS模块时，’./‘不能省略</li><li>若path为绝对路径，在window下<code>/</code>代表<font color='red'>磁盘根目录</font>，Linux下<code>/</code>代表<code>/home</code></li></ul><blockquote><p>如果使用<code>require方法</code>按确切的模块文件名没有找到模块，则 Node.js 会尝试带上 <code>.js</code>、 <code>.json</code> 或 <code>.node</code> 拓展名再加载。</p><p><code>.js</code> 文件会被解析为 JavaScript 文本文件， <code>.json</code> 文件会被解析为 JSON 文本文件。 <code>.node</code> 文件会被解析为通过 <code>process.dlopen()</code> 加载的编译后的插件模块。</p><p>所以在使用require导包时，文件名末尾的<code>.js</code>或<code>.json</code>可以省略。</p></blockquote><p><strong>3. 第三方模块</strong></p><p><code>require(packageName)</code>,按照以下顺序查找该模块:</p><ol><li><p>查找本JS文件所在目录下的<code>node_modules</code>目录，若不存在该目录，则向上一级目录查找<code>node_modules</code>目录。</p></li><li><p><code>node_modules</code>目录中查找名为<code>packageName.js</code>的JS模块，如果不存在则再判断是否存在<code>packageName</code>目录，若仍不存在，向上一级目录中查找node_modules模块，即重复第一步。</p><ul><li><p>如果在某一级<code>node_modules</code>目录中找到了<code>packageName.js</code>，则获取该JS模块的module.exports，结束模块解析过程。</p></li><li><p>如果在某一级<code>node_modules</code>找到了<code>packageName</code>目录，则在<code>packageName</code>目录中查找<code>package.json</code>文件，查找该文件中main属性标注的入口js文件。若未标明入口文件，查找<code>packageName</code>目录中是否有<code>index.js</code>文件，若存在则将<code>index.js</code>作为入口JS文件。</p><ul><li>若连<code>index.js</code>文件都不存在，则再向上一级目录查找<code>node_modules</code>，即重复第一步。</li></ul></li></ul></li></ol><h2 id="模块封装器"><a href="#模块封装器" class="headerlink" title="模块封装器"></a>模块封装器</h2><p>在执行模块代码之前，Node.js 会使用一个如下的函数封装器将其封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>, <span class="hljs-built_in">module</span>, __filename, __dirname</span>) </span>&#123;<br><span class="hljs-comment">// 模块的代码实际上在这里</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>通过这样做，Node.js 实现了以下几点：</p><ul><li><p>它保持了JS模块顶层的变量（用 <code>var</code>、 <code>const</code> 或 <code>let</code> 定义）作用在模块范围内，而不是全局对象。</p></li><li><p>它有助于提供一些看似全局的但实际上是模块特定的变量，例如：</p><ul><li>实现者可以用于从模块中导出值的 <code>module</code> 和 <code>exports</code> 对象。</li><li>包含模块绝对文件名和目录路径的快捷变量 <code>__filename</code> 和 <code>__dirname</code> 。</li></ul></li></ul><h2 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h2><blockquote><p>以下变量看似是全局变量，实际是模块作用域中的局部变量。</p></blockquote><h3 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h3><p>返回<code>&lt;string&gt;</code></p><p>当前模块所在目录的绝对路径。 相当于<code>path.dirname(__filename)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例，从 /Users/mjr 运行 node example.js：</span><br><br><span class="hljs-built_in">console</span>.log(__dirname);<br><span class="hljs-comment">// 打印: /Users/mjr</span><br><span class="hljs-built_in">console</span>.log(path.dirname(__filename));<br><span class="hljs-comment">// 打印: /Users/mjr</span><br></code></pre></td></tr></table></figure><h3 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h3><p>返回<code>&lt;string&gt;</code></p><p>当前的模块文件的绝对路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例：从 /Users/mjr 运行 node example.js：</span><br><br><span class="hljs-built_in">console</span>.log(__filename);<br><span class="hljs-comment">// 打印: /Users/mjr/example.js</span><br><span class="hljs-built_in">console</span>.log(__dirname);<br><span class="hljs-comment">// 打印: /Users/mjr</span><br></code></pre></td></tr></table></figure><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>&lt;Object&gt;</code></p><p>对当前模块的引用。该对象保存了模块的信息。</p><h3 id="module-filename"><a href="#module-filename" class="headerlink" title="module.filename"></a>module.filename</h3><p><code>&lt;string&gt;</code></p><p>当前模块文件的绝对路径。（目录+文件名） 相当于<code>__filename</code></p><h3 id="module-id"><a href="#module-id" class="headerlink" title="module.id"></a>module.id</h3><p><code>&lt;string&gt;</code></p><p>模块的标识符，通常是当前模块文件的绝对路径。<font color='red'>入口模块</font>的<code>module.id</code>为<code>.</code>。</p><h3 id="module-loaded"><a href="#module-loaded" class="headerlink" title="module.loaded"></a>module.loaded</h3><p><code>&lt;boolean&gt;</code></p><p>模块是否已经加载完成。在CommonJS中当一个模块的代码被完整地执行完，加入到缓存中后，此属性值才被置为<code>true</code>。</p><h3 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h3><p><code>&lt;any&gt;</code></p><p><code>module.exports</code>用于指定一个模块所到处的内容，既可以通过<code>require()</code>访问的内容。</p><h3 id="exports-快捷方式"><a href="#exports-快捷方式" class="headerlink" title="exports 快捷方式"></a>exports 快捷方式</h3><p><code>exports</code> 变量是在模块的文件级作用域内可用的，且在模块执行之前赋值为 <code>module.exports</code>。</p><p>它允许使用快捷方式，因此 <code>module.exports.f = ...</code> 可以更简洁地写成 <code>exports.f = ...</code>。 但是，就像任何变量一样，如果为 <code>exports</code> 赋予了新值，则它将不再绑定到 <code>module.exports</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports.hello = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 从模块的引用中导出。</span><br><span class="hljs-built_in">exports</span> = &#123; <span class="hljs-attr">hello</span>: <span class="hljs-literal">false</span> &#125;;  <span class="hljs-comment">// 不导出，仅在模块中可用。</span><br></code></pre></td></tr></table></figure><p>当 <code>module.exports</code> 属性被新对象完全替换时，通常也会重新赋值 <code>exports</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">exports</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ... 如果不为exports赋值，它会仍然指向废弃掉的导出对象。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>为了说明这种行为，想象对 <code>require()</code> 的假设实现，它与 <code>require()</code> 的实际实现非常类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">⭐⭐⭐ <span class="hljs-comment">// 贴近Node.js的导包原理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">require</span>(<span class="hljs-params"><span class="hljs-comment">/* ... */</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = &#123; <span class="hljs-attr">exports</span>: &#123;&#125; &#125;;<br>  (<span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 模块代码在这。在这个例子中，定义了一个函数。</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    <span class="hljs-built_in">exports</span> = someFunc;<br>    <span class="hljs-comment">// 此时，exports 不再是一个 module.exports 的快捷方式，</span><br>    <span class="hljs-comment">// 且这个模块依然导出一个空的默认对象。</span><br>    <span class="hljs-built_in">module</span>.exports = someFunc;<br>    <span class="hljs-comment">// 此时，该模块导出 someFunc，而不是默认对象。</span><br>  &#125;)(<span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="require-id-方法"><a href="#require-id-方法" class="headerlink" title="require(id)方法"></a>require(id)方法</h3><p><strong>id</strong>：<code>&lt;string&gt;</code> 模块的名称或路径。</p><p><strong>返回值</strong>：<code>&lt;any&gt;</code>导入的模块内容（<code>module.exports</code>）</p><p>用于引入模块、 <code>JSON</code>、或本地文件。 可以从 <code>node_modules</code> 引入模块。 可以使用相对路径（例如 <code>./</code>、 <code>./foo</code>、 <code>./bar/baz</code>、 <code>../foo</code>）引入本地模块或 JSON 文件，路径会根据 <a href="http://nodejs.cn/api/modules.html#modules_dirname"><code>__dirname</code></a> 定义的目录名或当前工作目录进行处理。 </p><blockquote><p>上面最后一句话的意思是：</p><p>CommonJS在使用相对路径导包时，会进行路径处理，使得相对路径的源路径是当前执行模块，而非启动模块。具体实现是将相对路径与当前<code>__dirname</code>结合。</p></blockquote><p>POSIX 风格的相对路径会以与操作系统无关的方式解析，这意味着上面的示例将会在 Windows 上以与在 Unix 系统上相同的方式工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用相对于 `__dirname` 或当前工作目录的路径引入一个本地模块。</span><br><span class="hljs-comment">// （在 Windows 上，这会解析为 .\path\myLocalModule。）</span><br><span class="hljs-keyword">const</span> myLocalModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./path/myLocalModule&#x27;</span>);<br><br><span class="hljs-comment">// 引入 JSON 文件：</span><br><span class="hljs-keyword">const</span> jsonData = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./path/filename.json&#x27;</span>); <span class="hljs-comment">// 导入的为一个json对象</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(jsonData)); <br><br><span class="hljs-comment">// 引入 node_modules 模块或 Node.js 内置模块：</span><br><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><ul><li><p>CommonJS使用一个缓存对象来管理缓存，可以通过<code>require.cache</code>访问缓存对象。</p></li><li><p><font color='red'>模块在第一次加载后就会被保存到缓存对象中。</font> 这也意味着（类似其他缓存机制）在第一次加载之后，不论何时何地，如果多次导入该模块都解析到同一文件，从缓存中得到相同的导出对象 / 导出内容 。</p></li><li><p>CommonJS在第一次导入某个模块时会立即执行模块作用域中的代码。</p></li><li><p><font color='red'>模块作用域中的代码只会被执行一次</font>，多次导入同一模块 <font color='red'>不会导致模块的代码被执行多次</font>。 </p><blockquote><p>这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。</p></blockquote></li><li><p><font color='red'>如果想要多次执行一个模块中的部分代码，可以将这部分代码封装成函数并导出</font>，然后供其他模块调用该函数。</p></li></ul><p>❗ <strong>注意点：</strong></p><ol><li><p>模块是基于其解析的文件名进行缓存的。 由于调用模块的位置的不同，模块可能被解析成不同的文件名（比如从 <code>node_modules</code> 目录加载），这样就不能保证 <code>require(&#39;foo&#39;)</code> 总能返回完全相同的对象。</p><blockquote><p>这句话的意思是，判断一个模块是否在缓存中，是通过 <code>__filename</code> 索引来判断的。</p><p>缓存的结构是一个键值对对象，各个模块保存在缓存对象的属性中，属性名为 <code>完整的文件路径</code>，属性值为<code>模块对象[module]</code>。</p></blockquote></li><li><p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，但缓存仍然会将它们视为不同的模块，并多次重新加载。 例如， <code>require(&#39;./foo&#39;)</code> 和 <code>require(&#39;./FOO&#39;)</code> 返回两个不同的对象，而不会管 <code>./foo</code> 和 <code>./FOO</code> 是否是相同的文件。</p></li></ol><h2 id="CommonJS-循环加载处理策略"><a href="#CommonJS-循环加载处理策略" class="headerlink" title="CommonJS 循环加载处理策略"></a>CommonJS 循环加载处理策略</h2><p>循环加载指的是a脚本的执行依赖b脚本，b脚本的执行依赖a脚本。</p><p><strong>CommonJS模块的加载原理</strong></p><p>CommonJS模块就是一个脚本文件，require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成该模块的一个说明对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  id: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">//模块名，唯一</span><br>  <span class="hljs-built_in">exports</span>: &#123; <span class="hljs-comment">//模块输出的各个接口</span><br>    ...<br>  &#125;,<br>  loaded: <span class="hljs-literal">true</span>, <span class="hljs-comment">//模块的脚本是否执行完毕</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>以后用到这个模块时，就会到对象的exports属性中取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。</p><p>CommonJS模块是加载时执行，即脚本代码在require时就全部执行。一旦出现某个模块被“循环加载”，就只输出已经执行的部分，没有执行的部分不会输出。</p><p><strong>案例说明</strong></p><p>案例来源于Node官方说明： <a href="https://nodejs.org/api/modules.html#modules_cycles">https://nodejs.org/api/modules.html#modules_cycles</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//a.js</span><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;在a.js中，b.done = %j&#x27;</span>, b.done);<br><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a.js执行完毕！&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//b.js</span><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;在b.js中，a.done = %j&#x27;</span>, a.done);<br><br><span class="hljs-built_in">exports</span>.done = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;b.js执行完毕！&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;main 开始&#x27;</span>);<br><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a.js&#x27;</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b.js&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;在main.js中，a.done = %j, b.done = %j&#x27;</span>, a.done, b.done);<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ node main.js<br>main 开始<br><span class="hljs-selector-tag">a</span> 开始<br><span class="hljs-selector-tag">b</span> 开始<br>在 <span class="hljs-selector-tag">b</span> 中，<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.done</span> = false<br><span class="hljs-selector-tag">b</span> 结束<br>在 <span class="hljs-selector-tag">a</span> 中，<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.done</span> = true<br><span class="hljs-selector-tag">a</span> 结束<br>在 main 中，<span class="hljs-selector-tag">a</span>.done=true，<span class="hljs-selector-tag">b</span>.done=true<br></code></pre></td></tr></table></figure><p>当 <code>main.js</code> 加载 <code>a.js</code> 时， <code>a.js</code> 又加载 <code>b.js</code>。 此时， <code>b.js</code> 会尝试去加载 <code>a.js</code>。 为了防止无限的循环，会返回一个 <code>a.js</code> 的 <code>exports</code> 对象的 <strong>未完成的副本</strong> 给 <code>b.js</code> 模块。 然后 <code>b.js</code> 完成加载，并将 <code>exports</code> 对象提供给 <code>a.js</code> 模块。</p><hr><h1 id="ES6-模块化规范"><a href="#ES6-模块化规范" class="headerlink" title="ES6 模块化规范"></a>ES6 模块化规范</h1><p><code>ECMAScript modules</code>即ES6模块化规范是JS模块化实现的官方标准形式。模块和模块之间通过一些列的<code>import</code>和<code>export</code>语句进行关联。</p><h2 id="导出内容的语法"><a href="#导出内容的语法" class="headerlink" title="导出内容的语法"></a>导出内容的语法</h2><h3 id="1-export-变量初始化"><a href="#1-export-变量初始化" class="headerlink" title="1.export + 变量初始化"></a>1.export + 变量初始化</h3><p><code>export let/const 变量名 = 初始值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* es-module.mjs */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> version = <span class="hljs-string">&quot;1.1.1&quot;</span>; <span class="hljs-comment">// export导出的变量必须在声明时初始化一个值。⭐</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-export-…"><a href="#2-export-…" class="headerlink" title="2.export {…}"></a>2.export {…}</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* es-module.mjs */</span><br><br><span class="hljs-keyword">const</span> version = <span class="hljs-string">&quot;1.1.1&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123;<br>version,<br>    foo<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ 在<code>export &#123;..&#125;</code>中使用<code>as</code>也可以修改导出内容的名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> &#123;<br> version <span class="hljs-keyword">as</span> v,<br> foo <span class="hljs-keyword">as</span> bar<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>外部导入 export{…} 导出的内容时，需要使用 import {…} from，导出内容的名称要统一。</p></blockquote><h3 id="3-export-default-…"><a href="#3-export-default-…" class="headerlink" title="3.export default {…}"></a>3.export default {…}</h3><p><code>export default &#123;...&#125;</code>为外部提供了一个默认的导出接口和一个可自定义的命名空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo;<br><span class="hljs-keyword">const</span> version;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-string">&quot;version&quot;</span> : version<br>    <span class="hljs-string">&quot;foo&quot;</span>: foo<br>&#125;<br><br><span class="hljs-comment">// ⭐ 或者使用对象属性的简写：</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    version,<br>    foo<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-组合语法"><a href="#4-组合语法" class="headerlink" title="4.组合语法"></a>4.组合语法</h3><p>组合语法是语法1、语法3、语法3的组合，即在同一模块中使用多种导出语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;m&quot;</span>;<br><br><span class="hljs-keyword">export</span> &#123;<br>name <span class="hljs-keyword">as</span> n  <span class="hljs-comment">// ⭐ export &#123;...&#125; 中导出的内容不可以与export重名，否则会导致冲突</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    name <span class="hljs-comment">// ⭐ 不需要考虑重名问题</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Module实例"><a href="#Module实例" class="headerlink" title="Module实例"></a>Module实例</h2><p>在<code>ES6</code>规范中，一个JS模块就是一个<code>Module</code>类的实例。</p><ul><li><p>模块中使用<code>export/export &#123;...&#125;</code>导出的内容会成为<code>Module实例</code>的属性。</p><blockquote><p>这也解释了为什么 export {…}中的内容和 export 导出的内容不能重名。</p></blockquote></li><li><p>而<code>export default &#123;...&#125;</code>导出的这个对象会挂载到<code>Module实例</code>的<code>default</code>属性上。</p><blockquote><p>如果模块中没有使用 export default 语法，则 Module实例不存在default属性。</p></blockquote></li></ul><h2 id="导入模块的语法"><a href="#导入模块的语法" class="headerlink" title="导入模块的语法"></a>导入模块的语法</h2><p>在<font color='red'>Node.js 环境中</font>，ES6 的 <code>import ... from ..</code>会按照 <code>CommonJS</code>的规则去搜寻目标模块，并将该模块封装成ES6的<code>Module实例</code>。</p><h3 id="1-import-…-from-…"><a href="#1-import-…-from-…" class="headerlink" title="1.import {…} from …"></a>1.import {…} from …</h3><p>能够解构出<code>Module实例</code>的指定属性。</p><h3 id="2-import-命名空间-from-…"><a href="#2-import-命名空间-from-…" class="headerlink" title="2.import 命名空间 from …"></a>2.import 命名空间 from …</h3><p>能够获取<code>Module实例</code>的<code>default</code>属性值，并赋值给命名空间变量。</p><h3 id="3-import-as-命名空间-from-…"><a href="#3-import-as-命名空间-from-…" class="headerlink" title="3.import * as 命名空间 from …"></a>3.import * as 命名空间 from …</h3><p>能够获取目标模块内<code>导出语法1</code> 和 <code>导出语法2</code> 的<font color='red'>全部内容</font>。</p><h3 id="4-import-命名空间-…-from-…"><a href="#4-import-命名空间-…-from-…" class="headerlink" title="4.import 命名空间 , {…} from …"></a>4.import 命名空间 , {…} from …</h3><p>能够获取目标模块内<code>导出语法1</code>和<code>导出语法2</code>的<font color='red'>指定内容</font>，并能够获取<code>导出语法3</code>的<font color='red'>全部内容</font>。</p><h2 id="使用import导入CommonJS模块"><a href="#使用import导入CommonJS模块" class="headerlink" title="使用import导入CommonJS模块"></a>使用import导入CommonJS模块</h2><p><strong>在较新的<font color='red'>Node.js环境中</font>，允许开发者使用<code>ES6</code>的<code>import ... from ..</code>语句导入一个<code>CommonJS</code>模块。当Node.js识别到正在用<code>ES6</code>语法导入目标模块的<code>module.exports</code>时，会进行以下操作：</strong></p><p>⭐</p><ol><li>将<code>module.exports</code>封装成一个<code>ES6</code>的<font color='red'>Module实例</font>。</li><li>将<code>module.exports</code>的内容会挂载到<font color='red'>Module实例</font>的<code>default</code>属性上。</li><li>如果<code>module.exports</code>是引用类型，则它的各个属性也挂载到<font color='red'>Module实例</font>上。</li></ol><p><strong>例如：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// cjs.cjs</span><br><span class="hljs-built_in">exports</span>.name = <span class="hljs-string">&#x27;exported&#x27;</span>;<br></code></pre></td></tr></table></figure><p>以下JS文件将导入<code>cjs.cjs</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cjs.cjs&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(m1);<br><span class="hljs-comment">// Prints: [Module] &#123; default: &#123; name: &#x27;exported&#x27; &#125;, name: &#x27;exported&#x27; &#125;</span><br><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> cjs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cjs.cjs&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(cjs);<br><span class="hljs-comment">// Prints: &#123; name: &quot;exported&quot;&#125;</span><br><br><span class="hljs-comment">// 也可以：</span><br><span class="hljs-keyword">import</span> &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cjs.cjs&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>语法糖写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> cjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./cjs.cjs&#x27;</span>; <br><span class="hljs-comment">// 直接获取module.exports 并命名为cjs</span><br><span class="hljs-comment">// 代替 import &#123; default as cjs &#125; from &#x27;./cjs.cjs&#x27;;</span><br></code></pre></td></tr></table></figure><blockquote><p>用Node.js官方文档的原话来说，这种写法 等价且简介。 “equivalent and sweeter”</p></blockquote><hr><h1 id="判断JS文件的模块化系统"><a href="#判断JS文件的模块化系统" class="headerlink" title="判断JS文件的模块化系统"></a>判断JS文件的模块化系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Node.js环境中，从入口JS文件开始，不论是使用<code>import</code>语句还是<code>require</code>语句，都可以加载模块，但是目标模块（将要被导入的JS文件）的模块化规范对于当前JS文件是未知的。所以我们需要一套规则来指引Node，让它知道该用何种模块化规范导出目标模块（JS文件）的内容。</p><h2 id="使用-require-语句导入模块"><a href="#使用-require-语句导入模块" class="headerlink" title="使用 require 语句导入模块"></a>使用 require 语句导入模块</h2><p>一个JS文件遵循“CommonJS规范”，用<code>require</code>导包时，<font color='red'>Node会按CommonJS去获取目标模块中的内容</font>。所以使用<code>require(id)</code>方法只能导入使用CommonJS规范导出内容的模块。</p><p>若尝试用<code>require(id)</code>导入一个按照<code>ES6</code>规范导入内容的包，<font color="red">此时Node会报错</font>。</p><h2 id="使用-import-语句导入模块"><a href="#使用-import-语句导入模块" class="headerlink" title="使用 import 语句导入模块"></a>使用 import 语句导入模块</h2><p>一个JS文件遵循“ES6模块化规范”，使用<code>import ... from &#39;...&#39;</code>导入模块时，Node会<font color='red'>优先分析</font> ①目标模块的扩展名 ，<font color='red'>再分析</font>② 离目标模块最近的❓<code>package.json</code>文件的<code>type</code>字段，从而判断用何种规范去解析目标模块的导出内容。</p><blockquote><p><strong>离目标模块最近的package.json</strong>是指从<font color='red'>目标模块所在目录及上级目录中，相对路径最短的package.json文件</font>。</p></blockquote><p><strong>Node.js解析以下情况的模块时，会按<code>ES6</code>规范去获取导出内容：</strong></p><ol><li>目标模块的扩展名为<code>.mjs</code>。</li><li>目标模块的扩展名为<code>.js</code>，但是离目标模块最近的<code>package.json</code>文件中的<code>type</code>字段的属性值为<code>module</code>。</li></ol><p><strong>Node.js解析以下情况的模块时，会按<code>CommonJS</code>规范去获取导出内容：</strong></p><ol><li>目标模块的扩展名为<code>.cjs</code>。</li><li>目标模块的扩展名为<code>.js</code>，但是离目标模块最近的<code>package.json</code>文件中的<code>type</code>字段的属性值为<code>commonjs</code></li><li>目标模块的扩展名为<code>.js</code>，但是离目标模块存在最近的<code>package.json</code>文件，但该文件中不存在<code>type</code>字段。⭐（即使是更上层目录中有package.json文件存在type: ‘module’配置）。</li><li>目标模块的扩展名为<code>.js</code>，但是<font color='red'>不存在</font>离目标模块最近的<code>package.json</code>，即<font color='red'>从目标文件所在目录到磁盘根目录都不存在</font><code>package.json</code>。</li></ol><blockquote><p>使用<code>import xxx from &#39;...&#39;</code>导入一个<code>CommonJS</code>模块时，<code>xxx</code>的值为模块的<code>module.exports</code>。</p></blockquote><p><a href="http://nodejs.cn/api/packages.html#packages_determining_module_system">Node.js文档判断模块系统原文</a></p><p>Node.js will treat the following as <a href="http://nodejs.cn/api/esm.html">ES modules</a> when passed to <code>node</code> as the initial input, or when referenced by <code>import</code> statements within ES module code:</p><ul><li>Files ending in <code>.mjs</code>.</li><li>Files ending in <code>.js</code> when the nearest parent <code>package.json</code> file contains a top-level <a href="http://nodejs.cn/api/packages.html#packages_type"><code>&quot;type&quot;</code></a> field with a value of <code>&quot;module&quot;</code>.</li><li>Strings passed in as an argument to <code>--eval</code>, or piped to <code>node</code> via <code>STDIN</code>, with the flag <code>--input-type=module</code>.</li></ul><p>Node.js will treat as <a href="http://nodejs.cn/api/modules.html">CommonJS</a> all other forms of input, such as <code>.js</code> files where the nearest parent <code>package.json</code> file contains no top-level <code>&quot;type&quot;</code> field, or string input without the flag <code>--input-type</code>. This behavior is to preserve backward compatibility. However, now that Node.js supports both CommonJS and ES modules, it is best to be explicit whenever possible. Node.js will treat the following as CommonJS when passed to <code>node</code> as the initial input, or when referenced by <code>import</code> statements within ES module code:</p><ul><li>Files ending in <code>.cjs</code>.</li><li>Files ending in <code>.js</code> when the nearest parent <code>package.json</code> file contains a top-level field <a href="http://nodejs.cn/api/packages.html#packages_type"><code>&quot;type&quot;</code></a> with a value of <code>&quot;commonjs&quot;</code>.</li><li>Strings passed in as an argument to <code>--eval</code> or <code>--print</code>, or piped to <code>node</code> via <code>STDIN</code>, with the flag <code>--input-type=commonjs</code>.</li></ul><p>Package authors should include the <a href="http://nodejs.cn/api/packages.html#packages_type"><code>&quot;type&quot;</code></a> field, even in packages where all sources are CommonJS. Being explicit about the <code>type</code> of the package will future-proof the package in case the default type of Node.js ever changes, and it will also make things easier for build tools and loaders to determine how the files in the package should be interpreted.</p><h2 id="使用-import-动态导入"><a href="#使用-import-动态导入" class="headerlink" title="使用 import() 动态导入"></a>使用 import() 动态导入</h2><p>在按照 <code>ES6</code>和<code>CommonJS</code>规则编写的JS模块中，都可以使用<code>import(id)</code>来动态导入其他模块，而且目标模块既可以是<code>ES6</code>模块，也可以是<code>CommonJS</code>模块。</p><p>此外，<code>import(id)</code>语法是动态导入，可以嵌套到<code>if</code>语句中。</p><p>但是<code>import(id)</code>是由<code>promise</code>封装的异步方法，它返回一个<code>promise实例</code>，当导入成功时<code>promise实例</code>的值为目标模块的内容。</p><h2 id="ES6模块编译成CommonJS模块"><a href="#ES6模块编译成CommonJS模块" class="headerlink" title="ES6模块编译成CommonJS模块"></a>ES6模块编译成CommonJS模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ES6模块</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br><span class="hljs-keyword">export</span> &#123;<br>bar: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    name: <span class="hljs-string">&#x27;es6 module&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 编译成CommonJS模块的结果：</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;); <span class="hljs-comment">/* 👈 为module.exports添加</span><br><span class="hljs-comment">__esModule属性，属性值为true*/</span><br><span class="hljs-built_in">exports</span>.foo = <span class="hljs-string">&#x27;foo&#x27;</span>; <span class="hljs-comment">// 👈 原来ES6语法：export let/const ... </span><br><br><span class="hljs-built_in">exports</span>.bar = <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 👈 原来ES6语法： export &#123;...&#125;</span><br><br><span class="hljs-built_in">exports</span>.default = &#123;  <span class="hljs-comment">// 👈 原来ES6语法： export default ...。挂载到了module.exports.default下</span><br>    name: <span class="hljs-string">&#x27;es6 module&#x27;</span><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h1 id="Node-js中的包"><a href="#Node-js中的包" class="headerlink" title="Node.js中的包"></a>Node.js中的包</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Node.js中，一个JS文件就是一个模块，一个模块可以依赖于另外一个模块。</p><p>将模块有机地组织成一个目录文件树，并在顶层目录拥有一个<code>package.json</code>文件，这个目录就是一个包。</p><blockquote><p>但是根据Node.js加载模块的规则，只有存放在<code>node_modules</code>目录下且具有<code>package.json</code>文件的文件夹<font color='red'>才是可以被正确导入的包</font>。</p></blockquote><h2 id="package-json的作用"><a href="#package-json的作用" class="headerlink" title="package.json的作用"></a>package.json的作用</h2><p><code>package.json</code>文件中的键值对可以描述包，包括 ①包的名字、②包的入口、③内部映射、④外部依赖等信息。</p><h3 id="包的名字"><a href="#包的名字" class="headerlink" title="包的名字"></a>包的名字</h3><p><code>name</code>字段用于指定包的名字。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-package&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="包的入口"><a href="#包的入口" class="headerlink" title="包的入口"></a>包的入口</h3><p>在一个包的<code>package.json</code>文件中，有两个字段可以定义包的入口文件，分别是<code>main</code>和<code>exports</code>。所有版本的Node.js都支持由<code>main</code>字段描述包的入口，而新版本的Node.js支持由<code>exports</code>定义包的入口，而且它的功能更加强大。</p><h4 id="exports和main的优先级"><a href="#exports和main的优先级" class="headerlink" title="exports和main的优先级"></a>exports和main的优先级</h4><ul><li><p>在新版本Node.js中，<code>exports</code>字段拥有更高的优先级，如果<code>package.json</code>中存在<code>exports</code>字段，则<code>main</code>字段不再起作用。</p></li><li><p>但是<code>main</code>字段可以作为向下兼容的备选出口而存在。即旧版本的Node.js始终将<code>main</code>字段定义的出口模块作为包的出口。</p></li></ul><h4 id="主入口的导出"><a href="#主入口的导出" class="headerlink" title="主入口的导出"></a>主入口的导出</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;.&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span>, <span class="hljs-comment">//  &quot;.&quot; 代表导包时的主入口</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>语法糖写法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 当使用exports只导出主入口时，可以像main字段一样简写入口</span><br>&#123;<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;exports&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用exports定义子入口"><a href="#使用exports定义子入口" class="headerlink" title="使用exports定义子入口"></a>使用exports定义子入口</h4><p><code>exports</code>字段允许我们定义包的子入口。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-package&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span>,<br>  <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;.&quot;</span>: <span class="hljs-string">&quot;./main.js&quot;</span>,<br>    <span class="hljs-attr">&quot;./submodule&quot;</span>: <span class="hljs-string">&quot;./src/submodule.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过子入口，外部可以导入模块的子模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> mySubModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my-package/submodule&#x27;</span>;<br><span class="hljs-comment">// Loads ./node_modules/my-package/src/submodule.js</span><br></code></pre></td></tr></table></figure><p>但需要注意的是，只有<code>package.json</code>中定义了的子入口才能够被导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> anotherModule <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my-package/another&#x27;</span>;<br><span class="hljs-comment">// ❌ Throws ERR_PACKAGE_PATH_NOT_EXPORTED</span><br></code></pre></td></tr></table></figure><h4 id="有条件的导出和双包"><a href="#有条件的导出和双包" class="headerlink" title="有条件的导出和双包"></a>有条件的导出和双包</h4><p><code>package.json</code>中的<code>exports</code>支持包的管理者根据不同的条件，将同一个导出路径分发到不同的入口模块。</p><p><strong>应用于双包模块</strong></p><p>例如，如果一个包想根据调用该包的JS文件的导入语句（<code>require() / import</code>）来导出不同的模块，可以这样做：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;my-package&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;./main-require.cjs&quot;</span>,<br>  <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;import&quot;</span>: <span class="hljs-string">&quot;./main-module.js&quot;</span>,<span class="hljs-comment">// main-module.js包内使用import语句导入包内模块</span><br>    <span class="hljs-attr">&quot;require&quot;</span>: <span class="hljs-string">&quot;./main-require.cjs&quot;</span> <br>  &#125;,<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>⭐⭐</p><p>这样做的好处是调用该包的JS文件并不清楚这个包内文件的模块化规范，为了实现一个包能够被两种语句导入，包内模块管理的<font color='red'>一种策略</font>是：</p><ol><li><p>首先，包内整体使用<code>CommonJS</code>模块化规范，即核心功能代码都使用<code>CommonJS</code>，导入和导出使用<code>require/ module.exports</code>。</p></li><li><p><code>require</code>导出的入口文件的扩展名设置为<code>.cjs</code>或<code>.js</code>。（只会按<code>CommonJS</code>解析包内内容）</p></li><li><p><code>import</code>导出的入口文件扩展名为<code>.js</code>或<code>.mjs</code>。如果设置为为<code>js</code>，则<code>package.json</code>的<code>type</code>字段的值要设置为<code>module</code>，且包内所有使用<code>CommonJS</code>的模块扩展名都应该为<code>.cjs</code>。</p></li></ol><h4 id="双包的危害"><a href="#双包的危害" class="headerlink" title="双包的危害"></a>双包的危害</h4><p><a href="http://nodejs.cn/api/packages.html#packages_dual_commonjs_es_module_packages">点击查看Node.js相关说明</a></p><p>双包的危害即<code>dual package hazard</code>。当一个JS包为了能够让不同的导入语句<code>import/require</code>获取包内的内容时，会提供两个入口。而当两个出口导出的是不同的导出对象时，就容易导致意想不到的Bug。</p><p><strong>双包危害发生时的表现</strong>：</p><p>假如当一个模块<code>main</code>依赖于<code>foo</code>模块，又依赖于<code>bar</code>模块，<code>bar</code>模块又依赖于<code>foo</code>。在<code>main</code>中导入<code>foo</code>使用的是<code>ES6</code>语法，<code>bar</code>中导入<code>foo</code>使用的是<code>CommonJS</code>语法，❗ 这就会导致<code>main</code>和<code>bar</code>中导入的<code>foo</code>很可能不是同一个模块对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ./node_modules/foo/package.json</span><br>&#123;<br>   <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>    <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>        <span class="hljs-attr">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ======================================</span><br><span class="hljs-comment">/* ./node_modules/foo/index.cjs */</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">exports</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    count += n;<br>&#125;<br><br><span class="hljs-built_in">exports</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;count:&quot;</span>, count);<br>&#125;<br><br><span class="hljs-comment">//=======================================</span><br><span class="hljs-comment">// ./node_modules/foo/index.mjs</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    count += n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;count:&quot;</span>, count);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    add,<br>    print<br>&#125;<br><br><span class="hljs-comment">//=======================================</span><br><span class="hljs-comment">// ./bar.cjs</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-built_in">exports</span>.add = foo.add;<br><span class="hljs-built_in">exports</span>.print = foo.print;<br><br><span class="hljs-comment">//=======================================</span><br><span class="hljs-comment">// ./main.mjs</span><br><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./bar.js&#x27;</span>;<br>bar.add(<span class="hljs-number">1</span>);<br>foo.print(); <span class="hljs-comment">// ⭐ 输出0，证明bar中的foo模块和main导入的foo模块不是同一个对象</span><br></code></pre></td></tr></table></figure><p><strong>最小化双包危害的方案：</strong></p><ol><li><p><code>ES模块封装器</code></p><p>在上例中，对<code>foo</code>包内的<code>index.mjs</code>进行修改，重命名为<code>es-wrapper.mjs</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ./node_modules/foo/package.json</span><br><br>&#123;<br>   <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>    <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>        <span class="hljs-attr">&quot;import&quot;</span>: <span class="hljs-string">&quot;./es-wrapper.mjs&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ./node_modules/foo/es-wrapper.mjs</span><br><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.cjs&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> foo;<br></code></pre></td></tr></table></figure></li><li><p><code>隔离状态</code></p><p>如果一个JS包是无状态的，且不考虑包的副本的冗余，可以不用考虑双包风险。因为不会出现让开发者意想不到的结果，只是内存中会存在一个包的两份代码。</p><p>但是上例中，存在状态<code>count</code>，为了保证内存中一个包只有一个状态，包内就需要对状态进行隔离。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ./node_modules/foo/package.json</span><br><br>&#123;<br>   <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;foo&quot;</span>,<br>    <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;require&quot;</span>: <span class="hljs-string">&quot;./index.cjs&quot;</span>,<br>        <span class="hljs-attr">&quot;import&quot;</span>: <span class="hljs-string">&quot;./index.mjs&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>foo</code>包内新增<code>state.cjs</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ./node_modules/foo/state.cjs</span><br><span class="hljs-keyword">let</span> state = &#123;  <span class="hljs-comment">// 被隔离的状态</span><br>    count: <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-built_in">module</span>.exports = state;<br></code></pre></td></tr></table></figure><p>修改<code>index.cjs</code>和<code>index.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ./node_modules/foo/index.cjs</span><br><span class="hljs-keyword">const</span> state = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./state.cjs&#x27;</span>);<br><br><span class="hljs-built_in">exports</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    state.count += n;<br>&#125;<br><br><span class="hljs-built_in">exports</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(state.count);<br>&#125;<br><br><span class="hljs-comment">//========================================</span><br><span class="hljs-comment">// ./node_modules/foo/index.mjs</span><br><span class="hljs-keyword">import</span> state <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./state.cjs&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    state.count += n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(state.fn);<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    add,<br>    print<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这样做虽然隔离了状态，但是一个包在内存中仍然有两份代码。</p></blockquote></li></ol><hr><h3 id="包内路径别名（内部映射）"><a href="#包内路径别名（内部映射）" class="headerlink" title="包内路径别名（内部映射）"></a>包内路径别名（内部映射）</h3><p>除了<code>exports</code>字段之外，<code>Package.json</code>文件还可以用<code>imports</code>字段定义<font color='red'>包内文件相互导入的路径别名</font>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ./node_modules/es-module-package/package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;exports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;./features/*&quot;</span>: <span class="hljs-string">&quot;./src/features/*.js&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;imports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;#internal/*&quot;</span>: <span class="hljs-string">&quot;./src/internal/*.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但需要注意的是<code>imports</code>字段定义的路径别名都需要以<code>#</code>开头，将<code>包内路径别名</code>和<code>向包外导出的子路径别名</code>区分开来。</p><blockquote><p>包内路径别名也可以有条件地导出。👇</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// package.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;imports&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;#dep&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;node&quot;</span>: <span class="hljs-string">&quot;dep-node-native&quot;</span>,<br>      <span class="hljs-attr">&quot;default&quot;</span>: <span class="hljs-string">&quot;./dep-polyfill.js&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;dep-node-native&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Node-js-API"><a href="#Node-js-API" class="headerlink" title="Node.js API"></a>Node.js API</h1><h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><h3 id="path-resolve-和-path-join-的区别"><a href="#path-resolve-和-path-join-的区别" class="headerlink" title="path.resolve 和 path.join 的区别"></a>path.resolve 和 path.join 的区别</h3><p><code>path.join</code>和<code>path.resolve</code>函数都允许传入多个字符串，将参数拼接后返回一个路径字符串。</p><p>但是在使用他们时，要考虑到其中的区别。</p><blockquote><p>在path.join和path.resolve函数的参数中，参数末尾的<code>/</code>不会起作用。</p><p>在path.join函数中，参数开头的<code>/</code>也不起作用，而在path.resolve中，参数的开头谨慎使用<code>/</code>。</p></blockquote><p><strong>一、path.resolve()方法</strong></p><p>我们可以将<code>path.resolve</code>方法<font color='red'>解析路径的起点是执行Node命令的工作目录</font>，跟path.resolve方法执行的位置无关，我们且将工作目录称作<code>root</code>。</p><p><code>path.resolve(subpath0, subpath1, subpath2, ...)</code>返回一个路径，该路径相当于不断地执行<code>cd</code>命令，</p><p>基于<code>root</code>，先<code>cd subpath0</code>，然后<code>cd subpath1</code>，再不断<code>cd</code>，最后返回切换到的所在目录。</p><p>❗ 需要注意的是，如果参数中有以磁盘<code>X:</code>或<code>/</code>开头的字符串，则将会切换到平台的根目录下。</p><blockquote><p>当然 path.resolve方法不会真的去切换目录，上面这段话会帮助我们理解path.resolve的算法。</p></blockquote><p>⭐ 例子：</p><p>假设当前工作目录为<code> E:\</code>， 同时<code>E:\test\index.js</code>中的内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log( path.resolve() );<br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>) );<br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>) );<br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>));<br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>));<br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;C:\\dist&#x27;</span>, <span class="hljs-string">&#x27;img&#x27;</span>));<br></code></pre></td></tr></table></figure><p>执行 <code>node ./test/index.js</code>，输出结果如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log( path.resolve() );                 <span class="hljs-comment">// 输出👉  &quot;E:\\&quot;</span><br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>) );     <span class="hljs-comment">// 输出👉  &quot;E:\\foo\\bar&quot;</span><br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>) );       <span class="hljs-comment">// 输出👉  &quot;E:\\foo&quot;</span><br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>));     <span class="hljs-comment">// 输出👉  &quot;E:\\bar&quot;</span><br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>)) <span class="hljs-comment">// 输出👉  &quot;E:\\foo&quot;</span><br><span class="hljs-built_in">console</span>.log( path.resolve(<span class="hljs-string">&#x27;C:\\dist&#x27;</span>, <span class="hljs-string">&#x27;img&#x27;</span>)); <span class="hljs-comment">// 输出👉  &quot;C:\\dist\\img&quot;</span><br></code></pre></td></tr></table></figure><p><strong>二、path.join()方法</strong></p><p>该方法只是将参数中的路径进行智能拼接，每个字符串参数最前面的<code>/</code>不起作用，会被认为是上一级目录。</p><p><code>path.join</code>方法解析的起点会变化：</p><p>如果第一个参数是以磁盘根路径开头的绝对路径，则<code>path.join</code>解析的起点为第一个参数路径。</p><p>如果第一个参数是以根路径<code>/</code>开头的绝对路径，则<code>path.join</code>解析的起点为第一个参数路径。</p><p>如果第一个参数不是以根路径开头的绝对路径，则<code>path.join</code>解析的起点为当前目录，即<code>&quot;.&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 没有参数</span><br><span class="hljs-built_in">console</span>.log( path.join() );                 <span class="hljs-comment">// 输出👉  &quot;.&quot;</span><br><br><span class="hljs-comment">// 以相对路径foo作为第一个参数</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>) );     <span class="hljs-comment">// 输出👉  &quot;foo\\bar&quot;</span><br><br><span class="hljs-comment">// &quot;/bar&quot; 前的斜杠无效</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;foo/&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>) );     <span class="hljs-comment">// 输出👉  &quot;foo\\bar&quot;</span><br><br><span class="hljs-comment">// 以linux下根路径/foo/作为第一个参数。</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;/foo/&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>) );  <span class="hljs-comment">// 输出👉  &#x27;\\foo\\bar&#x27;</span><br><br><span class="hljs-comment">// 以点号作为第一个参数</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>) );       <span class="hljs-comment">// 输出👉  &quot;foo&quot;</span><br><br><span class="hljs-comment">// 以上一级目录作为第一个参数</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;..&#x27;</span>, <span class="hljs-string">&#x27;foo&#x27;</span>));       <span class="hljs-comment">// 输出👉  &quot;..\\foo&quot;</span><br><br><span class="hljs-comment">// 以上一级目录作为参数</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;foo/&#x27;</span>, <span class="hljs-string">&#x27;/bar&#x27;</span>, <span class="hljs-string">&#x27;..&#x27;</span>)) <span class="hljs-comment">// 输出👉  &quot;foo&quot;</span><br><br><span class="hljs-comment">// windows下绝对路径作为参数</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;C:\\dist&#x27;</span>, <span class="hljs-string">&#x27;img&#x27;</span>)); <span class="hljs-comment">// 输出👉  &quot;C:\dist\img&quot;</span><br><span class="hljs-built_in">console</span>.log( path.join(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;C:\\&#x27;</span>));     <span class="hljs-comment">// 输出👉  &quot;foo\\C:\\&quot;</span><br></code></pre></td></tr></table></figure><h3 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h3><p><code>path.extname(filepath)</code>返回filepath指定文件的扩展名，例如： .js  .css  .html，会带有点号。</p><h3 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h3><p><code>path.basename(filepath, [extname])</code>返回filepath指定文件的文件名。</p><ul><li><p>如果调用该函数时，没有给定extname，则返回的结果形式为带有扩展名的文件名，</p><p>例如 path.basename(‘./src/index.js’) 返回<code> index.js</code>；</p></li><li><p>如果调用该函数时，给定了extname参数，则返回的结果形式为不带有扩展名的文件名，</p><p>例如 path.basename(‘./src/index.js’, ‘.js’) 返回<code> index</code>；</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="/2021/07/19/TypeScript/ts/"/>
    <url>/2021/07/19/TypeScript/ts/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="安装和基本使用"><a href="#安装和基本使用" class="headerlink" title="安装和基本使用"></a>安装和基本使用</h2><h3 id="全局安装TypeScript"><a href="#全局安装TypeScript" class="headerlink" title="全局安装TypeScript"></a>全局安装TypeScript</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> typescript<br></code></pre></td></tr></table></figure><p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc <span class="hljs-literal">-V</span> <br></code></pre></td></tr></table></figure><h3 id="编写TS程序"><a href="#编写TS程序" class="headerlink" title="编写TS程序"></a>编写TS程序</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* src/helloworld.ts */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;Yee&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure><h3 id="手动编译代码"><a href="#手动编译代码" class="headerlink" title="手动编译代码"></a>手动编译代码</h3><p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p><p>在命令行上，运行 TypeScript 编译器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc helloworld.ts<br></code></pre></td></tr></table></figure><p>输出结果为一个 <code>helloworld.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p><p>在命令行上，通过 Node.js 运行这段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node helloworld.js<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Hello, Yee<br></code></pre></td></tr></table></figure><h3 id="终端监视模式编译"><a href="#终端监视模式编译" class="headerlink" title="终端监视模式编译"></a>终端监视模式编译</h3><ol><li><p>生成配置文件tsconfig.json。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc -<span class="hljs-literal">-init</span><br></code></pre></td></tr></table></figure></li><li><p>修改tsconfig.json配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./js&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动监视模式编译</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc <span class="hljs-literal">-w</span>  👈 -<span class="hljs-literal">-watch</span>也可以<br></code></pre></td></tr></table></figure></li></ol><h3 id="Webpack打包TS"><a href="#Webpack打包TS" class="headerlink" title="Webpack打包TS"></a>Webpack打包TS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"># webpack.config.js<br><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/.tsx?$/</span>,<br>                use: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>                include: [path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;ts&#x27;</span>)],<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>接下来让我们看看 TypeScript 工具带来的高级功能。 给 <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;Yee&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure><p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure><p>重新编译，你会看到产生了一个错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">error TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;.<br></code></pre></td></tr></table></figure><p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p><p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 boolean"></a>布尔型 boolean</h3><p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>isDone = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// isDone = 2 // error</span><br></code></pre></td></tr></table></figure><h3 id="数字-number"><a href="#数字-number" class="headerlink" title="数字 number"></a>数字 number</h3><p><strong>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。</strong> 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a1: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 十进制</span><br><span class="hljs-keyword">let</span> a2: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1010</span>  <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> a3: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o12</span> <span class="hljs-comment">// 八进制</span><br><span class="hljs-keyword">let</span> a4: <span class="hljs-built_in">number</span> = <span class="hljs-number">0xa</span> <span class="hljs-comment">// 十六进制</span><br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> name:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;tom&#x27;</span><br>name = <span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-comment">// name = 12 // error</span><br><span class="hljs-keyword">let</span> age:<span class="hljs-built_in">number</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">const</span> info = <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>, I am <span class="hljs-subst">$&#123;age&#125;</span> years old!`</span><br></code></pre></td></tr></table></figure><h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 它们的本身的类型用处不是很大：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p><blockquote><p>注意，当处于TS类型检查的严格模式下，将其他类型的变量赋值为undefined或null，编译会报错，当设置<code>&quot;strict&quot;: false</code>或<code>&quot;strictNullChecks&quot;: true,</code>，则编译可以通过。</p></blockquote><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><ul><li><code>never</code>类型不是任何类型的子类型，任何其他类型的值不可以赋值给never类型变量。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">let a: never = 123; # 编译不通过<br></code></pre></td></tr></table></figure><p>它的应用场景主要用在定义函数的返回类型，当函数的返回值类型为never时，表示这个函数一定不会返回值。</p><ol><li><p>函数会抛出异常。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertNever</span>(<span class="hljs-params">val: <span class="hljs-built_in">never</span></span>):<span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unexpected object&#x27;</span> + val);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>函数中包含死循环或者是死递归函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>):<span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>never类型在联合类型的类型收窄中具有一定应用。</p></blockquote></li></ol><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>当TS编译的target为<code>ES2015</code>及以上版本或<code>Lib</code>中导入了ES2015时，TS支持Symbol类型。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES2015&quot;</span>, <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 👈 s 会被推断为symbol类型</span><br><br><span class="hljs-keyword">let</span> s: symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 👈 完整的写法</span><br></code></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有三种方式可以定义数组。</p><p> <strong>第一种，可以在<code>元素类型后面接上[]</code>，表示由此类型元素组成的一个数组：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>第三种方式是使用接口定义数组：</strong></p><p>接口也可以用来描述数组：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> NumberArray &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> fibonacci: NumberArray = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p><p>不过有一种情况例外，那就是它常用来表示类数组。</p><blockquote><p>⭐ 其实这是使用了接口的跳转，JS中的数组实现了NumberArray接口的所有成员，所以数组类型的值可以赋给该接口类型的变量。</p></blockquote><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>（在TS函数中也可以使用该隐式变量）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">number</span>[] = <span class="hljs-built_in">arguments</span>;<br>&#125;<br><br><span class="hljs-comment">// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span><br></code></pre></td></tr></table></figure><p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: &#123;  <span class="hljs-comment">// ⭐ 临时定义一个匿名的接口</span><br>        [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>        length: <span class="hljs-built_in">number</span>;<br>        callee: <span class="hljs-built_in">Function</span>;<br>    &#125; = <span class="hljs-built_in">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p><p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: IArguments = <span class="hljs-built_in">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IArguments &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>;<br>    length: <span class="hljs-built_in">number</span>;<br>    callee: <span class="hljs-built_in">Function</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元组-type1-type2…"><a href="#元组-type1-type2…" class="headerlink" title="元组 [type1, type2…]"></a>元组 [type1, type2…]</h3><p>元组类型允许表示一个已知元素数量和类型的数组，<code>各元素的类型不必相同</code>。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> t1: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]<br>t1 = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>] <span class="hljs-comment">// OK</span><br>t1 = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>] <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>当访问一个已知索引的元素，会得到正确的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">console</span>.log(t1[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>)) <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.log(t1[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>)) <span class="hljs-comment">// Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法</span><br></code></pre></td></tr></table></figure><h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以<code>为一组数值赋予友好的名字</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;<br>  Red,<br>  Green,<br>  Blue<br>&#125;<br><br><span class="hljs-comment">// 枚举数值默认从0开始依次递增</span><br><span class="hljs-comment">// 根据特定的名称得到对应的枚举数值</span><br><span class="hljs-keyword">let</span> myColor: Color = Color.Green  <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log(myColor, Color.Red, Color.Blue)<br></code></pre></td></tr></table></figure><p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green, Blue&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green<br></code></pre></td></tr></table></figure><p>或者，全部都采用手动赋值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green<br></code></pre></td></tr></table></figure><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green, Blue&#125;<br><span class="hljs-keyword">let</span> colorName: <span class="hljs-built_in">string</span> = Color[<span class="hljs-number">2</span>]<br><br><span class="hljs-built_in">console</span>.log(colorName)  <span class="hljs-comment">// &#x27;Green&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>字符串枚举</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Message &#123;<br>    <span class="hljs-built_in">Error</span> = <span class="hljs-string">&#x27;Sorry, error&#x27;</span>, <span class="hljs-comment">// 枚举值设置为字符串</span><br>    Success = <span class="hljs-string">&#x27;Hoho, success&#x27;</span>,<br>    Failed = <span class="hljs-built_in">Error</span>  <span class="hljs-comment">// 👈 可以使用本枚举类型的其他枚举值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>异构枚举</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 枚举值既有数字也有字符串</span><br><span class="hljs-built_in">enum</span> Result &#123;<br>    Failed = <span class="hljs-number">0</span>,<br>    Success = <span class="hljs-string">&#x27;success&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h4><p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue = <span class="hljs-string">&quot;blue&quot;</span>.length&#125;;<br></code></pre></td></tr></table></figure><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p><p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-string">&quot;red&quot;</span>.length, Green, Blue&#125;;<br><br><span class="hljs-comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span><br><span class="hljs-comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span><br><br><span class="hljs-built_in">enum</span> Status &#123;<br>  A = <span class="hljs-string">&#x27;a&#x27;</span>,<br>  B       # B不赋值时也会报错<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Directions &#123;<br>    Up,<br>    Down,<br>    Left,<br>    Right<br>&#125;<br><br><span class="hljs-keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];<br></code></pre></td></tr></table></figure><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><p>上例的编译结果是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> directions = [<span class="hljs-number">0</span> <span class="hljs-comment">/* Up */</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* Down */</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* Left */</span>, <span class="hljs-number">3</span> <span class="hljs-comment">/* Right */</span>];<br></code></pre></td></tr></table></figure><p>假如包含了计算成员，则会在编译阶段报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue = <span class="hljs-string">&quot;blue&quot;</span>.length&#125;;<br><br><span class="hljs-comment">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span><br></code></pre></td></tr></table></figure><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span><br>notSure = <span class="hljs-string">&#x27;maybe a string&#x27;</span><br>notSure = <span class="hljs-literal">false</span> <span class="hljs-comment">// 也可以是个 boolean</span><br></code></pre></td></tr></table></figure><p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;free&#x27;</span>]<br><br>list[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>在TS语法中，如果一个变量在声明时，既没有进行类型注解，也没有初始化赋值，则该变量的类型为any。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> bar;<br>bar = <span class="hljs-number">1</span>;<br>bar = <span class="hljs-string">&#x27;&#x27;</span>; <br></code></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它<code>表示没有任何类型</code>。 **当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>**：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn()&#x27;</span>)<br>  <span class="hljs-comment">// return undefined</span><br>  <span class="hljs-comment">// return null</span><br>  <span class="hljs-comment">// return 1 // error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>（<strong>非严格模式下</strong>）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> unusable: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h3 id="引用类型-object"><a href="#引用类型-object" class="headerlink" title="引用类型 object"></a>引用类型 object</h3><p><code>object</code> 表示非原始类型（引用类型），也就是除 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>之外的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">obj:<span class="hljs-built_in">object</span></span>):<span class="hljs-title">object</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn2()&#x27;</span>, obj)<br>  <span class="hljs-keyword">return</span> &#123;&#125;<br>  <span class="hljs-comment">// return undefined</span><br>  <span class="hljs-comment">// return null</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(fn2(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)))<br><span class="hljs-comment">// console.log(fn2(&#x27;abc&#x27;) // error</span><br><span class="hljs-built_in">console</span>.log(fn2(<span class="hljs-built_in">String</span>))<br></code></pre></td></tr></table></figure><blockquote><ul><li><p>Symbol只有在target为ES2015时才可以使用，所以不作为TypeScript的基本类型。</p></li><li><p>⭐ TypeScript中，所有JavaScript中定义的引用类型值都可以赋值给object类型的变量。</p></li><li><p>TypeScript非严格模式下，undefined和null可以赋给object类型的变量。</p></li></ul></blockquote><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>联合类型（Union Types）表示取值可以为多种类型中的一种。<br>需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString2</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) : <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x.toString()<br>&#125;<br></code></pre></td></tr></table></figure><p>需求2: 定义一个一个函数得到一个数字或字符串值的长度</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br><br>  <span class="hljs-comment">// return x.length // error</span><br><br>  <span class="hljs-keyword">if</span> (x.length) &#123; <span class="hljs-comment">// error</span><br>    <span class="hljs-keyword">return</span> x.length<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> x.toString().length<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> something.length;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="hljs-comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> something.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myFavoriteNumber: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 5</span><br>myFavoriteNumber = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 编译时报错</span><br><br><span class="hljs-comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p><p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p><h4 id="类型收窄"><a href="#类型收窄" class="headerlink" title="类型收窄"></a>类型收窄</h4><p>作者：尤雨溪<br>链接：<a href="https://www.zhihu.com/question/354601204/answer/888551021">https://www.zhihu.com/question/354601204/answer/888551021</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>举个具体点的例子，当你有一个 union type:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> Bar &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> All = Foo | Bar<br></code></pre></td></tr></table></figure><p>在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleValue</span>(<span class="hljs-params">val: All</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (val.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;foo&#x27;</span>:<br>      <span class="hljs-comment">// 这里 val 被收窄为 Foo</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;bar&#x27;</span>:<br>      <span class="hljs-comment">// val 在这里是 Bar</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">// val 在这里是 never</span><br>      <span class="hljs-keyword">const</span> exhaustiveCheck: <span class="hljs-built_in">never</span> = val<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> All = Foo | Bar | Baz<br></code></pre></td></tr></table></figure><p>然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。</p><h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><p>在TypeScript中，如果一个变量为联合类型，一般情况下在代码中我们只能访问联合类型的共有成员。</p><p>但是类型保护机制可以让我们访问联合类型的非共有成员时，不会出现编译出错的情况。</p><ol><li><p>使用类型保护函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> NumberOrString = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br><span class="hljs-keyword">let</span> a: NumberOrString = <span class="hljs-string">&#x27;string&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>    console.log(val.split(&#x27;&#x27;)); # 报错，number上不存在split<br>&#125;<br><br><span class="hljs-comment">// 定义类型保护函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">value: NumberOrString</span>): <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123; <span class="hljs-comment">// xxx is ... xxx必须和参数名一直</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(isString(val)) &#123;<br>    <span class="hljs-built_in">console</span>.log(val.split(<span class="hljs-string">&#x27;&#x27;</span>));  <span class="hljs-comment">// 👈 不再会报错</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(val.split()); <span class="hljs-comment">// ❌ 这里没有用类型保护函数，仍然会报错</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>类型保护函数一般用于复杂的类型判断，或者用于需要复用代码的情况。</p></blockquote></li><li><p>使用<code>typeof</code>进行类型保护。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>) &#123; <span class="hljs-comment">// 👈 使用typeof同样可以起到类型保护的作用</span><br>    <span class="hljs-built_in">console</span>.log(val.split(<span class="hljs-string">&#x27;&#x27;</span>));  <span class="hljs-comment">// 👈 不再会报错</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(val.split()); <span class="hljs-comment">// ❌ 这里没有用类型保护函数，仍然会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的是，typeof只能用于 number、string、boolean、symbol类型的类型保护。</p><p>因为使用typeof只能准确判断出这四种类型。</p></blockquote></li><li><p>使用<code>instanceof</code>进行类型保护。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>  sing(): <span class="hljs-built_in">void</span> &#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  eat(): <span class="hljs-built_in">void</span> &#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Animal = People | Dog<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">val: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>  val.sing();  # 报错，只有people有sing方法<br>&#125;<br><br><span class="hljs-comment">// 重新定义visit函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">val: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> People) &#123;<br>        val.sing()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在TypeScript种，当我们使用联合类型，且不确定该联合类型的具体类型的时候，我们只能使用联合类型所共有的属性或方法，比如：</p><p>let num:number|string = ‘10’<br>let count = num.toString().length<br>1<br>2<br>但是有的的时候，我们需要在不确定具体类型的时候来访问该联合类型，但是又会报错，这时候就可以用上类型断言：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;10&#x27;</span><br>num = <span class="hljs-number">20</span><br><span class="hljs-comment">// console.log(num.length) //报错，这种情况可以使用类型断言</span><br></code></pre></td></tr></table></figure><p><strong>类型断言</strong>：可以用来手动指定一个值的类型。</p><p>类型断言的三种种语法：</p><ol><li>语法&lt;类型&gt;值</li><li>值 as 类型</li><li>特殊情况，变量使用时后面加<code>!</code>，可以断言该变量不为undefined或null</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> ((x <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length) &#123;    <span class="hljs-comment">// 👈 仅仅是编译时避免报错，真正执行时，类型断言不起任何作用。</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;string类型的逻辑&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (x <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;非string类型的逻辑&#x27;</span>);<br>    <span class="hljs-keyword">return</span> x.toString().length<br>  &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-string">&#x27;abcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// 👇 输出内容</span><br><span class="hljs-comment">// string类型的逻辑</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 非string类型的逻辑</span><br><span class="hljs-comment">// 3</span><br><br><br><span class="hljs-comment">// 演示第三种情况</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> + val; <span class="hljs-comment">// ❌ 如果此处不断言val不为undefined，则会编译会飘红</span><br>  &#125;<br>  val = val || <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> fn();<br>&#125;<br><br><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> + val!; <span class="hljs-comment">// 使用`!` 断言val不为undefined</span><br>  &#125;<br>  val = val || <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> fn();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>❗ 在tsx语法（React的jsx语法的ts版）必须采用后面一种，因为在jsx种，尖括号会用来包裹标签，与第一种语法有冲突。</li><li>❗ 类型断言不是类型转换，<strong>断言成一个联合类型中不存在的类型是不允许的</strong> 。</li></ol></blockquote><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型<br>有下面2种情况: </p><ol><li>声明变量时，同时进行了赋值, 推断为对应的类型。</li><li>声明变量时没有初始化赋值, 推断为any类型。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 定义变量时赋值了, 推断为对应的类型 */</span><br><span class="hljs-keyword">let</span> b9 = <span class="hljs-number">123</span> <span class="hljs-comment">// number</span><br><span class="hljs-comment">// b9 = &#x27;abc&#x27; // error</span><br><br><span class="hljs-comment">/* 定义变量时没有赋值, 推断为any类型 */</span><br><span class="hljs-keyword">let</span> b10  <span class="hljs-comment">// any类型</span><br>b10 = <span class="hljs-number">123</span><br>b10 = <span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><h4 id="定义一个新类型"><a href="#定义一个新类型" class="headerlink" title="定义一个新类型"></a>定义一个新类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Person = &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NameResolver = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 定义一个具体的函数类型的名字</span><br></code></pre></td></tr></table></figure><p>甚至用<code>type</code>定义的类型可以指定该变量具有的方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Person = &#123;<br>  name: <span class="hljs-built_in">string</span>,<br>  age: <span class="hljs-built_in">number</span>,<br>  run: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> p: Person = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">23</span>,<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>👆 但不建议这样用。</p></blockquote><h4 id="定义类型别名"><a href="#定义类型别名" class="headerlink" title="定义类型别名"></a>定义类型别名</h4><p>类型别名用来给一个类型起个新名字。</p><p><strong>简单的例子</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Name = <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">type</span> NameOrResolver = Name | NameResolver;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">Name</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><p>类型别名常用于联合类型。</p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>字面量类型用来约束取值只能是某几个值中的一个。</p><h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> EventNames = <span class="hljs-string">&#x27;click&#x27;</span> | <span class="hljs-string">&#x27;scroll&#x27;</span> | <span class="hljs-string">&#x27;mousemove&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvent</span>(<span class="hljs-params">ele: Element, event: EventNames</span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br>handleEvent(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;hello&#x27;</span>), <span class="hljs-string">&#x27;scroll&#x27;</span>);  <span class="hljs-comment">// 没问题</span><br>handleEvent(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;world&#x27;</span>), <span class="hljs-string">&#x27;dblclick&#x27;</span>); <span class="hljs-comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span><br><br><span class="hljs-comment">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dblclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p><p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p><h4 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> StatusCode = <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">301</span><br></code></pre></td></tr></table></figure><h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>TypeScript中，<code>keyof</code>关键字是一个操作符，它的作用类似于JS中的<code>Object.keys</code>。</p><p><code>keyof</code>可以枚举出对象、接口、type、类的所有属性名、方法名，并将它们组合为一个<strong>字符串字面量类型</strong>返回。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> People = &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>&#125;<br><br><span class="hljs-keyword">interface</span> ILeg &#123;<br>    run(): <span class="hljs-built_in">void</span>,<br>    walk(): <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> StrangeInterface &#123;<br>    foo: <span class="hljs-built_in">never</span>,<br>    bar: <span class="hljs-literal">undefined</span>,<br>    xyz: <span class="hljs-literal">null</span>,<br>    usefulField: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    age: <span class="hljs-built_in">number</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> A = keyof People;  <span class="hljs-comment">// &#x27;name&#x27; | &#x27;age&#x27;</span><br><span class="hljs-keyword">type</span> B = keyof ILeg; <span class="hljs-comment">// &#x27;run&#x27; | walk</span><br><span class="hljs-keyword">type</span> C = keyof Dog; <span class="hljs-comment">// &#x27;age&#x27; | &#x27;name&#x27; | &#x27;eat&#x27; ⭐ constructor不会被枚举</span><br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="简单类的完整定义"><a href="#简单类的完整定义" class="headerlink" title="简单类的完整定义"></a>简单类的完整定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">/* 定义静态属性 */</span><br>    <span class="hljs-keyword">static</span> info: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;人类&#x27;</span><br>    <br>    <span class="hljs-comment">/* 定义静态方法，this指向类 */</span><br>    <span class="hljs-keyword">static</span> introduce(): <span class="hljs-built_in">void</span> &#123;  <span class="hljs-comment">// 👈 如果返回值值类型为void，可省略返回值类型注解</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.info);<br>    &#125;<br>    <br>    /* 定义实例属性 */  # 在TS中，实例属性要么在类中声明时初始化，要么在构造函数中初始化，否则编译不通过<br>    name: <span class="hljs-built_in">string</span><br>    age: <span class="hljs-built_in">number</span><br>    family: Person[] = []  <span class="hljs-comment">// 👈 如果在constructor中没有初始化语句，则必须在声明该属性时定义默认值</span><br>    <br>    <span class="hljs-comment">/* 定义实例方法, this指向实例 */</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    sayHi(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, 你好`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>TypeScript中，类的成员的定义写法是根据ES7部分提案设计的。</p><p>在ES6中，可以在类内定义静态方法、实例方法，只允许在构造函数内初始化实例属性，只允许在类外定义静态属性。</p></blockquote><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  sayHi(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a: Animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.sayHi()); <span class="hljs-comment">// My name is Jack</span><br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>除了<code>static</code>修饰符可以修饰静态成员外，TypeScript中在定义类的成员时，还可以使用<code>public</code>、<code>protected</code>、<code>private</code>以及<code>readonly</code>修饰符。</p><h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><p>下面举一些例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name);<br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-comment">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br><span class="hljs-comment">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;</span><br></code></pre></td></tr></table></figure><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">protected</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修饰构造函数"><a href="#修饰构造函数" class="headerlink" title="修饰构造函数"></a>修饰构造函数</h4><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.</span><br><span class="hljs-comment">// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.</span><br></code></pre></td></tr></table></figure><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the</span><br></code></pre></td></tr></table></figure><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">readonly</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span><br></code></pre></td></tr></table></figure><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-comment">// public readonly name;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> name</span>)</span> &#123;<br>    <span class="hljs-comment">// this.name = name;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Kitty&#x27;</span>); <span class="hljs-comment">// setter: Kitty</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>; <span class="hljs-comment">// setter: Tom</span><br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br></code></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript中，和JS一样，使用<code>extends</code>关键字定义继承关系。</p><p>子类会继承父类所有的非private成员，包括构造函数、实例属性、实例方法、静态属性、静态方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public name;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.sayHi()); <span class="hljs-comment">// My name is Jack</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br><span class="hljs-comment">/* 隐式地含有父类的所有非private的成员，包括构造函数 */</span><br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>); <span class="hljs-comment">// Tom  👈 继承了父类的构造函数</span><br><span class="hljs-built_in">console</span>.log(c.sayHi()); <span class="hljs-comment">// Meow, My name is Tom</span><br></code></pre></td></tr></table></figure><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123; <span class="hljs-comment">// ⭐ 定义子类的构造函数</span><br>    <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">// 当父类定义中存在构造函数时，必须先调用父类的constructor</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Meow, &#x27;</span> + <span class="hljs-built_in">super</span>.sayHi(); <span class="hljs-comment">// 调用父类的 sayHi()</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>); <span class="hljs-comment">// Tom</span><br><span class="hljs-built_in">console</span>.log(c.sayHi()); <span class="hljs-comment">// Meow, My name is Tom</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃东西&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃骨头&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃鱼&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a1: Animal = <span class="hljs-keyword">new</span> Cat();<br>a1.eat(); <span class="hljs-comment">// 吃鱼</span><br><br><span class="hljs-keyword">let</span> a2: Animal = <span class="hljs-keyword">new</span> Dog();<br>a2.eat(); <span class="hljs-comment">// 吃骨头</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>  a.eat();<br>&#125;<br><br>test(a1); <span class="hljs-comment">// 吃鱼</span><br>test(a2); <span class="hljs-comment">// 吃骨头</span><br><br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p><p>什么是抽象类？</p><p>首先，抽象类是不允许被实例化的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p><p>其次，抽象类中的抽象方法必须被子类实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is eating.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p><p>下面是一个正确使用抽象类的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Meow, My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 TypeScript 中，我们使用接口（Interfaces）。</p><p>根据接口的不同作用，可以将TypeScript接口分为多种类型的接口。</p><h3 id="约束对象属性和方法的接口"><a href="#约束对象属性和方法的接口" class="headerlink" title="约束对象属性和方法的接口"></a>约束对象属性和方法的接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo1 &#123;<br>    name: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对属性的类型进行约束 ⭐</span><br>    age: <span class="hljs-built_in">number</span>,<br>    fn0(): <span class="hljs-built_in">void</span>, <span class="hljs-comment">// 对方法的类型进行约束的第一种写法 ⭐ 无参数</span><br>    fn1(arg1: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对方法的类型进行约束的第一种写法 ⭐ 有参数</span><br>        <br>    fn2: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>, <span class="hljs-comment">// 对方法进行约束的第二种写法 ⭐ 无参数</span><br>    fn3: <span class="hljs-function">(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对方法进行约束的第二种写法 ⭐ 有参数</span><br>&#125;<br>    <br><span class="hljs-keyword">let</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">24</span>,<br>  <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> i: IDemo = obj;<br>i.fn();<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo1 &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>    fn(): <span class="hljs-built_in">void</span><br>&#125;<br>    <br><span class="hljs-keyword">let</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">24</span>,<br>  <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> i: IDemo = obj;<br>i.fn();<br></code></pre></td></tr></table></figure><p><strong>接口成员的嵌套约束</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    info: &#123;<br>        age: <span class="hljs-built_in">number</span>,<br>        gender: <span class="hljs-built_in">string</span>,<br>    &#125;,<br>    run(): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h3><p><strong>约束对象的全部属性（不常用）</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 要求某个对象或某个类的实例可以通过下标访问内容</span><br><span class="hljs-keyword">interface</span> IIndex &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>,<br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或某个类的实例可以通过下标访问内容，同时具有length属性</span><br><span class="hljs-keyword">interface</span> IArrayLike &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>,<br>    length: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或者某个类的实例的所有属性值都为string类型</span><br><span class="hljs-keyword">interface</span> IStringContent &#123;<br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或者某个类的实例的所有的方法都是没有参数且没有返回值的函数</span><br><span class="hljs-keyword">interface</span> IStringContent &#123;<br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约束类的成员的接口"><a href="#约束类的成员的接口" class="headerlink" title="约束类的成员的接口"></a>约束类的成员的接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个接口</span><br><span class="hljs-keyword">interface</span> IPerson &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  speak(): <span class="hljs-built_in">void</span><br>  growUp(years: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个学生类，该类要实现IPerson</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">IPerson</span></span>&#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br><br>  growUp(year: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-built_in">this</span>.age += year<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">goToSchool</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上学&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>在类实现接口时，接口中定义了的成员必须是<code>public</code>的，即在类内不可以用<code>private</code>、<code>protected</code>进行修饰接口要求的成员。</p></blockquote><p><strong>实现（implements）是面向对象中的一个重要概念。</strong>一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    alert(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Door</span> </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityDoor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Door</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;SecurityDoor alert&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car alert&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一个类可以实现多个接口：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    alert(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Light &#123;<br>    lightOn(): <span class="hljs-built_in">void</span>;<br>    lightOff(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span>, <span class="hljs-title">Light</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car alert&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">lightOn</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car light on&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">lightOff</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car light off&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p><h3 id="定义函数形状的接口"><a href="#定义函数形状的接口" class="headerlink" title="定义函数形状的接口"></a>定义函数形状的接口</h3><p>见函数相关章节。</p><h3 id="可选成员以及readonly修饰符"><a href="#可选成员以及readonly修饰符" class="headerlink" title="可选成员以及readonly修饰符"></a>可选成员以及readonly修饰符</h3><p>可选的成员使用<code>?</code></p><p>只读属性使用 <code>readonly</code>在成员前面进行修饰</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ILeg &#123;<br>    walk(): <span class="hljs-built_in">void</span><br>    run?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>,  <span class="hljs-comment">// 也可以写成 run?(): void</span><br>    <span class="hljs-keyword">readonly</span> count: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明（Function Declaration）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 函数表达式（Function Expression）</span><br><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br>sum(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在TS中通过函数表达式定义函数的一般写法：</span><br><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TS中完整的函数表达式：</span><br><span class="hljs-keyword">let</span> mySum: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p><p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></blockquote><h3 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h3><p><strong>我们也可以使用接口的方式来定义一个函数需要符合的形状：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>    (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123; <span class="hljs-comment">// 👈 这里可以省略函数返回值</span><br>    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><p><strong>定义函数形状的同时，还可以指定函数可能具有的属性：</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IFn &#123;<br>    (s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>,<br>    info?: <span class="hljs-built_in">string</span>,  <span class="hljs-comment">// 👈 必须用`?`修饰，否则使用函数表达式语法定义函数时，编译不通过</span><br><span class="hljs-comment">// ⭐ 每个函数接口，都具有隐式的属性name: string</span><br>&#125;<br><br><span class="hljs-keyword">let</span> fn: IFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><br>fn.info = <span class="hljs-string">&#x27;...&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(fn.info); <span class="hljs-comment">// ...</span><br><br><span class="hljs-built_in">console</span>.log(fn.name); <span class="hljs-comment">// fn 👈 TS中所有函数默认具有name属性</span><br><br></code></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p><p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName?: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (firstName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> lastName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span><br></code></pre></td></tr></table></figure><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Cat&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>, lastName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> cat = buildName(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array, ...items</span>) </span>&#123;<br>    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>        array.push(item);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> a: any[] = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array: <span class="hljs-built_in">any</span>[], ...items: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;<br>    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>        array.push(item);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> a = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ol><li>剩余参数只能是最后一个参数。</li><li>剩余参数前可以出现可选参数和有默认值的参数。</li></ol></blockquote><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><blockquote><p>TypeScript的函数重载语法很僵硬的表现：</p><p>允许多次声明，每次声明的同名函数的形状不同，但是函数的实现只允许发生一次。</p><p>原因在于：</p><p>TypeScript会被编译为JavaScript，而JavaScript是不具有函数重载语法的，任何函数只有一次实现。</p></blockquote><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p><p>利用联合类型，我们可以这么实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ❗  如果写  else if (typeof x === &#x27;string&#x27;) 编译报错</span><br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p><p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// ❗  如果写  else if (typeof x === &#x27;string&#x27;) 编译报错</span><br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">typeof</span> x) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x!.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:<br>      <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 或者 ⭐ 更推荐的写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;  <span class="hljs-comment">// 这里的any并不代表可以输入任何类型，而是表示实参与返回值类型不确定</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br><br>reverse(true) # 报错，不可以传入boolean类型的值<br>reverse(<span class="hljs-number">12</span>) <span class="hljs-comment">// 21</span><br>reverse(<span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ba&#x27;</span><br></code></pre></td></tr></table></figure><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><blockquote><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><blockquote><p>使用泛型的目的是为了提高代码的可复用性。</p></blockquote><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">any</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</p><p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：</p><p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p><p>这时候，泛型就派上用场了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 注意，第二个参数传入&#x27;x&#x27;，TS编译器会推测出此时T为string</span><br></code></pre></td></tr></table></figure><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>上述的例子中，使用的就是泛型函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// ⭐ 需要注意的是这里其实是省略了具体类型的传入。</span><br><br>createArray&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 本次函数调用的泛型T的具体类型为string类型</span><br></code></pre></td></tr></table></figure><blockquote><p>可以在函数的参数中使用泛型，使得函数可以传入多种类型的参数。</p><p>也可以在函数代码块中使用泛型，使得函数代码块中可以定义多种类型的变量。</p><p>还可以在函数的返回值中使用泛型，使得函数可以返回多种类型的值。</p></blockquote><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>定义泛型的时候，可以一次定义多个类型参数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">U</span>, <span class="hljs-title">T</span>] </span>&#123;<br>    <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];<br>&#125;<br><br>swap&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;([<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;seven&#x27;</span>]); <span class="hljs-comment">// [&#x27;seven&#x27;, 7]</span><br></code></pre></td></tr></table></figure><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><blockquote><p>在泛型形参后面使用 <code>extends</code>关键字，不是继承的含义，而是在对泛型进行约束，要求类型实参必须<strong>兼容</strong>某个接口、某个class、某种Type，甚至是其他的泛型。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></code></pre></td></tr></table></figure><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthwise &#123;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p><p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthwise &#123;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br>loggingIdentity(<span class="hljs-number">7</span>);<br><br><span class="hljs-comment">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span><br></code></pre></td></tr></table></figure><p><strong>多个类型参数之间也可以互相约束：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyFields</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">U</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">target: T, source: U</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> source) &#123;<br>        target[id] = (&lt;T&gt;source)[id];<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;<br><br>copyFields(x, &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">20</span> &#125;);<br></code></pre></td></tr></table></figure><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><a href="https://ts.xcatliu.com/basics/type-of-function.html#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用含有泛型的接口来定义函数的形状：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> CreateArrayFunc &#123;<br>    &lt;T&gt;(length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">let</span> createArray: CreateArrayFunc;<br>createArray = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><p>进一步，我们可以把泛型参数提前到接口名上：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;<br>    (length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">let</span> createArray: CreateArrayFunc&lt;<span class="hljs-built_in">number</span>&gt;;<br>createArray = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(3, &#x27;x&#x27;); # 编译报错，泛型接口的T为number，creatArray是该接口类型，第二个参数不能传入string类型<br><br><span class="hljs-keyword">let</span> result = createArray(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 编译通过，将返回 [0, 0, 0]</span><br></code></pre></td></tr></table></figure><blockquote><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p></blockquote><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    zeroValue: T;<br>    add: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.zeroValue = <span class="hljs-number">0</span>;<br>myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br></code></pre></td></tr></table></figure><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，<strong>从实际值参数中也无法推测出时，这个默认类型才会起作用</strong>。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">string</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// ⭐这里能够从实参推断出T为number，所以默认的T = string在这里不起作用</span><br></code></pre></td></tr></table></figure><h2 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h2><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><p>接口中的属性在合并时会简单的合并到一个接口中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<strong>合并的属性的类型必须是唯一的</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">// 虽然重复了，但是类型都是 `number`，所以不会报错</span><br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// 类型不一致，会报错</span><br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure><p>接口中方法的合并，与函数的合并一样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    weight: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    weight: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意，当接口中定义了同名不同形的方法，实现该接口的对象或者类，只需要实现其中一种形状的该方法。</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: Alarm = &#123;<br>    price: <span class="hljs-number">12</span>,<br>    weight: <span class="hljs-number">15</span>,<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的合并"><a href="#类的合并" class="headerlink" title="类的合并"></a>类的合并</h3><p>类的合并与接口的合并规则一致。</p><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git笔记</title>
    <link href="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git与GitHub"><a href="#Git与GitHub" class="headerlink" title="Git与GitHub"></a>Git与GitHub</h1><h2 id="Git结构"><a href="#Git结构" class="headerlink" title="Git结构"></a>Git结构</h2><p>==<font size='6'>工作区</font>==(写代码)</p><pre><code> git add 👇</code></pre><p>==<font size='6'>暂存区</font>==(临时存储)</p><p>  git commit 👇</p><p>==<font size='6'>本地库</font>==(历史版本)</p><h2 id="Git和代码托管中心"><a href="#Git和代码托管中心" class="headerlink" title="Git和代码托管中心"></a>Git和代码托管中心</h2><p><strong>代码托管中心的任务:   维护远程库</strong></p><ul><li>局域网环境下<ol><li>GitLab服务器</li></ol></li><li>外网环境下<ol><li>GitHub</li><li>码云</li></ol></li></ul><h2 id="Git的文件管理机制"><a href="#Git的文件管理机制" class="headerlink" title="Git的文件管理机制"></a>Git的文件管理机制</h2><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805160547652.png" alt="image-20200805160547652"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805161324105.png" alt="image-20200805161324105"></p><p><code>commit对象</code>、<code>tree对象</code>、<code>blob对象</code></p><p>commit对象具有一个hash索引，该索引值即版本id。一个commit对象具有一棵tree，代表仓库主目录的一组快照。</p><p>tree对象也具有一个hash索引，代表文件树id，可以理解成一个目录。</p><p>tree对象中保存了各个文件快照blob对象以及子树的hash索引。</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121150722116.png" alt="image-20201121150722116"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805162312028.png" alt="image-20200805162312028"></p><p>不同的commit对象使用parent指针形成一张反向的链表。</p><h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><h3 id="git-init：初始化本地仓库"><a href="#git-init：初始化本地仓库" class="headerlink" title="git init：初始化本地仓库"></a>git init：初始化本地仓库</h3><p>git init</p><h3 id="git-config-user-xxx：设置签名"><a href="#git-config-user-xxx：设置签名" class="headerlink" title="git config user.xxx：设置签名"></a>git config user.xxx：设置签名</h3><p>设置签名可以区分不同开发人员的身份。</p><p>签名的形式:  用户名：xxx   Email地址：<a href="mailto:&#x78;&#120;&#x78;&#120;&#x40;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;">&#x78;&#120;&#x78;&#120;&#x40;&#x78;&#x78;&#46;&#x63;&#x6f;&#109;</a></p><p><font color='red'>这里的签名和登录远程库的账号密码没有任何关系</font></p><ul><li><p>设置项目级别/仓库级别的签名,仅在当前本地库范围有效。</p><p>git config user.name  ==mazheng== </p><p>git config user.email  ==mzleman@126.com==</p><p>配置信息保存在了当前本地仓库目录下的 ./.git/config文件中</p></li></ul><ul><li><p>设置用户级别的签名，系统用户权限内有效。</p><p>git config –global user.name ==’admin’==   👈 可以加引号</p><p>git config –global user.email  ==’xxx@126.com’==</p><p>配置信息保存在用户根目录下 ~/.gitconfig文件中</p></li></ul><ul><li><p>(基本不用) 设置系统级别的签名，对系统所有登录的用户有效。</p><p>git config –system user.name ==admin==</p><p>git config –system user.email ==xxx@126.com==</p></li></ul><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121121008005.png" alt="image-20201121121008005"></p><p><em>签名优先级</em>规则：采取就近原则，项目级别签名的优先级更高，两种签名（local和global）至少设置一个。</p><h3 id="git-status：状态查看"><a href="#git-status：状态查看" class="headerlink" title="git status：状态查看"></a>git status：状态查看</h3><p>git status</p><h3 id="git-add：添加到暂存区"><a href="#git-add：添加到暂存区" class="headerlink" title="git add：添加到暂存区"></a>git add：添加到暂存区</h3><p>git add ==filePath==</p><p>git add -u  👈将显示”<font color="red">modified</font>“的<code>已经被git管理的文件</code>提交到暂存区。</p><p>git add *     👈将显示”<font color="red">untracked</font>“和<font color="red">modified</font>“的文件都提交到暂存区。</p><h3 id="git-commit：提交到本地库"><a href="#git-commit：提交到本地库" class="headerlink" title="git commit：提交到本地库"></a>git commit：提交到本地库</h3><p>git commit</p><p>git commit -m ==”提交信息”==</p><p>git commit -am ==”提交信息”== 👈 工作区直接提交到本地库，不提交到暂存区（不推荐使用）</p><h3 id="git-rm：清除对文件和目录的跟踪、删除文件"><a href="#git-rm：清除对文件和目录的跟踪、删除文件" class="headerlink" title="git rm：清除对文件和目录的跟踪、删除文件"></a>git rm：清除对文件和目录的跟踪、删除文件</h3><p>git rm –cached ==filename==  👈清除git对该文件的跟踪，但文件系统中不会删除该文件</p><p>git rm  ==filename== 👈清除git对该文件的跟踪，同时在文件系统中删除该文件</p><p>git rm -r –cached ==dirname== 👈清除对目录的跟踪，不删除目录</p><p>git rm -r –force/-f ==dirname== 👈清除对目录的跟踪，同时删除该目录</p><blockquote><p>不带参数的git rm命令相当于带默认参数 –force</p></blockquote><h3 id="git-mv：重命名、移动文件"><a href="#git-mv：重命名、移动文件" class="headerlink" title="git mv：重命名、移动文件"></a>git mv：重命名、移动文件</h3><p>git mv ==oldname==  ==newname== 👈重命名文件</p><p>git mv ==filename== ==tragetPath== 👈移动文件</p><h3 id="git-diff：比较文件的前后差异"><a href="#git-diff：比较文件的前后差异" class="headerlink" title="git diff：比较文件的前后差异"></a>git diff：比较文件的前后差异</h3><p><strong>当前分支下的比较命令：</strong></p><ul><li><p>git diff </p><p> 比较所有被git管理的文件在<code>工作区</code>与<code>暂存区</code>之间的区别</p></li><li><p>git diff ==[filename1== ==filename2…]== </p><p> 比较指定文件在<code>工作区</code>与<code>暂存区</code>之间的区别</p></li><li><p>git diff –cached </p><p> 比较所有被git管理的文件在<code>暂存区</code>与<code>本地库</code>之间的区别</p></li><li><p>git diff –cached ==[filename1== ==filename2…]== </p><p>比较指定文件在<code>暂存区</code>与<code>本地库</code>之间的区别</p></li><li><p>git diff commitHash1 commitHash2 [==filename==] </p><p>比较同一分支下不同commit对象指定文件/全部文件的区别</p></li></ul><p><strong>不同分支commit之间的比较：</strong></p><ul><li><p>git diff ==branch1== ==branch2==</p><p>比较两个分支指针指向的commit对象之间所有文件的区别</p></li><li><p>git diff ==branch1== ==branch2==   –  [==filename1== ==filename2…==]</p><p>git diff ==commitHash1== ==commitHash2==   –  [==filename1== ==filename2…==]</p><p>比较不同commit指定文件的区别</p></li></ul><h3 id="git-stash：藏匿处"><a href="#git-stash：藏匿处" class="headerlink" title="git stash：藏匿处"></a>git stash：藏匿处</h3><p>git  stash命令可以临时存储”尚未完成编辑”以及“需要临时藏匿”的文件，在需要的时候再加载到工作区。</p><p>git使用一个栈结构管理每一次藏匿请求。</p><blockquote><p>将stash堆栈中的内容正常拉取的前提是：拉取出的内容与当前工作区文件状态不冲突，否则会报错，需要合并冲突。</p></blockquote><p><strong>查看stash堆栈：</strong></p><ul><li><p>git stash list</p><p>查看stash堆栈。</p></li><li><p>git stash show</p><p>查看stash堆栈中的内容和当前工作区内的差别。</p></li><li><p>git stash show n</p><p>查看stash堆栈中索引为n的藏匿内容和当前工作区的差别</p></li></ul><p><strong>藏匿暂未缓存的内容：</strong></p><p>未缓存的内容即未提交到缓存区的内容，包括<code>modified</code> <code>untracked</code> <code>ignored</code>的文件。</p><ul><li><p>git stash</p><p>将当前工作区所有尚未暂存的全部修改藏匿起来。</p></li><li><p>git stash –include-untracked / -u</p><p>将当前工作区<code>modified</code>修改了的追踪文件、<code>untracked</code>未追踪文件等所有尚未暂存的内容藏匿起来。</p><blockquote><p>不包括.gitignore中忽略的文件和目录。但是如果.gitignore中指定了</p></blockquote></li><li><p>git stash –all</p><p>将当前工作区所有尚未暂存的文件藏起起来，包括<code>modiefied</code>、<code>untracked</code>以及<code>ignored</code>的文件。</p><blockquote><p>包括.gitignore中的指定文件和目录</p></blockquote></li><li><p>git stash –==filename==</p><p>将指定文件的修改藏起来。</p></li><li><p>git stash -m”==message==”</p><p>将当前工作区所有尚未暂存的全部修改藏匿起来，<em>并写入提示信息。</em></p></li></ul><p><strong>将藏匿内容添加到工作区：</strong></p><ul><li><p>git stash pop n</p><p>将stash中索引为n的工作区内容取出来。当不写n时，n默认为0。</p></li><li><p>git stash apply n</p><p>将stash中索引为n的工作区内容取出来。当不写n时，n默认为0。</p><blockquote><p>apply 和 pop 的区别在于apply不会将索引为n的内容从stash中移除。</p></blockquote></li></ul><p><strong>删除stash堆栈中的内容：</strong></p><ul><li><p>git stash drop n</p><p>将stash中索引为n的工作区内容从堆栈中删除。当不写n时，n默认为0。</p></li><li><p>git stash clear</p><p>清空stash中的所有内容</p></li></ul><h3 id="git-restore：恢复操作"><a href="#git-restore：恢复操作" class="headerlink" title="git restore：恢复操作"></a>git restore：恢复操作</h3><ul><li><p>git restore ==filename1 [filename2]== </p><p>撤销工作区指定一个或多个<font color='red'>已追踪文件</font>的修改。</p><p>👉 等价于 git checkout – ==filename1== ==[filename2]==</p></li><li><p>git restore *</p><p>撤销工作区所有<font color='red'>已追踪文件</font>的修改。</p><p>👉 等价于 git checkout – *</p><blockquote><p>即去除 工作区区内<code>modified</code>文件</p></blockquote></li><li><p>git restore –staged ==filename1== ==filename2…==</p><p>撤销暂存区指定内容相对于本地库的修改。</p><blockquote><p>撤销暂存区内容的操作不会影响工作区。</p></blockquote></li><li><p>git restore –staged  *</p><p>撤销暂存区所有内容相对于本地库的修改。</p><p>👉等价于 git reset –mixed HEAD</p></li></ul><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>应用：</p><ol><li><p>切换分支</p><p>git checkout ==branchName==</p></li><li><p>基于某一commit对象新建分支，同时切换到该分支</p><p>git checkout -b ==branchName== ==commitHash==</p></li><li><p>分离头指针</p><p>git checkout ==commitHash==</p></li><li><p>撤销工作区内容修改</p><p>git checkout – ==filename==  👈 单文件</p><p>git checkout – ==filename1== ==filename2…==   👈 多文件</p><p>git checkout – *  👈 所有文件</p></li></ol><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><strong>定义：在版本控制过程中，使用多条线同时推进多个任务。</strong></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804222504990.png" alt="image-20200804222504990"></p><p><strong>使用分支的优势：</strong>1. 同时并行推进多个功能的开发，提高开发效率。2. 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h3><h4 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1. 创建分支"></a>1. 创建分支</h4><ul><li><p>git branch ==分支名== 基于当前commit创建新分支</p></li><li><p>git branch ==分支名== ==commitHash== 基于指定commit创建新分支</p></li><li><p>git checkout -b ==newBranch== ==targetBranch/commitHash== 在某个版本处创建新分支,同时切换到该分支 ⭐</p><p>指针关系：HEAD 👉 newBranch 👉 targetBranch/commitHash</p></li></ul><h4 id="2-查看所有分支"><a href="#2-查看所有分支" class="headerlink" title="2. 查看所有分支"></a>2. 查看所有分支</h4><p>git branch -v</p><p>git branch -av  查看包含远程分支在内的所有分支</p><h4 id="3-切换到分支"><a href="#3-切换到分支" class="headerlink" title="3. 切换到分支"></a>3. 切换到分支</h4><p>git checkout ==分支名==</p><h4 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h4><p>git merge ==被合并分支名==</p><ul><li><p>第一步，切换到接受修改的分支（要合并其他分支的主分支）</p><p>git checkout [主分支]</p></li><li><p>第二步，执行git merge [被合并分支名]</p></li></ul><p><strong>解决合并冲突：</strong></p><p>合并主分支与被合并分支时，若同一个文件的同一个位置在两个分支内的内容有差异，则这时产生合并冲突。</p><ul><li><p>第一步：合并分支，若出现冲突，git会发出提示需要解决冲突，或取消合并。</p></li><li><p>第二步：若继续合并，则首先应编辑发生冲突的文件内容位置，删除标记冲突的特殊符号。</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804231102746.png" alt="image-20200804231102746"></p></li><li><p>第三步：git add ==发生冲突的文件== 或   git add .</p></li><li><p>第四步：git commit -m “日志信息”   <font color="red">此时commit一定不能带具体文件名</font>&gt;</p></li></ul><h4 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5. 删除分支"></a>5. 删除分支</h4><p>git branch -d ==branchName== 👈可以删除已经被合并过的分支</p><p>git branch -D ==branchName== 👈可以删除任意分支</p><blockquote><p>若要删除当前分支，则应先切换到其他分支再删除。</p></blockquote><h3 id="使用指针管理分支"><a href="#使用指针管理分支" class="headerlink" title="使用指针管理分支"></a>使用指针管理分支</h3><ul><li><p><strong>新建分支testing，并切换到testing。</strong></p><p>底层：新建一个分支指针testing指向当前版本，同时HEAD指针指向testing指针。</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805163243391.png" alt="image-20200805163243391"></p></li></ul><ul><li><p><strong>在testing分支下提交新的版本873ab2。</strong></p><p>底层：在testing分支下创建了一个新的commit对象，hash索引为87ab2，该对象的parent指针指向testing指针正在指向的commit对象，再把testing指针指向新建的commit对象。</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805163507534.png" alt="image-20200805163507534"></p></li></ul><ul><li><p><strong>切换回master主分支</strong></p><p>底层：只需要将HEAD指针指向master即可。</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805171322879.png" alt="image-20200805171322879"></p></li></ul><ul><li><p><strong>在master主分支内提交新的版本</strong></p><p>底层：新建一个commit对象，hash索引设为c2b92，parent指针指向前一个commit对象f30ab。master指针指向该新建的commit对象。</p><blockquote><p><em>HEAD指针无需移动，一直指向master即可</em></p></blockquote><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805171504066.png" alt="image-20200805171504066"></p></li></ul><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p>git log   完整的查看历史记录</p><p>完整的查看历史记录</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804174018030.png" alt="image-20200804174018030"> g</p><p><strong>git log –pretty=oneline</strong>   </p><p>一次提交记录显示成一行，同时显示完整的版本号</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804174101612.png" alt="image-20200804174101612"> </p><p><strong>git log –oneline</strong> ⭐</p><p>一次提交记录显示成一行，同时显示版本号的前几位</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804174138482.png" alt="image-20200804174138482"> </p><p><strong>git reflog</strong> </p><p>包含移动步数 HEAD@{移动步数}</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804174328155.png" alt="image-20200804174328155"> </p><p><strong>git log –all</strong> </p><p>查看所有分支的历史版本</p><p><strong>git log –all –graph</strong>  ⭐</p><p>以分支图的形式在终端中显示所有分支的历史版本</p><p><strong>git log –oneline –all –graph</strong> ⭐⭐</p><p>​            </p><h2 id="分离头指针"><a href="#分离头指针" class="headerlink" title="分离头指针"></a>分离头指针</h2><p>git checkout ==commitHash版本hash / HEAD~n指针移动位数==</p><p>个人对分离头指针的定义：头指针不再指向某个分支指针，而指向具体版本。</p><p>问题情景： </p><p>第一步：git checkout 版本hash  或 git checkout HEAD~n将HEAD指针指向历史版本</p><p>第二步：对代码进行修改</p><p>第三步⭐：修改添加到缓存区，提交版本到本地库==假设Git将该版本hash值设为abc123==，此时便真正处于<code>分离头指针状态 HEAD detached</code></p><p><strong>分离头指针状态存在这样一个问题</strong>：==abc123== 与所有branch指针都没有关联，此时git就要求我们新建一个分支保存该版本，否则会在distached缓存被清除后，丢失该版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch ==newBranchName== ==abc123==<br><br>或<br>git checkout -b newBranchName<br></code></pre></td></tr></table></figure><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201122172536098.png" alt="image-20201122172536098"></p><h2 id="版本回退git-reset-和-git-revert"><a href="#版本回退git-reset-和-git-revert" class="headerlink" title="版本回退git reset 和 git revert"></a>版本回退git reset 和 git revert</h2><h3 id="基于分支的版本回退git-reset"><a href="#基于分支的版本回退git-reset" class="headerlink" title="基于分支的版本回退git reset"></a>基于分支的版本回退git reset</h3><p>git reset 命令主要是修改分支最近版本的指针。</p><h3 id="git-reset-soft-hard-mixed之区别深解-⭐"><a href="#git-reset-soft-hard-mixed之区别深解-⭐" class="headerlink" title="git reset soft,hard,mixed之区别深解 ⭐"></a><strong>git reset soft,hard,mixed之区别深解 ⭐</strong></h3><p><a href="https://blog.csdn.net/zpf336/article/details/80896020?utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242">参考资料</a></p><p><strong>首先我们来看几个术语</strong></p><ul><li><strong>HEAD:</strong> 这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交</li><li><strong>Index:</strong> 也被称为Staging area，是指一整套即将被下一个提交的文件集合。他也是将成为HEAD的父亲的那个commit</li><li><strong>Working Copy:</strong> Working copy代表你正在工作的那个文件集</li></ul><p>当你第一次checkout一个分支，HEAD就指向当前分支的最近一个commit。在HEAD中的文件集（实际上他们从技术上不是文件，他们是blobs（一团），但是为了讨论的方便我们就简化认为他们就是一些文件）和在index中的文件集是相同的，在working copy的文件集和HEAD,INDEX中的文件集是完全相同的。所有三者(HEAD,INDEX(STAGING),WORKING COPY)都是相同的状态，GIT很happy。</p><p><img src="https://img-blog.csdn.net/20180703134050437" alt="img"></p><p>当你对一个文件执行一次修改，Git感知到了这个修改，并且说：“嘿，文件已经变更了！你的working copy不再和index,head相同！”，随后GIT标记这个文件是修改过的。</p><p><img src="https://img-blog.csdn.net/20180703134315399" alt="img"></p><p>然后，当你执行一个git add,它就stages the file in the index，并且GIT说：“嘿，OK，现在你的working copy和index区是相同的，但是他们和HEAD区是不同的！”</p><p><img src="https://img-blog.csdn.net/20180703134238194" alt="img"></p><p>当你执行一个git commit,GIT就创建一个新的commit，随后HEAD就指向这个新的commit，而index,working copy的状态和HEAD就又完全匹配相同了，GIT又一次HAPPY了。</p><p><img src="https://img-blog.csdn.net/20180703134050437" alt="img"></p><p><strong>Reset 参数</strong></p><p>git reset 有一些参数，不同参数对应的细节变化又是不一样的，具体如下：</p><p><strong><code>--mixed：</code></strong></p><blockquote><p>–mixed是reset的默认参数，也就是当你不指定任何参数时的参数。它将重置HEAD到另外一个commit,并且重置index以便和HEAD相匹配，但是也到此为止。working copy不会被更改。所有该branch上从original HEAD（commit）到你重置到的那个commit之间的所有变更将作为local modifications保存在working area中，（被标示为local modification or untracked via git status)，但是并未staged的状态，你可以重新检视然后再做修改和commit。</p></blockquote><blockquote><p><img src="https://img-blog.csdn.net/20180703134315399" alt="img"></p></blockquote><p><code>--soft：</code></p><blockquote><p>–soft参数告诉Git重置HEAD到另外一个commit，但也到此为止。如果你指定–soft参数，Git将停止在那里而什么也不会根本变化。这意味着index,working copy都不会做任何变化，所有的在original HEAD和你重置到的那个commit之间的所有变更集都放在stage(index)区域中。</p><p><img src="https://img-blog.csdn.net/20180703134238194" alt="img"></p></blockquote><p><code>--hard：</code></p><blockquote><p>–hard参数将会重置HEAD返回到另外一个commit，重置index以便反映HEAD的变化，并且重置working copy也使得其完全匹配起来。这是一个比较危险的动作，具有破坏性，数据因此可能会丢失！如果真是发生了数据丢失又希望找回来，那么只有使用：<strong>git reflog</strong>命令了。makes everything match the commit you have reset to.你的所有本地修改将丢失。如果我们希望彻底丢掉本地修改但是又不希望更改branch所指向的commit，则执行：</p></blockquote><h3 id="reset-参数归纳总结："><a href="#reset-参数归纳总结：" class="headerlink" title="reset 参数归纳总结："></a>reset 参数归纳总结：</h3><p><code>git reset --hard </code></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200804205051569.png" alt="image-20200804205051569"> </p><ol><li><p>切换到目标分支</p><p>git checkout master</p></li><li><p>指定要回退的版本</p><p>git reset –hard ==版本索引值==            使用索引值前进后退</p><p>git reset –hard HEAD^            后退一个版本</p><p>git reset –hard HEAD^^          后退两个版本 （几个^就后退几个版本）</p><p>git reset  –hard HEAD <del>==n==     后退n个版本 （^换成了</del>）</p><blockquote><p>注意：在某个分支上执行git reset 会导致丢失原版本和回退版本之间的版本。</p></blockquote></li></ol><p> <code>git reset --mixed </code></p><p>执行git reset 相当于执行 git reset –mixed 即默认使用mixed。</p><p>将分支的指针指向某个commit，同时暂存区与该commit一致，工作区代码保留。</p><p>应用场景： </p><ol><li><p>撤回暂存区的内容。</p><p>git reset HEAD</p></li><li><p>撤回暂存区一个或多个文件，暂存区的撤回内容不会对工作区造成影响。</p><p>git reset HEAD – ==file1== ==file2…==</p><p><code>相当于 </code>git restore –staged ==file1== ==file2…==</p></li></ol><p><code>git reset --soft</code></p><p>将分支的指针指向某个commit，暂存区和工作区仍保留原来状态。</p><p>HEAD！= INDEX = WORKING COPY</p><p>由于暂存区仍然保持回退前的状态，所以如果想要撤销回退，直接git commit即可。</p><h3 id="常见情景：删除文件并找回"><a href="#常见情景：删除文件并找回" class="headerlink" title="常见情景：删除文件并找回"></a><strong>常见情景：删除文件并找回</strong></h3><p>前提：删除前，文件存在时的状态提交到了本地库。（本地库中存储了具有该文件的状态版本）。</p><p>操作：git reset –hard [指针位置]</p><ul><li>删除操作已经提交到了本地库：调整指针位置到该文件存在的历史版本。</li><li>删除上做尚未提交到本地库：指针位置调整为HEAD（最新版本）。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">//demo：使用版本的后退来撤销删除文件的操作<br><br>git rm new.txt<br>git commit -m <span class="hljs-string">&quot;delete new.txt&quot;</span><br><br>git reset --hard HEAD^     👈回退一个版本，即返回到删除new.txt前的版本<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>demo：删除文件的操作尚未提交到本地库，但拉取到了缓存区，恢复该文件的方法👇<br><br><span class="hljs-regexp">//gi</span>t reset命令的--hard参数的含义是强制本地库、缓存区、工作区同时回退到某个版本<br><br><span class="hljs-regexp">//</span>可利用该特性来拉回缓存区的内容<br><br>git rm new.txt<br><br>git commit --mixed HEAD  👈回退到当前版本，使缓存区与本地库一致。<br><span class="hljs-regexp">//</span>或者使用 git restore --staged new.txt + git restore new.txt分两步解决<br></code></pre></td></tr></table></figure><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><ol><li><p>git revert ==commitHash==</p><p>撤销指定commit版本的操作，这个操作也会生成一个新的commit，指定版本commit之前及之后的操作均不受影响。</p><blockquote><p><strong>需要注意的是，<code>如果git revert指定了一个非上一版本的历史版本</code>，则该版本的parent的某些内容<code>可能会</code>和当前版本发生冲突，这就需要<code>合并冲突</code>才能提交git revert产生的新版本。</strong></p><p>发生冲突的情况举例：</p><p>current1  “ echo abc &gt; new.txt “👈HEAD</p><p>history2  “create a.txt”</p><p>history3   “echo 123&gt; new.txt”   👈 git revert history3</p><p>history4  “create new.txt”</p><p>可见，history4版本下new.txt内容为空，history3版本下new.txt内容为123，current1版本new.txt内容为abc，如果撤销history3的commit，则history4和current1之间便丢失了中间过程（git存储的是文件内容的变化），会导致历史链断裂。</p><p>不发生冲突的情况举例：</p><p>current1  “ echo abc &gt; new.txt “👈HEAD</p><p>history2   “echo 123&gt; new.txt” </p><p>history3  “create a.txt”  👈 git revert history3</p><p>history4  “create new.txt”</p><p>上述的情况不会发生冲突是因为撤销history3并不会使history2和history4之间丢失中间的变化过程。</p></blockquote></li><li><p>git revert ==commitHash1== ==commitHash2…==</p><p>撤销指定的多个commit版本。</p></li><li><p>git revert ==olderCommit..oldCommit==</p><p>撤销 (olderCommit, oldCommit]之间的commit，左开右闭，即会保留olderCommit的提交。</p><blockquote><p>current 👈HEAD</p><p>history1</p><p>oldCommit    ← revert end</p><p>….</p><p>olderCommit  ← revert start</p><p>….</p><p>如上所示，如果(start, end]之间的commit撤销后，olderCommit和 [ history, currnet]之间丢失了中间过程，同样会导致冲突。</p></blockquote></li></ol><pre><code>综上所述：使用git revert时最推荐的做法还是根据从新到旧的顺序，依次撤销commit，尽量不要存在间隔。</code></pre><h2 id="变基命令-rebase"><a href="#变基命令-rebase" class="headerlink" title="变基命令 rebase"></a>变基命令 rebase</h2><p>git rebase -i ==baseCommit==</p><blockquote><p>-i / –interactive  代表交互式</p></blockquote><h3 id="应用情景1：修改commit的message"><a href="#应用情景1：修改commit的message" class="headerlink" title="应用情景1：修改commit的message"></a>应用情景1：修改commit的message</h3><ol><li><p><strong>修改最近一次提交的commit的message</strong></p><p>git commit –amend， 会出现以下文件内容：</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121220040518.png" alt="image-20201121220040518"></p><p>修改顶部的message内容，:wq保存即可。</p></li></ol><ol start="2"><li><p><strong>修改历史任意一个commit的message</strong></p><p>例如，我们需要修改 hash值为balf22b的commit对象的message，则我们<code>需要以balf22b的parent为基础</code>进行变基操作。</p><p>==commit 18b080c==   👈<code>parent</code>   ==commit balf22b== 👈<code>parent</code> ==commit child123==</p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121221505369.png" alt="image-20201121221505369"> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rebase -i init00 进入交互式页面。（一个文件）<br></code></pre></td></tr></table></figure><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121221531229.png" alt="image-20201121221531229"></p><p>pick 命令代表使用该commit对象</p><p>reword 命令代表修改该commit对象的message</p><p>drop 命令代表丢弃该commit对象，即从历史版本链中删除该版本。</p><p>squash 命令代表合并commit</p><p>……</p><p>⭐ 可见，我们这里应该使用reword </p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121221721667.png" alt="image-20201121221721667"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121221837885.png" alt="image-20201121221837885"></p></li></ol><blockquote><p>这里解释为何必须选择目标commit的父级commit进行变基：</p><p>如果直接基于需要修改message的commit进行变基，则修改该commit的message后，该commit的hash值便发生了改变（例如由abc123变为def456），其后的版本commit的parent指针仍然指向abc123，所以就发生了版本链的断裂，而且abc123指向不明，就会报错。</p></blockquote><h3 id="应用情景2：合并commit"><a href="#应用情景2：合并commit" class="headerlink" title="应用情景2：合并commit"></a>应用情景2：合并commit</h3><ol><li><p><strong>合并连续的commit</strong></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121223201907.png" alt="image-20201121223201907"> </p><p>如上图，连续编辑了两次index.html的操作可以合并成一个。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#这里，853f263和d1bc279可以合并成一个，则必须使用853f263的父级commit进行变基操作。</span><br>$ git rebase -i 30438ce<br></code></pre></td></tr></table></figure><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121223508509.png" alt="image-20201121223508509"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用squash命令，将d1bc279合并到853f263</span><br></code></pre></td></tr></table></figure><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121223715612.png" alt="image-20201121223715612"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121223831593.png" alt="image-20201121223831593"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121223924154.png" alt="image-20201121223924154"></p></li></ol><ol start="2"><li><p><strong>合并不连续的commit</strong></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121224221399.png" alt="image-20201121224221399"> </p><p>在两次变基index.html中间有提交README的commit，则要合并间隔的commit<code>0775df9</code>和<code>5e1d10e</code>需要特殊操作。</p><blockquote><p>注意：</p><pre><code>合并0775df9和5e1d10e，要求合并的结果与 0775df9到5e1d10e之间任何一个版本不存在冲突，才允许合并。</code></pre></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$git</span> rebase -i 30438ce<br></code></pre></td></tr></table></figure><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121224428436.png" alt="image-20201121224428436"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121224534459.png" alt="image-20201121224534459"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121224638413.png" alt="image-20201121224638413"></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201121224751464.png" alt="image-20201121224751464"></p></li></ol><h3 id="应用场景3：删除一个或多个commit"><a href="#应用场景3：删除一个或多个commit" class="headerlink" title="应用场景3：删除一个或多个commit"></a>应用场景3：删除一个或多个commit</h3><p>git rebase -i ==baseHash==</p><p>然后对指定的commit使用<code>drop命令</code>，其用法逻辑与git revert类似。但需要注意的是，一旦drop某版本，就会丢失该版本。而git revert会保留原版本，创建新版本。 </p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201123172927502.png" alt="image-20201123172927502"></p><h3 id="变基操作失败"><a href="#变基操作失败" class="headerlink" title="变基操作失败"></a>变基操作失败</h3><p>git status查询状态，若处于rebase交互状态但抛出了错误，需要处理冲突。</p><p>或者可以使用git rebase –abort跳出rebase交互。</p><h2 id="Git仓库本地备份"><a href="#Git仓库本地备份" class="headerlink" title="Git仓库本地备份"></a>Git仓库本地备份</h2><p>假设本地有个git仓库的地址为 <code>~/Desktop/Git</code></p><p>想要在本地建立地址为 <code>D:/repository/Git</code>的备份仓库。</p><h3 id="使用本地库备份"><a href="#使用本地库备份" class="headerlink" title="使用本地库备份"></a><strong>使用本地库备份</strong></h3><ol><li><p>切换到D:/repository目录（父级目录）</p></li><li><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令格式： git clone 被备份仓库目录名/.git 备份仓库目录名  </span><br>git <span class="hljs-built_in">clone</span> ~/Desktop/Git/.git Git<br></code></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/Git <span class="hljs-comment"># 切换到被备份的仓库</span><br>git remote add localBackup D:/repository/Git<br>git push -u localBackup master <span class="hljs-comment"># 将master分支上传到本地备份库</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="使用裸仓库备份"><a href="#使用裸仓库备份" class="headerlink" title="使用裸仓库备份"></a><strong>使用裸仓库备份</strong></h3><p>裸仓库：不含有工作区的Git仓库，由于不存在工作区，所以在该仓库目录下不能执行用于更新的git命令，该仓库只能通过其他仓库push或自身去fetch来更新。</p><blockquote><p>网络释义：使用 git init –bare <repo> 或git clone –bare <url> <repo>可以创建一个裸仓库，并且这个仓库是可以被正常 clone 和 push 更新的， 裸仓库不包含工作区，所以并不会存在在裸仓库上直接提交变更的情况。</p></blockquote><ol><li><p>切换到D:/repository</p></li><li><p>执行带–bare参数的git clone命令，创建裸仓库（不带工作区）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用哑协议</span><br>git <span class="hljs-built_in">clone</span> --bare ~/Desktop/Git/.git Git <br><span class="hljs-comment"># 或使用file协议</span><br>git <span class="hljs-built_in">clone</span> --bare file://C:\\Users\\Mazheng\\Desktop\\Git\\.git Git <br><br><span class="hljs-comment"># 此时 D:/repository/Git成为一个裸仓库。</span><br></code></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/Git <span class="hljs-comment"># 切换到被备份的仓库</span><br>git remote add localBackup D:/repository/Git<br>git push -u localBackup master <span class="hljs-comment"># 将master分支上传到本地备份库</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="本地库与GitHub远程库交互"><a href="#本地库与GitHub远程库交互" class="headerlink" title="本地库与GitHub远程库交互"></a>本地库与GitHub远程库交互</h2><h3 id="本地库内容推送到远程库"><a href="#本地库内容推送到远程库" class="headerlink" title="本地库内容推送到远程库"></a>本地库内容推送到远程库</h3><ol><li><p>首先在GitHub账户内创建仓库。</p></li><li><p>在本地新建一个git仓库。</p></li><li><p>本地库提交版本后向远程库推送。</p><p>以http协议的URL向GitHub仓库推送为例</p><p>git remote add ==URL别名/主机名== ==远程仓库URL==</p><p>例：git remote add origin <a href="https://github.com/mzleman/MyFirstTest.git">https://github.com/mzleman/MyFirstTest.git</a> </p></li><li><p>输入GitHub账号与密码</p><p><font color="red">只有远程库仓库的Owner以及Collaborator才有权限向远程库推送，同时如果本地库的远程库版本比远程库当前版本旧（远程库被他人更新，用户本地的版本旧，或者是拉取的版本旧），则无法向远程库推送。必须拉取新的远程库到本地后，再更新内容，才可以向远程库推送。</font></p></li><li><p>git push -u ==URL别名/主机名== ==本地分支名==</p><p>-u参数是将本地的分支与远程主机的同名分支关联起来。同时git push命令用于将当前分支提交到远程库。</p></li><li><p>在使用过一次带-u的git push命令后，只需要在切换到当前分支后直接使用git push就可以将当前分支推送到远程对应的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin https://github.com/mzleman/MyFirstTest.git <br>git push -u origin master  <br>👆 第一次建立本地分支与远程分支之间的关联，并将本地的master分支推送到origin主机下的同名分支(这里就是master)。<br><br>👇<br>git checkout master<br>git push  在已经建立好远程分支关联的情况下，可以直接使用git push将本分支推送到远程分支<br></code></pre></td></tr></table></figure></li></ol><h3 id="SSH密钥登录"><a href="#SSH密钥登录" class="headerlink" title="SSH密钥登录"></a>SSH密钥登录</h3><p><strong>通过以下步骤：</strong></p><ol><li><p>客户端生成私钥和公钥。</p></li><li><p>GitHub账户内保存客户端SSH公钥</p></li><li><p>本地库设置远程库SSH地址的别名，例如==origin==</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;SSH&gt;<br></code></pre></td></tr></table></figure></li></ol><p><strong>就可以在本地库使用SSH远程地址向GitHub仓库推送，具体可百度或看视频</strong></p><p><a href="https://www.bilibili.com/video/BV1Ep4y1Q7KR?p=31">参考视频1</a></p><p><a href="https://www.bilibili.com/video/BV1pW411A7a5?p=42">参考视频2</a></p><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20201124175026945.png" alt="image-20201124175026945"></p><h3 id="远程库拷贝到本地"><a href="#远程库拷贝到本地" class="headerlink" title="远程库拷贝到本地"></a>远程库拷贝到本地</h3><ol><li><p>切换到准备存放本地库的<code>父级目录</code>。</p></li><li><p>拷贝远程库到本地</p><p>git clone ==GitHub仓库的URL(https/ssh)== ==本地库文件夹名==</p><p><font color="red">git clone命令会做三件事： ①完整的把远程库下载到本地 ；②创建origin远程地址别名 ；③在本地库目录中执行git init命令，初始化本地库。</font></p><blockquote><p>注意：如果在服务端设置了公钥，本地用户配置了公钥和私钥，则使用ssh地址克隆时，可以免密推送。</p></blockquote></li><li><p>切换到本地库目录</p><p>cd ==本地库文件夹名==</p></li></ol><h3 id="远程库的拉取"><a href="#远程库的拉取" class="headerlink" title="远程库的拉取"></a>远程库的拉取</h3><p>本地库拉取远程库的较新版本，若本地库的历史记录中已经拉取过了远程库该版本，本地库将不发生任何改变，并提示本地库已经是最新版本。 </p><ul><li><p><strong>间接拉取某个分支</strong></p><ol><li><p>git fetch ==远程库别名== ==分支名==</p><p>执行fetch操作后，git本地库会创建一个临时的新分支，分支名为  ==远程库别名/分支名== ，这个分支可供本地库拥有者查看远程库拉取的内容，再决定是否合并到本地库某个分支。</p></li><li><p>切换到要合并远程库的本地库分支，执行git merge ==远程库别名/分支名==</p></li><li><p>若发生合并冲突，解决冲突后执行git add 和git commit操作。</p></li></ol></li></ul><ul><li><strong>直接拉取某个分支</strong><ol><li>git pull ==远程库别名== ==分支名==</li><li>若发生合并冲突，解决冲突后执行git add和git commit操作。</li></ol></li></ul><h2 id="团队协同合作"><a href="#团队协同合作" class="headerlink" title="团队协同合作"></a>团队协同合作</h2><p>多数情况下，一个项目是由多人协同开发。</p><p>假设现有两个人维护开发同一个分支，可能会产生以下的情景：</p><h3 id="情景1-两人修改了不同的文件"><a href="#情景1-两人修改了不同的文件" class="headerlink" title="情景1. 两人修改了不同的文件"></a>情景1. 两人修改了不同的文件</h3><p>Coder1 在commit abc123的基础上修改了<code>index.html</code></p><p>Coder2 在commit abc123的基础上修改了<code>style.css</code></p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交修改style.css的版本，再向远端push时会<font color ="red">报错</font></p><h3 id="情景2-两人修改了同一文件的不同区域"><a href="#情景2-两人修改了同一文件的不同区域" class="headerlink" title="情景2. 两人修改了同一文件的不同区域"></a>情景2. 两人修改了同一文件的不同区域</h3><p>Coder1 在commit abc123的基础上修改了index.html的<code>第一行</code></p><p>Coder2 在commit abc123的基础上修改了index.html的<code>第二行</code></p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交修改index.html的版本，再向远端push时会<font color ="red">报错</font>。</p><blockquote><p>以上两种情况，只需要后提交的Coder在提交前进行一次 fetch + merge 的操作，就可以解决问题。因为多人修改不同的文件、修改同一文件的不同区域都不会引发合并冲突。</p><p>fetch + merge = pull</p><p>但是建议使用fetch后查看一下当前分支和远端分支的区别。</p></blockquote><h3 id="情景3-两人修改了同一文件的同一区域"><a href="#情景3-两人修改了同一文件的同一区域" class="headerlink" title="情景3. 两人修改了同一文件的同一区域"></a>情景3. 两人修改了同一文件的同一区域</h3><p>Coder1 在commit abc123的基础上修改了index.html的<code>第一行</code></p><p>Coder2 在commit abc123的基础上修改了index.html的<code>第一行</code></p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交修改index.html的版本，再向远端push时会<font color ="red">报错</font></p><blockquote><p>这种情况要求Coder2进行一次 fetch + merge + 合并冲突 的操作，然后再将合并后新版本push到远程库。</p></blockquote><h3 id="情景4-一人只修改了文件名，另一人只修改了该文件内容"><a href="#情景4-一人只修改了文件名，另一人只修改了该文件内容" class="headerlink" title="情景4. 一人只修改了文件名，另一人只修改了该文件内容"></a>情景4. 一人只修改了文件名，另一人只修改了该文件内容</h3><p>Coder1 在commit abc123的基础上将index.html改名为index.htm</p><p>Coder2 在commit abc123的基础上修改了index.html的<code>第一行</code></p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交自己的的版本（包含修改了第一行的index.html），再向远端push时会<font color ="red">报错</font></p><blockquote><p>此时需要Coder2将远端分支 fetch + merge  / pull 即可。由于修改文件名的操作并不会修改blob对象的哈希值，所以Git在Coder2拉取def456时能感知到index.html只是修改了文件名，而没有修改文件内容，所以可以直接合并。</p></blockquote><h3 id="情景5-两人同时修改了一个文件的文件名"><a href="#情景5-两人同时修改了一个文件的文件名" class="headerlink" title="情景5. 两人同时修改了一个文件的文件名"></a>情景5. 两人同时修改了一个文件的文件名</h3><p>Coder1 在commit abc123的基础上将index.html改名为index.htm</p><p>Coder2 在commit abc123的基础上将index.html改名为main.htm</p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交自己的新版本（包含main.htm），再向远端push时会<font color ="red">报错</font></p><blockquote><p>此时需要Coder2将远端分支 fetch + merge / pull 拉取远端分支最新内容。由于修改文件名的操作不会修改blob对象的hash值，Coder2的新版本和远端分支最近版本（Coder1提交的def456）之间的冲突<code>在于文件名的冲突</code>，所以需要依次执行</p><p>git rm index.html</p><p>git rm main.htm/index.htm</p><p>git add index.htm/main.htm</p><p>即在main.htm 和 index.htm中选择一个，提交成新commit后再push到远端分支。</p></blockquote><h3 id="情景6-两人同时修改了一个文-件的文件名，并对内容都做了修改。"><a href="#情景6-两人同时修改了一个文-件的文件名，并对内容都做了修改。" class="headerlink" title="情景6. 两人同时修改了一个文 件的文件名，并对内容都做了修改。"></a>情景6. 两人同时修改了一个文 件的文件名，并对内容都做了修改。</h3><p>Coder1 在commit abc123的基础上将index.html改名为index.htm，修改了第一行内容。</p><p>Coder2 在commit abc123的基础上将index.html改名为main.htm，修改了第一行内容。</p><p>Coder1 提交了修改了index.html的版本commit def456，同时push到远端分支。</p><p>Coder2 提交自己的新版本（包含main.htm），再向远端push时会<font color ="red">报错</font></p><blockquote><p>尽管不建议这样处理，但还是进行简单说明处理办法：</p><p>在这种情况下，Git会认为 远端分支删除了index.html、新增了index.htm，本地新增了main.htm，只需要简单的合并即可，并不会发生冲突。</p></blockquote><blockquote><p>❗  <strong>强烈建议</strong> ❗：在重命名某个文件后进行一次commit操作，同时push到远程库。让重命名文件的操作能够让团队协作者发现，从而可以提前发现问题。！！！</p></blockquote><h2 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h2><p><img src="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/image-20200805225957085.png" alt="image-20200805225957085"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2021/05/06/Web/front-end-optimization/"/>
    <url>/2021/05/06/Web/front-end-optimization/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下性能优化的手段是主流的、面向Chrome的，但适用于大部分浏览器。</p><h2 id="渲染引擎组成"><a href="#渲染引擎组成" class="headerlink" title="渲染引擎组成"></a>渲染引擎组成</h2><p>一个渲染引擎主要包括：</p><ol><li>HTML解析器：用于解析HTML文本，将文本解析为DOM树。</li><li>CSS解析器：用于解析CSS文本，构建CSS树。</li><li>JS引擎：用于执行HTML中script标签内的代码，可以通过浏览器的API操作DOM元素。</li><li>布局模块：在将DOM树和CSS树合并为Render树后，布局模块计算每个元素的位置和大小。</li><li>绘图模块：绘制页面。</li></ol><h2 id="大致的解析与渲染流程"><a href="#大致的解析与渲染流程" class="headerlink" title="大致的解析与渲染流程"></a>大致的解析与渲染流程</h2><ol><li><p>调用HTML解析器解析HTML文本（包括HTML标签、SVG、XHTML），目标是构建一棵DOM树。</p></li><li><p>遇到<code>style</code>标签，异步地解析<code>style</code>标签内的CSS代码，并更新CSS树。</p><blockquote><p>内联的CSS代码不阻塞Render Tree生成与页面初次渲染。</p></blockquote></li><li><p>遇到<code>link stylesheet</code>，异步地请求资源，在CSS文件被返回时，异步地调用CSS解析器解析文件中的CSS代码，并更新CSSOM（CSS Object Model）。</p><blockquote><p>不同于style标签，外链CSS样式表的下载与解析会阻塞Render Tree的生成与后续的页面初次渲染。</p></blockquote></li><li><p>遇到<code>普通 script</code>标签，同步地请求资源，在JS文件被返回时，同步地执行文件中的JS代码。</p></li><li><p>HTML解析完成后生成一棵DOM树，CSSOM构建完成后，将CSSOM和DOM树合并为<code>Render Tree</code>。</p><blockquote><p>渲染树不是简单地将二者合并，它只会包含可视节点与其样式信息。</p></blockquote></li><li><p>根据渲染树中的尺寸样式和布局样式，计算每个节点的几何信息（位置和形状）</p><blockquote><p>初次渲染时这个环节可以叫做“布局”，再次触发这个过程就称为回流 <code>reflow</code>或重排。</p></blockquote></li><li><p>根据外观样式+布局的结果，将节点绘制到图层位图上 👈 再次触发这个过程就称为重绘。</p><blockquote><p>初次渲染时这个环节可以叫“绘制”，再次触发这个过程就称为重绘<code>repaint</code>。</p></blockquote></li><li><p>将像素图层发送给GPU，显卡发送信号展示页面。</p></li></ol><h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210525230335464.png" alt="image-20210525230335464"></p><p><strong>为了构建渲染树，浏览器主要完成了以下工作：</strong></p><ol><li>从DOM树的根节点开始遍历每个可见节点。</li><li>对于每个可见的节点，找到CSSOM中对应的规则，并应用它们。</li><li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li></ol><blockquote><p>⭐ 由此可见，构建渲染树是一个相当复杂且费时的工作。</p><p>所以我们在构建页面时，要注意：</p><ol><li>DOM树要小，层级不宜过深。</li><li>CSS选择器尽量用id和class，层级不宜过深。</li></ol></blockquote><p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。</p><p><strong>不可见的节点包括：</strong></p><ul><li>一些不会渲染输出的节点，比如<code>script、meta、link</code>等。</li><li>一些通过css进行隐藏的节点。比如<code>display:none</code>。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li></ul><blockquote><p>再次强调，<strong>渲染树中只包含可见的节点。</strong></p></blockquote><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><h3 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h3><ol><li><p><strong>关于style标签内的CSS</strong></p><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>        margin: 0;<br>        padding: 0;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>不阻塞DOM解析</strong></li><li><strong>不阻塞DOM渲染</strong>（style标签内的CSS代码是异步解析更新CSS树的）</li></ul><ol start="2"><li><p><strong>关于link标签引用的外部样式表</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;common.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>外部样式表的下载不阻塞DOM解析，</strong>HTML解析器在解析到外部引用CSS时，会发出异步请求，得到响应后使用CSS解析器异步解析该文件（相较于HTML解析）。</li><li><strong>外部样式表的下载和解析阻塞DOM渲染，</strong>即只要有link标签引用的外部资源没有加载或加载了但CSS解析器没完成解析，DOM不会完成渲染，页面不显示内容，尽管这时候DOM解析可能已经完成了。</li><li><strong>外部样式表的下载和解析阻塞后面的JS脚本执行，</strong>即只要script标签前面的有引用的外部样式表没有加载、解析完成，则script标签内的JS脚本不会执行。</li></ul></li></ol><blockquote><p>优化手段：</p><ul><li>小：优化CSS代码，CSS文件压缩合并。</li><li>早：通过preload资源暗示、HTML中link标签位置放置于JS脚本之前等。</li><li>近：利用CDN节点。</li></ul><p>⭐ 目的都是尽可能快的下载CSS文件。</p></blockquote><h3 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h3><ol><li><p><strong>普通的内联JS代码</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>内联的JS脚本的执行阻塞DOM解析</strong>，即HTML解析器会停下来等待脚本执行完毕。</li><li><strong>由于阻塞DOM解析，所以一定阻塞DOM渲染</strong>（渲染的必要条件是DOM解析完成，构建DOM树）。</li></ul></li></ol><ol start="2"><li><p><strong>普通的外部JS资源</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>外部JS资源的下载会阻塞DOM解析</strong>。</li><li><strong>外部JS资源的执行也会阻塞DOM解析</strong>。</li></ul><blockquote><p>即HTML解析器遇到这样的一个外部JS引用标签，会等待该JS文件下载成功、执行完毕后，再继续解析下面的HTML代码。</p></blockquote></li></ol><ol start="3"><li><p><strong>defer / async script标签</strong></p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bar.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>async script 的下载是异步的，不阻塞DOM解析，也不阻塞渲染</strong>。注意，是JS脚本的下载任务是不阻塞DOM解析和渲染的。</li><li><strong>async script 的执行可能会阻塞DOM解析，因此可能阻塞渲染</strong>。如果下载完成的时间点在DOM解析完成之前，则该脚本的执行会阻塞，如果下载完成的时间点在DOM解析完成之后，则不阻塞DOM渲染。</li><li><strong>async script 是乱序执行的</strong>，只要下载完成且不被CSS解析阻塞就执行，不考虑与其他async script的顺序关系。</li></ul><blockquote><p>async script是乱序的，所以可以用于链接那些不依赖于其他脚本、且不被其他脚本依赖的JS代码文件。</p><p>async script的执行会中断DOM解析，所以async script中最好不要操作非该脚本创建的DOM元素，因为此时HTML解析到了哪个元素是不确定的。</p><p>❓ 有一个问题：如果async script下载完成的时机是在DOM解析完成之后，DOM渲染之前，那这个JS脚本阻不阻塞DOM渲染？</p></blockquote></li></ol><ul><li><p><strong>defer script 的下载是异步的，不阻塞DOM解析，也不阻塞渲染。</strong></p></li><li><p><strong>defer script 的执行不阻塞DOM解析</strong>。<font color='red'>最早的执行时间点</font>是DOM解析完成之后，DOMContentLoaded事件之前。</p></li><li><p><strong>defer script 的执行可能阻塞DOM渲染</strong>。如果defer script在DOM解析完成之前下载完成，则将在DOM解析完成之后进行执行，则可能阻塞DOM渲染。</p></li><li><p><strong>defer script 是顺序执行的。</strong>H5规范规定defer scripts 之间的执行顺序要严格按照在HTML文件中的位置，从上到下执行。</p><blockquote><p>一般情况下，defer script更能满足应用脚本的使用场景。</p><p>❓ 这里同样有这样一个问题：如果defer script下载完成的时机是在DOM解析完成之后，DOM渲染之前，那这个JS脚本阻不阻塞DOM渲染？</p></blockquote></li></ul><p>   <img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523144121965.png" alt="image-20210523144121965"></p><blockquote><p>优化手段：</p><ul><li>通过defer属性的JS引用避免阻塞DOM解析。</li><li>利用prefetch属性加载非必要但可能会用到的JS文件。</li></ul></blockquote><h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><h3 id="基于图层渲染"><a href="#基于图层渲染" class="headerlink" title="基于图层渲染"></a>基于图层渲染</h3><p>更具体来说，浏览器在渲染一个页面时会将页面分成一到多个图层：</p><ol><li><p>基于HTML解析+CSS解析的结果，这个过程中会根据DOM元素的特性将所有元素分为一到多个图层，而DOM树和CSS树合成为渲染树。</p><blockquote><p>我理解为：渲染树的节点信息中包含这个元素属于哪个图层，即图层信息包含在渲染树内。</p></blockquote></li><li><p>为每个节点计算位置、形状（回流）。</p></li><li><p>将每个DOM节点绘制填充到图层位图中（重绘）。</p></li><li><p>图层作为纹理上传到GPU。</p></li><li><p>GPU组合多个图层，进行叠加等操作，最后将结果展示到屏幕上。</p></li></ol><h3 id="创建图层"><a href="#创建图层" class="headerlink" title="创建图层"></a>创建图层</h3><p>基于Chrome进行测试，以下情况会创建图层：</p><ol><li><p>所有页面有一个document图层，一般的DOM元素绘制于该图层上。</p></li><li><p>拥有3D变换CSS属性<code>transform</code>的DOM节点会单独开辟一个图层。</p></li><li><p>应用CSS3动画的节点<code>animation: keyfameName</code>。</p></li><li><p>使用加速视频解码的<code>&lt;video&gt;</code>节点会开辟一个图层。</p></li><li><p><code>&lt;canvas&gt;</code>节点会开辟一个图层。</p></li><li><p>拥有CSS加速属性的元素（<code>will-change</code>）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#animate</span> &#123;<br>    <span class="hljs-attribute">will-change</span>: transform;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>❓ 不确定。Chrome中固定定位fixed和粘滞定位stick的元素好像也会单独设置为一个图层。</p></li></ol><h2 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h2><h3 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流 reflow"></a>回流 reflow</h3><p>基于更新后的渲染树，将可见DOM节点与其布局样式、尺寸结合起来，计算出它们在布局视口中的确切位置和形状大小，这个计算的阶段就是回流。</p><h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘 repaint"></a>重绘 repaint</h3><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，和他们的具体几何信息(位置、大小)，那么我们就可以再根据外观样式，将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。</p><blockquote><p><strong>重绘是以图层为单位的</strong>，如果图层中某个元素需要重绘，则整个图层都需要重绘。</p><p>所以为了提高性能，我们应该让这些经常会重绘的元素拥有一个自己的图层。</p></blockquote><h3 id="触发回流的情况"><a href="#触发回流的情况" class="headerlink" title="触发回流的情况"></a>触发回流的情况</h3><ul><li>添加或删除可见的DOM元素（包括设置<code>display：none</code>或由<code>none</code>转为其他值） 。</li><li>元素的位置发生变化。</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>页面的布局视口变化（特别是PC端窗口resize，因为回流是根据视口的大小来计算元素的位置和大小的）。</li><li>字体发生变化。</li><li>…..</li></ul><blockquote><p><strong>大部分情况下，重排是以Render Tree为单位的</strong>，因为如果某个独立图层上的元素触发了重排，而该图层的元素没有脱离文档流，则单独重排该图层是达不到效果的。</p></blockquote><p><strong>具体而言，以下CSS属性发生改变会触发回流：</strong></p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210525232641079.png" alt="image-20210525232641079"></p><p><strong>同时，通过Web APIS访问以下CSS样式会触发回流：</strong></p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210525233110226.png" alt="image-20210525233110226"></p><blockquote><p><strong>只要是获取元素位置相关的操作，都会触发回流，原因在于：</strong></p><p>现代的浏览器是经过优化的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列进行一次回流/重绘，以减少回流/重绘次数（类似于节流）。但是！<strong>当你每次获取布局信息的操作的时候，会强制队列刷新，进行一次回流/重绘，以得到最新最准确的信息</strong>。</p><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新触发回流的操作队列，强制进行一次回流计算。如果要使用它们，最好将值缓存到JS变量中。</strong></p></blockquote><h3 id="触发重绘的情况"><a href="#触发重绘的情况" class="headerlink" title="触发重绘的情况"></a>触发重绘的情况</h3><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210530192602044.png" alt="image-20210530192602044"></p><blockquote><p>总结为： </p><ul><li>color</li><li>background 简写属性及其相关具体样式。</li><li>一些装饰性的样式，如border-radius、border-style、text-decoration、box-shadow、outline相关。</li><li>visibility</li></ul></blockquote><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ol><li><p>在兼容性良好的情况下，移动元素位置时，使用<code>transform</code>，替代操作<code>left/top</code>。</p><blockquote><p><code>transform</code>的改变仅仅是改变图层的组合方式，而不触发重排和重绘。</p></blockquote></li><li><p>使用<code>opacity: 0;/ opacity: 1;</code>代替<code>visibility: hidden;/ visibility: visible;</code>。</p><ul><li><p>使用<code>visibility</code>不触发重排，但是依然重绘。</p></li><li><p>直接使用<code>opacity</code>既触发重绘，又触发重排。</p></li><li><p>理论上，改变一个独享图层的元素的<code>opacity</code>属性，既不触发重排，也不触发重绘。</p><blockquote><p>这里有点小问题，最新版本的Chrome测试的结果是配合图层使用时，<code>opacity</code>也会触发重绘。</p></blockquote></li></ul></li><li><p>利用元素的<code>class</code>，将多个样式的改变合并成一次操作（修改元素类名）。</p></li><li><p>将DOM元素脱离DOM树后再修改。</p><blockquote><p>DOM元素不在DOM树中意味着元素不在渲染树中，这有两种情况：</p><ul><li>元素不在DOM树中，就不可能存在于渲染树中。</li><li>元素在DOM树中，但<code>display: none;</code></li></ul><p>如果要对一个元素进行复杂的样式操作时，可以先不插入DOM树、或者先对该树中元素使用<code>display: none;</code>，操作完样式后再使之可见。这样至多触发2次重排重绘。</p></blockquote></li><li><p>利用文档碎片<code>documentFragment</code>。Vue中就利用了该方式提升渲染性能。</p></li><li><p>避免频繁地通过JS访问节点的位置、尺寸等样式属性，必要时进行缓存。</p></li></ol><p><strong>其他关于动画的优化手段：</strong></p><ol><li>当通过背景图片位置的变化实现动画效果时，记得为该元素开启一个图层，最简单的方式：<code>transform: translateZ(0)</code>。</li><li>不懂❓ 为动画元素新增图层，提高动画元素的<code>z-index</code>。</li></ol><h2 id="Event-Loop-与-渲染"><a href="#Event-Loop-与-渲染" class="headerlink" title="Event Loop 与 渲染"></a>Event Loop 与 渲染</h2><p>关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：</p><ol><li>每一轮 Event Loop 都会伴随着渲染吗？</li><li><code>requestAnimationFrame</code> 在哪个阶段执行，在渲染前还是后？在 <code>microTask</code> 的前还是后？</li><li><code>requestIdleCallback</code> 在哪个阶段执行？如何去执行？在渲染前还是后？在 <code>microTask</code> 的前还是后？</li><li><code>resize</code>、<code>scroll</code> 这些事件是何时去派发的。</li></ol><blockquote><p>这是一篇博客提出的问题👉<a href="https://blog.csdn.net/frontend_frank/article/details/106309066">原文</a>。</p></blockquote><h3 id="事件循环与页面渲染的流程"><a href="#事件循环与页面渲染的流程" class="headerlink" title="事件循环与页面渲染的流程"></a>事件循环与页面渲染的流程</h3><p>注意：同一时间，JavaScript脚本执行与页面渲染互斥。</p><ol><li><p>从任务队列中取出一个<font color='red'>宏任务</font>执行。</p></li><li><p>检查微任务队列，执行并清空<font color='red'>微任务</font>队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。</p></li><li><p>清空微任务队列后，<font color='red'>判断是否允许渲染</font>（每次渲染间有一个<font color='red'>最小时间间隔阈值</font>，这个阈值与用户屏幕刷新率、页面性能状态等有关）。</p><blockquote><p>浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。</p></blockquote></li><li><p>如果允许渲染，就这是一个<code>rendering oppotunity</code>，<font color='red'>再判断是否需要渲染</font>：</p><ul><li>考虑更新渲染是否会带来视觉上的改变？如果是，则渲染。</li><li>观察<code>map of animation frame callbacks</code>是否为空，即是否使用了requestAnimationFrame注册了回调。如果是，则渲染。</li></ul><p>如果上述两个条件都不满足，则浏览器将<font color='red'>跳过接下来的渲染流程</font>。</p></li><li><p>对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 <code>resize</code> 方法。</p></li><li><p>对于需要渲染的文档，如果页面发生了滚动，执行 <code>scroll</code> 方法。</p></li></ol><blockquote><p>❓ 对于5和6，也不清楚具体的意思，但是好像scroll和resize事件的回调有比较高的优先级。</p></blockquote><ol start="7"><li>对于需要渲染的文档，执行帧动画回调，也就是<font color='red'>执行requestAnimationFrame 的回调</font>。</li><li>对于需要渲染的文档， 执行 InterpObserver 的回调。</li><li>对于需要渲染的文档，<strong>重新渲染</strong>绘制用户界面。 ⭐⭐ <font color='red'>终于轮到正式渲染页面一次</font>。</li><li><font color='red'>判断宏任务队列和微任务队列是否都为空</font>，如果是的话，则进行 <code>Idle</code> 空闲周期的算法，判断是否要执行 <code>requestIdleCallback</code> 的回调函数。</li></ol><h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>使用<code>requestAnimationFrame</code>实现动画效果。</p><p><strong>MDN解释：</strong><code>window.requestAnimationFrame(fn)</code>告诉浏览器——你希望执行动画，并且要求浏览器<font color='red'>在下一次重绘之前调用指定的回调函数</font>更新动画。</p><ul><li><p>该方法需要传入一个回调函数<code>fn</code>作为参数，该回调函数会被注册，并在浏览器下一次重绘之前执行，执行完毕后会从注册表中清除，如果想实现连续的动画效果，<code>fn</code>中需要重新调用<code>requestAnimationFrame</code>。</p></li><li><p>该方法返回一个ID，该ID可以用于解除回调函数的注册（使用<code>cancelAnimationFrame(ID)</code>）。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> distance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">let</span> elm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>    elm.style.transform = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;++distance&#125;</span>)`</span>;<br>    id = requestAnimationFrame(move);  <span class="hljs-comment">// 更新id，JS会阻塞DOM渲染。</span><br>&#125;<br><br><span class="hljs-keyword">let</span> id = requestAnimationFrame(move); <span class="hljs-comment">// 页面第一次渲染时会发生重绘，动画便开始了。</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> cancelAnimationFrame(id), <span class="hljs-number">2000</span>); <span class="hljs-comment">// 👈2s 后取消动画</span><br></code></pre></td></tr></table></figure><blockquote><p>requestAnimationFrame注册的回调函数会在下一个<code>render oppotunity</code>时执行，不同用户屏幕的刷新率不同，高刷屏幕执行该回调函数的频率会更大。</p></blockquote><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，<strong>将网站的内容发布到最接近用户的“边缘节点”，使用户可以就近取得所需的内容</strong>，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。</p><p>————————————————<br>版权声明：本文为CSDN博主「xiangzhihong8」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/xiangzhihong8/article/details/83147542">https://blog.csdn.net/xiangzhihong8/article/details/83147542</a></p><h3 id="CDN相关技术"><a href="#CDN相关技术" class="headerlink" title="CDN相关技术"></a>CDN相关技术</h3><p>CDN的实现需要依赖多种网络技术的支持，其中最主要的包括负载均衡技术、动态内容分发与复制技术、缓存技术等。</p><p><strong>负载均衡技术</strong><br>负载均衡技术不仅仅应用于CDN中，在网络的很多领域都得到了广泛的应用，如服务器的负载均衡、网络流量的负载均衡。顾名思义，网络中的负载均衡就是将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或网络节点上，由此来避免部分网络节点过载。这样既可以提高网络流量，又提高了网络的整体性能。在CDN中，负载均衡又分为服务器负载均衡和服务器整体负载均衡(也有的称为服务器全局负载均衡)。服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。而服务器整体负载均衡允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。</p><blockquote><p>智能DNS服务器的核心就是根据负载均衡策略导流不同来源的请求。</p></blockquote><p><strong>动态分发与复制技术</strong><br>众所周知，网站访问响应速度取决于许多因素，如网络的带宽是否有瓶颈、传输途中的路由是否有阻塞和延迟、网站服务器的处理能力及访问距离等。多数情况下，网站响应速度和访问者与网站服务器之间的距离有密切的关系。如果访问者和网站之间的距离过远的话，它们之间的通信一样需要经过重重的路由转发和处理，网络延误不可避免。一个有效的方法就是利用内容分发与复制技术，将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上。所以动态内容分发与复制技术也是CDN所需的一个主要技术。</p><blockquote><p>个人理解：CDN上要能够存储一些静态资源，这里也存在推拉模型❓</p></blockquote><p><strong>缓存技术</strong><br>缓存技术已经不是一种新鲜技术。Web缓存服务通过几种方式来改善用户的响应时间，如代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务等。通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低。对于公司内联网用户来说，这意味着将内容在本地缓存，而无须通过专用的广域网来检索网页。对于Internet用户来说，这意味着将内容存储在他们的ISP的缓存器中，而无须通过Internet来检索网页。这样无疑会提高用户的访问速度。CDN的核心作用正是提高网络的访问速度，所以，缓存技术将是CDN所采用的又一个主要技术。</p><h3 id="使用CDN的好处"><a href="#使用CDN的好处" class="headerlink" title="使用CDN的好处"></a>使用CDN的好处</h3><p>对于用户：</p><ol><li>解决跨运营商和跨地域访问的问题，最重要的是大大降低获取网络资源的延迟，用户体验更好。</li></ol><p>对于企业、网站：</p><ol><li>大部分请求再CDN边缘节点完成，起到了分流作用，减轻了源站负载。</li><li>提高网站的稳定性、可用性。</li><li>让大规模的用户请求架构变得简单了，避免企业自己去部署很多节点。</li></ol><h3 id="大致工作流程"><a href="#大致工作流程" class="headerlink" title="大致工作流程"></a>大致工作流程</h3><p>当用户通过浏览器访问已经加入CDN服务的网站时，首先通过<strong>智能DNS（有博客说叫做DNS重定向）</strong>确定最接近用户的最佳<strong>CDN节点</strong>，同时浏览器将请求发送到该节点。当用户的请求到达指定节点时，CDN的服务器（节点上的高速缓存）负责将用户请求的内容响应给用户。</p><blockquote><p>从以上内容可以分析出，CDN技术的主要组成部分之一是DNS接管。</p></blockquote><p><strong>首先，让我们看一下传统的未加缓存服务的访问过程：</strong></p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210531165645196.png" alt="image-20210531165645196"></p><p>如图可以看出，传统的网络访问的流程如下：</p><ol><li><p>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址；</p></li><li><p>LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)；</p></li><li><p>ROOT DNS将域名授权dns记录回应给 LocalDns；</p><blockquote><p>这里是一个不断查找目标域名的NS纪录的过程，可能问询了不止一台授权服务器。</p></blockquote></li><li><p>LocalDns得到域名的授权dns记录后，继续向域名授权dns查询域名的ip地址；</p><blockquote><p>最终的授权DNS服务器上有目标域名的A纪录，即目标域名的ip地址。</p></blockquote></li><li><p>域名授权dns 查询域名记录后，回应给 LocalDns；</p></li><li><p>LocalDns 将得到的域名ip地址，回应给用户端；</p></li><li><p>用户得到域名ip地址后，访问站点服务器；</p></li><li><p>站点服务器应答请求，将内容返回给客户端。</p></li></ol><p><strong>下面让我们看一下使用CDN缓存后的网站的访问过程：</strong></p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210531170631233.png" alt="image-20210531170631233"></p><p>如上图，是使用CDN缓存后的网络访问流程：</p><ol><li><p>用户通过浏览器访问网站，浏览器调用操作系统接口向 LocalDns 查询域名的ip地址。</p><blockquote><p>这里存在以下假设前提：</p><ul><li>浏览器域名缓存不存在该域名IP。</li><li>操作系统的DNS解析缓存不存在该域名IP。</li><li>本地host文件中没有该域名+ip的键值对。</li></ul></blockquote></li><li><p>LocalDns向 ROOT DNS 查询域名的授权服务器。</p><blockquote><p>这里假设LocalDns缓存过期。</p></blockquote></li><li><p>ROOT DNS将域名授权dns记录回应给 LocalDns；</p><blockquote><p>❓ 域名授权DNS会不会是一台智能DNS服务器？从而减少4~6步？</p></blockquote></li><li><p>LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址；</p></li><li><p>域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDNS；</p><blockquote><p>DNS服务器的表中有A记录、NS记录、CNAME记录。</p></blockquote></li><li><p>LocalDNS重新到ROOT DNS查询域名别名的授权DNS服务器IP（智能DNS服务器的IP）。</p></li><li><p>LocalDNS 得到智能调度DNS的IP后,向智能调度DNS查询域名的ip地址；</p></li><li><p>智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给LocalDNS。</p></li><li><p>LocalDNS将得到的域名ip地址，回应给用户端；</p></li><li><p>用户浏览器得到域名ip地址后，访问站点服务器。</p></li></ol><blockquote><p><strong>综上，</strong>CDN网络是在用户和服务器之间增加Cache层，主要是通过<strong>网站接管DNS解析</strong>实现，将用户的请求引导到Cache上获得源服务器的数据，从而降低网络的访问时间。</p></blockquote><h3 id="CDN通过“推拉”更新内容"><a href="#CDN通过“推拉”更新内容" class="headerlink" title="CDN通过“推拉”更新内容"></a>CDN通过“推拉”更新内容</h3><p>CDN分为推拉两种方式，推是源服务器将内容推到cdn节点上，拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存，当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问地址。</p><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p>概念：  延迟要执行的动作，若在延迟的这段时间内，再次出发了，则取消之前开启的动作，重新计时。</p><p>实现：  借助<code>setTimeout</code>和<code>clearTimeout</code>。</p><p>应用场景：  搜索时等待用户完整输入内容后再发送查询请求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">300</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>       timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>       timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           fn.apply(<span class="hljs-built_in">this</span>, args);<br>           <span class="hljs-built_in">clearTimeout</span>(timer);<br>           timer = <span class="hljs-literal">undefined</span>;<br>       &#125;, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>概念：  设定一个特定的时间间隔，让函数在此事件间隔内只执行一次，不会频繁执行。</p><p>实现： 借助一个标识和<code>setTimeout</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">cb, interval = <span class="hljs-number">300</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> allowed = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (allowed) &#123;<br>            allowed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; allowed = <span class="hljs-literal">true</span>; &#125;, interval);<br>            cb.apply(<span class="hljs-built_in">this</span>, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h3><p>联系：防抖和节流的目的都是当短时间内同一事件多次触发时，避免多次执行同样的回调。</p><p>区别：</p><ul><li>防抖是一段时间内重复触发回调，下一次取消上一次的再执行。</li><li>节流是一段时间内重复触发回调，只要保证最先的一次执行即可。</li></ul><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>Cookie、LocalStorage、SessionStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。</p><p>Web Storage主要包括<code>localStorage</code>和<code>sessionStorage</code>，二者都有大约5M的空间。</p><h3 id="增删改API"><a href="#增删改API" class="headerlink" title="增删改API"></a>增删改API</h3><ol><li><p>保存数据。</p><p><code>localStoragge.setItem(&#39;key&#39;, &#39;value&#39;)</code></p><p><code>localStorage.setItem(&#39;obj&#39;, JSON.stringify(obj))</code></p><p><code>sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code></p><p><code>sessionStorage.setItem(&#39;obj&#39;, JSON.stringify(obj))</code></p><blockquote><p>本地存储中，存储的value一定是字符串类型。如果调用setItem方法，value为基本类型时，API会自动转换为字符串，而对于引用类型，必须显示调用<code>JSON.stringify</code>后再存入。</p></blockquote></li><li><p>读取数据，结果一定是字符串。</p><p><code>localStorage.getItem(&#39;key&#39;)</code></p><p><code>sessionStorage.getItem(&#39;key&#39;)</code></p><blockquote><p>如果不存在键名为key的记录，则返回null。</p></blockquote></li><li><p>删除一条记录。</p><p><code>localStorage.removeItem(&#39;key&#39;)</code></p><p><code>sessionStorage.removeItem(&#39;key&#39;)</code></p></li><li><p>清空所有键值对。</p><p><code>localStorage.clear()</code></p><p><code>sessionStorage.clear()</code></p></li></ol><h3 id="window的storage事件"><a href="#window的storage事件" class="headerlink" title="window的storage事件"></a>window的storage事件</h3><p>我们可以通过监听window对象的storage事件来实现跨页签通信（数据同步）。</p><p><code>window.addEventListener(&#39;storage&#39;, function(event)&#123;...&#125;)</code></p><p><strong>触发机制</strong></p><ol><li>该事件会在<code>web storage</code>（localStorage/sessionStorage）的内容发生变化时触发（例如创建、删除、修改、清空操作）。</li><li>在某个页面中修改了<code>web storage</code>的内容，<font color='red'>在本页面并不会触发window对象的storage事件，而是在其他共享的页面中触发</font>。</li></ol><p><strong>StorageEvent对象</strong></p><p>window对象的storage事件的回调函数中，event的实参是一个<code>StorageEvent</code>对象，该对象具有以下属性：</p><ul><li><p><code>key</code>： 新增、更新、删除的记录键名，调用的是clear()时，该属性值为null。</p></li><li><p><code>newValue</code>： 最新的值，如果调用clear()或removeItem()，该属性值为null。</p></li><li><p><code>oldValue</code>：  修改之前的值，如果调用clear()或新增了该键值对，该属性值为null。</p></li><li><p><code>url</code>： 触发该事件时的页面的url。</p></li><li><p><code>storageArea</code>：  当前的storage对象，即 localStorage或 sessionStorage。</p></li></ul><h3 id="有效期和作用域"><a href="#有效期和作用域" class="headerlink" title="有效期和作用域"></a>有效期和作用域</h3><p><strong>localStorage 作用域</strong></p><p>限定在文档源级别的，每个源只能访问属于自己的localStorage，不同的path之间共享。</p><blockquote><p>文档源通过协议、主机名、端口三者来确定（即每个源拥有一个localStorage）。</p></blockquote><p><strong>sessionStorage 作用域</strong></p><p>限定在文档源级别，一个标签页下的每个源只能访问属于自己的sessionStorage，不同的path之间共享，<font color='red'>但不同页签之间同一个源的sessionStorage不共享</font>。</p><blockquote><p>例如：第一个标签页打开<a href="http://www.baidu.com,写入一些东西到sessionstorage,再新建一个标签页打开www.baidu.com,新页签下www.baidu.com的sessionstorage和第一个页签www.baidu.com的sessionstorage不相同./">www.baidu.com，写入一些东西到sessionStorage，再新建一个标签页打开www.baidu.com，新页签下www.baidu.com的sessionStorage和第一个页签www.baidu.com的sessionStorage不相同。</a></p></blockquote><p><strong>localStorage 有效期</strong></p><p>某个源下的localStorage永不失效，除非web应用删除一条或全部的记录，或者浏览器清空本地存储。</p><p><strong>sessionStorage 有效期</strong></p><p>标签页或整个浏览器程序关闭后失效，单个标签页内的跳转、前进、后退或刷新不会使得会话期间某个源下的sessionStorage失效。</p><blockquote><p>但需要注意的是，如果在本标签页上点击了a标签，并使用新的标签页打开链接，即使新的标签页和本标签页是同源的，在新的标签页上也访问不到原标签页的sessionStorage。</p></blockquote><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的<strong>。Cookie诞生的最初目的是为了在客户端存储Web中的状态信息</strong>，以方便服务器端使用，例如：用于判断用户是否是第一次访问网站。</p><blockquote><p>HTTP是无状态的：HTTP通信中，每个请求/响应都是完全独立于其他的请求/响应的。每个请求包含了处理这个请求所需的完整的数据，每个响应也只是针对请求做出的回答。请求/响应的过程不涉及到状态变更。</p></blockquote><h3 id="Cookie的处理"><a href="#Cookie的处理" class="headerlink" title="Cookie的处理"></a>Cookie的处理</h3><ol><li>通过HTTP响应头中的Set-Cookie首部，服务器向客户端发送cookie。</li><li>根据有效期属性，Cookie在浏览器上保存一段时间或删除某条Cookie。</li><li>之后每次Http请求，浏览器都会自动将对本次请求<font color='red'>可见的、未过期的、被允许的</font>Cookie发送给服务器。</li></ol><h3 id="Cookie的结构"><a href="#Cookie的结构" class="headerlink" title="Cookie的结构"></a>Cookie的结构</h3><ul><li><p><code>Name/Value</code></p><p><strong>Name</strong>和<strong>Value</strong>是一个键值对。<strong>Name</strong>是Cookie的名称，Cookie一旦创建，名称便不可更改，一般名称不区分大小写；<strong>Value</strong>是该名称对应的Cookie的值，如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</p></li></ul><ul><li><p><code>Domain</code></p><p><font color='red'>Domain决定Cookie在哪些域名下的主机是有效的，也就是决定在向该主机发送请求时是否携带此Cookie，</font>Domain的设置在一些情况下是对子域生效的，如Domain设置为<code> .a.com</code>,则该域名下的主机<code>b.a.com</code>和主机<code>c.a.com</code>均可使用该Cookie，同时<code>.xxx.a.com</code>域名下</p><blockquote><p>需要强调：</p><ol><li><p>如果某个域下的Cookie如果希望能够被他的子域具有可见性、可用性，应该保证这个cookie在被Set的时候，<font color='red'>应该以”.”开头</font>。不同浏览器有不同样的实现，但这样做一定不会错。例如，有些浏览器认为Cookie的Domain不以点开头，只有请求的主机名和Domain相同时，才会发出该Cookie，而IE不是这样的。</p></li><li><p>如果服务端在Set Cookie时，如果省略Domain属性，那么大部分浏览器会将该条Cookie的domain设置HTTP请求中的host值（主机名）。</p></li><li><p>Cookie的Domain不支持端口（❓ 不确定支不支持IP），如果你想多个端口来区分cookie的域，可以为这些不同端口的访问来绑定不同的子域名。</p></li></ol></blockquote></li></ul><ul><li><p><code>Path</code></p><p>Path是Cookie的有效路径，和Domain类似，也对子路径生效，如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。</p><blockquote><p>需要强调：</p><ol><li><p>Cookie的Path属性值一定以<code>/</code>结尾。</p></li><li><p>如果服务端在Set Cookie时，如果省略Domain属性，则浏览器会将该条Cookie的path属性值设置为HTTP请求Path的目录。例如在请求<a href="http://localhost/day07_03/AServlet%E6%97%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E4%BA%86%E4%B8%80%E4%B8%AACookie%EF%BC%8C%E4%BD%86%E6%B2%A1%E6%9C%89path%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86%E8%BF%99%E4%B8%AACookie%E7%9A%84path%E5%B0%B1%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%E4%B8%BA%60/day07_03/%60%E3%80%82">http://localhost/day07_03/AServlet时，服务器响应了一个Cookie，但没有path属性，那么浏览器将这个Cookie的path就默认设置为`/day07_03/`。</a></p></li><li><p>大部分网站的做法是将Cookie的Domain设置为顶级域名<code>.xxx.com</code>，path设置为<code>/</code>。</p></li></ol><p>❓ 有一个疑惑：</p><p>对子域名下的主机发出请求时，父级域名下的Path不为<code>/</code>的Cookie是否对该请求可见？</p></blockquote></li></ul><ul><li><p><code>Expires/Max-age</code></p><p>Expires和Max-age均为Cookie的有效期，Expires是该Cookie被删除时的时间戳，格式为GMT。</p><p>Max-age也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，Max-age比Expires优先级更高。</p><p>设置了未过期的Expires值或Max-age&gt;=0的Cookie称为<font color='red'>持久化Cookie，会保存至硬盘文件，过期时删除</font>。</p><p>没有设置Max-age，但设置Expires时，以Expires为准。</p><p>既没有设置Max-age，也没有设置Expires的Cookie成为<font color='red'>会话Cookie，会保存在内存中，浏览器关闭时删除</font>。</p><blockquote><p>需要注意：</p><ol><li>Cookie的Expires值由服务端设置，该时间戳为服务器时间，而浏览器以本地时间做过期判定。</li><li>若Expires的值为本地过期的时间，则该Cookie立刻被删除。</li><li>若Max-age设置为0，则立刻失效，同Expires过期的情况。</li><li>若Max-age设置为-1，浏览器关闭时，该Cookie会删除，意味着该条Cookie成为会话Cookie。</li><li>如果希望将客户端已有的Cookie删除，则后端可以发送过期的Expires值或者Max-age=0；又或是希望通过Max-age=-1将客户端某条已有的Cookie变为会话Cookie；<font color='red'>必须同时指定Cookie的Name、Value、Expires/Max-age，以及Domain和Path，因为Domain+Path+Name才能定位到客户端的一条Cookie</font>。</li></ol></blockquote></li></ul><ul><li><p><code>HttpOnly</code></p><p>HttpOnly为布尔属性，默认时没有该属性，如果设置Cookie时存在该属性，则不允许通过脚本document.cookie去更改这个值，同样这条Cookie在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。</p></li></ul><ul><li><p><code>Secure</code></p><p>Secure为Cookie的安全属性，它是一个布尔属性，默认为false，若Cookie记录中存在该属性则为<em>true</em>，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。</p></li></ul><ul><li><p><code>SameSite</code></p><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止跨站点请求伪造（CSRF）攻击和用户追踪。这个属性也被IEIF提倡使用。当然防止CSRF攻击还有其他方法，如<code>CSRF token</code>校验以及<code>Referer</code>请求头校验。</p><p>SameSite属性可以设置三个值: <code>① Strict ② Lax ③ None</code>。</p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210602151717018.png" alt="image-20210602151717018"></p><p><strong>1. Strict</strong><br>Strict最为严格，完全禁止第三方 Cookie，<font color='red'>跨站点时</font>，任何情况下都不会发送此类型Cookie。换言之，只有当前网页的URL的主机名部分与Cookie的Domain属性值是同站的关系（same-site），请求时才会发送此类型的Cookie。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span>: CookieName=CookieValue; SameSite=Strict;<br></code></pre></td></tr></table></figure><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p><p><strong>2. Lax</strong><br>Lax规则稍稍放宽，<font color='red'>跨站点时，</font>大多数情况也是不发送第三方 Cookie，但是导航到与Cookie同站点的 Get 请求除外（如A标签、GET表单、link:prefetch/preload）。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span>: CookieName=CookieValue; SameSite=Lax;<br></code></pre></td></tr></table></figure><p><strong>3. None</strong></p><p>不对此条Cookie在第三方上下文中的发送作限制，只要是Cookie对第三方上下文的这次请求可见，就把Cookie发送过去。</p></li></ul><blockquote><p><strong>最新变化：</strong></p><p>但一些浏览器，例如Chrome，计划将<code>SameSite=Lax</code>作为每条Cookie的默认设置。而当网站希望不对某条Cookie的第三方上下文发送作限制，则需要显示地设置<code>SameSite=None</code>，但是必须配合<code>Secure</code>字段使用（即此条Cookie必须通过HTTPS发送，否则无效），例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">下面的设置无效，即浏览器不会记录该条Cookie：<br><span class="hljs-attribute">Set-Cookie</span>: widget_session=abc123;Max-age=100;SameSite=None<br>而下面的设置有效：<br><span class="hljs-attribute">Set-Cookie</span>: widget_session=abc123;Max-age=100;SameSite=None;Secure<br></code></pre></td></tr></table></figure><p>尽管有些浏览器将Cookie的<code>SameSite</code>属性默认为<code>Lax</code>，但考虑兼容情况，尽量在Set-Cookie时显示地为属性赋值<code>SameSite=Lax</code>；同时考虑到对一些浏览器单独使用<code>SameSize=None</code>无效，所以如果希望允许在第三方上下文中发送Cookie，则需要设置<code>SameSite=None;Secure</code>，无形中强制Cookie所属的网站使用HTTPS通信。</p></blockquote><p>  <a href="https://blog.csdn.net/weixin_44269886/article/details/102459425">Cookie的SameSite属性：https://blog.csdn.net/weixin_44269886/article/details/102459425</a></p><p>  <a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">SameSite阮一峰：http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p><p>  <a href="https://juejin.cn/post/6844904095476613133">SameSite cookies 理解 https://juejin.cn/post/6844904095476613133</a></p><ul><li><p><code>Priority</code></p><p>优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在<strong>Priority</strong>属性，不清楚在此类浏览器中设置该属性后是否生效。</p></li></ul><h3 id="Cookie的写入"><a href="#Cookie的写入" class="headerlink" title="Cookie的写入"></a>Cookie的写入</h3><p>① a标签跳转</p><p>② 表单GET/POST </p><p>③  外部资源引用src（图片） </p><p>④  iframe src </p><p>⑤ Ajax </p><p><strong>以上这五种方式，都有可能发出跨域/不跨域、跨站/不跨站的请求，返回的响应头中很可能会有Set-Cookie。</strong></p><p><strong>以下开始分析浏览器如果发现各种类型请求的响应头中有Set-Cookie，它会怎样处理。</strong></p><ol><li><p><font color='red'>如果请求不跨域</font><font color='red'>，就会像顶级导航一样</font>，响应头中任何Set的Cookie都有效，浏览器会对它执行有关逻辑。</p></li><li><p><font color='red'>如果这个请求跨域不跨站</font>，响应中Set的Cookie就可以写入，<font color='red'>不论</font>Cookie的<code>SameSite</code>属性为何值。</p><blockquote><p>❗ 如果是跨域不跨站的AJAX请求，请看第五条。</p></blockquote></li><li><p>⭐<font color='red'>即使这个请求不跨站，</font><font color='red'>但Scheme为HTTP</font>，浏览器只允许写入响应头中<code>SameSite=Lax</code>或<code>SameSite=Strict</code>的Cookie，不允许写入<code>SameSite=None;Secure</code>的Cookie。</p></li><li><p>❓ <font color='red'>如果是跨站请求</font>，浏览器只会写入响应头中<code>SameSite=None;Secure</code>的Cookie。</p><blockquote><p>不确定是否会存入<code>SameSite=Strict或SameSite=Lax</code>的Cookie。</p><p>❗ 如果是跨站的AJAX请求，请看第五条。</p></blockquote></li><li><p><font color='red'>如果是AJAX 跨域不跨站/ 跨站请求</font>：</p><ul><li><p>如果<code>XMLHttpRequest</code>对象的<code>withCredentials</code>属性值为false，则响应头中Set的任何Cookie都无效，浏览器不会写入它们。</p><blockquote><p>即<code>withCredentials</code>属性既控制AJAX跨域请求时是否携带Cookie，又控制是否允许该请求的响应在自己的域中设置Cookie，具体可以参考MDN对<code>XMLHttpRequest.withCredentials</code>的解释。</p></blockquote></li><li><p>如果<code>XMLHttpRequest</code>对象的<code>withCredentials</code>属性值为<code>true</code>，则跨域/跨站AJAX请求会发送与之相关的Cookie，而对响应头中的Set-Cookie的处理可以参考2~4条。</p></li></ul></li></ol><h3 id="Cookie的Web-API"><a href="#Cookie的Web-API" class="headerlink" title="Cookie的Web API"></a>Cookie的Web API</h3><p>我们不仅可以通过HTTP响应让浏览器操作Cookie，还可以在页面运行JS脚本时，通过代码操作当前域下可见的Cookie。</p><blockquote><p>受同源政策的约束，在某个页面中以JS脚本的方式只允许访问页面的主机名下的Cookie及其上级域名的Cookie（受限于<code>Domain</code>）。同时只能访问页面所在目录及其上级目录的Cookie（受限于<code>Path</code>）。</p><p>例如：</p><p>当前访问的页面是<code>https://www.a.com/pathtohtml/index.html</code>，则该页面的脚本只可以访问<code>www.a.com</code>与<code>.a.com</code>域名下的Cookie，同时只能访问<code>/pathtohtml/</code>和<code>/</code>路径下的Cookie。</p></blockquote><p><strong>API：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 读取当前页面下的所有Cookie，其值为形如`key1=value1;key2=value...`的字符串</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.cookie);<br><br><span class="hljs-comment">// 添加一条Cookie</span><br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;key=value;Max-age=300;Path=/;SameSite=None;Secure&#x27;</span><br><br><span class="hljs-comment">// 删除一条Cookie</span><br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;key=value;Max-age=0;Path=/;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>Cookie默认不会保存任何数据，<code>document.cookie</code>默认值为空字符串。</li><li>Cookie不能一次性设置多条，只能一条一条添加。</li><li>同一个站点，Cookie有个数限制，一般为20~50条，大小限制在4KB。</li><li>HTTP响应中设置了<code>HttpOnly</code>的Cookie不能通过<code>document.cookie</code>访问，但确实存在。</li></ol></blockquote><h3 id="第一方Cookie注意事项"><a href="#第一方Cookie注意事项" class="headerlink" title="第一方Cookie注意事项"></a>第一方Cookie注意事项</h3><p><strong>第一方Cookie是指：</strong>当前网页主机名下可以访问到的Cookie（一般是同站的Cookie）。</p><ol><li>第一方Cookie可以由网站加载的第三方脚本写入，即第三方脚本中使用 document.cookie 接口。</li><li>第一方Cookie如果没有设置HttpOnly，则可以通过跨站外链、跨站AJAX请求将第一方Cookie以参数形式发送给第三方脚本。</li><li>第一方Cookie即使设置了HttpOnly，第三方仍然可以让第一方（网站服务器）托管脚本，从而读取第一方Cookie。</li></ol><h3 id="浏览器禁用第三方Cookie"><a href="#浏览器禁用第三方Cookie" class="headerlink" title="浏览器禁用第三方Cookie"></a>浏览器禁用第三方Cookie</h3><p><strong>第三方Cookie是指：</strong>相对于当前页面URL的主机名，某个请求是跨站请求，发送给该站点以及该请求的响应头中含有的Cookie属于第三方Cookie（即在一次跨站请求中，第三方Cookie含有发送和写入两个环节）。</p><p>很多浏览器都具有禁用第三方Cookie的功能，开启禁用后，如果发送跨站请求：</p><ol><li>发送请求环节，不论浏览器在该跨站域名下的Cookie的<code>SameSite</code>属性为何值，都不会发送Cookie。</li><li>得到响应环节，Set-Cookie首部中的任何Cookie都不会被浏览器记录。</li></ol><blockquote><p>区别于<code>SameSite=Strict</code>的Cookie，该属性只是不允许在跨站请求时发送Cookie，这是对用户的Cookie进行保护。❓ 其实不是确定跨站响应中<code>SameSite=Strict</code>的Cookie是否会被写入。</p><p>浏览器禁用第三方Cookie功能是为了保护用户的隐私，禁止第三方网站跟踪用户、分析用户行为。</p></blockquote><h2 id="Cookie和Web-Storage的区别与联系"><a href="#Cookie和Web-Storage的区别与联系" class="headerlink" title="Cookie和Web Storage的区别与联系"></a>Cookie和Web Storage的区别与联系</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>可以从Cookie、localStorage、sessionStorage的有效期、作用域、大小限制、发送时机来进行回答。</p><p><strong>有效期</strong></p><ul><li>Cookie的有效期分两种，会话Cookie在浏览器程序关闭时删除，持久化Cookie在到期时被删除。</li><li>localStorage除非Web应用代码删除、用户点击删除、用户清空本地存储，否则一直有效。</li><li>sessionStorage在页签关闭时删除，历史记录前进后退时也不删除，不同页签打开同一页面不共享。</li></ul><p><strong>作用域</strong></p><ul><li><p>Cookie的作用域：</p><p>子域名可以访问本级与上级域名的Cookie，反之不可；</p><p>子目录可以访问当前目录与上级目录的Cookie，反之不可。</p><blockquote><p>不同浏览器不共享Cookie！！！</p></blockquote></li><li><p>localStorage的作用域为文档源，即同一个域名下的多个页面共享一个localStorage。</p></li><li><p>sessionStorage的作用域为一个页签下的一个文档源，页签可以不断跳转从而显示不同的页面，但是一个页签跳转到不同的域名时，sessionStorage会切换为该域下的存储空间。 </p></li></ul><p><strong>大小限制</strong></p><ul><li>Cookie的大小限制为：一个站点可以存储20~50条Cookie，大小限制在4KB。</li><li>Web Storage的大小限制为5M~8M。</li></ul><p><strong>发送时机</strong></p><ul><li>Cookie的发送时机是向某个站点下的某台主机发送请求时，会携带对于该次请求可见的Cookie。</li><li>Web Storage中的内容不会自动发送给服务器，需要通过JS脚本发送。</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol><li>都是在浏览器端存储状态的手段。</li><li>在一定程度上，都受同源策略保护。</li></ol><h2 id="对域名和主机名的理解"><a href="#对域名和主机名的理解" class="headerlink" title="对域名和主机名的理解"></a>对域名和主机名的理解</h2><p><code>.</code>为根域。</p><p>有人称<code>.com</code>、<code>.net</code>为顶级域名/一级域名，而<code>baidu.com</code>、<code>jd.com</code>为二级域名。</p><p>又有人称<code>baidu.com</code>为顶级域名/一级域名。</p><p>主机 = <code>主机的英文名字.域名</code></p><p>例如<code>www.baidu.com</code>是<code>baidu.com</code>域下的一台叫做<code>www</code>的主机。</p><p>例如<code>live.bilibili.com</code>是<code>bilibili.com</code>域下的一台叫做<code>live</code>的主机。</p><p>一个企业开发的网站，使用多少级域名由企业自己决定。</p><h2 id="对跨域和跨站的理解"><a href="#对跨域和跨站的理解" class="headerlink" title="对跨域和跨站的理解"></a>对跨域和跨站的理解</h2><p><strong>同域名</strong>：<code>scheme+host+port</code>相同，其他视为跨域。</p><p>举例：</p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210602225335101.png" alt="image-20210602225335101"></p><p><strong>同站点</strong>：<code>eTLD+1</code>相同，其他视为跨站。</p><p>举例：</p><p><img src="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210602225354985.png" alt="image-20210602225354985"></p><blockquote><p>注意：</p><ol><li>普通的跨站不考虑scheme，考虑scheme的跨站叫做<code>schemeful same-site</code>。</li><li><code>mzleman.github.io</code>和<code>ley.github.io</code>跨站，因为<code>.io</code>不是一个<code>eTLD</code>，<code>.github.io</code>才是。<code>a.mzleman.github.io</code>和<code>b.mzleman.github.io</code>才是同站的。</li></ol></blockquote><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>浏览器在本地磁盘/内存中将之前请求的响应存储起来，当页面再次需要发出这些请求时，无需真正地发送请求（可能是真的不发，也可能是发送简单的缓存校验），直接从浏览器本地获取响应结果。</p><h3 id="使用浏览器缓存的好处"><a href="#使用浏览器缓存的好处" class="headerlink" title="使用浏览器缓存的好处"></a>使用浏览器缓存的好处</h3><ol><li>减少请求次数，避免网络通信带来延迟，从而加快浏览器获取资源、数据的速度。</li><li>减轻网站服务器的压力。</li><li>节省带宽、流量。</li></ol><h3 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h3><p><strong>强缓存：</strong></p><p>浏览器发出一条请求，服务器在响应头中通过<code>Cache-control:max-age=.../Expires</code>指示浏览器将该请求的响应缓存一段时间，在缓存失效之前，这条缓存为强缓存。</p><p>在下一次请求时，如果缓存不不过期，则命中强缓存，返回<code>200 OK (from memory/disk cache)</code>。</p><p><strong>协商缓存：</strong></p><p>针对浏览器的请求，服务器在响应头中设置了<code>Cache-control:no-cache</code>的响应会被浏览器保存为协商缓存。</p><p>或者是当一条强缓存过期时，也可以认为该缓存成为协商缓存。</p><p>在下一次请求时，如果浏览器保存的是请求的协商缓存，浏览器会发送缓存校验请求（带有<code>If-modified-Since/If-None-Match</code>的条件请求），如果服务器认为客户端缓存仍然可用，则返回<code>304 Not Modified</code>，如果服务端更新了内容，则返回<code>200 ok</code>的完整响应并指示浏览器更新客户端缓存信息。</p><blockquote><p>针对协商缓存的两种情况进行讨论：</p><ol><li><code>Cache-control:no-cache</code>型的协商缓存：Chrome相应发出<code>Cache-Control:no-cache</code>的请求头。</li><li><code>过期的强缓存</code>：Chrome发出<code>Cache-control:max-age=0</code>的请求头。</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3笔记</title>
    <link href="/2021/04/29/Vue/vue3/"/>
    <url>/2021/04/29/Vue/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="Composition-API-常用内容"><a href="#Composition-API-常用内容" class="headerlink" title="Composition API 常用内容"></a>Composition API 常用内容</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p><strong>解释：</strong></p><ul><li>新的option，可以理解成一个钩子函数。</li><li>Vue3中，所有的组合API函数都在此使用, 只在初始化时执行一次。</li><li>函数如果返回对象, 对象中的<strong>属性</strong>或<strong>方法</strong>, 模板中可以直接使用。</li></ul><p><strong>执行时机：</strong></p><ul><li>在beforeCreate之前执行(一次), 此时组件实例还没有创建。</li><li>由于组件实例没有创建，setup钩子的this是undefined, 不能通过this来访问data/computed/methods / props。</li><li>其实所有的composition API相关回调函数中也都不可以通过this访问组件实例。</li></ul><p><strong>返回值：</strong></p><ul><li><p>一般都返回一个对象，对象中包含模板可以使用的数据以及组件的方法。</p><blockquote><p>这里组件的方法可能概念不太准确，但是可以理解为Vue2中组件的method，因为Vue3不推荐再使用method定义一些组件行为。</p></blockquote></li><li><p>setup返回值中的数据会与data中定义的数据合并，并挂载到组件实例上 ⭐。</p><blockquote><p>例如<code> setup</code>返回 <code>&#123;foo: ...&#125;</code>，<code>data</code>返回 <code>&#123;bar: ...&#125;</code>，组件实例上会具有<code>foo</code>和<code>bar</code>属性。</p><p>❗ 如果存在同名现象，setup返回的数据具有更高的优先级。</p><p>在data中可以访问到setup中定义的数据，意味着data定义的数据可以依赖与setup定义的数据。</p></blockquote></li><li><p>setup返回值中的方法会与method中定义的方法合并，并挂载到组件实例上⭐。</p><blockquote><p>同数据的定义，setup中定义的方法具有更高的优先级。</p><p>在method中可以访问到setup中定义了的数据和方法，意味着method中可以调用setup中已经定义的方法，也可以操作setup中定义的数据。</p></blockquote></li></ul><p><font color="red">尽管setup可以和data、method同时使用，但不推荐这样做。</font></p><h4 id="props-参数"><a href="#props-参数" class="headerlink" title="props 参数"></a>props 参数</h4><p>setup钩子实际上是有参数的。</p><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p><blockquote><p>该参数类似于Vue2中的props，但区别在于setup中的props只包含那些在<code>props option</code>中定义了，且被父组件注入了的或具有默认值的props。</p><p>即当一个父组件没有向子组件注入某个prop时，且子组件<code>props option</code>中没有为该prop定义默认值，则在子组件的setup中，props参数中不存在该prop的属性值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// MyBook.vue  👈 简单的例子</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  props: &#123;           <span class="hljs-comment">// Vue3中仍然按照旧有的方式定义多个prop</span><br>    title: <span class="hljs-built_in">String</span><br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;     <span class="hljs-comment">// 在setup中访问props的数据，props实参是一个Proxy对象。</span><br>    <span class="hljs-built_in">console</span>.log(props.title)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="props-toRefs"><a href="#props-toRefs" class="headerlink" title="props toRefs"></a>props toRefs</h4><p>上面提到了，props实参是一个Proxy对象，对它直接进行解构，解构出的内容不具有响应性。</p><p>如果需要解构 prop，可以通过使用 <code>setup</code> 函数中的 <code>toRefs</code> 来安全地完成此操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// MyBook.vue</span><br><br><span class="hljs-keyword">import</span> &#123; toRefs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> &#123;<br><span class="hljs-keyword">const</span> &#123; title &#125; = toRefs(props)<br><br><span class="hljs-built_in">console</span>.log(title.value)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="context-参数"><a href="#context-参数" class="headerlink" title="context 参数"></a>context 参数</h4><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露三个组件的 property：</p><ul><li><em>attrs</em>：相当于this.$attrs，即非prop和emits的attribute。</li><li><em>slots</em>：包含所有传入的插槽内容的对象, 相当于 this.$slots。</li><li><em>emit</em>：用来分发自定义事件的函数, 相当于 this.$emit。</li></ul><h4 id="setup中可以访问到的组件内容"><a href="#setup中可以访问到的组件内容" class="headerlink" title="setup中可以访问到的组件内容"></a>setup中可以访问到的组件内容</h4><p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p><ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul><p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p><ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li></ul><h4 id="返回渲染函数"><a href="#返回渲染函数" class="headerlink" title="返回渲染函数"></a>返回渲染函数</h4><p><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// MyBook.vue</span><br><br><span class="hljs-keyword">import</span> &#123; h, ref, reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> readersNumber = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">const</span> book = reactive(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span> &#125;)<br>    <span class="hljs-comment">// Please note that we need to explicitly expose ref value here</span><br>    <span class="hljs-comment">//                    👇 注意这里ref对象不会自动展开</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> h(<span class="hljs-string">&#x27;div&#x27;</span>, [readersNumber.value, book.title]) <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>至此，setup可以返回一个对象或一个渲染函数。其实setup还可以返回一个promise定义异步组件 ？❓</p></blockquote><h4 id="setup中的this"><a href="#setup中的this" class="headerlink" title="setup中的this"></a>setup中的this</h4><p>在setup执行时，组件实例还没有被创建，所以不能够通过this访问组件实例。</p><h3 id="通过ref定义数据响应式引用"><a href="#通过ref定义数据响应式引用" class="headerlink" title="通过ref定义数据响应式引用"></a>通过ref定义数据响应式引用</h3><p><strong>作用:</strong> ref函数返回一个数据的响应式引用。</p><p>（一般用来得到一个基本类型数据的响应式引用，但也可以得到引用类型数据的响应式引用）</p><p><strong>语法:</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; defineComponent, ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">const</span> name = ref(<span class="hljs-string">&#x27;mz&#x27;</span>);<br>        <span class="hljs-keyword">const</span> age = ref(<span class="hljs-number">24</span>);<br>        <span class="hljs-keyword">const</span> user = ref(&#123;<br>            name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>            age: <span class="hljs-number">24</span>,<br>        &#125;);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><p>ref函数包裹一个数据，会返回一个包含响应式数据的引用(reference)对象。</p></li><li><p>在脚本中修改响应式引用的value属性值，如： <code>xxx.value = ...</code>，这会“修改数据”，如果数据引用被追踪了，修改操作还能够触发视图更新。</p></li><li><p>模板中使用数据:：不需要通过<code>.value</code>（ref展开）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        &#123;&#123;name&#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="通过ref获取DOM元素-子组件实例"><a href="#通过ref获取DOM元素-子组件实例" class="headerlink" title="通过ref获取DOM元素/子组件实例"></a>通过ref获取DOM元素/子组件实例</h3><p><strong>功能需求:</strong> 让输入框自动获取焦点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;App&lt;&#x2F;h2&gt;<br>  &lt;input type&#x3D;&quot;text&quot;&gt;---<br>  &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;inputRef&quot;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123; onMounted, ref &#125; from &#39;vue&#39;<br>&#x2F;* <br>ref获取元素: 利用ref函数获取组件中的标签元素<br>功能需求: 让输入框自动获取焦点<br>*&#x2F;<br>export default &#123;<br>  setup() &#123;<br>    const inputRef &#x3D; ref&lt;HTMLElement|null&gt;(null);  &#x2F;&#x2F; 👈 变量名与ref值相同<br><br>    onMounted(() &#x3D;&gt; &#123;<br>      if (inputRef.value !&#x3D;&#x3D; null) &#123;<br>        inputRef.value.focus();   &#x2F;&#x2F; ⭐ value值为ref标记的DOM元素<br>      &#125;<br>    &#125;)<br><br>    return &#123;<br>      inputRef  &#x2F;&#x2F; ❗ 一定要导出以后才能在onMounted中访问到标记的元素<br>    &#125;<br>  &#125;,<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><a href="https://vue3js.cn/docs/zh/guide/composition-api-template-refs.html#v-for-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95">链接：与v-for结合使用</a></p><h3 id="通过reactive定义数据响应式"><a href="#通过reactive定义数据响应式" class="headerlink" title="通过reactive定义数据响应式"></a>通过reactive定义数据响应式</h3><p><strong>作用：</strong>定义多个数据的响应式。</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;name: &#123;&#123;state.name&#125;&#125;&lt;&#x2F;h2&gt;<br>  &lt;h2&gt;age: &#123;&#123;state.age&#125;&#125;&lt;&#x2F;h2&gt;<br>  &lt;h2&gt;wife: &#123;&#123;state.wife&#125;&#125;&lt;&#x2F;h2&gt;<br>  &lt;hr&gt;<br>  &lt;button @click&#x3D;&quot;update&quot;&gt;更新&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123;<br>  reactive,<br>&#125; from &#39;vue&#39;<br>export default &#123;<br>  setup () &#123;<br>    &#x2F;* <br>    定义响应式数据对象<br>    *&#x2F;<br>    const state &#x3D; reactive(&#123;<br>      name: &#39;tom&#39;,<br>      age: 25,<br>      wife: &#123;<br>        name: &#39;marry&#39;,<br>        age: 22<br>      &#125;,<br>    &#125;)<br>    console.log(state, state.wife)<br><br>    const update &#x3D; () &#x3D;&gt; &#123;<br>      state.name +&#x3D; &#39;--&#39;<br>      state.age +&#x3D; 1<br>      state.wife.name +&#x3D; &#39;++&#39;<br>      state.wife.age +&#x3D; 2<br>    &#125;<br><br>    return &#123;<br>      state,<br>      update,<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在setup中，使用reactive包裹引用类型的数据，返回一个Proxy对象，该对象是响应式的（代理对象）。</li><li>在模板中可以使用代理对象，通过代理对象读取到数据。</li><li>脚本中通过代理对象修改数据，这些修改会反应到视图上。</li><li>这种响应式是“ 深层 ”的。</li></ul><h3 id="ref与reactive的联系与区别"><a href="#ref与reactive的联系与区别" class="headerlink" title="ref与reactive的联系与区别"></a>ref与reactive的联系与区别</h3><p><strong>区别:</strong></p><ol><li><p>一般情况下我们用<code>ref</code>处理基本类型数据的响应式；</p><p>用<code>reactive</code>处理引用类型的响应式，而且使用<code>reactive</code>定义的响应式是“ 深层 ”的。</p></li></ol><ol start="2"><li><p>使用<code>ref()</code>包裹数据，返回的是一个<code>RefImpl</code>实例；</p><p>使用<code>reactive()</code>包裹数据，返回的是一个Proxy对象（代理对象）。</p></li></ol><ol start="3"><li><p><code>ref</code>通过给value属性添加getter/setter来实现对数据的劫持，修改<code>value</code>时会触发视图更新；</p><p><code>reactive</code>通过使用Proxy来实现对对象内部所有数据的劫持, 并通过Reflect操作对象内部数据。</p></li></ol><p><strong>联系:</strong></p><ol><li><p>都可以在模板中使用<code>ref</code>和<code>reactive</code>返回的内容。</p></li><li><p>使用<code>ref()</code>也可以包裹引用类型的数据，当<code>let objRef = ref(obj)</code>调用时，函数内部判断出obj是引用类型，则<code>objRef.value</code>为一个<code>reactive</code>对象。当修改<code>objRef.value</code>时，如果新的值仍为一个引用类型，则会将新的值再次封装成一个<code>reactive</code>对象。</p><blockquote><p>原因：操作<code>RefImpl</code>对象的<code>value</code>属性会被<code>getter/setter</code>拦截。</p></blockquote></li></ol><h3 id="ref-展开"><a href="#ref-展开" class="headerlink" title="ref 展开"></a>ref 展开</h3><p>所谓“ref展开” 是指访问ref对象引用的值时，不需要通过<code>.value</code>访问，这有两种情况：</p><ol><li><p>在模板中访问，当 ref 作为渲染上下文 (从 <code>setup()</code>中返回的对象) 上的 property 返回并可以在模板中被访问时，它将自动展开为内部值。不需要在模板中追加 <code>.value</code>。</p></li><li><p>当ref对象作为reactive对象的属性值被访问或者更改时，为了使其行为类似于访问reactive对象的普通的属性，它会自动展开内部值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  count<br>&#125;)<br><br><span class="hljs-built_in">console</span>.log(state.count) <span class="hljs-comment">// 0</span><br><br>state.count = <span class="hljs-number">1</span><br><span class="hljs-built_in">console</span>.log(count.value) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>如果将新的 ref 赋值给现有 ref 的 property，将会替换旧的 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> otherCount = ref(<span class="hljs-number">2</span>)<br><br>state.count = otherCount<br><span class="hljs-built_in">console</span>.log(state.count) <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(count.value) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><blockquote><p>但需要注意的是，<strong>仅当</strong>reactive对象代理的target是一个<code>Plain Object</code>且ref对象为其某个属性值时，对ref的访问会展开。</p><p>当reative代理的不再是<code>Plain Object</code>，而是一个<code>Array</code>或<code>Map</code>等其他原生容器，访问ref时，不会进行展开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> books = reactive([ref(<span class="hljs-string">&#x27;Vue 3 Guide&#x27;</span>)])<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-built_in">console</span>.log(books[<span class="hljs-number">0</span>].value)<br><br><span class="hljs-keyword">const</span> map = reactive(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&#x27;count&#x27;</span>, ref(<span class="hljs-number">0</span>)]]))<br><span class="hljs-comment">// 这里需要 .value</span><br><span class="hljs-built_in">console</span>.log(map.get(<span class="hljs-string">&#x27;count&#x27;</span>).value)<br></code></pre></td></tr></table></figure></blockquote></li></ol><h3 id="toRefs-和-toRef"><a href="#toRefs-和-toRef" class="headerlink" title="toRefs 和 toRef"></a>toRefs 和 toRef</h3><p><strong>一、toRefs</strong></p><p><strong>作用：</strong>该函数可以将一个reactive对象作为参数传入，同时返回一个普通对象，该对象的每个属性值都为一个ref对象，属性名对应reactive对象中的每个属性。<font color='red'>即将一个reactive对象分解为多个ref，同时修改每个ref的value时，会修改reactive对象的属性值。</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h1&gt;App&lt;&#x2F;h1&gt;<br>  &lt;button @click&#x3D;&quot;update&quot;&gt;更新父级组件&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123;<br>  defineComponent,<br>  ref,<br>  toRefs,<br>  reactive,<br>&#125; from &#39;vue&#39;;<br>import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;;<br><br>export default defineComponent(&#123;<br>  name: &#39;App&#39;,<br>  setup() &#123;<br>    &#x2F;&#x2F; 使用reactive定义一个响应式数据<br>    const info &#x3D; reactive(&#123;  <br>      name: &#39;mz&#39;,<br>      age: 24,<br>    &#125;);<br>    &#x2F;&#x2F; 将reactive对象分解为多个ref<br>      <br>    const &#123; name, age &#125; &#x3D; toRefs(info);<br>    const update &#x3D; () &#x3D;&gt; &#123;<br>      console.log(info);  &#x2F;&#x2F; 修改ref.value前，观察info<br>      name.value +&#x3D; &#39;⭐&#39;;<br>      age.value +&#x3D; 1;<br>      console.log(name.value, age.value); <br>      console.log(info); &#x2F;&#x2F; 修改ref.value后，观察info<br>    &#125;;<br>    return &#123;<br>      age,<br>      name,<br>      update,<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><strong>二、toRef</strong></p><p><code>toRef</code>和<code>toRefs</code>作用相同，只不过是创建reactive代理的指定属性的ref对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> info = reactive(&#123;<br>    name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>    age: <span class="hljs-number">24</span>,<br>&#125;)<br><br><span class="hljs-keyword">const</span> &#123;name, age&#125; = toRefs(info); <span class="hljs-comment">// toRefs</span><br><span class="hljs-keyword">const</span> nameRef = toRef(info, <span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// toRef</span><br><br></code></pre></td></tr></table></figure><blockquote><p>与toRefs一样，修改由toRef生成的ref对象的value属性，会同时修改原reactive代理的target的相应属性值。</p></blockquote><h3 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h3><p><code>computed</code>也是Vue3 Composition API的一部分，它是一个函数，允许传入一个getter或一组getter/setter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>    import &#123; defineComponent, computed &#125; from &#39;vue&#39;;<br>export default defineComponent(&#123;<br>      setup () &#123;<br>        const user &#x3D; reactive(&#123;<br>          firstName: &#39;A&#39;,<br>          lastName: &#39;B&#39;<br>        &#125;)<br><br>        &#x2F;&#x2F; 只有getter的计算属性<br>        const fullName1 &#x3D; computed(() &#x3D;&gt; &#123;<br>          console.log(&#39;fullName1&#39;)<br>          return user.firstName + &#39;-&#39; + user.lastName<br>        &#125;)<br><br>        &#x2F;&#x2F; 有getter与setter的计算属性<br>        const fullName2 &#x3D; computed(&#123;<br>          get () &#123;<br>            console.log(&#39;fullName2 get&#39;)<br>            return user.firstName + &#39;-&#39; + user.lastName<br>          &#125;,<br><br>          set (value: string) &#123;<br>            console.log(&#39;fullName2 set&#39;)<br>            const names &#x3D; value.split(&#39;-&#39;)<br>            user.firstName &#x3D; names[0]<br>            user.lastName &#x3D; names[1]<br>          &#125;<br>        &#125;)<br>    &#125;);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="watchEffect-和-watch-监视"><a href="#watchEffect-和-watch-监视" class="headerlink" title="watchEffect 和 watch 监视"></a>watchEffect 和 watch 监视</h3><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p><a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect">链接</a></p><h4 id="watch监听单个数据"><a href="#watch监听单个数据" class="headerlink" title="watch监听单个数据"></a>watch监听单个数据</h4><p>侦听器数据源可以是返回值的 getter 函数，也可以直接是 <code>ref</code>：</p><ol><li><p>首先引入 watch ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ..., watch &#125; <span class="hljs-keyword">from</span> vue<br></code></pre></td></tr></table></figure></li><li><p>函数式调用，传入参数：</p><p>第一个参数：<code>target / getter</code>，可以为一个ref对象、reactive对象或者是一个返回某个值的getter函数。</p><p>第二个参数：<code>(newVal, oldVal) =&gt; &#123;...&#125;</code>，一个副作用函数，用于处理newVal和oldVal的逻辑。</p><p>第三个参数：<code>option</code>，可选的配置。deep字段指定是否深层监视，默认为false，只跟踪一层属性的变化； immediate字段指定是否在组件初始化时立即执行一次回调，默认为false。</p><blockquote><p> target可以为以下内容：</p><ul><li><p>ref对象</p></li><li><p>reactive对象</p></li><li><p>getter函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> info1 = reactive(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span> &#125;);<br><span class="hljs-keyword">let</span> info2 = ref(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span> &#125;);<br><span class="hljs-keyword">let</span> info3 = ref(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">wife</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ley&#x27;</span> &#125; &#125;);<br>watch(<span class="hljs-function">() =&gt;</span> info1.name, <span class="hljs-function">(<span class="hljs-params">newVal, oldVal</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(newVal));<br>watch(<span class="hljs-function">() =&gt;</span> info2.value.name, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(newVal));<br>watch(<span class="hljs-function">() =&gt;</span> info3.value.wife, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(newVal), &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure></li></ul></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang&#x3D;&quot;ts&quot;&gt;<br><br>import &#123;<br>  defineComponent,<br>  ref,<br>  watch,<br>&#125; from &#39;vue&#39;;<br><br>export default defineComponent(&#123;<br>  name: &#39;HelloWorld&#39;,<br><br>  setup() &#123;<br>    const mz &#x3D; &#123;<br>      name: &#39;mz&#39;,<br>      age: 24,<br>      info: &#123;<br>        id: &#39;19970314&#39;,<br>        home: &#39;nj&#39;,<br>      &#125;,<br>    &#125;;<br>    let ley &#x3D; &#123;<br>      name: &#39;ley&#39;,<br>      age: 25,<br>      info: &#123;<br>        id: &#39;19960121&#39;,<br>        home: &#39;nanyang&#39;,<br>      &#125;,<br>    &#125;;<br><br>    let user &#x3D; ref(mz);<br><br>    const replace &#x3D; () &#x3D;&gt; &#123;<br>      user.value &#x3D; ley;<br>    &#125;;<br><br>    const update &#x3D; () &#x3D;&gt; &#123;<br>      user.value.info.id +&#x3D; &#39;.&#39;;<br>    &#125;;<br><br>    watch(user, (newVal, oldVal, validator) &#x3D;&gt; &#123;<br>      console.log(&#39;watch user&#39;);<br>      console.log(&#39;newVal:&#39;, newVal);<br>      console.log(&#39;oldVal&#39;, oldVal);<br>      console.log(validator);<br>    &#125;, &#123;<br>      deep: true,<br>    &#125;);<br><br>    return &#123;<br>      user,<br>      replace,<br>      update,<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="watch监听多个数据源"><a href="#watch监听多个数据源" class="headerlink" title="watch监听多个数据源"></a>watch监听多个数据源</h4><p>Vue3中的watch还可以使用数组同时侦听多个源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">watch([fooRef, barRef], <span class="hljs-function">(<span class="hljs-params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="watch回调的第三个参数"><a href="#watch回调的第三个参数" class="headerlink" title="watch回调的第三个参数"></a>watch回调的第三个参数</h4><p><code>watch</code> 与 <a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#watcheffect"><code>watchEffect</code></a>共享<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC">停止侦听</a>，<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#%E6%B8%85%E9%99%A4%E5%89%AF%E4%BD%9C%E7%94%A8">清除副作用</a> (相应地 <code>onInvalidate</code> 会作为回调的第三个参数传入)、<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA">副作用刷新时机</a>和<a href="https://vue3js.cn/docs/zh/guide/reactivity-computed-watchers.html#%E4%BE%A6%E5%90%AC%E5%99%A8%E8%B0%83%E8%AF%95">侦听器调试</a>行为。</p><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><h4 id="Vue3中的生命周期"><a href="#Vue3中的生命周期" class="headerlink" title="Vue3中的生命周期"></a>Vue3中的生命周期</h4><table><thead><tr><th>选项式 API</th><th>Hook inside <code>setup</code></th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>Not needed*</td></tr><tr><td><code>created</code></td><td>Not needed*</td></tr><tr><td><code>beforeMount</code></td><td><code>onBeforeMount</code></td></tr><tr><td><code>mounted</code></td><td><code>onMounted</code></td></tr><tr><td><code>beforeUpdate</code></td><td><code>onBeforeUpdate</code></td></tr><tr><td><code>updated</code></td><td><code>onUpdated</code></td></tr><tr><td><code>beforeUnmount</code></td><td><code>onBeforeUnmount</code></td></tr><tr><td><code>unmounted</code></td><td><code>onUnmounted</code></td></tr><tr><td><code>errorCaptured</code></td><td><code>onErrorCaptured</code></td></tr><tr><td><code>renderTracked</code></td><td><code>onRenderTracked</code></td></tr><tr><td><code>renderTriggered</code></td><td><code>onRenderTriggered</code></td></tr></tbody></table><p><strong>相对于Vue2，两个改名了的生命周期</strong></p><ul><li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li><li><code>destroyed</code> -&gt; <code>onUnmounted</code></li></ul><p><strong>新增的钩子函数</strong></p><p>Vue3新增以下调试钩子函数：</p><ul><li><code>onRenderTracked</code></li><li><code>onRenderTriggered</code></li></ul><blockquote><p><strong>需要注意：</strong></p><ol><li><p>在Vue3中仍然可以像使用options风格定义生命周期钩子（尽管已经不推荐这样做），但是Vue2中的<code>beforeDestroy</code>和<code>destroyed</code>钩子已经分别改名为<code>onBeforeUnmount</code>和<code>onUnmounted</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ...<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ...<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以同时使用Composition API风格以及Options风格来为组件注册生命周期钩子函数，处于同一生命周期的回调函数，在setup中定义的会优先按顺序执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ...<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ...<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>    onMounted(cb1);<br>    onMounted(cb2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></blockquote><h4 id="组合API风格的生命周期回调注册"><a href="#组合API风格的生命周期回调注册" class="headerlink" title="组合API风格的生命周期回调注册"></a>组合API风格的生命周期回调注册</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<br>  defineComponent,<br>  ref,<br>  <span class="hljs-comment">// 以下为主要的生命周期钩子</span><br>  onBeforeMount,<br>  onMounted,<br>  onBeforeUpdate,<br>  onUpdated,<br>  onBeforeUnmount,<br>  onUnmounted,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent(&#123;<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setup也是一个钩子&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义数据之前&#x27;</span>);<br>        <span class="hljs-keyword">const</span> data = ref(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义数据之后&#x27;</span>);<br>        <span class="hljs-comment">// 👇 定义其他生命周期钩子</span><br>        <span class="hljs-comment">// ❗  可以为同一个生命周期添加多个回调。</span><br>        onBeforeMount(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onBeforeMount11111&#x27;</span>));<br>        onBeforeMount(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onBeforeMount22222&#x27;</span>));<br>        <br>        onMounted(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onMounted&#x27;</span>));<br>        onBeforeUpdate(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onBeforeUpdate&#x27;</span>));<br>        onUpdated(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onUpdated&#x27;</span>));<br>        onBeforeUnmount(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onBeforeUnmount&#x27;</span>));<br>        onUnmounted(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onUnmounted&#x27;</span>));<br>        <br>        <span class="hljs-keyword">return</span> &#123;<br>            data,<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="自定义hook（组合式函数）"><a href="#自定义hook（组合式函数）" class="headerlink" title="自定义hook（组合式函数）"></a>自定义hook（组合式函数）</h3><p><strong>注意：</strong>Vue3中的自定义hook不是类似于生命周期的技术，而是类似于Vue2中的Mixin技术。</p><p><strong>作用：</strong>封装可复用的功能函数供组件使用。</p><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p>功能：收集用户鼠标点击的页面坐标。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"># /hooks/useMousePosition.ts<br><span class="hljs-keyword">import</span> &#123;<br>  ref,<br>  Ref,<br>  onMounted,<br>  onUnmounted,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义一个接口，收集用户鼠标点击的页面坐标</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">interface</span> RefMousePosition &#123;<br>  x: Ref&lt;<span class="hljs-built_in">number</span>&gt;,<br>  y: Ref&lt;<span class="hljs-built_in">number</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useMousePosition</span>(<span class="hljs-params"></span>): <span class="hljs-title">RefMousePosition</span> </span>&#123;<br>  <span class="hljs-comment">// 初始化坐标数据</span><br>  <span class="hljs-keyword">const</span> x = ref(-<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">const</span> y = ref(-<span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// 页面点击事件坐标的回调函数</span><br>  <span class="hljs-keyword">const</span> updatePosition = <span class="hljs-function">(<span class="hljs-params">e: MouseEvent</span>) =&gt;</span> &#123;<br>    x.value = e.pageX;<br>    y.value = e.pageY;<br>  &#125;;<br><br>  <span class="hljs-comment">// 挂载后绑定点击监听</span><br>  onMounted(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, updatePosition);<br>  &#125;);<br><br>  <span class="hljs-comment">// 卸载前解绑点击监听</span><br>  onUnmounted(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, updatePosition);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> &#123; x, y &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>  &lt;h2&gt;x: &#123;&#123;x&#125;&#125;, y: &#123;&#123;y&#125;&#125;&lt;&#x2F;h2&gt;<br>&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br><br>import &#123;<br>  ref<br>&#125; from &quot;vue&quot;<br>&#x2F;* <br>在组件中引入并使用自定义hook<br>自定义hook的作用类似于vue2中的mixin技术<br>自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂<br>*&#x2F;<br>import useMousePosition from &#39;.&#x2F;hooks&#x2F;useMousePosition&#39;<br><br>export default &#123;<br>  setup() &#123;<br><br>    const &#123;x, y&#125; &#x3D; useMousePosition(); &#x2F;&#x2F; 👈 组件生命周期钩子挂载，返回两个响应式数据。<br><br>    return &#123;<br>      x,<br>      y,<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="案例2-1"><a href="#案例2-1" class="headerlink" title="案例2.1"></a>案例2.1</h4><p>功能：封装发Ajax请求的hook函数。使用<code>reactive</code>封装响应。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"># hooks/useRequest.ts<br><span class="hljs-keyword">import</span> &#123;<br>  ref,<br>  Ref,<br>  UnwrapRef,<br>  reactive,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用axios发送异步ajax请求</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义向外暴露响应的接口（一个响应式泛型接口，result为泛型成员）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">interface</span> ReactiveResponse&lt;T&gt; &#123;<br>  result: T | <span class="hljs-literal">null</span>,<br>  loading: <span class="hljs-built_in">boolean</span>,<br>  errorMsg: <span class="hljs-built_in">string</span>,<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUrlLoader</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">UnwrapRef</span>&lt;<span class="hljs-title">ReactiveResponse</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-keyword">let</span> reactiveResponse = reactive&lt;ReactiveResponse&lt;T&gt;&gt;(&#123;<br>    result: <span class="hljs-literal">null</span>,<br>    loading: <span class="hljs-literal">true</span>,<br>    errorMsg: <span class="hljs-string">&#x27;&#x27;</span>,<br>  &#125;);<br><br>  axios.get(url)<br>    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      reactiveResponse.loading = <span class="hljs-literal">false</span>;<br>      reactiveResponse.result = response.data;<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      reactiveResponse.loading = <span class="hljs-literal">false</span>;<br>      reactiveResponse.errorMsg = e.message || <span class="hljs-string">&#x27;未知错误&#x27;</span>;<br>    &#125;);<br><br>  <span class="hljs-keyword">return</span> reactiveResponse;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;hello world&lt;&#x2F;h2&gt;<br>  &lt;div&gt;&#123;&#123;responceUsers.result&#125;&#125;&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>    import &#123; defineComponent&#125; from &#39;vue&#39;;<br>    defineComponent(&#123;<br>      name: &#39;HelloWorld&#39;,<br>      setup() &#123;<br>        interface User &#123;<br>          id: string,<br>          name: string,<br>          age: number<br>        &#125;<br><br>        let responceUsers &#x3D; useUrlLoader&lt;User[]&gt;(&#39;&#x2F;mock&#x2F;users.json&#39;);<br><br>        if (responceUsers.result !&#x3D;&#x3D; null) &#123;<br>          console.log(responceUsers.result); &#x2F;&#x2F; ⭐ useUrlLoader初始化时将result赋值为null<br>        &#125;                                    &#x2F;&#x2F; ⭐ 只有在onBeforeUpdate中才能访问到最新的result<br><br>        return &#123;<br>          responceUsers,<br>        &#125;;<br>      &#125;,<br>    &#125;);   <br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="案例2-2"><a href="#案例2-2" class="headerlink" title="案例2.2"></a>案例2.2</h4><p>功能：封装发Ajax请求的hook函数。使用<code>ref</code>封装响应。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<br>  ref,<br>  Ref,<br>  UnwrapRef,<br>  <span class="hljs-comment">// reactive,</span><br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">定义向外暴露响应的接口。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">interface</span> RefResponse&lt;T&gt; &#123;<br>  result: Ref&lt;UnwrapRef&lt;T&gt; | <span class="hljs-literal">null</span>&gt;;<br>  loading: Ref&lt;<span class="hljs-built_in">boolean</span>&gt;;<br>  errorMsg: Ref&lt;<span class="hljs-built_in">string</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUrlLoader</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">RefResponse</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>  <span class="hljs-keyword">const</span> result = ref&lt;T | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> loading = ref(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">const</span> errorMsg = ref(<span class="hljs-string">&#x27;&#x27;</span>);<br><br>  axios.get(url)<br>    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      loading.value = <span class="hljs-literal">false</span>;<br>      result.value = response.data;<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      loading.value = <span class="hljs-literal">false</span>;<br>      errorMsg.value = e.message || <span class="hljs-string">&#x27;未知错误&#x27;</span>;<br>    &#125;);<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    loading,<br>    result,<br>    errorMsg,<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Composition-API-其他内容"><a href="#Composition-API-其他内容" class="headerlink" title="Composition API 其他内容"></a>Composition API 其他内容</h2><h3 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h3><ul><li><code>shallowReactive</code> : 只处理了对象内最外层属性的响应式(也就是浅响应式)</li><li><code>shallowRef</code>: 只处理了value的响应式, 不进行对象的reactive处理</li><li><strong>什么时候用浅响应式呢?</strong><ul><li>一般情况下使用ref和reactive即可</li><li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li><li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;App&lt;&#x2F;h2&gt;<br><br>  &lt;h3&gt;m1: &#123;&#123;m1&#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;h3&gt;m2: &#123;&#123;m2&#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;h3&gt;m3: &#123;&#123;m3&#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;h3&gt;m4: &#123;&#123;m4&#125;&#125;&lt;&#x2F;h3&gt;<br><br>  &lt;button @click&#x3D;&quot;update&quot;&gt;更新&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123; reactive, ref, shallowReactive, shallowRef &#125; from &#39;vue&#39;<br>&#x2F;* <br>shallowReactive与shallowRef<br>  shallowReactive: 只处理了对象内最外层属性的响应式(也就是浅响应式)<br>  shallowRef: 只处理了value的响应式, 不进行对象的reactive处理<br>总结:<br>  reactive与ref实现的是深度响应式, 而shallowReactive与shallowRef是浅响应式<br>  什么时候用浅响应式呢?<br>    一般情况下使用ref和reactive即可,<br>    如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive<br>    如果有一个对象数据, 后面会产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef<br>*&#x2F;<br><br>export default &#123;<br><br>  setup () &#123;<br><br>    const m1 &#x3D; reactive(&#123;a: 1, b: &#123;c: 2&#125;&#125;)<br>    const m2 &#x3D; shallowReactive(&#123;a: 1, b: &#123;c: 2&#125;&#125;)<br><br>    const m3 &#x3D; ref(&#123;a: 1, b: &#123;c: 2&#125;&#125;)<br>    const m4 &#x3D; shallowRef(&#123;a: 1, b: &#123;c: 2&#125;&#125;)<br><br>    const update &#x3D; () &#x3D;&gt; &#123;<br>      &#x2F;&#x2F; m1.b.c +&#x3D; 1<br>      &#x2F;&#x2F; m2.b.c +&#x3D; 1<br><br>      &#x2F;&#x2F; m3.value.a +&#x3D; 1<br>      m4.value.a +&#x3D; 1<br>    &#125;<br><br>    return &#123;<br>      m1,<br>      m2,<br>      m3,<br>      m4,<br>      update,<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="readonly-和-shallowReadonly"><a href="#readonly-和-shallowReadonly" class="headerlink" title="readonly 和 shallowReadonly"></a>readonly 和 shallowReadonly</h3><p><strong>一、readonly</strong></p><p><code>readonly</code>是一个组合API中的一个函数，它允许传入一个对象类型的数据，并返回传入数据的只读代理。</p><blockquote><p>readonly定义的只读代理是深层次的。</p></blockquote><p>参数可以是：</p><ol><li>ref对象，此时ref对象的value属性变为只读，且如果value为Proxy，那么该Proxy各层嵌套属性也变为只读。</li><li>reactive对象，此时reactive对象的各层嵌套属性都为只读。</li><li>普通JS对象，此时该对象的各层嵌套属性都为只读。</li></ol><p><strong>二、shallowReadonly</strong></p><p><code>shallowReadonly</code>函数的用法和<code>readonly</code>函数一样，但返回的是一个浅只读代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;App&lt;&#x2F;h2&gt;<br>  &lt;h3&gt;&#123;&#123;state&#125;&#125;&lt;&#x2F;h3&gt;<br>  &lt;button @click&#x3D;&quot;update&quot;&gt;更新&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123; reactive, readonly, shallowReadonly &#125; from &#39;vue&#39;<br><br>export default &#123;<br><br>  setup () &#123;<br>      <br>    const state &#x3D; reactive(&#123;<br>      a: 1,<br>      b: &#123;<br>        c: 2<br>      &#125;<br>    &#125;)<br><br>    const rState1 &#x3D; readonly(state);<br>    const rState2 &#x3D; shallowReadonly(state);<br><br>    const update &#x3D; () &#x3D;&gt; &#123;<br>      rState1.a++ # error<br>      rState1.b.c++ # error<br><br>      rState2.a++ # error<br>      rState2.b.c++  &#x2F;&#x2F; ok<br>    &#125;<br>    <br>    return &#123;<br>      state,<br>      update<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="toRaw-和-markRaw"><a href="#toRaw-和-markRaw" class="headerlink" title="toRaw 和 markRaw"></a>toRaw 和 markRaw</h3><p><strong>一、toRaw</strong></p><p><code>toRaw</code>函数可以传入一个reactive对象或者一个readonly代理，然后返回该代理对象所代理的target。</p><p>（可以理解为一种还原操作）</p><ol><li><p>传入reactive代理，返回target后，<strong>可以对target进行读写，不会触发更新视图</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; toRaw, reactive, &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> info = &#123;<br>    name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>    age: <span class="hljs-number">24</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> infoReactive = reactive(info);<br><br><span class="hljs-keyword">const</span> infoToRaw = toRaw(infoReactive);<br><br><span class="hljs-built_in">console</span>.log(infoToRaw === info); <span class="hljs-comment">//返回 true  ⭐说明toRaw函数返回的是reactive对象代理的原数据</span><br><br><span class="hljs-keyword">const</span> update = <span class="hljs-function">() =&gt;</span> &#123;<br>    infoToRaw.name = <span class="hljs-string">&#x27;ley&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(infoToRaw);<br>    <span class="hljs-built_in">console</span>.log(infoReactive);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>传入readonly代理，可以得到target。</p><ul><li>如果target是一个reactive代理，则返回深层次的target，即返回reactive代理的target。</li><li>如果target是一个ref，则返回ref。</li><li>如果target是一个普通对象，则返回该对象。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">const</span> info = &#123;<br>    name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>    age: <span class="hljs-number">24</span>,<br>    more: &#123;<br>      foo: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>      bar: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    &#125;,<br>  &#125;;<br>   <br>  <span class="hljs-keyword">const</span> infoReactive = reactive(info);<br>   <br>  <span class="hljs-keyword">const</span> infoReadonly = <span class="hljs-keyword">readonly</span>(infoReactive);<br>   <br>  <span class="hljs-keyword">const</span> infoToRaw = toRaw(infoReadonly);<br>   <br>  <span class="hljs-keyword">const</span> test1 = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(infoToRaw);  <span class="hljs-comment">// 👈 执行test1时，infoToRaw的值为info，而不是infoReactive。</span><br>    <span class="hljs-built_in">console</span>.log(infoToRaw === info);<br>  &#125;;<br>    <br>  <span class="hljs-keyword">return</span> &#123;<br>      infoReactive,<br>      test1,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li>传入其他类型的参数，则返回该参数本身。</li></ol><blockquote><p><strong>小结</strong></p><ol><li><p><code>toRaw</code>函数如果传入的是一个reactive代理或readonly代理，则返回代理的target。如果代理的target仍然是一个reactive代理或readonly代理，则返回深层的target，直到target不再为一个Proxy为止，并返回该target。</p></li><li><p>如果<code>toRaw</code>函数传入的参数不是一个reactive代理或readonly代理，则返回值为参数本身。</p></li></ol></blockquote><p><strong>二、markRaw</strong></p><p><code>markRaw</code>函数用于对一个<strong>引用类型数据</strong>（例如Plain Object或数组）进行标记，当这个数据通过ref、reactive变为响应式数据，或者将该引用类型数据赋值给ref的value或者reactive代理对象的某个属性时，修改ref.value或者通过reactive代理修改该数据，<strong>不会触发视图更新</strong>（被标记的数据不会被响应式化）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;MarkRawTest&lt;&#x2F;h2&gt;<br>  &lt;div&gt;<br>    stateReactive1: &#123;&#123; stateReactive1 &#125;&#125;<br>  &lt;&#x2F;div&gt;<br>  &lt;button @click&#x3D;&quot;update1&quot;&gt;更新stateReactive1&lt;&#x2F;button&gt;<br>  &lt;div&gt;<br>    stateReactive2：&#123;&#123; stateReactive2 &#125;&#125;<br>  &lt;&#x2F;div&gt;<br>  &lt;button @click&#x3D;&quot;update2&quot;&gt;更新stateReactive2.friends&lt;&#x2F;button&gt;<br>  &lt;button @click&#x3D;&quot;update3&quot;&gt;stateReactive2.friends新增朋友&lt;&#x2F;button&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&#39;ts&#39;&gt;<br>import &#123;<br>  defineComponent,<br>  reactive,<br>  markRaw,<br>&#125; from &#39;vue&#39;;<br><br>export default defineComponent(&#123;<br>  name: &#39;MarkRawTest&#39;,<br>  setup() &#123;<br>    const state1 &#x3D; &#123;<br>      name: &#39;mz&#39;,<br>      age: 24,<br>      friends: [&#123;<br>        name: &#39;sxl&#39;,<br>        age: 24,<br>      &#125;],<br>    &#125;;<br>    markRaw(state1);<br><br>    const stateReactive1 &#x3D; reactive(state1);<br>    const update1 &#x3D; () &#x3D;&gt; &#123;<br>      stateReactive1.name &#x3D; &#39;ley&#39;;<br>      console.log(stateReactive1);<br>    &#125;;<br><br>    const state2: &#123;<br>      name: string,<br>      age: number,<br>      friends: any[],<br>    &#125; &#x3D; &#123;<br>      name: &#39;mz&#39;,<br>      age: 24,<br>      friends: [],<br>    &#125;;<br>    const stateReactive2 &#x3D; reactive(state2);<br>    &#x2F;&#x2F; 给state2.friends赋新值，新值已经用markRaw标记<br>    const update2 &#x3D; () &#x3D;&gt; &#123;<br>      let friends &#x3D; [&#39;foo&#39;, &#39;bar&#39;];<br>      markRaw(friends); &#x2F;&#x2F; 👈 标记<br>      stateReactive2.friends &#x3D; friends; &#x2F;&#x2F; 👈 这里会触发视图更新，因为原来的数据（空数组[]）没有被markRaw标记<br>    &#125;;<br>    &#x2F;&#x2F; 新增一个朋友名字<br>    const update3 &#x3D; () &#x3D;&gt; &#123;<br>      stateReactive2.friends.push(&#39;xxx&#39;); &#x2F;&#x2F; 标记了的数据不会触发视图更新，但数据确实会发生变化<br>      console.log(stateReactive2);<br>    &#125;;<br><br>    return &#123;<br>      stateReactive1,<br>      update1,<br>      stateReactive2,<br>      update2,<br>      update3,<br>    &#125;;<br>  &#125;,<br>&#125;);<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p><code>customRef</code>用于创建自定义ref，我们可以对自定义ref进行显示的跟踪，同时修改自定义ref的value时，可以控制视图更新的时机。</p><blockquote><p>即自定义ref对象的 getter/setter 是由开发者通过customRef定义的。</p></blockquote><p>案例：使用 customRef 实现防抖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;App&lt;&#x2F;h2&gt;<br>  &lt;input v-model&#x3D;&quot;keyword&quot; placeholder&#x3D;&quot;搜索关键字&quot;&#x2F;&gt;<br>  &lt;p&gt;&#123;&#123; keyword &#125;&#125;&lt;&#x2F;p&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>&#x2F;*<br>customRef:<br>  创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制<br><br>需求: <br>  使用 customRef 实现 debounce 的示例<br>*&#x2F;<br><br>import &#123;<br>  ref,<br>  customRef<br>&#125; from &#39;vue&#39;;<br><br>export default &#123;<br><br>  setup () &#123;<br>    const keyword &#x3D; useDebouncedRef(&#39;&#39;, 500)<br>    console.log(keyword)<br>    return &#123;<br>      keyword<br>    &#125;<br>  &#125;,<br>&#125;<br><br>&#x2F;* <br>实现函数防抖的自定义ref<br>*&#x2F;<br>function useDebouncedRef&lt;T&gt;(value: T, delay &#x3D; 200) &#123;<br>  let timeout: number<br>  return customRef((track, trigger) &#x3D;&gt; &#123;<br>    return &#123;<br>      get() &#123;<br>        &#x2F;&#x2F; 告诉Vue追踪数据<br>        track()<br>        return value<br>      &#125;,<br>      set(newValue: T) &#123;<br>        clearTimeout(timeout)<br>        timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;<br>          value &#x3D; newValue<br>          &#x2F;&#x2F; 告诉Vue去触发界面更新<br>          trigger()<br>        &#125;, delay)<br>      &#125;<br>    &#125;<br>  &#125;)<br>&#125;<br><br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a>provide 和 inject</h3><p><code>provide</code>和 <code>inject</code>提供依赖注入，功能类似 Vue2.x 的 <code>provide/inject</code>，实现跨层级组件(祖孙)间通信。</p><p>Vue3中的inject和provide比Vue2中更加好用。</p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p><strong>一、父级组件provide数据（响应式/非响应式）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h1&gt;父组件&lt;&#x2F;h1&gt;<br>  &lt;p&gt;当前颜色: &#123;&#123;color&#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;button @click&#x3D;&quot;color&#x3D;&#39;red&#39;&quot;&gt;红&lt;&#x2F;button&gt;<br>  &lt;button @click&#x3D;&quot;color&#x3D;&#39;yellow&#39;&quot;&gt;黄&lt;&#x2F;button&gt;<br>  &lt;button @click&#x3D;&quot;color&#x3D;&#39;blue&#39;&quot;&gt;蓝&lt;&#x2F;button&gt;<br>  <br>  &lt;hr&gt;<br>  &lt;Son &#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123; provide, ref &#125; from &#39;vue&#39;<br><br><br>import Son from &#39;.&#x2F;Son.vue&#39;<br>export default &#123;<br>  name: &#39;ProvideInject&#39;,<br>  components: &#123;<br>    Son<br>  &#125;,<br>  setup() &#123;<br>    const color &#x3D; ref(&#39;red&#39;)<br>    provide(&#39;color&#39;, color)<br>    return &#123;<br>      color<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>Vue2.x中，如果子孙组件获取到的inject注入是响应式的，则父组件provide的内容必须引用data中的数据。</p></blockquote><p><strong>二、子孙组件获取inject</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue"># 孙子组件<br>&lt;template&gt;<br>  &lt;h3 :style&#x3D;&quot;&#123;color&#125;&quot;&gt;孙子组件: &#123;&#123;color&#125;&#125;&lt;&#x2F;h3&gt;<br>  <br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import &#123; inject &#125; from &#39;vue&#39;<br>export default &#123;<br>  name: &#39;GrandSon&#39;,<br>  setup() &#123;<br>    const color &#x3D; inject(&#39;color&#39;); &#x2F;&#x2F; 获取祖先组件实例中的注入，并由setup返回，在模板中使用<br>    return &#123;<br>      color<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue"># 子级组件<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;子组件&lt;&#x2F;h2&gt;<br>    &lt;hr&gt;<br>    &lt;GrandSon &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import GrandSon from &#39;.&#x2F;GrandSon.vue&#39;<br>export default &#123;<br>  name: &#39;Son&#39;,<br>  components: &#123;<br>    GrandSon<br>  &#125;,<br>&#125;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>定义父级组件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;h2&gt;<br>    Inject and Provide Test<br>  &lt;&#x2F;h2&gt;<br>  &lt;hr&gt;<br>  &lt;son-1&#x2F;&gt;<br>  &lt;hr&gt;<br>  &lt;son-2&#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123;<br>  defineComponent,<br>  provide,<br>  ref,<br>  reactive,<br>&#125; from &#39;vue&#39;;<br><br>import Son1 from &#39;.&#x2F;Son1.vue&#39;;<br>import Son2 from &#39;.&#x2F;Son2.vue&#39;;<br><br>export default defineComponent(&#123;<br>  name: &#39;ProvideInjectTest&#39;,<br>  components: &#123;<br>    Son1,<br>    Son2,<br>  &#125;,<br>  setup() &#123;<br>    provide(&#39;color&#39;, &#39;red&#39;);   &#x2F;&#x2F; 提供一个非响应式的基本类型数据<br>    provide(&#39;colorRef&#39;, ref(&#39;red&#39;)); &#x2F;&#x2F; 提供一个响应式的基本类型数据<br>    provide(&#39;style&#39;, &#123; color: &#39;red&#39; &#125;); &#x2F;&#x2F; 提供一个非响应式的引用类型数据<br>    provide(&#39;styleReactive&#39;, reactive(&#123; color: &#39;red&#39; &#125;)); &#x2F;&#x2F; 提供一个响应式的引用类型数据<br>    return &#123;&#125;;<br>  &#125;,<br>&#125;);<br><br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>自定hook，在子组件中获取inject，并定义相同的方法</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useColorTest</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> color = inject(<span class="hljs-string">&#x27;color&#x27;</span>);<br>  <span class="hljs-keyword">const</span> style: <span class="hljs-built_in">any</span> = inject(<span class="hljs-string">&#x27;style&#x27;</span>);<br>  <span class="hljs-keyword">const</span> colorRef: <span class="hljs-built_in">any</span> = inject(<span class="hljs-string">&#x27;colorRef&#x27;</span>);<br>  <span class="hljs-keyword">const</span> styleReactive: <span class="hljs-built_in">any</span> = inject(<span class="hljs-string">&#x27;styleReactive&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> updateColor = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>      color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> updateStyle = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (style.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>      style.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      style.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> updateColorRef = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (colorRef.value === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>      colorRef.value = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      colorRef.value = <span class="hljs-string">&#x27;red&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">const</span> updateStyleReactive = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (styleReactive.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>      styleReactive.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      styleReactive.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    color,<br>    style,<br>    colorRef,<br>    styleReactive,<br>    updateColor,<br>    updateColorRef,<br>    updateStyle,<br>    updateStyleReactive,<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>定义子组件1</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;container&quot; :style&#x3D;&quot;&#123; color &#125;&quot;&gt;<br>    Son1<br>  &lt;&#x2F;div&gt;<br>  &lt;ul&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;&#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateColorRef&quot;&gt;updateColorRef&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;&#123; color: colorRef &#125;&quot;&gt;&#123;&#123; colorRef &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;style&quot;&gt;&#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;&#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>  &lt;&#x2F;ul&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import useColorTest from &#39;..&#x2F;hooks&#x2F;useColorTest&#39;;<br><br>export default &#123;<br>  name: &#39;Son1&#39;,<br>  setup() &#123;<br>    return &#123;<br>      ...useColorTest(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;<br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>定义子组件2</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;container&quot; :style&#x3D;&quot;&#123; color &#125;&quot;&gt;<br>    Son2<br>  &lt;&#x2F;div&gt;<br>  &lt;ul&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;&#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateColorRef&quot;&gt;updateColorRef&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;&#123; color: colorRef &#125;&quot;&gt;&#123;&#123; colorRef &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;style&quot;&gt;&#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>    &lt;li&gt;<br>      &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>      &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;&#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>    &lt;&#x2F;li&gt;<br>  &lt;&#x2F;ul&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script lang&#x3D;&quot;ts&quot;&gt;<br>import useColorTest from &#39;..&#x2F;hooks&#x2F;useColorTest&#39;;<br><br>export default &#123;<br>  name: &#39;Son2&#39;,<br>  setup() &#123;<br>    return &#123;<br>      ...useColorTest(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;<br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure><ol start="5"><li>小结</li></ol><blockquote><ol><li>当子组件获取的inject内容为非响应式的基本类型时，不会具有响应式效果，这个内容一般作为只读数据。</li><li>当子组件获取的inject为响应式的基本类型数据时（value为基本类型的ref对象），在子组件内修改该ref对象的value会触发子组件的视图更新，也会影响到其他引用该ref对象的组件。</li><li>当子组件获取的inject为非响应式的引用类型数据时（如Plain Object或Array），该数据不具有响应式的效果，即修改该引用类型数据的内容时，不会立刻触发视图的更新。但是数据确实发生改变了，此后，当组件因为其他原因更新视图时，能够在视图中看到该数据的更新（Vue3 vDom更新会patch模板中的非响应式引用类型数据，但非响应式数据不会触发视图更新）。</li><li>当子组件获取的inject为响应式的引用类型数据时（reactive代理），修改该数据的属性会触发子组件以及依赖该数据的其他组件的更新。</li></ol></blockquote><h4 id="提供修改provide数据的方法"><a href="#提供修改provide数据的方法" class="headerlink" title="提供修改provide数据的方法"></a>提供修改provide数据的方法</h4><p>有时我们需要在注入数据的组件内部更新注入的数据。在这种情况下，我们建议提供一个方法来负责改变响应式 property。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src&#x2F;components&#x2F;MyMap.vue --&gt;<br>&lt;template&gt;<br>  &lt;MyMarker &#x2F;&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import &#123; provide, reactive, ref &#125; from &#39;vue&#39;<br>import MyMarker from &#39;.&#x2F;MyMarker.vue<br><br>export default &#123;<br>  components: &#123;<br>    MyMarker<br>  &#125;,<br>  setup() &#123;<br>    const location &#x3D; ref(&#39;North Pole&#39;)<br>    const geolocation &#x3D; reactive(&#123;<br>      longitude: 90,<br>      latitude: 135<br>    &#125;)<br><br>    const updateLocation &#x3D; () &#x3D;&gt; &#123;<br>      location.value &#x3D; &#39;South Pole&#39;<br>    &#125;<br><br>    provide(&#39;location&#39;, location)<br>    provide(&#39;geolocation&#39;, geolocation)<br>    provide(&#39;updateLocation&#39;, updateLocation)<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- src&#x2F;components&#x2F;MyMarker.vue --&gt;<br>&lt;script&gt;<br>import &#123; inject &#125; from &#39;vue&#39;<br><br>export default &#123;<br>  setup() &#123;<br>    const userLocation &#x3D; inject(&#39;location&#39;, &#39;The Universe&#39;)<br>    const userGeolocation &#x3D; inject(&#39;geolocation&#39;)<br>    const updateUserLocation &#x3D; inject(&#39;updateLocation&#39;)<br><br>    return &#123;<br>      userLocation,<br>      userGeolocation,<br>      updateUserLocation<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="和Vue2-x-provide-inject的区别"><a href="#和Vue2-x-provide-inject的区别" class="headerlink" title="和Vue2.x provide/inject的区别"></a>和Vue2.x provide/inject的区别</h4><p>a. Vue2中inject内容为基本数据类型时，不论该数据是响应式的还是非响应式的，都会触发视图更新，但不会影响其他组件，即这份数据是子组件实例独有的。</p><p>a. 而Vue3的响应式基本类型数据一般由ref包裹，修改ref对象的value属性时，会触发视图更新，同时会影响依赖于该ref对象的其他组件，即这份数据是共享的；</p><p>a. 此外Vue3中，非响应式的基本类型inject数据被修改时，不会触发试图更新，同时在子组件下一次更新时，模板中依赖于该注入数据的DOM元素也不会发生变化（还是祖先组件provide的值）。</p><blockquote><p>这里可以理解为：</p><p>Vue3中子组件更新时，如果模板中依赖于注入的数据（inject的内容），则每次都会从祖先组件的provide中去获取，而跟子组件之前的状态无关。</p><p>Vue2中子组件更新时，如果模板中依赖于注入的数据（inject的内容），新的注入数据不是重新到祖先的provide中去获取，而是到子组件实例上获取。👈 这明显没有Vue3逻辑正确。</p></blockquote><p>b. Vue2中inject内容为非响应式的引用类型数据时，修改该注入数据的属性值不会立刻触发视图更新，在下一次子组件更新时，模板中依赖于该值的插值语法处会更新，<font color='red'>但是通过v-bind绑定的地方不会发生更新，这可能是一个Vue2中没有处理到的细节</font>（可能潜藏在模板编译或vNode的prepatch的逻辑里）。</p><p>b. Vue3中inject内容为非响应式的引用类型数据时，修改该注入数据的属性值不会立刻触发视图更新，在下一次子组件更新时，模板中依赖于该值的地方都会更新（包括v-bind绑定的属性值）。</p><blockquote><p>模板中依赖非响应式的引用类型inject，当该inject的内容发生更新时，不会立刻触发视图更新。</p><p>这是因为inject的值是一个引用类型数据的地址，所以尽管该引用类型内部可能发生了变化，但injetc的值没有发生变化，Vue响应式系统不认为这个数据更新了。</p><p>而当下一次子组件更新时，会根据更新后的inject数据内容，重新生成VNode，从而进行patch。</p></blockquote><p><strong>综上，Vue3.0中的 provide/inject 使用起来更加方便，同时各种情况下的表现更加合理。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack4配置</title>
    <link href="/2021/04/19/Webpack/webpack4/"/>
    <url>/2021/04/19/Webpack/webpack4/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack的作用"><a href="#webpack的作用" class="headerlink" title="webpack的作用"></a>webpack的作用</h1><p>使用webpack构建前端项目工程其实是工程化、自动化思想在前端发开中的体现，把一系列流程用代码去自动实现。</p><ul><li>代码转换：将TypeScript编译成JS，SCSS编译成CSS等。</li><li>文件优化：压缩JS、CSS、HTML代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li>自动刷新：主要是依赖于webpack-dev-server，监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：主要是依赖于Eslint，对代码的正确性和规范性进行检查，以及单元测试是否通过。</li><li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><h1 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h1><ol><li><p><strong>entry</strong>：入口，webpack执行构建的第一步将从Entry开始。</p></li><li><p><strong>output</strong>：输出结果，在webpack经过一系列处理并得出最终想要的代码后输出结果。</p></li><li><p><strong>module</strong>：模块，在webpack中一切皆模块，指的是一个模块对应着一个文件，webpack会从entry开始递归找出所有依赖的模块。</p></li><li><p><strong>chunk</strong>：代码块，一个chunk由多个模块组合而成，用于代码合并与分割。</p></li><li><p><strong>loader</strong>：模块转换器，用于把模块原内容按照要求转换成新内容。</p><blockquote><p>默认情况下，webpack只能识别<code>.json</code>和<code>.js</code>文件。</p></blockquote></li><li><p><strong>plugin</strong>：扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情。</p></li><li><p><strong>mode</strong>：模式，分为开发模式<code>development</code>和生产模式<code>production</code>。不同的模式下，对webpack的配置和webpack自身的处理流程有一些区别。</p></li></ol><h2 id="关于module、chunk、chunk组"><a href="#关于module、chunk、chunk组" class="headerlink" title="关于module、chunk、chunk组"></a>关于module、chunk、chunk组</h2><p><strong>以下内容来源于Webpack中文官方文档：</strong></p><p><a href="https://webpack.docschina.org/concepts/under-the-hood/#the-main-parts">链接</a></p><p>项目中使用的每个文件都是一个<strong>模块</strong>。</p><p><strong>./index.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.js&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>./app.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;the app&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通过互相引用，这些模块会形成一个图(<code>ModuleGraph</code>)数据结构。</p><p><strong>模块之间相互依赖，并形成一个连接的图(<code>ModuleGraph</code>)，入口模块就是拓扑的起点</strong>。 </p><p><strong>从入口模块开始分析依赖关系，将同步的模块合并生成chunk，将异步的模块、共同的依赖进行分离成chunk，这个过程中就产生了一到多个chunk，称为chunk组（<code>chunk group</code>）。</strong></p><p><strong>./webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./index.js&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这会创建出一个名为 <code>main</code> 的 chunk 组（<code>main</code> 是入口起点的默认名称）。 此 chunk 组包含 <code>./index.js</code> 模块。随着 parser 处理 <code>./index.js</code> 内部的 import 时， 新模块就会被添加到此 chunk 中。</p><p><strong>另外的一个示例：</strong></p><p><strong>./webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    home: <span class="hljs-string">&#x27;./home.js&#x27;</span>,<br>    about: <span class="hljs-string">&#x27;./about.js&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这会创建出两个名为 <code>home</code> 和 <code>about</code> 的 chunk 组。 每个 chunk 组都有一个包含一个模块的 chunk：<code>./home.js</code> 对应 <code>home</code>，<code>./about.js</code> 对应 <code>about</code>。</p><blockquote><p><em>一个 chunk 组中可能有多个 chunk。例如，</em><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> <em>会将一个 chunk 拆分为一个或多个 chunk。</em></p></blockquote><p><font size="10">chunks</font></p><p><strong>chunk 有两种形式：</strong></p><ul><li><p><code>initial（初始化chunk）</code> ，也可以叫做主chunk，是由入口起点生成的主线。此 chunk 包含为入口起点指定的所有模块及其依赖项。</p></li><li><p><code>non-initial（非初始化chunk）</code> 。由 <a href="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports">动态导入(dynamic imports)</a> 语法或者 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 规则分离出的chunk。</p></li></ul><blockquote><p>一般而言，splitChunksPlugin分离出的非懒加载chunk打包出的js文件一般插入在initial-chunk打包出的js之前。</p></blockquote><p>所有的chunk会对应一个资源（<code>asset</code>），资源是由chunk打包出的结果，一般是js+css+图片等资源的组合。</p><p><strong>webpack.config.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/index.jsx&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>./src/index.jsx</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./app.jsx&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> &#123;<br>  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这会创建出一个名为 <code>main</code> 的 initial chunk。其中包含：</p><ul><li><code>./src/index.jsx</code></li><li><code>react</code></li><li><code>react-dom</code></li></ul><p>以及除 <code>./app.jsx</code> 外的所有依赖</p><p>然后会为 <code>./app.jsx</code> 创建 non-initial chunk，这是因为 <code>./app.jsx</code> 是动态导入的。</p><p><strong>输出的结果文件（<code>asset</code>）</strong>:</p><ul><li><code>/dist/main.js</code> - 一个 <code>initial</code> chunk</li><li><code>/dist/394.js</code> - <code>non-initial</code> chunk</li></ul><p>默认情况下，这些 <code>non-initial</code> chunk 没有名称，因此会使用唯一 ID 来替代名称。 在使用动态导入时，我们可以通过使用 <a href="https://webpack.docschina.org/api/module-methods/#magic-comments">magic comment(魔术注释)</a> 来显式指定 chunk 名称：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<br>  <span class="hljs-comment">/* webpackChunkName: &quot;app&quot; */</span><br>  <span class="hljs-string">&#x27;./app.jsx&#x27;</span><br>).then(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> &#123;<br>  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>Webpack5中，异步导入的模块的webpackChunkName默认为由下划线和中划线连接的文件解析路径，这是与Webpack4的不同之处之一。</p></blockquote><p><strong>输出文件的名称会受配置中的两个字段的影响：</strong></p><ul><li><a href="https://webpack.docschina.org/configuration/output/#outputfilename"><code>output.filename</code></a> - 用于 <code>initial</code> chunk 文件</li><li><a href="https://webpack.docschina.org/configuration/output/#outputchunkfilename"><code>output.chunkFilename</code></a> - 用于 <code>non-initial</code> chunk 文件</li></ul><h1 id="模块的初级打包"><a href="#模块的初级打包" class="headerlink" title="模块的初级打包"></a>模块的初级打包</h1><h2 id="webpack的hello-world"><a href="#webpack的hello-world" class="headerlink" title="webpack的hello world"></a>webpack的hello world</h2><ol><li><p>创建工程目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir project<br></code></pre></td></tr></table></figure></li><li><p>创建源代码目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> project<br>mkdir src<br></code></pre></td></tr></table></figure></li><li><p>创建输出目录（可省略，换在webpack配置中声明）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir dist<br></code></pre></td></tr></table></figure></li><li><p>初始化npm包并安装<code>webpack</code>、<code>webpack-cli</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm init <span class="hljs-literal">-y</span><br>npm install webpack webpack<span class="hljs-literal">-cli</span> <span class="hljs-literal">-D</span><br></code></pre></td></tr></table></figure></li><li><p>新建<code>webpack.config.js</code>，配置入口和输出路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">// 入口为src目录下main.js</span><br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>, <span class="hljs-comment">// 打包后的主文件名</span><br>        path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>) <span class="hljs-comment">// 输出目录，必须是绝对路径</span><br>    &#125;,<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中配置npm脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-comment">// 新增scripts字段</span><br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建<code>src/main.js</code>，执行<code>npm run build</code>打包文件。打包后在dist目录下新建<code>index.html</code>，引入<code>bundle.js</code>进行测试</p><p>– dist</p><p>—- bundle.js</p><p>—- index.html</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//# src/main.js</span><br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2021/04/19/Webpack/webpack4/image-20210213175816749.png"> </p></li></ol><h2 id="打包JS"><a href="#打包JS" class="headerlink" title="打包JS"></a>打包JS</h2><p>webpack会从入口js文件开始自动递归打包依赖，所以设置好入口后就能够打包js文件。</p><p>在不分割代码、没有懒加载的情况下，一个入口js文件会对应一个chunk，多个入口文件会对应多个chunk，每个chunk打包出一个bundle。</p><h3 id="单入口"><a href="#单入口" class="headerlink" title="单入口"></a>单入口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">/* ⭐ 这其实是语法糖写法，相当于 entry: &#123; main: &#x27;./src/main.js&#x27; &#125;*/</span><br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>) <span class="hljs-comment">// 打包的输出目录</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    <span class="hljs-comment">/* 多入口时，entry采用键值对写法, key为入口chunk的name，value为入口文件的路径/第三方包名 </span><br><span class="hljs-comment">    单入口语法糖写法时，chunk的name默认为main */</span><br>    main: <span class="hljs-string">&#x27;main.js&#x27;</span>,<br>    index: <span class="hljs-string">&#x27;index.js&#x27;</span>,<br>    vendor: <span class="hljs-string">&#x27;jquery&#x27;</span><br>  &#125;<br>  output: &#123;<br>  <span class="hljs-comment">// 👇 多入口时文件名应该这样写，[name]为entry中定义的key，也就是chunk的name。[hash]为可选</span><br>    filename: <span class="hljs-string">&#x27;[name].[hash].js&#x27;</span>, <span class="hljs-comment">// 比如说jquery打包后就是为vendor.[hash].js</span><br>  path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打包单页HTML"><a href="#打包单页HTML" class="headerlink" title="打包单页HTML"></a>打包单页HTML</h2><p>使用插件<code>html-webpack-plugin</code>读取模板。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>            template: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> <span class="hljs-comment">// 指定以哪个html文件作为模板</span><br>        <span class="hljs-comment">// 其他可配置项</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        filename: &#x27;index.html&#x27;, 👈 可以更改输出的文件路径</span><br><span class="hljs-comment">        hash: true, 👈 为html引用的其他资源的url后加上查询hash，例如：bundle.js?29ab09214532</span><br><span class="hljs-comment">        chunks: [&#x27;main&#x27;], 👈 指定html.body末尾插入哪些chunk的script标签，数组中元素为chunk的name</span><br><span class="hljs-comment">        chunksSortMode: &#x27;maunal&#x27; 👈 手动设置chunk的插入顺序，即按照上一行chunks数组中的顺序插入</span><br><span class="hljs-comment">        */</span><br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>❗ 新版html-webpack-plugin中默认会将script插入到<head>标签中，但同时插入的script标签会拥有<code>defer=&quot;defer&quot;</code> 属性</strong>。这个属性会标记js脚本在页面加载完后执行，但是能够在<strong>高级浏览器中</strong>提高页面加载的性能，这种技术叫做非阻塞JavaScript加载（non-blocking javascript loading）。</p><p>如果仍然需要将script标签插入到body最后，需要在<code>options</code>中多配置一条：<code>inject: &#39;body&#39;</code>。但由于defer属性的存在，仅仅将script标签插入到body最后，有点画蛇添足。这是因为只要有defer属性的存在，script标签指向的外部js脚本都会非阻塞加载。</p><p>如果不想使用非阻塞加载并且将script标签插入到body最后，则需要在<code>options</code>中再多配置一条：<code>scriptLoading: &#39;blocking&#39;</code>，该值默认为<code>defer</code>。</p></blockquote><h2 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h2><h3 id="开发环境内联"><a href="#开发环境内联" class="headerlink" title="开发环境内联"></a>开发环境内联</h3><p>开发环境下样式内联，将一个chunk中的css打包结果插入到style标签中。使用<code>css-loader</code>和<code>style-loader</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;  <span class="hljs-comment">// 所有的loader匹配规则在module.rules中配置</span><br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-comment">// loader的执行顺序是从后向前</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生产环境分离"><a href="#生产环境分离" class="headerlink" title="生产环境分离"></a>生产环境分离</h3><p>生产环境中如果样式仍然打包到head中的style标签中，由于css文件体积过大，解析需要短暂的时间，会出现闪屏现象，所以我们用<code>mini-css-extract-plugin</code>的loader代替<code>style-loader</code>，<strong>将css文件分离。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;  <br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,<br>                use: [MiniCssExtractPlugin.loader, <span class="hljs-string">&#x27;css-loader&#x27;</span>] ⭐ <span class="hljs-comment">// 替换掉style-loader</span><br>            &#125;<br>        ]<br>    &#125;,<br>    plugins: [<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;<br>            filename: <span class="hljs-string">&#x27;[name].css&#x27;</span> <span class="hljs-comment">// name是所在chunk的name，单入口时为main.css</span><br>        &#125;)<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h2><h3 id="处理js中引入的图片"><a href="#处理js中引入的图片" class="headerlink" title="处理js中引入的图片"></a>处理js中引入的图片</h3><p>例如，在如下的代码块中引入了一个图片模块，webpack是识别不了图片的，所以需要loader的帮助</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//# main.js</span><br><span class="hljs-keyword">const</span> imgSrc = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./images/xxx.jpg&#x27;</span>);<br></code></pre></td></tr></table></figure><p>webpack建议我们使用<code>url-loader</code>或<code>file-loader</code>处理图片，<code>url-loader</code>内置了<code>file-loader</code>，功能更强大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)$/</span>,<br>        use: &#123;<br>          <span class="hljs-comment">/* 当需要对一个loader进行配置时，采用对象写法 */</span><br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>, <br>          options: &#123;             <span class="hljs-comment">// 配置写在options中</span><br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// limit限制了多大的图片以下采用Base64内联，单位为Byte。这里限制了12KB</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理html模板中的图片标签"><a href="#处理html模板中的图片标签" class="headerlink" title="处理html模板中的图片标签"></a>处理html模板中的图片标签</h3><p>HTML模板中如果用img标签引入了开发目录下的图片资源，如果不进行处理，webpack是不会打包引入的图片的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!--....--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./images/xxx.jpg&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--👈打包后dist目录中index.html的img标签不会变化，但是没有打包图片--&gt;</span><br><span class="hljs-comment">&lt;!----&gt;</span><br></code></pre></td></tr></table></figure><p>所以我们要使用<code>html-withimg-loader</code>处理html文件, 发现其中的图片引用，从而交给<code>url-loader</code>处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)$/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>          options: &#123;<br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>,<br>            esModule: <span class="hljs-literal">false</span> <span class="hljs-comment">/*👈⭐⭐ 有时需要指定url-loader使用commonJS导入,否则和html-webpack-plugin之间会存在bug*/</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.html$/</span>,<br>        use: <span class="hljs-string">&#x27;html-withimg-loader&#x27;</span> <span class="hljs-comment">// 配置html-withimg-loader</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理css中的文件"><a href="#处理css中的文件" class="headerlink" title="处理css中的文件"></a>处理css中的文件</h3><p>css中使用<code>url(...)</code>这样的语法引用的图片资源会被<code>css-loader</code>进行处理。</p><h1 id="模块的高级处理"><a href="#模块的高级处理" class="headerlink" title="模块的高级处理"></a>模块的高级处理</h1><h2 id="静态资源分离与重命名"><a href="#静态资源分离与重命名" class="headerlink" title="静态资源分离与重命名"></a>静态资源分离与重命名</h2><p>之前对js、图片、css的处理都只会将打包的结果全部保存在dist目录下，这无疑是混乱的，我们需要将不同的静态资源分类，存放在<code>dist</code>或<code>dist/static</code>目录下。</p><h3 id="将js打包到dist-js-或-dist-static-js"><a href="#将js打包到dist-js-或-dist-static-js" class="headerlink" title="将js打包到dist/js 或 dist/static/js"></a>将js打包到dist/js 或 dist/static/js</h3><p>webpack会从<code>entry</code>开始打包js，并输出到<code>output</code>，所以js打包到指定目录需要在<code>output</code>中处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/bundle.js&#x27;</span> <br>    <span class="hljs-comment">// ⭐ 如果打包结果要保存到dist/static， 则filename: &#x27;static/js/bundle.js&#x27;</span><br>    <span class="hljs-comment">// ⭐ 如果多入口且结果保存到js目录下，则filename: &#x27;js/[name].[hash].js&#x27;</span><br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  publicPath: <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-comment">// ⭐ 最好设置一下publicPath为&quot;/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将图片打包到dist-image或dist-static-image"><a href="#将图片打包到dist-image或dist-static-image" class="headerlink" title="将图片打包到dist/image或dist/static/image"></a>将图片打包到dist/image或dist/static/image</h3><p>图片打包到指定目录需要在<code>url-loader</code>的<code>options</code>中处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  output: &#123;<br>    <span class="hljs-comment">//...</span><br>    publicPath: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// 👈 这里配合output.publicPath</span><br>  &#125;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>          options: &#123;<br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>,<br>    esModule: <span class="hljs-literal">false</span>,<br>            <span class="hljs-comment">// 👇 ⭐</span><br>    outputPath: <span class="hljs-string">&#x27;static/image&#x27;</span> <span class="hljs-comment">// outputPath为file-loader中的可选项，资源的统一存放路径。</span><br>            name: <span class="hljs-string">&#x27;[name].[contenthash:10].[ext]&#x27;</span>, <span class="hljs-comment">// name可以省略，文件名直接由hash值替代</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将css打包到dist-css-或-dist-static-css"><a href="#将css打包到dist-css-或-dist-static-css" class="headerlink" title="将css打包到dist/css 或 dist/static/css"></a>将css打包到dist/css 或 dist/static/css</h3><p>生产环境下，css打包到指定目录需要在<code>mini-css-extract-plugin</code>中配置<code>filename</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  output: &#123;<br>    <span class="hljs-comment">//...</span><br>    publicPath: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// 👈 这里配合output.publicPath</span><br>  &#125;<br>  plugins: [<br>    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;<br>      <span class="hljs-comment">// 👇 ⭐ </span><br>      filename: <span class="hljs-string">&#x27;css/[name].[contenthash].css&#x27;</span> <span class="hljs-comment">// 或 &#x27;static/css/[name].[contenthash].css&#x27;     </span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="hash-、-chunkhash-、-contenthash"><a href="#hash-、-chunkhash-、-contenthash" class="headerlink" title="[hash]、[chunkhash]、[contenthash]"></a>[hash]、[chunkhash]、[contenthash]</h3><p>以上三个文件名占位符可以叫做<strong>文件指纹</strong>。</p><p>区别在于：</p><ul><li><p>[hash]：同一次webpack打包的所有文件具有同一个[hash]。</p></li><li><p>[chunkhash]：即使进行多次打包，只要同一个chunk内的模块没有发生改变，[chunkhash]不变。</p></li><li><p>[contenthash]：该哈希值只与文件内容有关，文件内容改变该哈希值才会改变。</p></li></ul><h2 id="处理CSS兼容性问题"><a href="#处理CSS兼容性问题" class="headerlink" title="处理CSS兼容性问题"></a>处理CSS兼容性问题</h2><p>我们一般使用<code>postcss</code>来处理css兼容性问题，为各种样式添加厂商前缀。</p><p>使用<code>postcss-loader</code>和 <code>postcss-preset-env</code>帮助我们根据需要适配的浏览器版本对css进行兼容性处理。</p><blockquote><p><strong>postcss-preset-dev</strong> 的作用是帮助 <strong>postcss-loader</strong> 读取 <strong>browserslist</strong> 定义的各种环境下需要适配的浏览器版本，再根据当前运行环境  <strong>process.env.BROWSERSLIST_ENV</strong>  ，处理css样式。</p></blockquote><h3 id="新版postcss-loader"><a href="#新版postcss-loader" class="headerlink" title="新版postcss-loader"></a>新版postcss-loader</h3><p><strong>配置步骤：</strong></p><p><strong>1. 首先下载需要的包<code>postcss-loader postcss-preset-env</code></strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-loader postcss-preset-env -D<br></code></pre></td></tr></table></figure><p><strong>2. 配置<code>browserslist</code>，声明各个环境下需要适配的浏览器版本，以下两种方法取其一：</strong></p><p>⭐方法1：在<code>package.json</code>的<code>browserslist</code>字段中声明。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">//...</span><br>  browserslist: &#123;<br>    <span class="hljs-comment">/* 生开发环境需要兼容的浏览器 */</span><br>    &quot;development&quot;: [ <br>      &quot;last 1 chrome version&quot;,<br>      &quot;last 1 firefox version&quot;,<br>      <span class="hljs-string">&quot;last 1 safari version&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 生产环境需要兼容的浏览器 */</span><br>    &quot;production&quot;: [<br>      &quot;&gt; 1%&quot;,<br>      &quot;not dead&quot;,<br>      <span class="hljs-string">&quot;not op_mini all&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 自定义的环境1 */</span><br>    &quot;chrome&quot;: [<br>      <span class="hljs-string">&quot;last 1 chrome version&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 自定义的环境2 */</span><br>    &quot;modern&quot;: [<br>      <span class="hljs-string">&quot;&gt; 10%&quot;</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐方法2：在工程目录下的<code>.browserslistrc</code>文件中声明。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">[development]<br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> chrome <span class="hljs-keyword">version</span><br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> firefox <span class="hljs-keyword">version</span><br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> safari <span class="hljs-keyword">version</span><br>[production]<br>  &gt; <span class="hljs-number">1</span>%<br>  not dead<br>  not op_mini <span class="hljs-keyword">all</span><br>[chrome]<br><span class="hljs-keyword">last</span> <span class="hljs-number">1</span> <span class="hljs-keyword">version</span> chrome<br>[modern]<br>&gt; <span class="hljs-number">10</span>%<br></code></pre></td></tr></table></figure><p><strong>3. 在<code>webpack.config.js</code>中配置<code>postcss-loader</code>对css文件进行处理</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// 👇 最近版本的postcss-loader结合postcss-preset-env的配置如下</span><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  postcssOptions: &#123;<br>    plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>]<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// process.env.BROWSERSLIST_ENV = &#x27;production&#x27;;</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-comment">//👇 开始配置postcss-loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>⭐ 默认情况下，postcss-preset-env会告诉postcss-loader兼容<strong>生产环境</strong>下的浏览器。</p><p>如果在开发环境下，只需要兼容开发环境需要兼容的浏览器，则应该在webpack.config.js中通过process.env.BROWSERSLIST_ENV声明环境为开发环境或其他在browserslist中声明的环境。</p></blockquote><p><strong>4. 声明何种环境下的浏览器</strong></p><p>通过修改<code>process.env.BROWERSLIST_ENV</code>环境变量，告诉<code>postcss</code>当前运行环境。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">//👇⭐</span><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>; <span class="hljs-comment">// 默认情况下该值是&quot;production&quot;</span><br><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  postcssOptions: &#123;<br>    plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>]<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="旧版postcss-loader的options"><a href="#旧版postcss-loader的options" class="headerlink" title="旧版postcss-loader的options"></a>旧版postcss-loader的options</h3><p>旧版<code>postcss-loader</code>结合<code>postcss-preset-env</code>的<code>options</code>的写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// 👇 ⭐只需要将postcssLoaderOptions修改为：</span><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  ident: <span class="hljs-string">&#x27;postcss&#x27;</span>,<br>  plugins: <span class="hljs-function">() =&gt;</span> [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>)()<br>  ]<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-comment">//👇 开始配置postcss-loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="处理Sass和Less"><a href="#处理Sass和Less" class="headerlink" title="处理Sass和Less"></a>处理Sass和Less</h2><h3 id="处理scss"><a href="#处理scss" class="headerlink" title="处理scss"></a>处理scss</h3><p>首先下载需要的包 <code>npm install sass sass-loader -D</code></p><p>然后在进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;sass-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理less"><a href="#处理less" class="headerlink" title="处理less"></a>处理less</h3><p>首先下载需要的包 <code>npm install less less-loader -D</code></p><p>然后在进行配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;less-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配合postcss使用"><a href="#配合postcss使用" class="headerlink" title="配合postcss使用"></a>配合postcss使用</h3><p>以处理sass为例，需要配置<code>sass-loader</code>处理<code>.scss</code>文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-comment">// 👇 定义一般css的处理流程使用到的loader数组</span><br><span class="hljs-keyword">const</span> cssProcessingLoaders = [<br>  MiniCssExtractPlugin.loader,<br>  <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>  &#123;<br>    loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>    options: &#123;<br>      postcssOptions: &#123;<br>        plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>],<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>];<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [...cssProcessingLoaders, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="处理JS兼容性问题"><a href="#处理JS兼容性问题" class="headerlink" title="处理JS兼容性问题"></a>处理JS兼容性问题</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>不同浏览器对<code>ECMAScript</code>的版本支持不同，所以对不同的浏览器需要做<strong>JS语法的兼容性处理</strong>。</p><p>推荐的做法是根据需要适配的浏览器环境，动态调整polyfill的内容：</p><p><strong>1. 下载<code>babel-loader</code>、<code>@bable/core</code>、<code>@bable/preset-env</code>、<code>core-js</code></strong></p><ul><li><code>babel-loader</code>是一个loader，相当于处理兼容性的入口。</li><li><code>@bable/core</code>是babel的核心，负责控制处理流程。</li><li><code>@bable/preset-env</code>根据所要兼容的环境，指示<strong>babel</strong>如何做最基本的JS语法兼容性处理。</li><li><code>core-js</code>用来指示<strong>bable</strong>按需做更高级的JS语法兼容处理，如 <strong>promise</strong>。</li></ul><p><strong>2. 配置<code>babel-loader</code>，但其<code>options</code>有两种写法：</strong></p><p>⭐ 方法1： 内联在<code>webpack.config.js</code>中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// ⭐⭐⭐ 一定要去除node_modules，不对第三方包做兼容处理</span><br>        <span class="hljs-comment">// 否则会产生不可预计的后果。</span><br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-comment">// 开始对babel-loader进行配置，也可以用use &#123;loader: &#x27;babel-loader&#x27;, options:&#123;...&#125;&#125;</span><br>        options: &#123;<br>          presets: [<br>            [ <span class="hljs-comment">// 👈 注意这里又有一层数组，</span><br>              <span class="hljs-comment">//    所有babel预设和插件如果需要添加参数，写法是：[preset/plugin, optionsObject]</span><br>              <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>              <span class="hljs-comment">// 👇 @babel/preset-env.options</span><br>              &#123;<br>                modules: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 👈 该字段与tree-shaking相关</span><br>                <br>                useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span>, <span class="hljs-comment">// 👈 根据具体的浏览器运行环境，调整polyfill，按需加载。</span><br>                <br>                corejs: &#123;<br>                  version: <span class="hljs-number">3</span>,<br>                &#125;,<br>                <br>                targets: &#123;  <br>                  chrome: <span class="hljs-string">&quot;60&quot;</span>,<br>                  ie: <span class="hljs-string">&quot;9&quot;</span><br>                &#125;<br>             <span class="hljs-comment">// targets的类型可以是string | Array&lt;string&gt; | &#123; [string]: string &#125;</span><br>                <span class="hljs-comment">// 默认值是 &#123;&#125;，将所有的ES2015-ES2020转为ES5. 注: ES2015 = ES6</span><br>                targets: <span class="hljs-string">&#x27;&gt; 0.25%, not dead&#x27;</span>,<br>                targets: [<span class="hljs-string">&#x27;&gt; 0.25%&#x27;</span>, <span class="hljs-string">&#x27;not dead&#x27;</span>, <span class="hljs-string">&#x27;not op_mini all&#x27;</span>]<br>              &#125;<br>            ]<br>          ]<br>        &#125;<br>      &#125;,<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐ 方法2：<code>options</code>分离到<code>.babelrc</code>中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># .babelrc<br>&#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-string">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>        <span class="hljs-string">&quot;corejs&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-comment">// 数字或者字符串都可以，具体到版本号第一位即可</span><br>        &#125;,<br>        <span class="hljs-string">&quot;targets&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;60&quot;</span>, <span class="hljs-comment">// 数字或者字符串都可以，尽量写字符串</span><br>          <span class="hljs-string">&quot;ie&quot;</span>: <span class="hljs-string">&quot;9&quot;</span> <span class="hljs-comment">// 数字或者字符串都可以，尽量写字符串</span><br>        &#125;<br>      &#125;<br>    ]<br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: []<br>&#125;<br><span class="hljs-comment">// 以下是.babelrc最基本的结构</span><br>&#123;<br>  <span class="hljs-string">&quot;preset&quot;</span>: [],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: []<br>&#125;<br><span class="hljs-comment">//=======================================================================</span><br># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 👈 ⭐⭐ 一定要去除node_modules，不对第三方包做兼容处理</span><br>     loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br> ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>使用：</strong><code>@babel/preset-env</code>+ <code>@babel/plugin-transform-runtime</code>  + <code>@babel/runtime-corejs3</code></p><p><strong>使用方案二的好处：</strong></p><ol><li><p>同样可以根据<code>@babel/preset-env.options.targets</code>设定的目标兼容环境进行JS的转译。</p></li><li><p>新增的<code>api</code>都会从<code>runtime-corejs3</code>提供的统一命名空间中获取，<font color='red'>不会污染当前环境。</font></p><p>例如 IE9 不支持Promise，使用方案二后，在全局仍然不存在<code>window.Promise</code>。</p></li><li><p>方案一中每个模块中都会含有帮助转译语法的<code>helper</code>方法，不同的打包结果会含有重复的<code>helper</code>代码。</p><p>方案二会从<code>runtime-corejs3</code>提供的统一命名空间中获取<code>helpers</code>。</p></li></ol><blockquote><p>但使用方案二有时候打包的结果还是比方案一来的大。。不知道是为什么。。。</p><p>所以方案二的最大好处还是可以避免污染环境吧。。</p></blockquote><p><strong>使用步骤：</strong></p><ol><li><p>安装<code>babel-loader</code>、<code>@babel/core</code>、<code>@babel/preset-env</code>、<code>@babel/plugin-transform-runtime</code>、<code>@babel/runtime-corejs3</code>。</p><blockquote><p>@babel/runtime-corejs3包含了corejs3和@babel/runtime。</p></blockquote></li><li><p>配置<code>babel-loader</code>处理JS文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          presets: [<br>            [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>              modules: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 不允许将ES6模块化语法转译，和tree-shaking有关</span><br>              targets: <span class="hljs-string">&quot;ie&gt;=9&quot;</span>, <span class="hljs-comment">// 👈 声明需要兼容的环境</span><br>            &#125;]<br>          ],<br>          plugins: [<br>            [<span class="hljs-string">&#x27;@babel/plugin-transform-runtime&#x27;</span>, &#123;<br>              corejs: &#123;<br>                version: <span class="hljs-string">&quot;3&quot;</span>,<br>              &#125;<br>            &#125;],<br>          ]<br>        &#125;,<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="开启babel缓存"><a href="#开启babel缓存" class="headerlink" title="开启babel缓存"></a>开启babel缓存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          cacheDirectory: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 👈 构建时会读取上一次的缓存</span><br>          <span class="hljs-comment">//.....</span><br>        &#125;,<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对Webpack5的特殊处理"><a href="#对Webpack5的特殊处理" class="headerlink" title="对Webpack5的特殊处理"></a>对Webpack5的特殊处理</h3><p>由于webpack5在打包后的JS代码由一个箭头函数包裹，所以在不支持ES6的浏览器中运行不了webpack5打包的结果。</p><p>因此，如果是用webpack5构建项目，在上述的配置的基础上，需要多增加一条配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 👇 </span><br>  target: [<span class="hljs-string">&#x27;web&#x27;</span>, <span class="hljs-string">&#x27;es5&#x27;</span>],<br>&#125;<br></code></pre></td></tr></table></figure><p>增加该条配置后，最外层的箭头函数就会变为普通函数。</p><h2 id="配置ESlint和airbnb语法规范"><a href="#配置ESlint和airbnb语法规范" class="headerlink" title="配置ESlint和airbnb语法规范"></a>配置ESlint和airbnb语法规范</h2><p><strong>1. 首先安装<code>eslint</code>、<code>eslint-loader</code>、<code>eslint-config-airbnb-base</code>、<code>eslint-plugin-import</code></strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm i eslint eslint-loader eslint-<span class="hljs-built_in">config</span>-airbnb-base eslint-plugin-<span class="hljs-keyword">import</span> -D<br></code></pre></td></tr></table></figure><p><strong>2. 在<code>webpack.config.js</code>中配置<code>eslint-loader</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;eslint-loader&#x27;</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// ⭐⭐ 不对node_modules目录下的第三方模块作检查</span><br>        enforce: <span class="hljs-string">&#x27;pre&#x27;</span>, <span class="hljs-comment">// ⭐⭐ 强制该eslint-loader最先执行 </span><br>        options: &#123;<br>          fix: <span class="hljs-literal">true</span> <span class="hljs-comment">// 通知eslint自动修改开发源码中错误的语法</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 配置<code>eslintConfig</code>，有两种方法：</strong></p><p>⭐方法1：内联在<code>package.json</code>中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-attr">&quot;eslintConfig&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;extends&quot;</span>: <span class="hljs-string">&quot;airbnb-base&quot;</span>, <span class="hljs-comment">// 继承airbnb-base的规则</span><br>    <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;browser&quot;</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 按浏览器环境语法进行检查，允许存在window等全局对象</span><br>    &#125;,<br>    <span class="hljs-comment">// 👇 还可以覆盖掉airbnb-base中一些检查规则</span><br>    <span class="hljs-attr">&quot;rules&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>, <span class="hljs-comment">// 允许出现console.log等</span><br>      <span class="hljs-attr">&quot;no-alert&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>, <span class="hljs-comment">// 允许出现alert()</span><br>      <span class="hljs-attr">&quot;linebreak-style&quot;</span>: <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-comment">// 不检查换行符是LF还是CRLF</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⭐方法2：分离到工程目录下的<code>.eslintrc</code>文件中，<code>eslint</code>会自动读取该文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"># .eslintrc<br>&#123;<br>  <span class="hljs-attr">&quot;extends&quot;</span>: <span class="hljs-string">&quot;airbnb-base&quot;</span>,<br>  <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;browser&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;rules&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>    <span class="hljs-attr">&quot;no-alert&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>    <span class="hljs-attr">&quot;linebreak-style&quot;</span>: <span class="hljs-string">&quot;off&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. VSCode中安装ESlint扩展， 同时在项目目录下新增<code>.eslintignore</code>文件</strong></p><blockquote><p>该步骤为可选，目的是让扩展插件帮我们及时检查出代码书写不规范的地方，避免编译时再报错修改。</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># .eslintignore</span><br><span class="hljs-comment"># 在允许vscode读取工程目录下的eslint配置文件时，</span><br><span class="hljs-comment"># ESlint扩展会根据.eslintrc中配置的规则对工程目录下的文件进行检查，</span><br><span class="hljs-comment"># 同时跳过.eslintignore指定的文件区域</span><br><br><span class="hljs-regexp">/dist/</span><br><span class="hljs-regexp">/node_modules/</span><br></code></pre></td></tr></table></figure><h2 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h2><h3 id="压缩JS"><a href="#压缩JS" class="headerlink" title="压缩JS"></a>压缩JS</h3><p>在Webpack4及其以上版本中，在<code>production</code>模式下，Webpack会自动将打包后的JS代码进行压缩。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h3><p>在生产环境下，webpack会自动压缩js，但不会压缩css资源。</p><p>所以我们要使用<code>optimize-css-assets-webpack-plugin</code>插件来帮助压缩css代码。</p><p><strong>1. 首先安装插件</strong></p><p><code>npm install optimize-css-assets-webpack-plugin</code></p><p><strong>2. 使用插件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(), <span class="hljs-comment">// 在这里使用插件即可</span><br>  ],<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 生产环境使用 （开发环境下也可以使用，配置即可）</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="压缩HTML"><a href="#压缩HTML" class="headerlink" title="压缩HTML"></a>压缩HTML</h3><p>在<strong>Webpack5</strong>中，在<code>production</code>模式下，Webpack会压缩编译后的HTML文件（清除空白字符+注释）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而在<strong>Webpack4</strong>中，Webpack是不会自动打包HTML的，需要用到打包时用到的插件<code>html-webpack-plugin</code>。</p><p>也就是要对打包HTML的插件进行配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      template: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>,<br>      <span class="hljs-comment">//⭐ 配置 minify参数</span><br>      minify: &#123;<br>        collapseWhitespace: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 压缩空白字符</span><br>        removeComments: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 清除注释</span><br>      &#125;<br>    &#125;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>压缩图片后，图片的质量会下降。</p><p><strong>使用loader：</strong><code>image-webpack-loader</code></p><p><strong>1. 首先安装loader</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm install <span class="hljs-built_in">image</span>-webpack-loader -D<br></code></pre></td></tr></table></figure><blockquote><p>❗ 注意：这个包下的会有点慢</p></blockquote><p><strong>2. 对图片使用loader</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">// 分离出image-webpack-loader的配置</span><br><span class="hljs-comment">// 以下为官方实例的配置 https://www.npmjs.com/package/image-webpack-loader</span><br><span class="hljs-keyword">const</span> imageWebpackLoaderOptions = &#123;<br>  mozjpeg: &#123;<br>    progressive: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-comment">// optipng.enabled: false will disable optipng</span><br>  optipng: &#123;<br>    enabled: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  pngquant: &#123;<br>    quality: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.90</span>],<br>    speed: <span class="hljs-number">4</span><br>  &#125;,<br>  gifsicle: &#123;<br>    interlaced: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  <span class="hljs-comment">// the webp option will enable WEBP</span><br>  webp: &#123;<br>    quality: <span class="hljs-number">75</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>          <span class="hljs-comment">// 👇 使用该loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>,<br>            options: imageWebpackLoaderOptions<br>          &#125;,<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Webpack高级功能"><a href="#Webpack高级功能" class="headerlink" title="Webpack高级功能"></a>Webpack高级功能</h1><h2 id="devServer-⭐"><a href="#devServer-⭐" class="headerlink" title="devServer ⭐"></a>devServer ⭐</h2><h3 id="开启devServer"><a href="#开启devServer" class="headerlink" title="开启devServer"></a>开启devServer</h3><p>配置本地开发服务器，原理是将打包的结果保存到内存中。</p><ol><li><p>首先安装<code>npm i webpack-dev-server -D</code></p></li><li><p>在<code>webpack.config.js</code>中配置<code>devServer</code>字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  devServer: &#123;<br>    <span class="hljs-comment">//👇 此条是配置devServer服务器根目录，这里定位到打包后的dist，要使用绝对路径。</span><br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-comment">// 以下内容为可选</span><br>    compress: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 一切资源使用gzip压缩</span><br>    port: <span class="hljs-number">8080</span>, <span class="hljs-comment">// 端口号</span><br>    open: <span class="hljs-literal">true</span> <span class="hljs-comment">// 启动服务后自动打开浏览器访问，配置后就不需要在运行devServer时输入--open参数</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中配置<code>scripts</code>脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">/*....*/</span><br> <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span>,<span class="hljs-comment">/* 如果配置了open为true，就不需要--open */</span><br>    <span class="hljs-comment">/* &quot;start&quot;: &quot;webpack serve --open&quot;  👈 webpack5 中的命令脚本 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>❗❗ <strong>注意</strong>：在<code> webpack5</code> 中，运行<code>webpack-dev-server</code>的命令发生了变化，需要用<code>webpack serve</code>代替原来的<code>webpack-dev-server</code>命令。</p></blockquote></li></ol><h3 id="proxy-代理"><a href="#proxy-代理" class="headerlink" title="proxy 代理"></a>proxy 代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port: <span class="hljs-number">8080</span>,<br>    compress: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 转发写法：</span><br>    proxy: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: <span class="hljs-string">&#x27;http://127.0.0.1:5000&#x27;</span>, <span class="hljs-comment">// 如果path部分以/api开头，将请求转发到本地的5000端口。</span><br>    &#125;,<br>    <span class="hljs-comment">// 重写写法：</span><br>    proxy: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        target: <span class="hljs-string">&#x27;http://127.0.0.1:5000&#x27;</span>,<br>        pathRewrite: &#123;<br>          <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 👈 将开头的api去除</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟接口"><a href="#模拟接口" class="headerlink" title="模拟接口"></a>模拟接口</h3><p>使用devServer中的before钩子来为内置的express服务器添加路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> mockUsers = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>&#125;,<br>]<br><span class="hljs-keyword">const</span> mockObj = &#123;<br>  foo: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port: <span class="hljs-number">8080</span>,<br>    compress: <span class="hljs-literal">true</span>,<br><span class="hljs-function"><span class="hljs-title">before</span>(<span class="hljs-params">app</span>)</span> &#123;<br>      app.get(<span class="hljs-string">&#x27;/api/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.redirect(<span class="hljs-string">&#x27;/&#x27;</span>));<br>      <span class="hljs-comment">// 在这里就可以在一些路由中返回mock数据。</span><br>      app.get(<span class="hljs-string">&#x27;/api/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.json(mockUsers));<br>      app.get(<span class="hljs-string">&#x27;/api/obj&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.end(<span class="hljs-built_in">JSON</span>.stringify(mockObj)));<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>webpack-dev-server实际是一个基于Express框架的服务器，before钩子函数会在服务器启动前执行。</p><p>可以在before钩子中扩展devServer服务器的功能。</p></blockquote><h2 id="one-of"><a href="#one-of" class="headerlink" title="one-of"></a>one-of</h2><p>webpack对各个模块的文件名进行模式匹配时，会将每个文件与module.rules中设置的每条规则进行匹配，这在某些情况下是多余的。比如说css文件只会交由一组loader处理（style-loader, css-loader），而不会交给babel-loader处理，所以有些模式匹配是多余的。</p><p>所以webpack提供了one-of功能，对于某些类型文件，只匹配某一条规则，即只交由一组loader处理，匹配成功后就不再与剩余的模式进行匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>                loader: <span class="hljs-string">&#x27;eslint-loader&#x27;</span>,<br>                enforce: <span class="hljs-string">&#x27;pre&#x27;</span><br>            &#125;,<br>            <br>            one-<span class="hljs-keyword">of</span>: [<br>            &#123;<br>            test: <span class="hljs-regexp">/\.css$/</span>,<br>            use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>        &#125;, &#123;<br>    test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>    use: <span class="hljs-string">&#x27;url-loader&#x27;</span><br>&#125;,&#123;<br>    test: <span class="hljs-regexp">/\.js$/</span>,<br>    exclude: <span class="hljs-regexp">/node_modules/</span>,<br>    loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>&#125;<br><span class="hljs-comment">//....</span><br>            ]<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>开启webpack的watch功能，可以在代码修改时自动重新编译</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  watch: <span class="hljs-literal">true</span>,<br>  watchOptions: &#123;<br>    ignored: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 不需要监听的内容，支持正则</span><br>    aggregate: <span class="hljs-number">300</span>, <span class="hljs-comment">// 节流时间，开始重新编译后，300ms内不再重新编译</span><br>    poll: <span class="hljs-number">10</span>, <span class="hljs-comment">// watch是通过不断询问文件指针来判断是否要重新编译的，poll为1秒内询问的次数</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>webpack配置中如果配置了<code>context</code>字段，则配置对象内的所有相对路径都是基于<code>context</code>的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  context: __dirname, <span class="hljs-comment">// 默认就是工程项目目录</span><br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  ouput: &#123;<br>    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    path: <span class="hljs-string">&#x27;./dist&#x27;</span>, <span class="hljs-comment">// 这里不再使用绝对路径</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="devtool-“source-map”-⭐"><a href="#devtool-“source-map”-⭐" class="headerlink" title="devtool: “source-map” ⭐"></a>devtool: “source-map” ⭐</h2><p>SourceMap是一种提供源代码到构建后代码映射的技术，如果构建后源代码出错了，通过映射可以追踪到源代码错误。在浏览器中运行Webpack打包后的JS和CSS，如果存在问题，可以通过SourceMap找到打包前出错的位置。</p><h3 id="关键字解析"><a href="#关键字解析" class="headerlink" title="关键字解析"></a>关键字解析</h3><p>在<code>webpack.config.js</code>的<code>devtool</code>属性中可以配置SourceMap选项，可选的值有：</p><p><code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p><p><strong>不添加关键字</strong></p><ul><li><p><code>source-map</code></p><p><font color='cornflowerblue'>作用</font>：构建项目代码时，为每个chunk打包的结果和css文件生成一个map文件。</p><p><font color='cornflowerblue'>效果</font>：可以追踪到错误发生在哪个源代码文件的哪一行哪一列。</p></li></ul><p><strong>解释第一组关键字</strong></p><blockquote><p>❗ 以下关键字不能互相组合，但是能够后面两组关键字组合。</p></blockquote><ul><li><p><code>inline</code></p><p><font color='cornflowerblue'>作用</font>：让source-map映射信息内联到构建后的文件中，不单独形成一个文件。</p><p><font color='cornflowerblue'>效果</font>：映射信息内联，比<code>source-map</code>编译速度快，但因为内联，最终打包后的文件体积大。</p></li><li><p><code>eval</code></p><p><font color='cornflowerblue'>作用</font>：使用eval函数包裹构建后的代码和映射信息，同时每一个模块的映射信息写在自己的代码块中。</p><p><font color='cornflowerblue'>效果</font>：映射信息内联，速度比<code>inline-source-map</code>还快。</p></li><li><p><code>hidden</code></p><p><font color='cornflowerblue'>作用</font>：映射信息单独成立一个文件，不再映射到源代码，而是映射到webpack构建后的代码。</p><p><font color='cornflowerblue'>效果</font>：如果代码出错，能够反映错误发生在构建后的代码中的位置。</p><blockquote><p>hidden-source-map不再显示开发源代码目录的内容，只显示dist中的内容。一般只在生产环境下使用，映射到的是webpack转换、压缩后的代码。由于是映射到构建后的代码，生产环境下相当于没有提供任何与源代码有关的信息。</p></blockquote></li></ul><p><strong>解释第二组关键字</strong></p><blockquote><p>nosources关键字可以和其他两组关键字组合。</p></blockquote><ul><li><p><code>nosources</code></p><p><font color='cornflowerblue'>作用</font>：不再显示任何源代码。</p><p><font color='cornflowerblue'>效果</font>：构建代码发生的错误，只能定位错误发生在源代码中的位置，但看不到相应代码内容。<font color='red'>会向客户端暴露源代码目录结构。</font></p><p><font color='red'>注意</font>：一般不和<code>hidden</code>结合使用。</p></li></ul><p><strong>解释第三组关键字</strong></p><blockquote><p>以下关键字可以和前两组中的关键字组合。</p></blockquote><ul><li><p><code>cheap</code></p><p><font color='cornflowerblue'>作用</font>：简化<code>source-map</code>的行为，生成map文件，但不再包含<code>loader</code>的source-map，不再计算列号。</p><p><font color='cornflowerblue'>效果</font>：只能追踪到<code>loader</code>处理后的中间代码的位置，同时不能精确到列，但比<code>source-map</code>编译更快。</p></li><li><p><code>cheap-module</code></p><p>作用：在<code>cheap-source-map</code>和<code>source-map</code>之间折衷，囊括<code>loader</code>的source-map，但也不计算列号。</p><p>效果：能追踪到源代码位置，但同样不能精确到列。生成的map文件比<code>cheap-source-map</code>大。</p></li></ul><h3 id="开发环境-devtool配置"><a href="#开发环境-devtool配置" class="headerlink" title="开发环境 devtool配置"></a>开发环境 devtool配置</h3><p>对开发环境的代码进行调试时，要考虑<strong>编译的速度</strong>和<strong>调试友好程度</strong>。</p><blockquote><p>调试友好程度无非就是能否准确定位到错误在源代码中的位置。    </p><p>由于内联模式编译速度快于非内联，所以开发环境只考虑内联模式。</p></blockquote><p><strong>按编译速度排名：</strong></p><ol><li><code>eval-cheap-source-map</code></li><li><code>eval-cheap-module-source-map</code>和<code>eval-source-map</code></li><li><code>cheap-source-map</code></li></ol><p><strong>按调试友好程度排名</strong></p><ol><li><code>eval-source-map</code> 和 <code>inline-source-map</code> 精确到某文件中的某行某列</li><li><code>[inline-|eval-]cheap-module-source-map</code> 精确到某文件中的某行</li></ol><p><strong>综上所述：</strong></p><p>一般开发环境推荐使用<code>eval-source-map</code>或<code>eval-cheap-module-source-map</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devtool: <span class="hljs-string">&#x27;eval-source-map&#x27;</span> <span class="hljs-comment">// 在vue和react脚手架中，开发环境默认使用的是eval-source-map</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生产环境-devtool配置"><a href="#生产环境-devtool配置" class="headerlink" title="生产环境 devtool配置"></a>生产环境 devtool配置</h3><p>对生产环境的代码进行调试时，要考虑<strong>是否隐藏源代码</strong>和<strong>调试友好程度</strong>。</p><blockquote><p>SourceMapingURL如果内联会导致单个文件体积过大，所以生产环境不考虑SourceMap内联模式。</p></blockquote><p><strong>按照调试友好程度排名</strong></p><ol><li><code>source-map</code> 会暴露源码</li><li><code>cheap-module-source-map</code> 会暴露源码</li><li><code>nosources-source-map</code> 👈 能够定位错误发生在源代码中的位置，但无法在浏览器中看到源码</li></ol><p><strong>按对源码的保护程度排名</strong></p><ol><li><p><code>不使用SourceMap，即不配置devtool</code></p></li><li><p><code>hidden-source-map</code></p></li><li><p><code>nosources-source-map</code> </p></li></ol><p><strong>综上所述：</strong></p><p>如果既要保护源代码，又要能够定位到错误发生在源代码中的位置：</p><p>​    方法1 使用<code>nosources-source-map</code>。</p><p>​    方法2 使用<code>source-map</code>打包后，上线时规定不允许前端加载map文件。</p><p>如果不需要保护源代码，可以使用<code>source-map</code>。</p><p>如果不需要进行生产环境下的调试，则不需要配置<code>devtool</code>。</p><h3 id="官方指南"><a href="#官方指南" class="headerlink" title="官方指南"></a>官方指南</h3><p><a href="http://doc.codingdict.com/webpack-cn-doc/configuration/devtool/">http://doc.codingdict.com/webpack-cn-doc/configuration/devtool/</a></p><h2 id="resolve-解析查找模块和包-⭐"><a href="#resolve-解析查找模块和包-⭐" class="headerlink" title="resolve 解析查找模块和包 ⭐"></a>resolve 解析查找模块和包 ⭐</h2><p><strong>webpack.config.js中可以配置resolve字段帮助我们优化对文件模块解析查找的过程。</strong></p><h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p><code>resolove.extensions</code>中包含的扩展名可以在使用<code>require</code>和<code>import</code>语句时省略，webpack会依次尝试添加扩展名进行匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>  &#125;, <br>&#125;<br><span class="hljs-comment">//============================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>); <span class="hljs-comment">// 省略 &quot;.js&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><code>resolve.alias</code>可以定义路径别名。</p><p>如果在<code>require</code>和<code>import</code>加载的路径中使用别名，真正的路径是将<font color='red'>别名</font>和<font color='red'>被别名分割的字符串</font>传入到<code>path.join</code>方法得到的结果。</p><p>如果使用别名没有匹配到，那么会将别名作为真名再去匹配一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>    alias: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>      <span class="hljs-string">&#x27;@components&#x27;</span>: resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;component&#x27;</span>),<br>    &#125;<br>  &#125;, <br>&#125;<br><span class="hljs-comment">//============================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> indexJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/foo&#x27;</span>); <br><br></code></pre></td></tr></table></figure><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>对于在文件模块依赖的包（如vue，jquery），webpack会按照Node.js的规则一路向上查找<code>node_modules</code>目录。</p><p>而<code>resolve.modules</code>提供了一种方式让webpack去指定的目录中查找模块所依赖的包。</p><p>这样做有两个好处：① 减少搜索的目录，提高查询速度 ，② 可以自定义添加查询目录。</p><blockquote><p>❗ 但是需要注意的是，到自定义的查询目录去查找包时，仍旧按照Node.js规范去加载包的入口模块。</p><p>换句话说，本地开发目录下，要先将自定义的包按照Node.js的规范整理好，然后将包的文件夹放在自定义查询目录下。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 目录结构<br>.<br>|  src<br>|  |  modules<br>|  |  |  bar<br>|  |  |  |--index.js<br>|  |--main.js<br>|--webpack.config.js<br><br><span class="hljs-comment">// =======================================================================</span><br><br># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    <span class="hljs-comment">/* 设置搜寻目录为工程目录下的node_modules以及src目录下的modules，</span><br><span class="hljs-comment">    *  该目录存放自定义的包。</span><br><span class="hljs-comment">    */</span><br>    modules: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;src/modules&#x27;</span>], <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ======================================================================</span><br><br># .src/main.js<br><span class="hljs-comment">// 假设此时在src/modules目录下存在自定义的包bar，以文件夹形式存储，其中含有index.js文件</span><br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 如果node_modules下不存在bar包，则回到src/modules加载bar</span><br><br></code></pre></td></tr></table></figure><h3 id="mainFileds"><a href="#mainFileds" class="headerlink" title="mainFileds"></a>mainFileds</h3><p>默认情况下，在导入一个包时，会查找该包目录下<code>package.json</code>的<code>main</code>字段标记的路径作为入口模块的路径。</p><p>但是这个入口字段是可以配置的，不一定非要是<code>main</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.configs.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    mainFields: [<span class="hljs-string">&#x27;my-entry&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-comment">// 先看my-entry，再看main</span><br>    <span class="hljs-comment">// 配置 target === web 或者 target ==== webworker时，mainFields的值：</span><br>    mainFields: [<span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>    <span class="hljs-comment">// target的值为其他时，mainfields默认值为：</span><br>    mainFields: [<span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mainFiles"><a href="#mainFiles" class="headerlink" title="mainFiles"></a>mainFiles</h3><p>当一个包的主目录下没有<code>package.json</code>文件，或<code>package.json</code>没有指示入口文件时，默认入口为包的主目录下的<code>index.js</code>文件，其实这个也是可以配置的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.configs.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    mainFiles: [<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;entry&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span> ],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="resolveLoader-解析查找loader"><a href="#resolveLoader-解析查找loader" class="headerlink" title="resolveLoader 解析查找loader"></a>resolveLoader 解析查找loader</h2><p><code>resolve</code>是用来指定如何解析查找模块和包，而<code>resolveLoader</code>用于指定如何查找loader。</p><p>这个字段的配置与<code>resolve</code>配置类似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;my-loader&#x27;</span>, <span class="hljs-comment">// 👈 自定义loader</span><br>      &#125;<br>    ]<br>  &#125;<br>  <span class="hljs-comment">//👇  配置loader如何查找</span><br>  resolveLoader: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>],<br>    modules: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;loaders&#x27;</span>, <span class="hljs-string">&#x27;src/loaders&#x27;</span>],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="module-noParse"><a href="#module-noParse" class="headerlink" title="module.noParse"></a>module.noParse</h2><p><code>module.noParse</code>字段可以用于配置哪些模块文件的内容不需要解析依赖。</p><p>一些第三方库比较独立，不依赖于别的模块，所以我们可以通过<code>module.noParse</code>告诉webpack不去解析这些模块的依赖，从而一定程度上<font color='red'>提高构建速度</font>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [],<br>    <span class="hljs-comment">// 👇 使用正则表达式</span><br>    noParse: <span class="hljs-regexp">/jquery|lodash/</span>,<br>    <span class="hljs-comment">// 👇 或者改用函数</span><br>    <span class="hljs-function"><span class="hljs-title">noParse</span>(<span class="hljs-params">id</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/jquery|lodash/</span>.test(id);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stats-日志优化"><a href="#stats-日志优化" class="headerlink" title="stats 日志优化"></a>stats 日志优化</h2><p>webpack编译时，控制台日志太多或太少都不美观。通过配置<code>stats</code>字段可以优化日志的输出。</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>&quot;normal&quot;</code></td><td>默认值，标准输出</td></tr><tr><td><code>&quot;none&quot;</code></td><td>没有日志输出</td></tr><tr><td><code>&quot;errors-only&quot;</code></td><td>只有发生错误时输出</td></tr><tr><td><code>&quot;minimal&quot;</code></td><td>发生错误或有新的编译内容时输出</td></tr><tr><td><code>&quot;verbose&quot;</code></td><td>全部输出</td></tr></tbody></table><h2 id="tree-shaking-⭐"><a href="#tree-shaking-⭐" class="headerlink" title="tree-shaking ⭐"></a>tree-shaking ⭐</h2><p>当 Javascript 项目达到一定体积时，将代码分成模块会更易于管理。但是当这样做时，我们最终可能会导入实际上未使用的代码(<code>dead code</code>)。Tree Shaking 是一种通过消除最终文件中未使用的代码来优化体积的方法。</p><h3 id="依赖于ES6模块化"><a href="#依赖于ES6模块化" class="headerlink" title="依赖于ES6模块化"></a>依赖于ES6模块化</h3><p>Tree-shaking主要依赖于<code>ES6的模块化import和export</code>。</p><p>我们都知道ES6的module只能是在模块顶部出现，和运行时无关，不能运行时加载，Tree-shaking主要就是依靠这个基础进行静态分析，不执行代码就能对模块依赖关系进行判定。</p><p>而<code>commonJS模块化规范</code>支持动态导入，需要执行模块代码后才知道有没有运行某个<code>require</code>语句。CommonJS 模块的这种 <code>dynamic</code> 性质意味着无法 Tree Shaking，因为在实际运行代码之前无法确定需要哪些模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myDynamicModule;<br><br><span class="hljs-keyword">if</span> (condition) &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure><p>在 ES6 中，引入了模块的新语法，这是 <code>static</code> 的。使用<code>import</code>语法，我们不再能够动态导入模块。</p><p>如下所示的代码是不被允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相反，我们必须在任何条件之外定义全局范围内的所有导入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br><br><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-comment">// do stuff with foo</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// do stuff with bar</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关闭babel的模块化转译"><a href="#关闭babel的模块化转译" class="headerlink" title="关闭babel的模块化转译"></a>关闭babel的模块化转译</h3><p>先要了解，Tree Shaking 实现的前提，是基于 「必须用 ES Modules 组织代码」。</p><p>即交给webpack处理的代码，必须使用 <code>ES6 modules</code>方式实现模块化。</p><blockquote><p>MDN：Tree shaking 依赖于ES6中的import和export语句，用来检测代码模块是否被导出、导入，且被Javascript文件使用。</p></blockquote><p>webpack优化的过程是先将代码交给loader去处理，然后再将处理结果优化输出。</p><p>而为了转换代码中的 ECMAScript 新特性，一般会选择<code>babel-loader</code>去处理JS。</p><p><font color='red'>而在<code>babel-loader</code>处理代码时，就有可能将代码中的 <code>ES6 modules</code> 转换为 <code>CommonJS</code>。</font></p><blockquote><p>PS：实际上这取决于是否使用了转换ESM的babel插件，而常用的插件集合 @babel/preset-env 就包含转换ESM的插件。</p></blockquote><p><font color='red'>所以当 @babel/preset-env 工作时，代码中的 ESM 就应该被转换为 CommonJS。</font></p><p>因此webpack在打包时，拿到的就是 CommonJS 组织的代码，从而 Tree Shaking 也就不能生效。</font></p><p><strong>但是现在的效果并不是这样。</strong></p><p>在项目中使用babel-loader，并仅开启usedExports，查看打包结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;none&#x27;</span>,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>          options: &#123;<br>            presets: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>],<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;<br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">/* harmony export (binding) */</span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> Button; &#125;);<br>  <br><span class="hljs-comment">// usedExports 生效了，也就是Tree Shaking 生效了</span><br>  <br><span class="hljs-comment">/* unused harmony export Link */</span><br><span class="hljs-comment">/* unused harmony export Heading */</span><br>  <br><span class="hljs-keyword">var</span> Button = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;dead-code&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> Link = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Link</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> Heading = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Heading</span>(<span class="hljs-params">level</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h&#x27;</span> + level);<br>&#125;;<br><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>发现 usedExports 生效了，也就表示 Tree Shaking 并没有失效。</p><p><strong>这是因为在最新版本的 babel-loader 中自动关闭了 转换ESM 的插件。</strong></p><hr><p>可以通过修改插件集合的配置，开启 ESM 转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>: &#123;<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>  <br>  &#125;,<br>  rules: [<br>    &#123;<br>      test: <span class="hljs-regexp">/\.js$/</span>,<br>      use: &#123;<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          <span class="hljs-comment">// 注意：仅使用时，是将插件集合名称放到一个数组中</span><br>          <span class="hljs-comment">// presets: [&#x27;@babel/preset-env&#x27;],</span><br><br>          <span class="hljs-comment">// 当对插件集合编写配置时，就需要再套一个数组</span><br>          <span class="hljs-comment">// 数组的第一个元素是插件集合的名称</span><br>          <span class="hljs-comment">// 第二个元素是它的配置对象</span><br>          presets: [<br>            [<br>              <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>              &#123;<br>                <span class="hljs-comment">// modules默认是auto，即根据环境去判断是否开启转换ESM插件</span><br>                <span class="hljs-comment">// 这里设置为强制转换为commonjs</span><br>                modules: <span class="hljs-string">&#x27;commonjs&#x27;</span>,<br>              &#125;,<br>            ],<br>          ],<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>再次打包查看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, __webpack_require__</span>) </span>&#123;<br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;<br>  value: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-built_in">exports</span>.Heading = <span class="hljs-built_in">exports</span>.Link = <span class="hljs-built_in">exports</span>.Button = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> Button = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;dead-code&#x27;</span>);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Button = Button;<br><br><span class="hljs-keyword">var</span> Link = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Link</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Link = Link;<br><br><span class="hljs-keyword">var</span> Heading = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Heading</span>(<span class="hljs-params">level</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h&#x27;</span> + level);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Heading = Heading;<br><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>3个成员都被导出，从而压缩优化时，也不会将它们删除。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>通过以上实验发现，最新版本的babel-loader，并不会导致Tree Shaking失效。即不需要配置<code>modules</code>，默认为<code>auto</code>。</p></li><li><p>如果还不确定，也可以尝试将<code>@babel/preset-env</code>配置中的<code>modules</code>，设置为<code>false</code>。这样就会确保，preset-env不会开启 转换ESM 的插件。同时确保了Tree Shaking工作的前提。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          presets: [<br>            [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>              <span class="hljs-comment">// 👇 标记不允许将ES6转换为commonjs，最新版本的babel-loader不需要配置该项</span><br>              modules: <span class="hljs-literal">false</span>, <br>              useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span>,<br>              corejs: &#123;<br>              version: <span class="hljs-number">3</span>,<br>            &#125;,<br>              targets: <span class="hljs-string">&#x27;&gt; 0.25%&#x27;</span>,<br>            &#125;],<br>          ]<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="模块的副作用"><a href="#模块的副作用" class="headerlink" title="模块的副作用"></a>模块的副作用</h3><p>副作用是：有一些代码，是在 <code>import</code> 时执行了一些行为，这些行为不一定和任何导出相关。</p><p>简单来说，如果模块仅仅在导入后就会对全局、外部环境产生影响，那么它就属于具有副作用的模块。</p><p>例如 <code>polyfill</code> ，Polyfills 通常是在项目中向全局注入新的内容，而不是在导入后调用。</p><h3 id="开启tree-shaking"><a href="#开启tree-shaking" class="headerlink" title="开启tree-shaking"></a>开启tree-shaking</h3><h4 id="生产模式下自动开启"><a href="#生产模式下自动开启" class="headerlink" title="生产模式下自动开启"></a>生产模式下自动开启</h4><p>将webpack的<code>mode</code>设置为<code>production</code>，将自动开启tree-shaking，<font color='red'>但要考虑模块的副作用问题。</font></p><ul><li><p>在<code>package.json</code>中全局标记或在<code>module.rules</code>中对每种规则的文件标记是否有副作用<code>sideEffects</code>。</p><p>如果确定全部文件没有副作用，则在<code>package.json</code>设置<code>&quot;sideEffect&quot;: false</code>，项目内所有引用的文件都会被<code>tree-shaking</code>；</p><p>如果某些文件会存在副作用，则在<code>package.json</code>中标明哪些文件存在副作用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;./src/some-side-effectful-file.js&quot;</span>, <span class="hljs-string">&quot;*.css&quot;</span>] <span class="hljs-comment">//👈 一般css文件都有副作用 </span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果某些规则的文件会存在副作用，比如css文件，则在<code>module.rules</code>中标记<code>sideEffects: true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCSSExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>        ],<br>        sideEffects: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 👈 标记存在副作用，优先级高于package.json中的sideEffects</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="开发模式下手动开启"><a href="#开发模式下手动开启" class="headerlink" title="开发模式下手动开启"></a>开发模式下手动开启</h4><blockquote><p>Tree Shaking并不是 webpack 的某个配置选项。它是一组功能搭配使用后的优化效果。这组功能会在生产模式production下自动使用。</p></blockquote><p>在开发模式下<code>mode: &#39;development&#39;</code>，通过配置optimization中的<code>usedExports</code>、<code>minimize</code>以及<code>minimizer</code>，能够模仿Tree Shaking的开启。</p><p><code>usedExports: true</code> 表示在输出结果中模块只导出外部使用了的成员。</p><p>打包查看输出文件：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210222182858889.png" alt="image-20210222182858889"></p><p>此时就可以通过压缩优化，删除掉「没有用到的代码」。</p><p><code>minimize: true</code>： 表示要删除被标记为<code>unused</code>的代码块。</p><p>删除注释、删除没有用到的代码、删除空白、替换变量名为简短的名称等。</p><blockquote><p>它默认使用的是TerserPlugin， 除非在optimization .minimizer中指定使用哪个插件。</p></blockquote><p>再次打包：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210222183217915.png" alt="image-20210222183217915"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>,<br>    minimize: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 以下为可选</span><br>    minimizer: [....]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="正确编写可以tree-shaking的模块"><a href="#正确编写可以tree-shaking的模块" class="headerlink" title="正确编写可以tree-shaking的模块"></a>正确编写可以tree-shaking的模块</h3><ol><li>使用<code>ES6 modules</code>进行导出和导入。</li><li>第三方内容按需加载。</li><li>避免在模块顶层作用域写具有副作用的代码。</li><li>如果某个模块具有副作用，导入该模块又没有访问该模块的内容，则必须注明该模块有副作用。</li></ol><h2 id="Scope-Hoisting-作用域提升"><a href="#Scope-Hoisting-作用域提升" class="headerlink" title="Scope Hoisting 作用域提升"></a>Scope Hoisting 作用域提升</h2><p>Scope Hoisting可以让webpack打包出来的代码文件更小、运行的更快，是Webpack3新推出的功能。</p><p>开发环境下，webpack会对转换后的模块包裹上一层函数，这样的弊端在于：</p><ul><li>大量的函数声明语句增大了代码量。 </li><li>运行时嵌套的函数作用域变多，内存开销变大。</li></ul><p>Scope Hoisting功能会将所有的模块按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止命名冲突。</p><p><strong>如何开启？</strong></p><p>这个功能在<code>mode: &#39;production&#39;</code>下默认开启。</p><p>而开发环境要用到<code>wepack.optimize.ModuleConcatenationPlugin</code>插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    <span class="hljs-comment">// 针对nom中的第三方模块优先采用 jsnext:main中指向的ES6模块化语法的插件</span><br>    mainFields: [<span class="hljs-string">&#x27;jsnext:main&#x27;</span>, <span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 开启 Scope Hoisting</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h2><p><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">官方文档链接</a></p><p>简单的来说splitChunks就是Webpack中一个提取或分离代码的插件，<strong>主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件。</strong></p><p>提到前端优化，提取公共代码是必不可少的手段。在Webpack出现前，提取公共代码是人为去处理，而SplitChunks插件的作用就是通过配置让Webpack去帮你提取公共代码。Webpack创始人的初衷也是希望能有更多时间写更多代码，所以这种纯体力的劳动交给Webpack去完成。</p><h3 id="基本配置项"><a href="#基本配置项" class="headerlink" title="基本配置项"></a>基本配置项</h3><ul><li><p><code>chunks</code>选项，决定要提取那些模块。</p></li><li><ul><li><p>默认是<code>async</code>：将每个异步模块提取成一个chunk，再提取不同异步模块的相同依赖，并打包到一个新的chunk中。</p></li><li><blockquote><p>异步加载的模块：通过<code>import(&#39;xxx&#39;)</code>或<code>require([&#39;xxx&#39;],() =&gt;&#123;&#125;)</code>加载的模块。</p></blockquote></li></ul></li><li><ul><li><p><code>initial</code>：从每个入口进行深度遍历，将一个入口依赖的所有同步模块生成一个initial chunk，然后对不同的initial chunk的相同依赖进行提取并打包到新的chunk中。（每个异步模块也会打包成单独chunk。）</p></li><li><blockquote><p>同步加载的模块：通过 <code>import xxx</code>或<code>require(&#39;xxx&#39;)</code>加载的模块。</p></blockquote></li></ul></li><li><ul><li><code>all</code>：将所有initial chunk以及所有异步模块生成的non-initial chunk放在一起进行分析提取。</li></ul></li></ul><ul><li><p><code>minSize</code>选项：规定被提取的模块在压缩前的大小最小值，单位为字节，默认为30000，只有超过了30000字节才会被提取。</p></li><li><p><code>maxSize</code>选项：把提取出来的模块打包生成的文件大小不能超过maxSize值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为0，表示不限制大小。</p></li><li><p><code>minChunks</code>选项：表示要被提取的模块最小被引用次数，引用次数超过或等于minChunks值，才能被提取。</p></li><li><p><code>maxAsyncRequests</code>选项：最大的按需(异步)加载次数，默认为 6。</p></li><li><p><code>maxInitialRequests</code>选项：打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件），默认为4。</p><blockquote><p>优先级 ：</p><ul><li>webpack5中 maxInitialRequests / maxAsyncRequests&lt; maxSize &lt; minSize。</li><li>webpack4中好像存在bug，minSize/maxSize的优先级没有maxInitialRequests / maxAsyncRequests高。</li></ul></blockquote></li><li><p><code>automaticNameDelimiter</code>选项：打包生成的js文件名的分割符，默认为<code>~</code>。</p></li><li><p><code>name</code>选项：打包生成js文件的名称。</p></li><li><p><code>cacheGroups</code>选项，核心重点，<strong>配置提取模块的方案</strong>。里面每一项代表一个提取模块的方案。下面是<code>cacheGroups</code>每项中特有的选项，其余选项和外面一致，若<code>cacheGroups</code>每项中有，就按配置的，没有就使用外面配置的。</p></li><li><ul><li><code>test</code>选项：用来匹配要提取的模块的资源路径或名称。值是正则或函数。</li><li><code>priority</code>选项：方案的优先级，值越大表示提取模块时优先采用此方案。默认值为0。</li><li><code>reuseExistingChunk</code>选项：<code>true</code>/<code>false</code>。为<code>true</code>时，如果当前要提取的模块，在已经在打包生成的<em>js</em>文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的<em>js</em>文件。</li><li><code>enforce</code>选项：<code>true</code>/<code>false</code>。为<code>true</code>时，忽略<code>minSize</code>，<code>minChunks</code>，<code>maxAsyncRequests</code>和<code>maxInitialRequests</code>外面选项</li></ul></li></ul><h3 id="自己分析出的默认分割策略"><a href="#自己分析出的默认分割策略" class="headerlink" title="自己分析出的默认分割策略"></a>自己分析出的默认分割策略</h3><p>简单情况下，Webpack的splitChunks插件<strong>基本策略</strong>（priority为0，即默认策略）：</p><ol><li><p>从依赖图的拓扑顶点<code>vi</code>开始对<code>vi</code>所依赖的node_modules目录下的所有第三方模块进行分离，命名为<code>vendors~vi</code>。</p></li><li><p>如果不同的拓扑顶点<code>v1、v2</code>依赖相同的<strong>一个或多个node_modules下的第三方模块</strong>，则对<code>vendors~v1、vendors~v2</code>进一步分离为<code>vendors~v1~v2</code>和<code>vendor~v1、vendors~v2</code>，这种分离保证了<code>vendors~v1</code>和<code>vendors~v2</code>不再具有交集。</p><p>例如：v1、v2同时依赖了lodash和vue，则lodash和vue会被打包到<code>vendors~v1~v2</code>的chunk中。</p></li><li><p>找到被<code>v1、v2...vn</code>依赖了两次及其上，且压缩前模块大于等于30000b（约等于30kb）的<strong>文件模块</strong>，此类模块会被一起打包到名为<code>v1~v2~...vn</code>的chunk。小于30kb的模块，即使是被多个initial chunk依赖，也只会打包到initial chunk中，不会单独分离，<strong>这样虽然重复打包了，但可以减少请求次数</strong>。</p><p>例如：如果v1、v2、v3同时依赖了src/lib/a.js、src/lib/b.js，且这两个文件都大于30kb，则src/lib/a.js、src/lib/b.js会被打包到名为<code>v1~v2~v3</code>的chunk中。</p></li><li><p>对动态导入的懒加载模块（异步/懒加载）单独分离，如果懒加载模块中依赖了intial chunk中已经打包了的同步模块，则懒加载模块中不会再打包这些模块，而是只记录引用。</p></li></ol><blockquote><p>由于splitChunks.chunks 默认值为”async”，所以只会对不同的懒加载模块进行上述分离操作，而不会对不同的入口模块initial chunk进行依赖分离。下面就来说说如何选取需要进行分割操作的模块。</p></blockquote><h3 id="chunks属性"><a href="#chunks属性" class="headerlink" title="chunks属性"></a>chunks属性</h3><p>在splitChunks中，chunks是一个可配置的属性，它用于指示插件对哪些chunk分离相同的依赖，该属性既可以在splitChunks.chunks中全局配置，也可以在cacheGroups[group].chunks中配置并覆盖全局的配置。</p><p>该属性的可选值有：</p><ol><li><p>“async”：默认值，将懒加载模块进行分离，然后只对懒加载模块进行默认的分割处理。</p><p>例如单入口的情况：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210329155145451.png" alt="image-20210329155145451"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单入口</span><br>entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span><br>optimization: &#123;<br>    splitChunks: &#123;<br>        chunks: <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-comment">// 👈 默认就为&#x27;async&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// main.js内动态导入了两个模块</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./async.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// 👆 此时，webpack只会对 src/async.js 和 src/lazy.js进行依赖分析。并分离出他们的共同依赖。</span><br><span class="hljs-comment">// 在ModuleGraph中 src/async.js就是v1顶点，src/lazy就是v2顶点</span><br></code></pre></td></tr></table></figure><p><img src="/2021/04/19/Webpack/webpack4/image-20210329155225599.png" alt="分析async"></p></li></ol><p>   又例如多入口的情况：</p><p>   <img src="/2021/04/19/Webpack/webpack4/image-20210329154956362.png" alt="Module Graph"></p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 多入口</span><br><span class="hljs-comment">// ================= webpack.config.js ==================</span><br>entry: &#123;<br>main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>&#125;,<br>optimization: &#123;<br>    splitChunks: &#123;<br>        chunks: <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-comment">// 👈 默认就为&#x27;async&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// =============== main.js内动态导入了两个模块 ==================</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./async.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// ================ index.js内动态导入了一个模块 ==================</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./index-lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// 👆 此时，webpack只会对 src/async.js、src/lazy.js、src/index-lazy进行依赖分析。并分离出他们的共同依赖。</span><br><span class="hljs-comment">// 在ModuleGraph中 src/async.js就是v1顶点，src/lazy就是v2顶点，src/index-lazy就是v3顶点。</span><br></code></pre></td></tr></table></figure><p>   <img src="/2021/04/19/Webpack/webpack4/image-20210329155347635.png" alt="多入口async依赖图"></p><ol start="2"><li><p>“initial”：只对initial chunk进行分割处理，即在<code>Module Graph</code>中将<strong>懒加载模块及其独立依赖的模块移除后</strong>再进行依赖分析。</p><p>单入口依赖图：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210329155522181.png" alt="image-20210329155522181"></p><p>单入口initial chunk依赖分析：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210329155613618.png" alt="image-20210329155613618"></p><p>多入口依赖图：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210329154956362.png" alt="Module Graph"></p><p>多入口initial chunks依赖分析：</p><p><img src="/2021/04/19/Webpack/webpack4/image-20210329155813684.png" alt="image-20210329155813684"></p></li><li><p>“all”：配置chunk为该值时，<strong>会对initial chunk和non-initial chunk同时分析依赖，分离出共有的依赖项。</strong></p><p>单入口情况下，采取默认策略时，splitChunks.chunks = “all”<strong>只有一个作用</strong>，就是提取出懒加载模块依赖的node_modules目录下第三方模块，并打包到intial chunk中。</p><p>多入口情况下，采取默认策略时，splitChunks.chunks = “all”<strong>还有另外一个作用</strong>，就是提取出main.js入口的懒加载模块与index.js的initial chunk的相同依赖项，并打包成单独的chunk。</p><blockquote><p>一般来说，在splitChunks.chunks = “all”时，打包出的总体积是最小的，分离出的文件数量是最多的。</p></blockquote></li></ol><h3 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a>cacheGroups</h3><p>splitChunks.cacheGroups可以用于提取一些模块打包成一个chunk。</p><p>配置该属性有以下用处：</p><ol><li><p>⭐ 将过大的chunk分割，提取一些首屏依赖的第三方代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>            <span class="hljs-comment">// 👇 将element-ui 提取成单独一个chunk</span><br>            cacheGroups: &#123;<br>                elementUI: &#123;<br>                    chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                    name: <span class="hljs-string">&#x27;element-ui&#x27;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/].*element-ui/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;,<br>                jquery: &#123;<br>                    chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                    name: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/].*jquery/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>合并太过琐碎的chunk，减少请求次数。</p><p>例如：在单入口且splitChunks.chunks = ‘all’时，懒加载会分离出第三方依赖<code>vendors~lazy</code>，如果不想让它和<code>vendors~initial-chunk</code>割裂开来，可以将异步模块依赖的第三方模块提前加载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>            cacheGroups: &#123;<br>                <span class="hljs-string">&quot;vendors&quot;</span>: &#123;<br>                    name: <span class="hljs-string">&quot;vendors&quot;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="chunkName和fileName"><a href="#chunkName和fileName" class="headerlink" title="chunkName和fileName"></a>chunkName和fileName</h3><p>在Webpack中，模块打包成chunk，chunk分离成chunk组，每一个chunk应该拥有一个名字，chunk打包出的文件也应该拥有一个名字。</p><p>在之前提到，chunk分为<code>initial chunk</code>和<code>no-initial chunk</code>。</p><ul><li><p><code>initial chunk</code>即主chunk，是根据入口模块的依赖生成的主线。该类型的chunk名字是在定义<code>entry</code>时设定的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">// 此入口生成的intial chunk的chunkName为main</span><br>        index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span> <span class="hljs-comment">// 此入口生成的initial chunk的chunkName为index</span><br>    &#125;,<br>    output: &#123;<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&quot;initial-chunk-[name].[hash].js&quot;</span> <span class="hljs-comment">// intial chunk打包结果文件名</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>initial chunk打包后的文件名（<code>asset</code>）是在output.filename配置的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">output: &#123;<br> filename: <span class="hljs-string">&quot;[name].[hash:8].js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>non-initial chunk</code>一般由三种情况生成。① 异步导入（懒加载）。 ② 由splitChunks默认的分割策略生成。③ 由splitChunks.cacheGroups自定义的分割策略生成。</p><p>对于异步导入的模块生成的chunk命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;lazy&quot; */</span><span class="hljs-string">&#x27;./lib/lazy.js&#x27;</span>) <span class="hljs-comment">// 使用魔法注释为chunk命名。</span><br></code></pre></td></tr></table></figure><p>对于node_modules或者&gt; 30kb的共同依赖项命名规则：</p><ul><li><p><code>vendors-v1~v2</code> 👈 node_modules</p></li><li><p><code>v1~v2</code>  &gt; 30kb共同依赖项。</p></li></ul><p>对splitChunks.cacheGroups分割出的chunk命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//....</span><br>    optimization: &#123;<br>        <span class="hljs-comment">//....</span><br>        splitChunks: &#123;<br>            cacheGroups: &#123;<br>                lodash: &#123;  <span class="hljs-comment">// 👈 key的作用在于 假如v1和v2依赖了lodash</span><br>                      <span class="hljs-comment">// Webpack4 默认的chunkName为 key~v1~v2</span><br>                    name: <span class="hljs-string">&#x27;lodash&#x27;</span>,  <span class="hljs-comment">// name的作用在于替换掉默认的chunkName</span><br>                    test: <span class="hljs-regexp">/lodash/</span>,<br>                    chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>⭐ non-initial chunk打包出的文件名在output.chunkFilename中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">output: &#123;<br> <span class="hljs-comment">//...</span><br> chunkFilename: <span class="hljs-string">&quot;non-initial-[name].js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><p>HMR功能就是热更新功能。开发环境下，当我们修改了js代码，webpack会重新打包，devServer会刷新页面。而当我们开启HMR后，webpack不会将所有资源重新打包，而是只更新修改了的模块，从而<strong>提高构建速度，而且能够在保留页面原有数据状态的基础上，快速地将修改了的内容体现到页面上。</strong></p><p>CSS的HMR：style-loader已经内部实现了~</p><p>JS的HMR：需要在devServer中配置，同时需要手写每个模块更新的逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    devServer: &#123;<br>        <span class="hljs-comment">//...</span><br>        hot: <span class="hljs-literal">true</span> <span class="hljs-comment">// 👈 开启HMR</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> A <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lib/a.js&#x27;</span><br><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#app&#x27;</span>).innerHTML = A.msg;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">module</span>.hot) &#123;<br>    <span class="hljs-comment">// 👇 手写当 src/lib/a.js修改时热更新的逻辑</span><br>    <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./lib/a.js&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#app&#x27;</span>).innerHTML = A.msg;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>❗❗   以上是webpack4的配置，webpack5中，HMR的配置有点不一样。</p></blockquote><h2 id="preFetch"><a href="#preFetch" class="headerlink" title="preFetch"></a>preFetch</h2><p>懒加载的模块一般在真正需要时才会向服务器发送请求，而何时才是懒加载模块被真正需要了呢？</p><p>：当真正执行<code>import(&#39;./lazy.js&#39;)</code>时，浏览器就会向服务器请求懒加载模块。</p><p>所以一般<code>import(./lazy.js)</code>会封装到UI交互的回调函数中，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.lazyLoaded) &#123;<br>        <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.innerHTML = m.default.text&#125; );<br>        <span class="hljs-built_in">this</span>.lazyLoaded = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有当button的click事件第一次触发时才会向服务器请求 lazy.js。</p><p>但是webpack提供另外一种技术，当浏览器空闲时会自动请求设置了prefetch的懒加载模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.lazyLoaded) &#123;<br>        <span class="hljs-comment">// 👇 在魔法注释中设置prefetch为true</span><br>        <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &#x27;lazy&#x27;, webpackPrefetch: true */</span><span class="hljs-string">&#x27;./lazy.js&#x27;</span>)<br>            .then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.innerHTML = m.default.text&#125; );<br>        <span class="hljs-built_in">this</span>.lazyLoaded = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，浏览器空闲时已经把lazy.js请求到了，当button第一次触发点击事件时，lazy.js会从缓存获取。</p><h1 id="其他常见操作与相关插件"><a href="#其他常见操作与相关插件" class="headerlink" title="其他常见操作与相关插件"></a>其他常见操作与相关插件</h1><h2 id="构建前自动清空打包目录-⭐"><a href="#构建前自动清空打包目录-⭐" class="headerlink" title="构建前自动清空打包目录 ⭐"></a>构建前自动清空打包目录 ⭐</h2><p><strong>使用的插件：</strong><code>clean-webpack-plugin</code> <a href="https://www.npmjs.com/package/clean-webpack-plugin">参考链接https://www.npmjs.com/package/clean-webpack-plugin</a></p><p>该插件会帮助我们在重新打包项目时，清空<code>output.path</code>中设定的输出目录的内容。</p><p><strong>安装插件</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> clean-webpack-<span class="hljs-keyword">plugin</span> -D<br></code></pre></td></tr></table></figure><p><strong>使用插件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// </span><br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); ❗❗ <span class="hljs-comment">// 需要解构！</span><br><br><span class="hljs-comment">// ⭐ 该插件的options对象</span><br><span class="hljs-keyword">const</span> CleanPluginOptions = &#123;<br>  <br>  <span class="hljs-comment">// 下面这个选项用于配置删除哪些文件， **代表任意级目录</span><br>  <span class="hljs-comment">// 如：&#x27;**/foo&#x27; 可以匹配 /bar/foo、/foo等。</span><br>  cleanOnceBeforeBuildPatterns: [<span class="hljs-string">&#x27;**/*&#x27;</span>],<br>  <br>  <span class="hljs-comment">// ❗ 如果希望排除某些目录，则要用`!`感叹号排除。</span><br>  dry: <span class="hljs-literal">true</span>, <span class="hljs-comment">//👈 必须设置该字段为true，感叹号才起作用</span><br>  cleanOnceBeforeBuildPatterns: [<span class="hljs-string">&#x27;**/*&#x27;</span>, <span class="hljs-string">&#x27;!dll/*&#x27;</span>],<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports =  &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/[name].[hash:10].js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 👈 默认会情况该目录下的内容</span><br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(CleanPluginOptions), <span class="hljs-comment">// 👈 使用插件即可</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><p><strong>使用loader：</strong><code>thread-loader</code></p><p>使用方法：module.rules中规定了各种类型文件使用的转换loader，当需要使用多进程加快打包速度时，只需要在某个类型的文件处理流程的最后使用一下<code>thread-loader</code>。</p><p>例如多进程打包js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>                use: [<br>                    <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 👇 进一步配置打包的进程数</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                use: [<br>                    &#123;<br>                        loader: <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>                        options: &#123;<br>                            workers: <span class="hljs-number">2</span> <span class="hljs-comment">// 👈使用两个核心</span><br>                        &#125;<br>                    &#125;<br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用thread-loader的优点是提升打包速度，缺点是每个进程的开启和交流都会有开销</strong>（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）。</p></blockquote><h2 id="向HTML模板中添加本地资源链接"><a href="#向HTML模板中添加本地资源链接" class="headerlink" title="向HTML模板中添加本地资源链接"></a>向HTML模板中添加本地资源链接</h2><p><strong>使用插件：</strong><code>add-asset-html-webpack-plugin</code></p><p>该插件能够帮助我们将源码区域的某些JS或CSS资源复制到打包输出目录，并在指定的HTML模板插入这些资源的引用标签。（<strong>复制资源、插入引用标签</strong>）</p><p><strong><a href="https://github.com/SimenB/add-asset-html-webpack-plugin">可配置项</a></strong></p><ul><li><p><strong>filepath</strong>：指示需要将哪些JS/CSS以标签的形式添加到HTML中。</p><p>Type: <code>string|Glob</code>, mandatory</p><p>The absolute path of the file you want to add to the compilation, and resulting HTML file. Also support globby string.</p></li><li><p><strong>files</strong>：为哪些模板添加filepath中包含的所有文件。</p><p>Type: <code>string|Array&lt;string&gt;</code>, default `[]</p><p>Files that the assets will be added to.</p><p>By default the assets will be included in all files. If files are defined, the assets will only be included in specified file globs.</p></li><li><p><strong>hash</strong>：是否为资源文件名后添加hash值。</p><p>Type: <code>boolean</code>, default: <code>false</code></p><p>If <code>true</code>, will append a unique hash of the file to the filename. This is useful for cache busting.</p></li><li><p><strong>includeRelatedFiles</strong>：一般不用，直接在filepath中使用glob语法即可。</p><p>Type: <code>boolean</code>, default: <code>true</code></p><p>If <code>true</code>, will add <code>filepath + &#39;.*&#39;</code> to the compilation as well. E.g <code>filepath.map</code> and <code>filepath.gz</code>.</p></li><li><p><strong>outputPath</strong>：资源复制到哪个目录下，默认为output.path。</p><p>Type: <code>string</code></p><p>If set, will be used as the output directory of the file.</p></li><li><p><strong>publicPath</strong>：标签的公共路径。</p><p>Type: <code>string</code></p><p>If set, will be used as the public path of the script or link tag.</p></li><li><p><strong>typeOfAsset</strong>：可以指示是为资源添加CSS还是JS标签。</p><p>Type: <code>string</code>, default: <code>js</code></p><p>Can be set to <code>css</code> to create a <code>link</code>-tag instead of a <code>script</code>-tag.</p></li><li><p><strong>attributes</strong>：可以用于为标签添加额外属性。</p><p>Type: <code>object</code>, default: <code>&#123;&#125;</code></p><p>Extra attributes to be added to the generated tag. Useful to for instance add <code>nomodule</code> to a polyfill script. The <code>attributes</code> object uses the key as the name of the attribute, and the value as the value of it. If value is simply <code>true</code> no value will be added.</p><p>An example of this is included in the repository.</p><p>Currently only supports script tags.</p></li></ul><p><strong>添加JS资源</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            filepath: <span class="hljs-string">&quot;./dll/*.dll.js&quot;</span>, <span class="hljs-comment">// 👈 使用glob语法，添加开发目录下的dll脚本。</span><br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <span class="hljs-comment">// 👈 只为dist目录中的该模板添加资源</span><br>            <span class="hljs-comment">// typeOfAsset默认为&#x27;js&#x27;</span><br>        &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>添加CSS资源</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            typeOfAsset: <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-comment">// 👈 一定要指明css</span><br>            filepath: <span class="hljs-string">&quot;src/static/**/*.css&quot;</span>, <br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <br>        &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>同时添加JS和CSS资源</strong></p><p>需要使用两次插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            filepath: <span class="hljs-string">&quot;./dll/*.dll.js&quot;</span>,<br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>],<br>        &#125;),<br><span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            typeOfAsset: <span class="hljs-string">&#x27;css&#x27;</span>,<br>            publicPath: <span class="hljs-string">&#x27;/static/&#x27;</span>, <span class="hljs-comment">// ⭐ publicPath需要和outputPath配合使用，</span><br>            outputPath: <span class="hljs-string">&#x27;static&#x27;</span>,  <span class="hljs-comment">// outputPath相对于dist</span><br>            filepath: <span class="hljs-string">&quot;src/static/**/*.css&quot;</span>, <br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <br>        &#125;),        <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>❗ <strong>注意：</strong></p><p><strong>add-asset-html-webpack-plugin会将CSS的link标签插入到head中，而JS标签的插入位置与html-webpack-plugin的配置有关。</strong></p></blockquote><h2 id="大型框架打包成Dll-js"><a href="#大型框架打包成Dll-js" class="headerlink" title="大型框架打包成Dll.js"></a>大型框架打包成Dll.js</h2><p><strong>使用插件：</strong><code>webpack/lib/DllPlugin</code>   👉 生成Dll.js和接口文件manifest.json</p><p><strong>使用插件：</strong><code>webpack/lib/DllReferencePlugin</code> 👉 引用Dll内容</p><p><strong>注意：</strong></p><p>此种做法还需要我们手动将生成后的dll文件以script标签的方式插入到模板中，所以还不是很完善。</p><p><font color="red">开发环境下为了提高打包速度，我们可以这样做。</font></p><p><strong>前言：</strong></p><p>像<code>react</code>这种大型框架，在反复打包时会多次分析依赖，会消耗大量编译时间。</p><p>对于此类包或依赖，我们可以先将其打包成Dll，通过接口访问其内容。</p><p>由于<code>react</code>要转义<code>jsx</code>，所以方便起见，下面以将<code>Vue</code>打包成<code>Dll</code>为例：</p><p><strong>总体流程：</strong></p><p>首先建立单独的webpack配置，用于将某个大型第三方包打包成dll。</p><p>然后在构建项目的webpack配置中引用该dll。</p><p><strong>1. 新建用于打包dll的webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 新建 webpack.dll.js<br><br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> DllPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/DllPlugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    vue: [<span class="hljs-string">&#x27;vue&#x27;</span>]<br>  &#125;,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;Dll&#x27;</span>),<br>    library: <span class="hljs-string">&#x27;__dll__[name]&#x27;</span>,<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> DllPlugin(&#123;<br>      name: <span class="hljs-string">&#x27;__dll__[name]&#x27;</span>,<br>      path: resolve(__dirname, <span class="hljs-string">&#x27;dll&#x27;</span>, <span class="hljs-string">&#x27;[name].manifest.json&#x27;</span>)<br>    &#125;)<br>  ],<br>&#125;<br><br><span class="hljs-comment">// ==========================</span><br># package.json<br><br>&#123;<br>  scripts: &#123;<br>    <span class="hljs-string">&quot;dll&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.dll.js&quot;</span> , <span class="hljs-comment">// 👈 配置一条构建vue dll的脚本</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 将vue打包成Dll</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="bash"> dll</span><br></code></pre></td></tr></table></figure><p>此时dist/dll目录下生成两个文件：</p><p> <img src="/2021/04/19/Webpack/webpack4/image-20210329232433059.png" alt="image-20210329232433059"></p><p><strong>3. 在构建项目的webpack配置中读取Dll接口，并向模板中添加对vue.dll.js的引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> CleanWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br><br>⭐ <span class="hljs-keyword">const</span> DllReferencePlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/DllReferencePlugin&#x27;</span>);<br>⭐ <span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>;<br><br><span class="hljs-keyword">const</span> devConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,<br>  plugins: [<br>    <span class="hljs-comment">// 👇 配置引用DLL插件,该插件读取vue.mainfest.json后会知道哪些第三方包是不需要打包的。</span><br>    <span class="hljs-comment">// 同时在打包构建过程中，如果某些模块依赖了这些没有打包的第三方包的内容时，</span><br>    <span class="hljs-comment">// 插件通过读取mainifest.json，能够告诉模块到全局的哪个属性中获取依赖的内容。</span><br>    <span class="hljs-keyword">new</span> DllReferencePlugin(&#123;<br>      manifest: resolve(__dirname, <span class="hljs-string">&#x27;dll&#x27;</span>, <span class="hljs-string">&#x27;vue.manifest.json&#x27;</span>),<br>    &#125;),<br>    <span class="hljs-comment">// ⭐ 将vue.dll.js复制到dist目录，并向HTML中插入vue.dll.js的引用标签</span><br>    <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>      filepath: <span class="hljs-string">&#x27;./dll/vue.dll.js&#x27;</span>,<br>      files: [<span class="hljs-string">&#x27;index.html&#x27;</span>]<br>    &#125;),<br>      <br>  ],<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, devConfig);<br><br></code></pre></td></tr></table></figure><h2 id="模块免导入"><a href="#模块免导入" class="headerlink" title="模块免导入"></a>模块免导入</h2><p><strong>使用插件：</strong><code>webpack.ProvidePlugin</code></p><p>webpack配置ProvidePlugin后，在使用时将不再需要import和require进行引入，直接使用即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br> <br><span class="hljs-built_in">module</span>.exports = &#123;<br>  plugins: [<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;<br>      <span class="hljs-string">&#x27;$&#x27;</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-string">&#x27;Vue&#x27;</span>: <span class="hljs-string">&#x27;vue&#x27;</span><br>    &#125;),<br>   <span class="hljs-comment">// ...</span><br>]<br>&#125;<br><br><span class="hljs-comment">//-------------------------------------</span><br># .src/index.js<br><br><span class="hljs-comment">// 无需导入，就可以使用该变量。（手动导入了也不影响效果）</span><br><span class="hljs-built_in">console</span>.log($);<br><span class="hljs-built_in">console</span>.log(Vue);<br></code></pre></td></tr></table></figure><h2 id="在页面中使用CDN引入第三方包"><a href="#在页面中使用CDN引入第三方包" class="headerlink" title="在页面中使用CDN引入第三方包"></a>在页面中使用CDN引入第三方包</h2><h3 id="方法1：使用插件处理"><a href="#方法1：使用插件处理" class="headerlink" title="方法1：使用插件处理"></a>方法1：使用插件处理</h3><p><strong>使用的插件：</strong><code>html-webpack-externals-plugin</code></p><p>正常情况下，我们在本地开发时使用<code>import</code>或<code>require</code>导入第三方模块，都是到 <strong>node_modules</strong> 目录或缓存中导入。<code>html-webpack-externals-plugin</code>为我们提供了另外一种导入方式，即CDN引入。</p><p><font color='red'>该插件自动将CDN script标签插入到模板HTML中</font>，第三方内容<code>foo</code>就挂载到了全局对象window下（这里假设第三方包将自己挂载到<code>Foo</code>属性上），在其他模块导入<code>foo</code>时，会将<code>window.Foo</code>作为导入。</p><p><strong>下面以CDN导入jQuery为例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> HTMLWebPackExternalsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-externals-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/[name].[hash].js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>);<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 使用插件</span><br>    <span class="hljs-keyword">new</span> HTMLWebpackExternalsPlugin(&#123;<br>      <span class="hljs-comment">// 👇 注意是复数 externals</span><br>      externals: [ <span class="hljs-comment">// 可以定义多个CDN扩展，用对象数组的形式</span><br>        &#123;<br>          <span class="hljs-built_in">module</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>          entry: <span class="hljs-string">&#x27;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&#x27;</span> <span class="hljs-comment">// cdn链接</span><br>          <span class="hljs-built_in">global</span>: <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-comment">// 到全局的该属性上获取</span><br>        &#125;,<br>      ],<br>      <span class="hljs-comment">/* ⭐⭐</span><br><span class="hljs-comment">      *如果是多页面应用，就会有多个html文件，`html-webpack-externals-plugin`默认将cdn插入到所有页面中</span><br><span class="hljs-comment">      * 如果开发时只需要将cdn加入到某些html中。则需要指定 files: [...]，来指示需要cdn的HTML文件</span><br><span class="hljs-comment">      */</span><br>      files: [<span class="hljs-string">&#x27;index.html&#x27;</span>]  <span class="hljs-comment">// 👈 files数组中填的是打包后的html文件相对于输出目录的路径</span><br><span class="hljs-comment">// 如果html打包到了dist/static中，files: [&#x27;static/index.html&#x27;]</span><br>      <br>    &#125;)<br>  ]<br>&#125;<br><br><span class="hljs-comment">//====================================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>; <span class="hljs-comment">// 将会从全局获取jquery</span><br><br><span class="hljs-built_in">console</span>.log($);<br></code></pre></td></tr></table></figure><h3 id="方法2：手动插入配合externals"><a href="#方法2：手动插入配合externals" class="headerlink" title="方法2：手动插入配合externals"></a>方法2：手动插入配合externals</h3><blockquote><p>当我们在开发时也可以直接在模板HTML中插入了第三方包的CDN script标签，但我们需要让webpack在打包时告诉JS模块到全局去获取。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- .src/index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在模板中直接cdn引入--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scripts</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scripts</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  externals: &#123;<br>    jquery: <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-comment">// 指示引入jquery时，访问全局对象的$属性</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="将资源目录拷贝到打包目录"><a href="#将资源目录拷贝到打包目录" class="headerlink" title="将资源目录拷贝到打包目录"></a>将资源目录拷贝到打包目录</h2><p><strong>使用的插件：</strong><code>copy-webpack-plugin</code></p><p>在一定场合下需要使用该功能，比如将开发目录下的mock数据拷贝到打包后的输出目录中。</p><p>现在假设将<code>.src/mock</code>拷贝到<code>.dist/mock</code></p><p><strong>安装插件</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm install <span class="hljs-keyword">copy</span><span class="bash">-webpack-plugin -D</span><br></code></pre></td></tr></table></figure><p><strong>使用插件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  plugins: [<br>    <span class="hljs-comment">// 该插件的配置是一个数组，数组中的元素要求含有from和to两个属性，分别代表源路径和目标路径</span><br>    <span class="hljs-keyword">new</span> CopyWebpackPlugin([<br>      &#123;<br>        <span class="hljs-keyword">from</span>: resolve(__dirname, <span class="hljs-string">&#x27;src/mock&#x27;</span>), <span class="hljs-comment">// 需要使用绝对路径</span><br>        to: resolve(__dirname, <span class="hljs-string">&#x27;dist/mock&#x27;</span>),<br>      &#125;,<br>    ]),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模拟将打包结果部署到Express服务器"><a href="#模拟将打包结果部署到Express服务器" class="headerlink" title="模拟将打包结果部署到Express服务器"></a>模拟将打包结果部署到Express服务器</h2><p><strong>使用Express中间件</strong>：<code>webpack-dev-middleware</code></p><p><strong>1. 安装express和webpack-dev-middleware</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">express</span> webpack-dev-middleware --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure><p><strong>2. 在前端项目页面下新建server.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># ./server.js<br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config&#x27;</span>); <span class="hljs-comment">// 引入webpack配置</span><br><br><span class="hljs-keyword">const</span> compiler = webpack(webpackConfig); <span class="hljs-comment">// 执行webpack函数，生成编译对象</span><br><br><span class="hljs-keyword">const</span> app = express(); <span class="hljs-comment">// 新建Express服务器</span><br><br>app.use(webpackDevMiddleware(compiler, &#123;&#125;)); <span class="hljs-comment">// 执行中间件，将编译对象传入</span><br><span class="hljs-comment">/* 该中间件会做两件事：</span><br><span class="hljs-comment">* 1. 调用compiler.run()，执行编译。</span><br><span class="hljs-comment">* 2. 使用一个中间件，响应客户端对打包后的文件的请求。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 以下开始express项目的正常逻辑，这里模拟一个&#x27;/api/mock&#x27; 路由。</span><br>app.get(<span class="hljs-string">&#x27;/api/mock&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.json(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;ok&#x27;</span> &#125;));<br><br>app.listen(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 监听3000端口</span><br><br><span class="hljs-comment">// 输入命令：node ./server.js 启动服务器</span><br><br></code></pre></td></tr></table></figure><h2 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h2><p><strong>使用插件：</strong><code>webpack.DefinePlugin</code></p><p><a href="https://webpack.js.org/plugins/define-plugin/">参考链接：https://webpack.js.org/plugins/define-plugin/</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>  <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-built_in">JSON</span>.stringify(process.env.NODE_ENV),<br>  <span class="hljs-string">&#x27;SERVICE_URL&#x27;</span>: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;https://dev.example.com&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p><strong>使用插件：</strong><code>webpack.BannerPlugin</code></p><p><a href="https://webpack.js.org/plugins/banner-plugin/">参考链接：https://webpack.js.org/plugins/banner-plugin/</a></p><h2 id="拆分配置-⭐"><a href="#拆分配置-⭐" class="headerlink" title="拆分配置 ⭐"></a>拆分配置 ⭐</h2><p><strong>安装<code>webpack-merge</code>，将<code>webpack.config.js</code>拆分成：</strong></p><ol><li><code>webpack.config.base.js</code></li><li><code>webpack.config.dev.js</code></li><li><code>webpack.config.prod.js</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><span class="hljs-comment">// ⭐ 需要使用webpack-merge的merge方法去合并配置</span><br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>); <br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 👇导入基本配置对象</span><br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>;<br><br><span class="hljs-keyword">const</span> devConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, devConfig);<br><br><span class="hljs-comment">//-----------------------------------------------------------</span><br># webpack.config.prod.js<br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;production&#x27;</span>;<br><br><span class="hljs-keyword">const</span> prodConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>,<br>  devtool: <span class="hljs-string">&#x27;nosources-source-map&#x27;</span>,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(),<br>  ],<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, prodConfig);<br><br><span class="hljs-comment">//------------------------------------------------------------</span><br># webpack.config.base.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *    基本配置内容</span><br><span class="hljs-comment">  */</span><br>&#125;<br><br><span class="hljs-comment">//------------------------------------------------------------</span><br># package.json<br><span class="hljs-comment">// ⭐⭐ 配置脚本</span><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack server --config ./webpack.config.dev.js&quot;</span>,<br>    <span class="hljs-string">&quot;build:dev&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.config.dev.js&quot;</span>,<br>    <span class="hljs-string">&quot;build:prod&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.config.prod.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="MPA-多页面打包"><a href="#MPA-多页面打包" class="headerlink" title="MPA 多页面打包"></a>MPA 多页面打包</h2><p>在模块的初级打包中提到过“多入口”如何配置。当一个项目不再是SPA，而是多页面应用程序时，我们就要打包多个HTML和每个页面对应的入口JS。</p><h3 id="多次使用插件"><a href="#多次使用插件" class="headerlink" title="多次使用插件"></a>多次使用插件</h3><p><strong>使用插件：</strong><code>html-webpack-plugin</code></p><p>我们依然是使用该插件打包html和入口文件，多页面时，每个页面都要<code>new</code>一个<code>html-webpack-plugin</code>。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HTMLWebpackPlugin = reuqire(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>entry: &#123;<br>    <span class="hljs-comment">// 👇 定义两个入口，一个叫home，一个叫app</span><br>    main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <br>    app: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>    vendor: [<span class="hljs-string">&#x27;jquery&#x27;</span>],<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      <span class="hljs-comment">// 以src/pages目录下的index.html为模板</span><br>      template: <span class="hljs-string">&#x27;./src/pages/index.html&#x27;</span>,<br>       <span class="hljs-comment">// 👈 标记该页面依赖于jquery，同时入口为home</span><br>      chunks: [<span class="hljs-string">&#x27;vendor&#x27;</span>,<span class="hljs-string">&#x27;main&#x27;</span>],<br>      chunksSortMode: <span class="hljs-string">&#x27;manual&#x27;</span>,<br>      filename: <span class="hljs-string">&#x27;index.js&#x27;</span>, <span class="hljs-comment">// ❗⭐❗ 一定要为每个打包的页面注明文件名，否则会报错</span><br>      <span class="hljs-comment">// chunk: [&#x27;main&#x27;]</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      <span class="hljs-comment">// 以src/pages目录下的sub.html为模板</span><br>      template: <span class="hljs-string">&#x27;./src/pages/sub.html&#x27;</span>,<br>      <span class="hljs-comment">// 标记该页面的入口为app</span><br>      chunks: [<span class="hljs-string">&#x27;app&#x27;</span>],<br>      filename: <span class="hljs-string">&#x27;sub.html&#x27;</span> <span class="hljs-comment">// ❗⭐❗ 一定要为每个打包的页面注明文件名，否则会报错</span><br>    &#125;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>多页面时，如果配置了html-webpack-externals-plugin，需要指明依赖于cdn的打包后的html文件。</p><p>具体查看 html-webpack-externals-plugin 的 files字段配置。</p></blockquote><h3 id="页面和入口JS的约定"><a href="#页面和入口JS的约定" class="headerlink" title="页面和入口JS的约定"></a>页面和入口JS的约定</h3><p>当我们约定一个页面模板和其入口JS文件名相同时，我们可以将页面和入口JS分别放在<code>pages</code>和<code>entries</code>目录下，然后按文件名进行一一对应，并通过<code>html-webpack-plugin</code>绑定起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> &#123; resolve, basename &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">// 通过glob这个第三方库去读取一个文件夹下的js文件</span><br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);<br><br><span class="hljs-comment">// 新建一个匹配模式，去匹配src/entries目录下的入口js文件</span><br><span class="hljs-keyword">const</span> entryFilesPattern = resolve(__dirname, <span class="hljs-string">&#x27;src/entries/*.js&#x27;</span>);<br><span class="hljs-keyword">const</span> entryFilePaths = glob.sync(entryFilesPattern);<br><br><span class="hljs-comment">// 👇 多入口对象</span><br><span class="hljs-keyword">const</span> entries = &#123;&#125;;<br>entryFilePaths.forEach(<span class="hljs-function">(<span class="hljs-params">entryPath</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> entryName = basename(entryPath, <span class="hljs-string">&#x27;.js&#x27;</span>); <span class="hljs-comment">// 通过path.basename方法获得不带扩展名.js的文件名</span><br>  entries[entryName] = entryPath;<br>&#125;);<br><br><span class="hljs-comment">// 页面模板所在目录</span><br><span class="hljs-keyword">const</span> pagesDirPath = resolve(__dirname, <span class="hljs-string">&#x27;src/pages&#x27;</span>);<br><span class="hljs-comment">// 👇 用数组保存多页面对应的插件</span><br><span class="hljs-keyword">const</span> htmlWebpackPlugins = <span class="hljs-built_in">Object</span>.keys(entries).map(<span class="hljs-function">(<span class="hljs-params">entryName</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> chunkName = entryName;<br>  <span class="hljs-keyword">const</span> options = &#123;<br>    template: resolve(pagesDirPath, <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkName&#125;</span>.html`</span>),<br>    chunks: [chunkName],<br>    <span class="hljs-comment">// ⭐ 必须指明打包后的文件名，同时可以加入子目录路径，如 `static/&#123;chunkName&#125;.html`</span><br>    filename: <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkName&#125;</span>.html`</span>,<br>    <span class="hljs-comment">// 以下为可选</span><br>    chunksSortMode: <span class="hljs-string">&#x27;manual&#x27;</span>,<br>    inject: <span class="hljs-string">&#x27;body&#x27;</span>,<br>    hash: <span class="hljs-literal">true</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HTMLWebpackPlugin(options);<br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  entry: entries,<br>  plugins: [<br>    ...htmlWebpackPlugins, <span class="hljs-comment">// 👈 配置多页面</span><br>    <span class="hljs-comment">//...</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="html-webpack-plugin模板字符串-❓"><a href="#html-webpack-plugin模板字符串-❓" class="headerlink" title="html-webpack-plugin模板字符串 ❓"></a>html-webpack-plugin模板字符串 ❓</h2><p><code>html-webpack-plugin</code>能够识别<code>$&#123;...&#125;</code>这样的插值语法，配合<code>raw-loader</code>可以将导入的资源文件的内容放入到插值语法的位置。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--👇 内联html --&gt;</span><br>    $&#123;require(&#x27;!!raw-loader!./src/head.html&#x27;)&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      &lt;* 👇 内联css *&gt;<br>      $&#123;require(&#x27;!!raw-loader!./src/css/index.css&#x27;)&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">// 👇 内联js</span></span><br><span class="javascript">      $&#123;<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;!!raw-loader!./src/js/jquery.min.js&#x27;</span>)&#125;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><p><code>require()</code>中的<code>raw-loader![source-id]</code>的写法是<strong>行内loader</strong>，用<code>!</code>分割loader和参数。</p></li><li><p><code>!!raw-loader</code>中，前面的两个<code>!!</code>是标记该条引用的资源不需要再被<code>rules</code>中配置的loader处理。</p></li></ul><h2 id="分析plugins和loaders耗时"><a href="#分析plugins和loaders耗时" class="headerlink" title="分析plugins和loaders耗时"></a>分析plugins和loaders耗时</h2><p><strong>使用插件：</strong><code>speed-measure-webpack-plugin</code></p><p><strong>1. 安装</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> speed-measure-webpack-<span class="hljs-keyword">plugin</span> -D<br></code></pre></td></tr></table></figure><p><strong>2. 新建插件对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> SpeedMeasureWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;speed-measure-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> smw = <span class="hljs-keyword">new</span> SpeedMeasureWebpackPlugin();<br><br></code></pre></td></tr></table></figure><p><strong>3. 使用wrap方法包裹webpack配置对象并导出</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> SpeedMeasureWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;speed-measure-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> smw = <span class="hljs-keyword">new</span> SpeedMeasureWebpackPlugin();<br><br><span class="hljs-built_in">module</span>.exports = smw.wrap(&#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  ouput: &#123;<span class="hljs-comment">/*...*/</span>&#125;,<br>  <span class="hljs-built_in">module</span>: &#123;<span class="hljs-comment">/*...*/</span>&#125;<br>  <span class="hljs-comment">//...</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>4. npm run build</strong></p><h2 id="生成打包过程的分析报告"><a href="#生成打包过程的分析报告" class="headerlink" title="生成打包过程的分析报告"></a>生成打包过程的分析报告</h2><p><strong>使用插件：</strong><code>webpack-bundle-analyzer</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack-bundle-analyzer –save-dev<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接使用插件：</span><br>plugins: [<br>    <span class="hljs-keyword">new</span> BundleAnalyzerPlugin()<br>]<br><br>👇 该插件的默认配置，一般无需修改：<br>&#123;<br>  <span class="hljs-comment">//  可以是`server`，`static`或`disabled`。</span><br>  <span class="hljs-comment">//  在`server`模式下，分析器将启动HTTP服务器来显示软件包报告。</span><br>  <span class="hljs-comment">//  在“静态”模式下，会生成带有报告的单个HTML文件。</span><br>  <span class="hljs-comment">//  在`disabled`模式下，你可以使用这个插件来将`generateStatsFile`设置为`true`来生成Webpack Stats JSON文件。</span><br>  analyzerMode: <span class="hljs-string">&#x27;server&#x27;</span>,<br>  <span class="hljs-comment">//  将在“服务器”模式下使用的主机启动HTTP服务器。</span><br>  analyzerHost: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>  <span class="hljs-comment">//  将在“服务器”模式下使用的端口启动HTTP服务器。</span><br>  analyzerPort: <span class="hljs-number">8888</span>, <br>  <span class="hljs-comment">//  路径捆绑，将在`static`模式下生成的报告文件。</span><br>  <span class="hljs-comment">//  相对于捆绑输出目录。</span><br>  reportFilename: <span class="hljs-string">&#x27;report.html&#x27;</span>,<br>  <span class="hljs-comment">//  模块大小默认显示在报告中。</span><br>  <span class="hljs-comment">//  应该是`stat`，`parsed`或者`gzip`中的一个。</span><br>  <span class="hljs-comment">//  有关更多信息，请参见“定义”一节。</span><br>  defaultSizes: <span class="hljs-string">&#x27;parsed&#x27;</span>,<br>  <span class="hljs-comment">//  在默认浏览器中自动打开报告</span><br>  openAnalyzer: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">//  如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成</span><br>  generateStatsFile: <span class="hljs-literal">false</span>, <br>  <span class="hljs-comment">//  如果`generateStatsFile`为`true`，将会生成Webpack Stats JSON文件的名字。</span><br>  <span class="hljs-comment">//  相对于捆绑输出目录。</span><br>  statsFilename: <span class="hljs-string">&#x27;stats.json&#x27;</span>,<br>  <span class="hljs-comment">//  stats.toJson（）方法的选项。</span><br>  <span class="hljs-comment">//  例如，您可以使用`source：false`选项排除统计文件中模块的来源。</span><br>  <span class="hljs-comment">//  在这里查看更多选项：https：  //github.com/webpack/webpack/blob/webpack-1/lib/Stats.js#L21</span><br>  statsOptions: <span class="hljs-literal">null</span>,<br>  logLevel: <span class="hljs-string">&#x27;info&#x27;</span> <span class="hljs-comment">// 日志级别。可以是&#x27;信息&#x27;，&#x27;警告&#x27;，&#x27;错误&#x27;或&#x27;沉默&#x27;。</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/04/19/Webpack/webpack4/image-20210328200605532.png" alt="image-20210328200605532"></p><h2 id="样式表px自动换算rem"><a href="#样式表px自动换算rem" class="headerlink" title="样式表px自动换算rem"></a>样式表px自动换算rem</h2><p><strong>使用loader：</strong><code>px2rem-loader</code></p><p><strong>前言</strong></p><p>移动端开发rem布局中，我们会使用内联的JS脚本改变rem的大小。<font color='red'>而这个JS脚本中会耦合设计稿的信息</font>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> html = <span class="hljs-built_in">document</span>.documentElement;<br><span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.body;<br><br><span class="hljs-keyword">const</span> designWidth = <span class="hljs-number">750</span>; <span class="hljs-comment">// 👈 设计稿宽度，耦合了设计稿信息</span><br><span class="hljs-keyword">const</span> zoomRatio = <span class="hljs-number">100</span>; <span class="hljs-comment">// rem放大比例，便于换算。</span><br>html.style.fontSize = html.clientWidth / designWidth * zoomRatio + <span class="hljs-string">&#x27;px&#x27;</span>;<br>body.style.fontSize = <span class="hljs-string">&#x27;16px&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p><strong>现在提供一种方式：</strong> 抽离控制rem的JS脚本中的设计稿宽度信息，将设计稿宽度的变化由wepack的插件来适配。<font color='red'>同时在写css文件时，不再需要进行人为的换算, 插件会帮助我们换算。</font></p><p>😄 <strong>在如下配置下，我们的css文件中不再需要开发者换算啦 ~ 量多少，写多少。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 控制rem大小的脚本或者其他类似的通用脚本/插件<br><br><span class="hljs-keyword">const</span> html = <span class="hljs-built_in">document</span>.documentElement;<br><span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.body;<br><br><span class="hljs-keyword">const</span> ratio = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/* 👇 剥离设计稿信息，rem大小永远为理想视口宽度的十分之一。插件换算比例 = 设计稿宽度 / 10</span><br><span class="hljs-comment">*ratio也可以是别的值，但是插件换算比例  = 设计稿 / ratio</span><br><span class="hljs-comment">*/</span><br>html.style.fontSize = html.clientWidth / ratio; <br><br>body.style.fontSize = <span class="hljs-string">&#x27;16px&#x27;</span>;<br><br><span class="hljs-comment">//====================================================================</span><br># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;px2rem-loader&#x27;</span>,<br>            options: &#123;<br>              remPrecesion: <span class="hljs-number">8</span>, <span class="hljs-comment">// 👈 换算成rem后，保留多少位小数</span><br>              remunit: <span class="hljs-number">75</span>, <span class="hljs-comment">// 👈 换算比例，即在css样式表中75px换算为1rem，相当于设计稿 750/10</span><br>              <br>              <span class="hljs-comment">// 假如说设计稿是1080，控制rem大小JS脚本中的ratio设置为10，则：</span><br>              remunit: <span class="hljs-number">108</span>,<br>              <span class="hljs-comment">// 假如说设计稿是1000，ratio设置为20，则：</span><br>              remunit: <span class="hljs-number">50</span>,<br>              <br>            &#125;<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假如设计稿上一个div宽度是 250px</span><br><span class="hljs-comment">px2rem-loader中设置了remunit是75</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span> <span class="hljs-comment">/* 👉 loader 编译后 width: 3.33333333rem */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>❗ ❗  需要注意的是：内联样式不会被 <code>px2rem-loader</code>处理，仍然需要开发者换算。</p><blockquote><p>所以可能还是 remunit 固定为100，根据不同设计稿调整ratio来的好。</p></blockquote><h1 id="归纳小结"><a href="#归纳小结" class="headerlink" title="归纳小结"></a>归纳小结</h1><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="webpack4、cli、html-webpack-plugin兼容"><a href="#webpack4、cli、html-webpack-plugin兼容" class="headerlink" title="webpack4、cli、html-webpack-plugin兼容"></a>webpack4、cli、html-webpack-plugin兼容</h2><ul><li>现在使用<code>npm install webpack -D</code>默认安装的是webpack5。</li><li>webpack-cli、html-webpack-plugin默认安装的最新版本是配合webpack5使用，所以当使用webpack4时，也需要降低webpack-cli、html-webpack-plugin的版本。</li></ul><p><strong>安装组合：</strong><code>npm install -D wepack@4 webpack-cli@3 html-webpack-plugin@4 </code></p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WebAPIs</title>
    <link href="/2021/04/09/JavaScript/webapis/"/>
    <url>/2021/04/09/JavaScript/webapis/</url>
    
    <content type="html"><![CDATA[<h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ul><li>API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结其内在实现。</li><li>Web API主要是浏览器提供接口，允许我们操作BOM和DOM元素。</li><li>API一般都是函数或方法，有输入和输出，Web API也不例外。</li></ul><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（Document Object Model），是W3C阻止推荐的处理可扩展标记语言（HTML或XML）的标准编程接口。</p><p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p><h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p><img src="/2021/04/09/JavaScript/webapis/image-20210109150913764.png" alt="image-20210109150913764"></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM使用node表示节点，节点也就是一个个节点对象。</li><li>元素：HTML标签就是元素，DOM中使用element表示。</li><li>文档：一个页面就是一个文档，DOM中用document表示</li></ol><h4 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h4><ul><li>文档节点，特指 <code>document</code></li><li>元素节点，即标签, html节点是<code>document.documentElement</code></li><li>属性节点 , 可以通过element.getAttributeNode(attrName) 获得</li><li>文本节点</li></ul><h4 id="节点的共有属性"><a href="#节点的共有属性" class="headerlink" title="节点的共有属性"></a>节点的共有属性</h4><table><thead><tr><th></th><th>nodeName</th><th>nodeType</th><th>nodeValue</th></tr></thead><tbody><tr><td>文档节点</td><td>#document</td><td>9</td><td>null</td></tr><tr><td>元素节点</td><td>标签名大写 ⭐❗</td><td>1</td><td>null</td></tr><tr><td>属性节点</td><td>属性名小写  ❗</td><td>2</td><td>属性值</td></tr><tr><td>文本节点</td><td>#text</td><td>3 ⭐</td><td>文本内容 ⭐</td></tr></tbody></table><hr><h3 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h3><h4 id="兼容-IE8："><a href="#兼容-IE8：" class="headerlink" title="兼容 IE8："></a>兼容 IE8：</h4><ul><li><p><code>document.getElementById(id)</code></p></li><li><p><code>element.getElementsByTagName(tageName)</code></p></li><li><p><code>document.getElementsByName(name)</code></p></li></ul><h4 id="HTML5新增-IE9-："><a href="#HTML5新增-IE9-：" class="headerlink" title="HTML5新增 IE9+："></a>HTML5新增 IE9+：</h4><ul><li><code>element.getElementsByClassName(className)</code></li><li><code>element.querySelector(selector)</code></li><li><code>element.querySelectorAll(selector)</code></li></ul><h4 id="特殊元素的获取"><a href="#特殊元素的获取" class="headerlink" title="特殊元素的获取"></a>特殊元素的获取</h4><ul><li>html元素：<code>document.documentElement</code></li><li>body元素：<code>document.body</code></li><li>head元素：<code>document.head</code></li></ul><h4 id="查询方法分类"><a href="#查询方法分类" class="headerlink" title="查询方法分类"></a>查询方法分类</h4><ol><li><p>document的方法：</p><ul><li>getElementById</li><li>getElementsByName</li></ul></li><li><p>可以变化范围的属于一般element的方法：</p><ul><li>getElementsByTagName</li><li>getElementsByClassName</li><li>querySelector</li><li>querySelectorAll</li></ul></li><li><p>返回查询到的第一个元素的：</p><ul><li>getElementById</li><li>querySelector</li></ul></li><li><p>返回一个NodeList的：</p><ul><li>getElementsByName</li><li>getElementsByTagName</li><li>getElementsByClassName</li><li>querySelectorAll</li></ul><blockquote><p>NodeList是一个伪数组，在遍历功能上只实现了ForEach方法。</p></blockquote></li></ol><p>⭐ <strong>总结：</strong></p><ul><li><p><font color='red'>一共有6种DOM查询方法</font>。</p></li><li><p><font color='red'>两种方法只属于document</font>，分别为<code>document.getElementById</code>和<code>document.getElementsByName</code>；</p><p><font color='red'>其他四种方法都属于一般DOM元素</font>，且<font color='red'>搜寻范围为后代元素</font>。</p></li><li><p><font color='red'>两种方法只返回第一个查询到的DOM元素</font>，分别为<code>document.getElementById</code>和<code>node.querySelector</code>；</p><p><font color='red'>其他四种方法都返回一个NodeList。</font></p></li></ul><hr><h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><h4 id="1-子节点"><a href="#1-子节点" class="headerlink" title="1. 子节点"></a>1. 子节点</h4><ul><li><p><code>childNodes</code>属性</p><p>属性值为当前节点的所有子节点所组成的伪数组<code>NodeList</code>，包含文本子节点。</p></li><li><p><code>firstChild</code>属性</p><p>属性值为第一个子节点，如果不存在子节点，则值为<code>null</code></p></li><li><p><code>lastChild</code>属性</p><p>属性值为最后一个子节点，如果不存在子节点，则值为<code>null</code></p></li></ul><ul><li><p><code>children</code>属性</p><p>属性值为当前节点的所有<code>子元素节点</code>所组成的伪数组<code>NodeList</code>，不包含文本字节点。</p><blockquote><p>children属性是非标准属性，但兼容所有浏览器，放心使用。</p></blockquote></li><li><p><code>firstElementChild</code>属性 </p><p>IE9+支持，属性值为第一个<code>子元素节点</code>，如果不存在子元素节点，则值为<code>null</code></p><blockquote><p>实际开发中尽量使用node.children[0]代替firstElementChild</p></blockquote></li><li><p><code>lastElementChild</code>属性</p><p>IE9+支持，属性值为最后一个<code>子元素节点</code>，如果不存在子元素节点 ，则值为<code>null</code></p><blockquote><p>实际开发中尽量使用node.children[node.children.length-1]代替lastElementChild</p></blockquote></li></ul><h4 id="2-父节点"><a href="#2-父节点" class="headerlink" title="2. 父节点"></a>2. 父节点</h4><ul><li><p><code>parentNode</code>属性</p><p>返回当前节点的父节点。</p><blockquote><p>html的父节点是document，document的父节点是null。</p></blockquote></li></ul><h4 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="3. 兄弟节点"></a>3. 兄弟节点</h4><ul><li><p><code>previousSibling</code>属性</p><p>属性值为当前节点的前一个兄弟节点 （可能为文本节点），若不存在则值为<code>null</code></p></li><li><p><code>nextSibling</code>属性</p><p>属性值为当前节点的后一个兄弟节点（可能为文本节点），若不存在则值为<code>null</code></p></li></ul><ul><li><p><code>previousElementSibling</code>属性</p><p>IE9+支持，属性值为当前节点的前一个兄弟<code>元素节点 </code>，若不存在则值为<code>null</code></p></li><li><p><code>nextElementSibling</code>属性</p><p>IE9+支持，属性值为当前节点的后一个兄弟<code>元素节点</code>，若不存在则值为<code>null</code></p></li></ul><hr><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="读写文本或HTML片段"><a href="#读写文本或HTML片段" class="headerlink" title="读写文本或HTML片段"></a>读写文本或HTML片段</h4><p>通过以下DOM元素的属性，可以操作元素的内容：</p><ol><li><code>innerText</code></li><li><code>innerHTML</code></li><li><code>textContent</code></li></ol><p>区别：</p><ul><li><strong>innerText</strong>：返回由css决定的<font color='red'>可显示的后代节点中所有的文本内容，display: none的元素的文本子节点会被忽略。</font>文本节点text两端的空白字符会被忽略（导致全是空白字符的文本节点会被忽略），文本节点text内的换行符当作一个空格来处理，块元素的文本与其他文本节点内容之间用”\n”连接，内联元素的文本与文本节点的文本之间用””连接。❓ 由于受css影响，会触发回流 ❓。</li><li><strong>textContent</strong>：不受css影响，<font color='red'>display: none的元素不会被忽略</font>，返回所有子结点中所有的文本内容，保留所有空白字符。文本内容间用””连接。</li><li><strong>innerHTML</strong>：返回元素的HTML代码，保留所有空白字符。</li></ul><blockquote><p>以上属性都可以读写。</p></blockquote><hr><h4 id="DOM-增删改"><a href="#DOM-增删改" class="headerlink" title="DOM 增删改"></a>DOM 增删改</h4><p><strong>1. 创建文本节点</strong></p><p><code>document.createTextNode(text)</code></p><p>返回nodeValue为text的文本节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-built_in">document</span>.body.appendChild(tNode)<br></code></pre></td></tr></table></figure><p><strong>2. 创建元素节点</strong></p><ul><li><p>使用<code>document.createElement(tagName)</code></p><p>返回标签名为tagName的空元素节点</p></li><li><p>使用<code>node.innerHTML</code>创建子树</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">box.innerHTML = <span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">&lt;ul&gt;</span><br><span class="hljs-string">&lt;li&gt;&lt;/li&gt;</span><br><span class="hljs-string">&lt;/ul&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span><br></code></pre></td></tr></table></figure></li><li><p><code>document.write(htmlText)</code></p><p>在body元素中写入新的HTML片段，但如果实在文档流已经解析完的情况下调用该方法，会触发文档的重绘。</p></li></ul><blockquote><p>在为元素新增子节点或子树的操作中，相比于createElement创建元素再插入的做法，将html片段字符串赋值给父元素的innerHTML属性的做法效率更高。</p></blockquote><p><strong>3. 向父节点添加一个子节点（尾插）</strong></p><p><code>parentNode.appendChild(childNode)</code></p><p><strong>4. 在指定子节点前插入一个子节点</strong></p><p><code>parentNode.insertBefore(newChild, targetChild)</code></p><p><strong>5. 替换一个子节点</strong></p><p><code>parentNode.replaceChild(newChild, oldChild)</code></p><blockquote><p>如果oldChild不是parentNode的子节点，则会抛出异常。</p></blockquote><p><strong>6. 删除一个子节点</strong></p><p><code>parentNode.removeChild(childNode)</code></p><blockquote><p>如果childNode不是parentNode的子节点，则抛出异常。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.parent.removeChild(node); <span class="hljs-comment">// 自杀行为</span><br></code></pre></td></tr></table></figure><p><strong>7. 节点克隆</strong></p><p><code>node.cloneNode(deep = false)</code></p><p>该方法属于DOMNode，返回调用该方法的节点的一个副本。</p><p>deep参数可选，是否采用深度克隆。</p><ul><li>默认值为<code>false</code>，只克隆该节点本身（<font color='red'>如果为元素节点，则也会复制元素属性</font>）。</li><li>如果为<code>true,</code>则该节点的所有<font color='red'>后代元素节点</font>也都会被克隆，即会返回一棵节点树。</li></ul><blockquote><p><strong>关于deep参数默认值的问题：</strong></p><p>在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，<code>deep</code>是一个可选参数。如果省略的话，参数的默认值为 <code>true，</code>也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 <code>false。</code></p><p>在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。</p><p><font color='red'>所以在使用cloneNode方法时，最好明确deep参数的值，以防兼容性问题。</font></p></blockquote><blockquote><p><strong>关于克隆模板节点的Id和Name属性唯一性的问题：</strong></p><p>如果原始节点设置了ID，并且克隆节点会被插入到相同的文档中，那么应该更新克隆节点的ID以保证唯一性。name属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。</p><p><font color='red'>对存在Id或Name属性的节点进行克隆后，在将克隆节点插入到文档之前，应更新Id和Name属性。</font></p></blockquote><hr><h4 id="读写内置属性与自定义属性"><a href="#读写内置属性与自定义属性" class="headerlink" title="读写内置属性与自定义属性"></a>读写内置属性与自定义属性</h4><p><strong>1.内置属性的读写</strong></p><p>内置属性是HTML各类的标签所拥有的原生属性，包括普通的id、class、title以及img的src等。</p><p>内置属性可以直接通过 <code>element.xxx </code>读写。</p><p>内置属性也可以通过<code>element.getAttribute</code>读取，通过<code>element.setAttribute</code>修改。</p><blockquote><p>❗ 需要注意的是获取class属性值时，需要使用element.className，而不是class</p></blockquote><p><strong>2.自定义属性的读写</strong></p><p>自定义属性是指内置属性以外的标签属性，开发人员可以自定义属性上保存数据。</p><p>自定义属性可以通过element.getAttribute读取，element.setAttribute修改。</p><blockquote><p>使用element.getAttribute(attrName)，若属性不存在则返回null</p></blockquote><p>⭐ H5标准 ⭐</p><p>H5规范中要求自定义属性必须以<code>data-</code>开头。</p><p>以<code>data-</code>开头的自定义属性，除了可以用上述的<code>getAttribute</code>和<code>setAttribute</code>读写外，还可以在<code>element.dataset</code>中访问。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">data-my-prop</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 自定义属性 data-my-prop --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.getAttribute(<span class="hljs-string">&#x27;data-my-prop&#x27;</span>)); </span><br><span class="javascript">    <span class="hljs-comment">// 输出 123</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.dataset.myProp); <span class="hljs-comment">// 👈 驼峰命名法，不带 &#x27;data&#x27;</span></span><br><span class="javascript">    <span class="hljs-comment">// 输入 123</span></span><br><span class="javascript">    box.dataset.myProp = <span class="hljs-string">&#x27;321&#x27;</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 等价于data.dataset[&#x27;myProp&#x27;] = &#x27;321&#x27;;</span></span><br><span class="javascript">    <span class="hljs-comment">// 等价于 box.setAttribute(&#x27;data-my-prop&#x27;, &#x27;321&#x27;);</span></span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>❗ 兼容性问题：通过<code>element.dataset</code>访问自定义属性，只有<code>IE11+</code>兼容。</p></blockquote><p><strong>3. 删除属性</strong></p><p><code>element.removeAttribute(attrName)</code></p><p>如果指定的属性不存在也不会生成错误。</p><blockquote><p>若要彻底移除一个属性的效果，应当使用  <code>removeAttribute()</code>，而不是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute"><code>setAttribute()</code></a> 将属性值设置为 <code>null</code>。</p></blockquote><hr><h4 id="类名的增删查"><a href="#类名的增删查" class="headerlink" title="类名的增删查"></a>类名的增删查</h4><p><strong>1.读取class属性</strong></p><ul><li><p>element.className 属性，返回标签中class属性值，字符串类型。</p></li><li><p>element.classList 属性，返回标签中class属性值，伪数组类型<code>DOMTokenList</code>。</p></li><li><p>element.classList.value，返回标签中的class属性，字符串类型。</p></li><li><p>element.getAttribute(‘class’)，返回标签中class属性值，字符串类型。</p></li></ul><p><strong>2.增删类名</strong></p><ul><li><p>直接修改标签的class属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.className = <span class="hljs-string">&#x27;...&#x27;</span>;<br>element.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>封装操作className字符串的方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用正则表达式 ⭐</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elHasClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw <span class="hljs-string">`\b<span class="hljs-subst">$&#123;cn&#125;</span>\b`</span>);<br>    <span class="hljs-keyword">return</span> reg.test(el.className);<br>&#125;<br><span class="hljs-comment">// 增加一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(!elHasClassName(el, cn)) &#123;<br>        el.className = el.className + <span class="hljs-string">&#x27; &#x27;</span> + cn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 清除一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    el.className = el.className.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\b$(cn)\\b`</span>), <span class="hljs-string">&#x27;&#x27;</span>); <br>&#125;<br><span class="hljs-comment">// 切换一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(elHasClassName(el, cn)) &#123;<br>        removeClassName(el, cn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addClassName(el, cn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>通过element.classList的各种方法增删类名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. contains()方法，判断一个元素是否具有某一个类名</span><br>element.classList.contains(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 2. add()方法，增加一个或多个类名  兼容性:IE10+</span><br>element.classList.add(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2...&#x27;</span>);<br><br><span class="hljs-comment">// 3. remove()方法，删除1个或多个类名 兼容性 IE10+</span><br>element.classList.remove(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2&#x27;</span>);<br><br><span class="hljs-comment">// 4. toggle()方法，切换一个类名的存在状态 兼容性:IE10+</span><br>element.classList.toggle(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 5. replace()方法，将一个类名替换为新类名 ❗ 兼容性不好，尽量不要使用。其实也不好用。</span><br>element.classList.replace(<span class="hljs-string">&#x27;oldClassName&#x27;</span>, <span class="hljs-string">&#x27;newClassName&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>element.classList的类型<code>DOMTokenList</code>严格意义上是一个只读属性，但能通过该类型的方法（如add、remove）来改变自身的元素。<a href="https://developer.mozilla.org/en-US/docs/web/api/element/classlist">参考连接</a></p></blockquote></li></ul><hr><h4 id="读写样式"><a href="#读写样式" class="headerlink" title="读写样式"></a>读写样式</h4><p><strong>1. 读写内联样式</strong></p><ul><li>通过<code>element.style </code>读取css字符串，或 <code>element.style.样式名 </code>读取样式值。</li><li>通过 <code>element.style.样式名 = 样式值 </code>修改内联样式</li></ul><blockquote><p>通过JS访问元素的style属性只能够读写内联样式，不能读取到css样式表中的样式。</p></blockquote><p><strong>2.读取元素当前显示的样式</strong></p><ul><li><p><code>element.currentStyle.样式名</code></p><p>兼容性：<strong>只有IE支持</strong>。</p><p>可访问性：只读。</p><p>若元素未设置该样式，则返回该样式的默认值</p></li><li><p><code>window.getComputedStyle(element, null)</code></p><p>兼容性：只有IE9+支持。</p><p>可访问性：只读。</p><p>参数：getComputedstyle是window的方法，传入两个参数，第一个参数是所求元素，第二个参数传入一个伪元素（一般设置为null）。</p><p>返回值：返回一个对象，该对象封装了当前元素的样式。</p></li><li><p><code>兼容方案</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">el, prop</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle) &#123;<br>        <span class="hljs-keyword">return</span> getComputedStyle(el, <span class="hljs-literal">null</span>)[prop];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> el.currentStyle[prop];<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><p>事件三要素：</p><ol><li>事件源，谁发生了事件。（可以在响应函数中用event.target获取到）</li><li>事件类型，发生了什么事件。</li><li>事件处理程序，就是事件响应函数。</li></ol><h4 id="注册和移除事件的响应函数"><a href="#注册和移除事件的响应函数" class="headerlink" title="注册和移除事件的响应函数"></a>注册和移除事件的响应函数</h4><p><strong>1. 传统方式</strong></p><p><code>element.onclick = fn</code></p><p><code>element.onblur = fn</code></p><p><code>....</code></p><ul><li><p>这种方式具有唯一性，即同一元素只能对一个事件注册一个响应函数，后面注册的会覆盖前面的。</p></li><li><p>不存在兼容性问题。</p></li></ul><p><strong>移除响应函数：</strong><code>element.onclick = null</code></p><p><strong>2. W3C推荐的方式：监听事件</strong></p><p><code>element.addEventListener(事件名， listener, options/useCapture)</code></p><ul><li><p>事件名不带”on”。</p></li><li><p>可以为同一事件绑定多个响应函数，先注册的先执行。</p></li><li><p>允许输入<code>第三个参数</code>，如果第三个参数为<code>true</code>，则响应函数会在<code>捕获阶段执行</code>。</p></li><li><p>如果<code>第三个参数为Object类型</code>，则认为是一个<code>options对象</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    capture: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在捕获阶段执行listener</span><br>    once: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在listener执行一次后移除该listener，即只执行一次</span><br>    passive: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否不允许listener中执行preventDefault()</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>移除响应函数：</strong><code>element.removeEventListener(事件名, fn)</code></p><p><strong>3. IE6~8的方式</strong></p><p><code>element.attachEvent(on事件名，fn)</code></p><ul><li>事件名带”on”。</li><li>可以为同一事件绑定多个响应函数，<code>先注册的后执行</code>。</li><li>这种方式绑定的响应函数只会在冒泡阶段执行。</li></ul><p><strong>移除响应函数：</strong> <code>element.detachEvent(on事件名，fn)</code></p><p><strong>4. 兼容性解决方案</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注册事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.addEventListener) &#123;<br>        el.addEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.attachEvent) &#123;<br>        el.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = fn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 移除事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.removeEventListener) &#123;<br>        el.removeEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.detachEvent) &#123;<br>        el.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="事件流（事件的传播）"><a href="#事件流（事件的传播）" class="headerlink" title="事件流（事件的传播）"></a>事件流（事件的传播）</h4><p><strong>概念</strong></p><p>事件流描述的是从页面中接收事件的顺序。</p><p>事件发生时会在元素节点之间按照<code>从外至内、从内向外</code>的顺序传播，这个<code>传播过程</code>叫做DOM事件流。</p><p>比如我们给一个div注册了单击事件的响应函数：</p><p><img src="/2021/04/09/JavaScript/webapis/image-20210115202428033.png" alt="image-20210115202428033"> </p><p><strong>事件传播的三个阶段</strong></p><p>W3C综合了网景和微软的方案，将DOM事件流分为三个阶段：</p><ol><li>捕获阶段：从最外层的祖先元素向目标元素进行捕获，但默认此时不会触发事件的响应函数。（网景提出）</li><li>目标阶段：捕获到目标元素，按顺序执行响应函数。</li><li>冒泡阶段：向祖先元素传递，依次触发祖先元素上的事件响应函数。（微软提出）</li></ol><blockquote><ul><li>如果希望在捕获阶段执行响应函数，则需要将addEventListener方法的第三个参数设置为true，则该次注册的响应函数会在捕获阶段执行。</li><li>IE8及以下没有捕获阶段，使用<code>传统方法</code>和<code>attachEvent</code>方法注册的函数永远<code>不会在捕获阶段执行</code>。</li></ul></blockquote><p>❗ <strong>误区</strong> ❗：<code>在目标阶段</code>，即使是设置为捕获阶段执行的响应函数，不一定会在冒泡型响应函数之前执行。</p><p>举例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble body&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定捕获阶段的响应函数</span></span><br><span class="javascript"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture body&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">//true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble box&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定捕获阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture box&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble content&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定捕获阶段的响应函数</span></span><br><span class="javascript">       content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture content&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 👇 结果输出 👇 --&gt;</span><br>capture body<br>capture box<br>bubble content   <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 原因是在事件传播到了content时已经处于目标阶段<br>capture content  <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 目标阶段会按照函数注册的顺序执行，而不会考虑该函数是在哪个阶段执行<br>bubble box<br>bubble body<br><span class="hljs-comment">&lt;!------------------&gt;</span><br><br></code></pre></td></tr></table></figure><hr><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p><strong>概念</strong></p><p>当DOM事件发生时，浏览器都会按照事件流将一个事件对象传递给各元素的响应函数。</p><p>在事件对象中封装了当前事件相关的一切信息，比如事件源、事件类型、鼠标的坐标、键盘的键位等。</p><blockquote><p>在捕获阶段，响应函数中的target属性已经存在，且指向事件源。</p></blockquote><p><strong>兼容性</strong></p><p>IE6~8浏览器将事件对象保存在了window.event属性中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;<br>    evt = evt || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-built_in">console</span>.log(evt);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件对象的常见属性和方法</strong></p><table><thead><tr><th>事件对的属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>e.target</td><td>返回触发事件的源对象    ✔ 标准  ⭐</td></tr><tr><td>window.event.srcElement</td><td>返回触发事件的源对象    ❌ 非标准，IE6~8使用</td></tr><tr><td>e.type</td><td>返回时间的类型 比如 click mouseover 不带”on” ⭐</td></tr><tr><td>window.event.cancelBubble</td><td>布尔值，该属性值设为false则阻止冒泡 ❌ 非标准 ，IE6~8使用</td></tr><tr><td>window.event.returnValue</td><td>布尔值，该属性值设为false则阻止事件的默认行为 ❌非标准 IE6~8使用， Chrome、火狐兼容，IE9+反而不兼容。                                                                                    反正就不要用这个属性了, 用return false就可以。</td></tr><tr><td>e.preventDefault()</td><td>该方法阻止事件的默认行为         ✔ 标准   ⭐</td></tr><tr><td>e.preventPropagation()</td><td>该方法阻止事件的传播，包括捕获和冒泡。 ✔ 标准 ⭐</td></tr></tbody></table><blockquote><p>在事件的响应函数中，要区分this 和 e.target，this不一定是事件源。</p></blockquote><hr><h4 id="阻止事件的默认行为"><a href="#阻止事件的默认行为" class="headerlink" title="阻止事件的默认行为"></a>阻止事件的默认行为</h4><ol><li><code>preventDefault()</code></li><li><code>return false</code></li><li><code>event.returnValue = false</code> ❌ 兼容性很奇葩，不推荐使用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-comment">// 第一种方式</span><br>    <span class="hljs-keyword">if</span>(e.preventDefault) e.preventDefault();  <span class="hljs-comment">// IE9+支持</span><br>    <br>    <span class="hljs-comment">// .....</span><br>    <span class="hljs-comment">// 因为IE6~8 不认识 preventDefault方法</span><br><br>    <span class="hljs-comment">// 第二种方式</span><br>    e.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ❌ IE9~11不支持，IE6~8支持，其他浏览器支持。</span><br>    <br>    <span class="hljs-comment">// 第三种方式，兼容所有浏览器的方法 👇</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 兼容性做法 </span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><ol><li><code>event.preventPropagation()</code>  👈 IE9+ 不只是阻止冒泡，也会中断事件的捕获。</li><li><code>window.event.cancelBubble = true</code> 👈 IE6~8</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-keyword">if</span>(e.preventPropagation) &#123;<br>        e.preventPropagation();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        e.cancelBubble = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="冒泡的应用：事件委托"><a href="#冒泡的应用：事件委托" class="headerlink" title="冒泡的应用：事件委托"></a>冒泡的应用：事件委托</h4><p>事件委托也称为事件代理，在jQuery中也叫做事件委派。</p><p><strong>原理：</strong></p><p>不是在每个子节点上单独设置事件监听器，而是在父节点上设置事件监听器，然后利用冒泡原理监听所有子节点的某个事件。</p><hr><h4 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h4><table><thead><tr><th>鼠标事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标左键单击一次触发</td></tr><tr><td>ondbclick</td><td>鼠标左键双击一次触发</td></tr><tr><td>onmouseover</td><td>鼠标进入元素范围触发，<code>会进行冒泡</code>。</td></tr><tr><td>onmouseout</td><td>鼠标离开元素范围触发，<code>会进行冒泡</code>。</td></tr><tr><td>onfocus</td><td>获得鼠标焦点</td></tr><tr><td>onblur</td><td>失去鼠标焦点</td></tr><tr><td>onmousemove</td><td>鼠标在元素范围内移动“1px”触发。</td></tr><tr><td>onmousedown</td><td>鼠标按下一次触发。滚轮、右键、上下翻页键也会触发。</td></tr><tr><td>onmouseup</td><td>鼠标松开一次触发。滚轮、右键、上下翻页键也会触发。</td></tr><tr><td>onmouseenter</td><td>鼠标进入元素范围触发，<code>不会冒泡</code>。⭐</td></tr><tr><td>onmouseleave</td><td>鼠标离开元素范围触发，<code>不会冒泡</code>。⭐</td></tr></tbody></table><ul><li><p>onmousedown事件，单次点击只会触发一次，直到松开鼠标键后才会触发下一次。</p></li><li><p>onmouseenter/ onmouseleave 和 onmouseover/ onmouseout 之间的区别是 “是否会触发冒泡”。</p><p>前一组不会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>不会触发</code>父容器的鼠标enter/ leave。</p><p>后一组会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>会多次触发</code>父容器的鼠标over/ out。</p><blockquote><p><strong>mouseover和mouseenter的另外一个区别</strong></p><p>鼠标从父容器独有的范围内进入后代元素的范围，会先触发父容器的mouseout，再触发后代元素的mouseover，然后再冒泡父容器的mouseover。</p><p>鼠标从后代元素范围中挪出，进入父容器独有的范围会先冒泡onmouseout， 然后再次触发父容器的onmouseover。</p></blockquote></li></ul><p><strong>鼠标事件对象的属性</strong></p><ul><li><p><code>type</code>属性标识了鼠标事件的类型，如click, mousedown, mouseenter等。</p></li><li><p><code>which</code>属性标识了鼠标按键。</p><p>1：没有按键或左键</p><p>2：滚轮按下</p><p>3：右键</p></li><li><p><code>clientX</code> / <code>clientY</code> 属性，是鼠标事件发生的位置相对于浏览器视口左上角的偏移量。</p></li><li><p><code>pageX</code> / <code>pageY</code> 属性，是鼠标事件发生的位置相对于页面（布局视口）左上角的偏移量。不论页面怎么滚动，鼠标点击页面中同一位置时，event.pageX 和 event.pageY的值不会发生改变。</p><blockquote><p>pageX / pageY属性仅在 IE9+中支持。</p></blockquote></li><li><p><code>screenX</code> / <code>screenY</code> 属性，是鼠标事件发生的位置相对于设备屏幕左上角的偏移量。</p></li></ul><hr><h4 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h4><table><thead><tr><th>键盘事件</th><th>触发条件</th></tr></thead><tbody><tr><td>onkeyup</td><td>某个键盘按键松开时会<code>触发一次</code>。⭐ 尽可能用onkeyup，因为不会不断触发。</td></tr><tr><td>onkeydown</td><td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td></tr><tr><td>onkeypress</td><td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td></tr></tbody></table><p>onkeydown和onkeypress的区别在于：</p><ol><li><p>onkeypress不会识别功能键。即Backspace、ctrl、alt、shift、箭头方向键按下时，不会触发onkeypress事件。</p><p>而onkeydown能够识别功能键。</p></li><li><p>onkeydown不区分按键的大小写，即按下a和大写A时都认为按下了”a”，keyCode都是97。</p></li><li><p>在函数执行顺序上，onkeydown事件绑定的响应函数会先于onkeypress事件绑定的响应函数。</p></li></ol><blockquote><p>在input标签中onkeydown/ onkeypress事件的回调函数会先于input标签更新value执行。</p><p>所以要获取键盘输入后的input的value值，应该在onkeyup的响应函数中才能获取。</p></blockquote><p><strong>键盘事件对象的属性</strong></p><ul><li><p><code>keyCode</code>属性</p><p>键盘键位的asc码值</p></li></ul><ul><li><p><code>key</code>属性，IE9+支持</p><p>键盘键位的特征字符串</p><ol><li>回车 Enter</li><li>退格 Backspace</li><li>大写键 CapsLock</li><li>大写键盘开启按a A</li><li>….</li></ol></li></ul><hr><h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p><strong>1. 阻止鼠标右键菜单的显示</strong></p><p><code>contextmenu</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault()); <span class="hljs-comment">// 这里好像不能用return false</span><br><span class="hljs-comment">// html.addEventListener(&#x27;contextmenu&#x27;, e =&gt; e.preventDefault()); 对html绑定也可以</span><br><span class="hljs-comment">// 对其他指定DOM元素绑定也可以，实现阻止局部范围内右键菜单的显示。</span><br></code></pre></td></tr></table></figure><p><strong>2. 不允许选中内容</strong></p><p><code>selectstart</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault());<br></code></pre></td></tr></table></figure><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model，浏览器对象模型，它提供独立于内容而与浏览器窗口进行交互的对象，其<code>核心+顶级</code>的对象是window。</p><p>简而言之，BOM为我们提供了一组对象，用来完成对浏览器的操作。</p><blockquote><p>BOM缺乏标准， JavaScript语法的标准化组织是ECMA，DOM的标准化阻止是W3C，而BOM最初是Netscape浏览器标准的一部分。</p></blockquote><h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><p>BOM比DOM更大，它包含了DOM。</p><p><img src="/2021/04/09/JavaScript/webapis/image-20210123104526159.png" alt="image-20210123104526159"> </p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p><font color="red">window对象是浏览器的顶级对象，它具有双重角色</font></p><ol><li><p>它是JS访问浏览器的一个接口</p></li><li><p>它是一个全局对象。定在<code>全局作用域中的变量和函数</code>会分别成为<code>window对象的属性和方法</code>。</p><p>在调用全局函数、访问全局变量时，可以省略书写window。</p><blockquote><p>注意：window下存在一个特殊属性window.name，所以不要在全局作用域中用”name”作为变量名。</p></blockquote></li></ol><hr><h4 id="onload事件"><a href="#onload事件" class="headerlink" title="onload事件"></a>onload事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    ...<br>&#125;;<br><br><span class="hljs-comment">// 或者使用标准方法可绑定多个页面加载完成的响应函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure><p>window.onload是窗口（页面）加载事件，当文档的内容<code>完全加载完成</code>后才会触发该事件，<code>包括图像的加载、脚本文件、CSS文件等</code>。</p><hr><h4 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br><span class="hljs-comment">// 这个事件只能这样绑定响应函数</span><br></code></pre></td></tr></table></figure><p>DOMContentLoaded事件会在<code>DOM加载完成时</code>就触发，<code>不会等待图片、flash、样式表的加载</code>。</p><blockquote><p>❗ 兼容性：IE9+支持，且只能使用标准方法绑定响应函数。</p></blockquote><p>如果<code>页面的图片很多</code>的话，从页面打开到onload事件触发可能需要很长的事件，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适。</p><hr><h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-comment">// </span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure><p>window.onresize是调整浏览器窗口大小的事件。</p><p>只要窗口的尺寸发生变化，就会触发这个事件。我们会利用这个事件完成<code>响应式布局、移动端适配</code>等，会用到相关的属性有<code>window.innerWidth</code>、<code>window.innerHeigth</code>。</p><blockquote><p>⭐区别：window.innerWidth / window.innerHeight和documentElement.clientWidth、clientHeight都是描述浏览器视口尺寸的属性，他们的区别在于前一组包含html滚动条的宽度，后一组不包含html滚动条的宽度。</p><p>此外，window还有<code>outerWidth</code>和<code>outerHeight</code>属性，他们表示整个浏览器窗口的尺寸，包含菜单、工具栏等。</p></blockquote><hr><h4 id="对话框方法"><a href="#对话框方法" class="headerlink" title="对话框方法"></a>对话框方法</h4><ol><li><p><code>alert(message)</code> 显示带有一段消息和一个确认按钮的对话框。</p><blockquote><p>参数message是对话框中要显示的信息。</p></blockquote></li></ol><ol start="2"><li><p><code>confirm(message)</code>显示带有一段消息和确认、取消两个按钮的对话框。</p><blockquote><p><code>message参数</code>是对话框中的提示信息，confirm方法会<code>返回一个布尔值</code>，当用户点击确认会返回<code>true</code>，取消会返回<code>false</code>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;当前操作会引发危险，是否继续？&#x27;</span>);<br><span class="hljs-keyword">if</span>(ret) &#123;<br>    <span class="hljs-comment">// continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// stop</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><code>prompt(message, value)</code>显示可提示用户输入的对话框。</p><blockquote><p><code>message参数</code>是对话框中的提示信息，<code>value参数</code>是输入框中的默认值，默认为空字符串。<code>prompt方法会返回一个字符串</code>，该字符串是用户在对话框的输入框中输入的内容。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.prompt(<span class="hljs-string">&#x27;请输入您想输入的内容&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(ret);<br></code></pre></td></tr></table></figure></li></ol><h4 id="定时器方法"><a href="#定时器方法" class="headerlink" title="定时器方法"></a>定时器方法</h4><ol><li><p><code>setTimeout(cb, timeout) / clearTimeout(timer)</code></p></li><li><p><code>setInterval(cb, interval) / clearInterval(timer)</code></p></li></ol><hr><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是window对象的一个属性，它提供了读写浏览器窗体的URL的接口，并且封装了对URL的解析结果。</p><p>URL的一般语法格式为：</p><p><code>protocol://hostName[:port]/path/[?query]#fagnent</code></p><h4 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h4><ol><li><code>href</code> 整个URL</li><li><code>protocol</code> 协议名 + “:”</li><li><code>host</code> IP地址 / 域名 + 端口号</li><li><code>port</code> url显式的端口号，如果是域名，则该值为空串</li><li><code>hostname</code> IP地址 / 域名</li><li><code>pathname</code> path字符串，”/“ 开头</li><li><code>search</code> query字符串，”?” 开头</li><li><code>hash</code> fragnent字符串，”#” 开头</li></ol><h4 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h4><ol><li><p><code>assign(url)</code> </p><p>用于跳转页面，作用和直接修改<code>location</code>或<code>location.href</code>效果相同。</p></li><li><p><code>replace(url)</code></p><p>同样是用于跳转页面，用法和<code>assign</code>相同，但会重置栈顶并跳转，即无法回退到前一个url对应的页面。</p></li><li><p><code>reload([forcedReload])</code></p><p>用于刷新页面，作用相当于按下<code>F5</code>。forcedReload参数可选，表示是否强制清除缓存，如果为<code>true</code>，相当于按下<code>ctrl+F5</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.reload(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="通过location对象进行页面跳转"><a href="#通过location对象进行页面跳转" class="headerlink" title="通过location对象进行页面跳转"></a>通过location对象进行页面跳转</h4><p>实现跳转的方法有很多：</p><ul><li>```javascript<br>location = url;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.href = url<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><pre><code class="javascript">location.assign(url);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.replace(url)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>&gt; url要求是一个字符串类型，可以是完整的url，也可以是相对路径，也可以是以&quot;/&quot;开头的根路径。</code></pre></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.assign(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;image/1.png&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;../index.html&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;/index.html&#x27;</span>);<br></code></pre></td></tr></table></figure><hr><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>window对象的history属性让我们能够与浏览器的历史记录进行交互。</p><h4 id="history对象的属性"><a href="#history对象的属性" class="headerlink" title="history对象的属性"></a>history对象的属性</h4><ol><li><p><code>length</code></p><p>可以获取到当前访问过的链接数量，其实就是保存访问url顺序的栈结构的长度。</p></li></ol><h4 id="前后跳转页面的方法"><a href="#前后跳转页面的方法" class="headerlink" title="前后跳转页面的方法"></a>前后跳转页面的方法</h4><ol><li><p><code>history.go(n)</code></p><p>传入一个整数参数，表示跳转步长，正为前进，负为后退。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">history.go(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p><code>history.back()</code></p><p>回退到上一个页面，作用和浏览器回退按钮一样，相当于<code>history.go(-1)</code>。</p></li><li><p><code>history.forward()</code></p><p>跳转到下一个页面，作用和浏览器前进按钮一样，相当于<code>history.go(1)</code>。</p></li></ol><h4 id="H5新增方法（与前端路由相关）"><a href="#H5新增方法（与前端路由相关）" class="headerlink" title="H5新增方法（与前端路由相关）"></a>H5新增方法（与前端路由相关）</h4><p>🐕 后续补充</p><hr><h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象包含有关客户端的信息，它有很多熟悉，我们最常用的是<code>navigator.userAgent</code>。</p><p><code>navigator.userAgent </code>是一个只读的字符串，声明了浏览器用于 <code>HTTP 请求的用户代理头</code>的值。</p><p><code>User-Agent</code>是HTTP请求中的用户标识，一般发送一个能够代表客户端类型的字符串，比如浏览器类型 操作系统等信息。User-Agent 的约定格式是：应用名，跟一个斜线，跟版本号，剩下的是自由的格式。</p><blockquote><p>一般都是以 Mozilla/5.0 开头</p></blockquote><p>对于前端而言：</p><p><code>navigator.userAgent</code>可以帮助我们识别设备、平台、浏览器，从而进行兼容处理。</p><blockquote><p>根据具体情况，到百度查找识别方法。因为navigator.userAgent属性值千奇百怪，缺乏标准。</p></blockquote><p>对于后端而言：</p><p><code>navigator.userAgent</code>会赋值给<code>HTTP</code>中头部信息的<code>User-Agent</code>，用于通知后端HTTP请求来源于什么设备、什么平台、什么浏览器。</p><hr><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>PC端一般不用。🐕 后续补充内容</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Scss</title>
    <link href="/2021/03/25/CSS/scss/"/>
    <url>/2021/03/25/CSS/scss/</url>
    
    <content type="html"><![CDATA[<h1 id="SCSS"><a href="#SCSS" class="headerlink" title="SCSS"></a>SCSS</h1><h2 id="不依赖于IDE的sass安装"><a href="#不依赖于IDE的sass安装" class="headerlink" title="不依赖于IDE的sass安装"></a>不依赖于IDE的sass安装</h2><h3 id="node-sass"><a href="#node-sass" class="headerlink" title="node-sass"></a>node-sass</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i -g node-sass<br></code></pre></td></tr></table></figure><p><strong>基本使用</strong></p><ul><li><p>单文件编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span>-sass  原有的scss文件 生成的css文件<br><span class="hljs-variable">$node</span>-sass  原有的scss文件 -o 生成目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass a.scss b.css<br><span class="hljs-variable">$node</span>-sass a.scss css_files<br></code></pre></td></tr></table></figure></li><li><p>多文件编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$node</span>-sass 原有的scss文件目录 -o 生成的css文件目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass c -o d<br></code></pre></td></tr></table></figure></li><li><p>文件监听模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在&quot;1&quot;和&quot;2&quot;的基础上填加&quot;-w&quot;命令行参数即可</span><br><span class="hljs-variable">$node</span>-sass -w 原有的scss文件 -o 输出目录 <span class="hljs-comment">#编译的结果会保存在输出目录的同名文件</span><br><span class="hljs-variable">$node</span>-sass -w 原有的scss文件目录 -o css文件输出目录<br><br><span class="hljs-comment"># example:</span><br><span class="hljs-variable">$node</span>-sass -w a.scss -o css<br><span class="hljs-variable">$node</span>-sass -w scss -o css<br><br><span class="hljs-comment"># 效果：编译进程不结束，监听文件内容</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs">  <br>  <br><br>&gt; -o 相当于--output，之后跟输出的目录<br>&gt;<br>&gt; -w 参数相当于--watch， 不跟参数值，用于监听目标文件/目录<br><br><br><br>## 注释<br><br>1. Sass 支持标准的 CSS 多行注释 `/* */`，以及单行注释 `//`，前者会被完整输出到编译后的 CSS 文件中，而后者则不会, 所以后者亦称作`静默注释`。<br><br>2. 将 `!` 作为多行注释的第一个字符表示在压缩输出模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。<br><br>3. 插值语句 (interpolation) 也可写进多行注释中输出变量值<br><br>例如：<br><br>​```scss<br>/* <br>hello<br>world!<br>*/<br><br>// compile scss files to css<br>// it&#x27;s ready to do it.<br>$pink: #f3e1e1;<br><span class="hljs-attribute">html&#123;</span><br>    background-color: $pink;<br>&#125;<br><br>$author: &#x27;gdream@126.com&#x27;;<br>/*!<br>Author: #&#123;$author&#125;.   语法👉 #&#123;插值内容&#125;<br>*/<br></code></pre></td></tr></table></figure><p>开发模式编译后：</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* </span><br><span class="hljs-comment">hello</span><br><span class="hljs-comment">world!</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">html</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f3e1e1</span>;<br>&#125;<br><span class="hljs-comment">/*!</span><br><span class="hljs-comment">Author: &#x27;gdream@126.com&#x27;.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$width</span>: <span class="hljs-number">1600px</span>;<br><span class="hljs-variable">$pen-size</span>: <span class="hljs-number">3em</span>;<br></code></pre></td></tr></table></figure><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p>直接使用变量的名称即可调用变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#app</span> &#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-variable">$width</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$pen-size</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3.作用域"></a>3.作用域</h3><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明 </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#foo</span> &#123;<br>  <span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span> !global;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-id">#bar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#foo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br><br><span class="hljs-selector-id">#bar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>SassScript 支持 7 种主要的数据类型：</p><ul><li><p>数字，<code>1, 2, 13, 10px, 5a</code> </p><blockquote><p>整数/小数 [+ 英文单位]</p></blockquote></li><li><p>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, &#39;bar&#39;, baz</code></p><blockquote><p>尽量使用带双引号的字符串</p></blockquote></li><li><p>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></p></li><li><p>布尔型，<code>true, false</code></p></li><li><p>空值，<code>null</code></p><blockquote><p>不常用，一般用在逻辑判断中</p></blockquote></li><li><p>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></p></li><li><p>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></p></li></ul><p>SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p><p>判断数据类型的方式：<code>type-of($value)</code></p><h3 id="1-字符串-Strings"><a href="#1-字符串-Strings" class="headerlink" title="1.字符串 (Strings)"></a>1.字符串 (Strings)</h3><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>，和<code>无引号字符串 (unquoted strings)</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$name</span>: <span class="hljs-string">&#x27;Tom Bob&#x27;</span>;<br><span class="hljs-variable">$container</span>: <span class="hljs-string">&quot;top bottom&quot;</span>;<br><span class="hljs-variable">$what</span>: heart;<br></code></pre></td></tr></table></figure><blockquote><p>注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 <code>#&#123;&#125;</code> (interpolation)  /ɪnˌtɜːpəˈleɪʃn/ 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$div</span>: <span class="hljs-string">&quot;div&quot;</span>;<br><span class="hljs-keyword">@mixin</span> boxFontSize(<span class="hljs-variable">$index</span>, <span class="hljs-variable">$fontSize</span>) &#123;<br><span class="hljs-selector-class">.box-</span>#&#123;<span class="hljs-variable">$index</span>&#125; &#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$fontSize</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-selector-tag">html</span> &#123;<br><span class="hljs-keyword">@include</span> boxFontSize(<span class="hljs-number">1</span>, <span class="hljs-number">16px</span>);<br>&#125;<br><br><span class="hljs-comment">// 编译结果 👇</span><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-class">.box-1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="2-数字-Numbers"><a href="#2-数字-Numbers" class="headerlink" title="2.数字(Numbers)"></a>2.数字(Numbers)</h3><p>SassScript支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可整可浮点）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$my-age</span>: <span class="hljs-number">19</span>;<br><span class="hljs-variable">$your-age</span>: <span class="hljs-number">19.5</span>;<br><span class="hljs-variable">$height</span>: <span class="hljs-number">120px</span>;<br><br><span class="hljs-comment">// 注：单位会和数字当做一个整体，进行算数运算</span><br></code></pre></td></tr></table></figure><h3 id="3-空值-Null"><a href="#3-空值-Null" class="headerlink" title="3.空值(Null)"></a>3.空值(Null)</h3><p>只有一个取值<code>null</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$value</span>: null;<br><br><span class="hljs-comment">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span><br></code></pre></td></tr></table></figure><h3 id="4-布尔型-Booleans"><a href="#4-布尔型-Booleans" class="headerlink" title="4.布尔型(Booleans)"></a>4.布尔型(Booleans)</h3><p>只有两个取值：<code>true</code>和<code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: true;<br><span class="hljs-variable">$b</span>: false;<br></code></pre></td></tr></table></figure><blockquote><p>注：只有自身是false和null在逻辑判断时才会返回false，其他一切都将返回true</p></blockquote><h3 id="5-数组-Lists"><a href="#5-数组-Lists" class="headerlink" title="5.数组 (Lists)"></a>5.数组 (Lists)</h3><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组 —— 只包含一个值的数组。索引从<code>1</code>开始</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$list0</span>: <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">6px</span>;<br><span class="hljs-variable">$list1</span>: <span class="hljs-number">1px</span> <span class="hljs-number">2px</span>, <span class="hljs-number">5px</span> <span class="hljs-number">6px</span>;<br><span class="hljs-variable">$list2</span>: (<span class="hljs-number">1px</span> <span class="hljs-number">2px</span>) (<span class="hljs-number">5px</span> <span class="hljs-number">6px</span>);<br></code></pre></td></tr></table></figure><p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p><p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p><p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p><p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p><h3 id="6-映射-Maps"><a href="#6-映射-Maps" class="headerlink" title="6.映射(Maps)"></a>6.映射(Maps)</h3><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$map</span>: ( <br>  key1: value1, <br>  key2: value2, <br>  key3: value3,<br>  <span class="hljs-string">&quot;1&quot;</span> : value4,<br>   <span class="hljs-number">1</span>: value5     // <span class="hljs-string">&quot;1&quot;</span>和<span class="hljs-number">1</span> 是不同数据类型，是不同的键<br>)<br></code></pre></td></tr></table></figure><blockquote><p>Maps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。 和Lists不同Maps必须被圆括号包围，键和值之间用<code>冒号</code>连接，键值对之间用<code>逗号</code>分割 。</p><p>Maps中的<code>keys和values</code>可以是sass script的<code>任何数据类型</code>。（包括任意的sassscript表达式 arbitrary SassScript expressions）</p><p>和Lists一样，Maps主要为sass script函数服务，</p><p>如 map-get函数用于查找键值，</p><p>map-get($map, key1)、map-get($map, “key1”)</p><p>map-merge函数用于map和新加的键值融合，</p><p>@each命令可添加样式到一个map中的每个键值对。</p><p>Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。</p></blockquote><h3 id="7-颜色-Colors"><a href="#7-颜色-Colors" class="headerlink" title="7.颜色 (Colors)"></a>7.颜色 (Colors)</h3><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词。</p><p>SCSS提供了与颜色有关的内置函数，从而使用户能够更方便地使用颜色。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$color0</span>: green;<br><span class="hljs-variable">$color1</span>: lighten(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color2</span>: darken(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color3</span>: saturate(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color4</span>: desaturate(<span class="hljs-variable">$color</span>, <span class="hljs-number">15%</span>);<br><span class="hljs-variable">$color5</span>: (green + red);<br></code></pre></td></tr></table></figure><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h3><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值</p><p>如果要保留运算符号，则应该使用插值语法</p><ul><li><p><code>+</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 纯数字</span><br><span class="hljs-variable">$add1</span>: <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<span class="hljs-comment">// 3</span><br><span class="hljs-variable">$add2</span>: <span class="hljs-number">1</span> + <span class="hljs-number">2px</span>; <span class="hljs-comment">// 3px</span><br><span class="hljs-variable">$add3</span>: <span class="hljs-number">1px</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 3px</span><br><span class="hljs-variable">$add4</span>: <span class="hljs-number">1px</span> + <span class="hljs-number">2px</span>;<span class="hljs-comment">//3px</span><br><br><span class="hljs-comment">// 纯字符串</span><br><span class="hljs-variable">$add5</span>: <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">// &quot;ab&quot;</span><br><span class="hljs-variable">$add6</span>: <span class="hljs-string">&quot;a&quot;</span> + b;  <span class="hljs-comment">// &quot;ab&quot;</span><br><span class="hljs-variable">$add7</span>: a + <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-comment">// ab</span><br><span class="hljs-variable">$add8</span>: a + b;  <span class="hljs-comment">// ab</span><br><br><span class="hljs-comment">// 数字和字符串</span><br><span class="hljs-variable">$add9</span>: <span class="hljs-number">1</span> + a;<span class="hljs-comment">// 1a</span><br><span class="hljs-variable">$adda</span>: a + <span class="hljs-number">1</span>;<span class="hljs-comment">// a1</span><br><span class="hljs-variable">$addb</span>: <span class="hljs-string">&quot;1&quot;</span> + a; <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-variable">$addc</span>: <span class="hljs-number">1</span> + <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-variable">$addd</span>: <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// &quot;a1&quot;</span><br><span class="hljs-variable">$adde</span>: a + <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// a1</span><br><span class="hljs-variable">$addf</span>: <span class="hljs-number">1</span> + <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// &quot;11&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 总结：</span><br><span class="hljs-selector-tag">a</span>.纯数字：只要表达式中某个数字值带有单位，则结果必有单位。<br><span class="hljs-selector-tag">b</span>.纯字符串：第一个字符串有无引号决定结果是否有引号<br>c数字和字符串：结果一定为字符串。数字与字符串的加法表达式中，最靠左的字符串字面量是否带引号，将决定相加的结果字符串是否带引号。<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>-</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$add1</span>: <span class="hljs-number">1</span> - <span class="hljs-number">2</span>;<span class="hljs-comment">// -1</span><br><span class="hljs-variable">$add2</span>: <span class="hljs-number">1</span> - <span class="hljs-number">2px</span>; <span class="hljs-comment">// -1px</span><br><span class="hljs-variable">$add3</span>: <span class="hljs-number">1px</span> - <span class="hljs-number">2</span>; <span class="hljs-comment">// -1px</span><br><span class="hljs-variable">$add4</span>: <span class="hljs-number">1px</span> - <span class="hljs-number">2px</span>;<span class="hljs-comment">//-1px</span><br><br><span class="hljs-variable">$sub1</span>: a - <span class="hljs-number">1</span>;  <span class="hljs-comment">// a-1</span><br><span class="hljs-variable">$sub2</span>: <span class="hljs-number">1</span> - a;  <span class="hljs-comment">// 1-a</span><br><span class="hljs-variable">$sub3</span>: <span class="hljs-string">&quot;a&quot;</span> - <span class="hljs-number">1</span>;<span class="hljs-comment">// &quot;a&quot;-1</span><br><span class="hljs-variable">$sub4</span>: a - <span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-comment">// a-&quot;1&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>减法表达式中出现字符串类型， 则整个表达式视作一个字符串。</p></blockquote></li></ul><ul><li><p><code>*</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$num1</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2</span>;    <span class="hljs-comment">// 2</span><br><span class="hljs-variable">$mul2</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2px</span>;  <span class="hljs-comment">// 2px</span><br><span class="hljs-variable">$num3</span>: <span class="hljs-number">1px</span> * <span class="hljs-number">2</span>;  <span class="hljs-comment">// 2px</span><br><span class="hljs-variable">$num4</span>: <span class="hljs-number">2px</span> * <span class="hljs-number">2px</span>;<span class="hljs-comment">// 编译不通过</span><br><br><span class="hljs-variable">$num5</span>: <span class="hljs-number">1</span> * <span class="hljs-number">2</span>abc; <span class="hljs-comment">// 2abc</span><br></code></pre></td></tr></table></figure><blockquote><p>允许至多一个带单位的数字出现在乘号两侧。</p></blockquote></li></ul><ul><li><p><code>/</code></p><blockquote><p>不会四舍五入，精确到小数点后5位。</p><p>被除数允许带单位，除数不允许带单位。</p></blockquote></li></ul><ul><li><p><code>%</code></p><blockquote><p>表达式两侧的值与”%”之间必须要有空格，否则会被看做字符串</p></blockquote></li></ul><h3 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h3><p>大前提：两端必须为<code>数字类型</code>， 单位不同的数字之间无法比较。 </p><p>返回值：<code>true</code> or <code>false</code></p><ul><li><p><code>&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><code>&gt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &gt;= <span class="hljs-number">2</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><code>&lt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-相等运算符"><a href="#3-相等运算符" class="headerlink" title="3.相等运算符"></a>3.相等运算符</h3><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p><p>返回值：<code>true</code> or <code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span> == <span class="hljs-number">1px</span>; <span class="hljs-comment">// true</span><br><span class="hljs-variable">$b</span>: <span class="hljs-string">&quot;a&quot;</span> == a; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>数字类型相比较，只比较数字部分，不比较单位。</p><p>字符串类型相比较，有无引号不影响结果，只比较各个位置字符是否相同。</p></blockquote><h3 id="4-布尔运算符"><a href="#4-布尔运算符" class="headerlink" title="4.布尔运算符"></a>4.布尔运算符</h3><p>SassScript 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$a</span>: <span class="hljs-number">1</span>&gt;<span class="hljs-number">0</span> and <span class="hljs-number">0</span>&gt;=<span class="hljs-number">5</span>; <span class="hljs-comment">// fasle</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 总结：</span><br>值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串<br></code></pre></td></tr></table></figure><h3 id="5-颜色值运算"><a href="#5-颜色值运算" class="headerlink" title="5.颜色值运算"></a>5.颜色值运算</h3><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p><ul><li><p><code>颜色值与颜色值</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#010203</span> + <span class="hljs-number">#040506</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#050709</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>颜色值与数字</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#010203</span> * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#020406</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p><code>RGB和HSL</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span><br><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: rgba(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>) + rgba(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>);<br>&#125;<br><br><span class="hljs-comment">// p &#123;</span><br>  <span class="hljs-attribute">color</span>: rgba(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>); &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-运算优先级"><a href="#6-运算优先级" class="headerlink" title="6.运算优先级"></a>6.运算优先级</h3><ol start="0"><li><p><code>()</code></p></li><li><p><code>*</code>、<code>/</code>、<code>%</code></p></li><li><p><code>+</code>、<code>-</code></p></li><li><p><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p></li></ol><hr><h2 id="嵌套语法"><a href="#嵌套语法" class="headerlink" title="嵌套语法"></a>嵌套语法</h2><h3 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h3><p>scss允许css选择器进行嵌套，表示父子关系。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br>&#125;<br><span class="hljs-comment">// 编译后 👇 css</span><br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">a</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><h3 id="CSS属性嵌套"><a href="#CSS属性嵌套" class="headerlink" title="CSS属性嵌套"></a>CSS属性嵌套</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">font</span>: &#123;  // 👈 注意这里有个冒号，是与选择器嵌套的区别<br>        family: Arial;<br>        size: <span class="hljs-number">16px</span>; &#125;<br>    <span class="hljs-attribute">margin</span>: &#123;<br>left: <span class="hljs-number">20px</span>;<br><span class="hljs-attribute">right</span>: <span class="hljs-number">40px</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译后👇 css</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">40px</span>; &#125;<br><br></code></pre></td></tr></table></figure><h2 id="模板字符串-插值语法"><a href="#模板字符串-插值语法" class="headerlink" title="模板字符串(插值语法)"></a>模板字符串(插值语法)</h2><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p><p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$name</span>: foo;<br><span class="hljs-variable">$attr</span>: border;<br><span class="hljs-selector-tag">p</span>.#&#123;<span class="hljs-variable">$name</span>&#125; &#123;<br>  #&#123;<span class="hljs-variable">$attr</span>&#125;-<span class="hljs-attribute">color</span>: <span class="hljs-variable">$name</span>;<br>&#125;<br><br><span class="hljs-comment">// 编译后：</span><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.foo</span> &#123;<br>  <span class="hljs-attribute">border-color</span>: foo;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父选择器"><a href="#父选择器" class="headerlink" title="父选择器"></a>父选择器</h2><p><code>&amp;</code>为父选择器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">color</span>: yellow;<br>    &amp;<span class="hljs-selector-pseudo">:hover</span>&#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>    &amp;<span class="hljs-selector-pseudo">:active</span>&#123;<br>        <span class="hljs-attribute">color</span>: blank;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="default-和-global"><a href="#default-和-global" class="headerlink" title="!default 和 !global"></a>!default 和 !global</h2><h3 id="default"><a href="#default" class="headerlink" title="!default"></a>!default</h3><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p><blockquote><p>这个语法主要在scss的文件模块化时起作用。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$content</span>: <span class="hljs-string">&quot;First content&quot;</span>;<br><span class="hljs-variable">$content</span>: <span class="hljs-string">&quot;Second content?&quot;</span> !default;<br><span class="hljs-variable">$new_content</span>: <span class="hljs-string">&quot;First time reference&quot;</span> !default;<br><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-variable">$content</span>;<br>  new-<span class="hljs-attribute">content</span>: <span class="hljs-variable">$new_content</span>;<br>&#125;<br><br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-selector-id">#main</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;First content&quot;</span>;<br>  new-<span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;First time reference&quot;</span>; &#125;<br></code></pre></td></tr></table></figure><p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。 </p><h3 id="global"><a href="#global" class="headerlink" title="!global"></a>!global</h3><p>将局部变量提升为全局变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-id">#foo</span> &#123;<br>    <span class="hljs-variable">$width</span>: <span class="hljs-number">5em</span> !global;<br>&#125;<br><span class="hljs-selector-id">#bar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块化指令-import"><a href="#模块化指令-import" class="headerlink" title="模块化指令 @import"></a>模块化指令 @import</h2><h3 id="基本使用与注意点"><a href="#基本使用与注意点" class="headerlink" title="基本使用与注意点"></a>基本使用与注意点</h3><p>Sass <code>拓展了css的 @import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p><blockquote><p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。即以下情况的<code>@import</code>被当作css语句执行。</p><ul><li>文件拓展名是 <code>.css</code>；</li><li>文件名以 <code>http://</code> 开头；</li><li>文件名是 <code>url()</code>；</li><li><code>@import</code> 包含 media queries。</li></ul></blockquote><p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a/bar.scss&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a/bar&quot;</span><br>// 以上两种方式均可<br><br><br>// 以下方式均不可行<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo.css&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;foo&quot;</span> screen;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;http://foo.com/bar&quot;</span>;<br><span class="hljs-keyword">@import</span> url(foo);<br></code></pre></td></tr></table></figure><h3 id="导入多个文件"><a href="#导入多个文件" class="headerlink" title="导入多个文件"></a>导入多个文件</h3><p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;rounded-corners&quot;</span>, <span class="hljs-string">&quot;text-shadow&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="路径插值"><a href="#路径插值" class="headerlink" title="路径插值"></a>路径插值</h3><p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于<code>CSS</code>的 <code>url()</code> 导入方式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$family</span>: unquote(<span class="hljs-string">&quot;Droid+Sans&quot;</span>);<br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=\#&#123;$family&#125;&quot;</span>);<br><br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>如果你有一个 SCSS 或 Sass <code>模板文件</code>需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以<code>在文件名前面加一个下划线</code>，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;template/_bar.scss&quot;</span>; <br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;template/bar&quot;</span>;  <span class="hljs-comment">// 等价于上面的写法</span><br></code></pre></td></tr></table></figure><blockquote><p>当使用 @import “template/bar” 时，template目录下不允许存在_bar.scss和bar.scss，否则编译器不知道该导入哪个scss文件（出现歧义）</p></blockquote><h3 id="支持在嵌套语法中使用-import"><a href="#支持在嵌套语法中使用-import" class="headerlink" title="支持在嵌套语法中使用@import"></a>支持在嵌套语法中使用@import</h3><p>–b.scss</p><p>–_a.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// _a.scss的内容</span><br><span class="hljs-selector-tag">div</span> &#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>:<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// b.scss的内容</span><br><span class="hljs-selector-class">.b</span> &#123;<br>    <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;a.scss&quot;</span><br>&#125;<br>// 编译b.scss的结果 👇<br>.b div &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承指令-extend"><a href="#继承指令-extend" class="headerlink" title="继承指令 @extend"></a>继承指令 @extend</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用方法1</span><br><span class="hljs-selector-id">#app</span> &#123;<br>    <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-id">#app2</span> &#123;<br>    <span class="hljs-keyword">@extend</span> <span class="hljs-number">#a</span>pp;<br>&#125;<br><span class="hljs-comment">// 编译结果👇</span><br><span class="hljs-selector-id">#app</span>, <span class="hljs-selector-id">#app1</span> &#123; <span class="hljs-attribute">color</span>: red; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 使用方法2</span><br>%colorred &#123;    <span class="hljs-comment">// “%”开头的选择器叫做占位选择器，本身不会起实际作用，只能被继承</span><br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.b</span> &#123;<br><span class="hljs-keyword">@extend</span> %colorred;<br><span class="hljs-attribute">background-color</span>: black;<br>&#125;<br><span class="hljs-comment">// 编译结果👇</span><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">color</span>: red; &#125;<br><br><span class="hljs-selector-class">.b</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: black; &#125;<br><br></code></pre></td></tr></table></figure><h2 id="媒体查询扩展-media"><a href="#媒体查询扩展-media" class="headerlink" title="媒体查询扩展 @media"></a>媒体查询扩展 @media</h2><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，<code>包含嵌套的父选择器</code>。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-comment">// 👇 这里的媒体查询规则是作用域父级选择器，即 .sidebar， 而不是.sidebar的子元素</span><br>  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;   <br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为 👇    实际编译后的格式可能与下面不同，但一定是将媒体查询规则提到顶层。</span><br><span class="hljs-selector-class">.sidebar</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>; <br>&#125;<br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;  <br>    <span class="hljs-selector-class">.sidebar</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><code>@media</code>的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@media</span> screen &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-keyword">@media</span> (orientation: landscape) &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (orientation: landscape) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><p><code>@media</code> 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$media</span>: screen;<br><span class="hljs-variable">$feature</span>: -webkit-min-device-pixel-ratio;<br><span class="hljs-variable">$value</span>: <span class="hljs-number">1.5</span>;<br><br><span class="hljs-keyword">@media</span> #&#123;<span class="hljs-variable">$media</span>&#125; and (<span class="hljs-variable">$feature</span>: <span class="hljs-variable">$value</span>) &#123;<br>  .sidebar &#123;<br>    width: <span class="hljs-number">500px</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 编译为：</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="hljs-number">1.5</span>) &#123;<br>  <span class="hljs-selector-class">.sidebar</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>; &#125; &#125;<br></code></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="debug"><a href="#debug" class="headerlink" title="@debug"></a>@debug</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$max</span>: <span class="hljs-number">1000px</span>;<br><span class="hljs-keyword">@debug</span> <span class="hljs-variable">$max</span>;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-keyword">@debug</span> <span class="hljs-string">&quot;hello word&quot;</span>;<br>&#125;<br><br>👇 会在控制台输出<br>1000px<br>hello world;<br></code></pre></td></tr></table></figure><p><img src="/./image-20201120194928824.png" alt="image-20201120194928824"></p><h3 id="warn"><a href="#warn" class="headerlink" title="@warn"></a>@warn</h3><p>没试过</p><h3 id="error"><a href="#error" class="headerlink" title="@error"></a>@error</h3><p>没试过</p><h2 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h2><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p><em><code>if()</code>语句就是SassScript中的三目运算符</em></p><p>表达式：<code>if(expression, value1, value2)</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: if(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>, green, yellow);<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span>&#123;<br>    <span class="hljs-attribute">color</span>: green;&#125;<br></code></pre></td></tr></table></figure><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="@if @else if  @else"></a>@if @else if  @else</h3><p><em>条件语句</em></p><p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p><p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p><ul><li><p><code>单@if</code></p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> != <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125; <span class="hljs-keyword">@else</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>@if - @else if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$age</span>: <span class="hljs-number">19</span>;<br><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@if</span> <span class="hljs-variable">$age</span> == <span class="hljs-number">18</span> &#123;<br>        <span class="hljs-attribute">color</span>: red;<br>    &#125; <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$age</span> == <span class="hljs-number">19</span> &#123;<br>        <span class="hljs-attribute">color</span>: blue;<br>    &#125; <span class="hljs-keyword">@else</span> &#123;<br>        <span class="hljs-attribute">color</span>: green;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h2><h3 id="for"><a href="#for" class="headerlink" title="@for"></a>@for</h3><p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p><p>through 和 to 的相同点与不同点：</p><ul><li>相同点：两者均包含<start>的值</li><li>不同点：through包含<end>的值，但to不包含<end>的值</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span>; &#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>; &#125;<br><span class="hljs-selector-class">.item-3</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">6em</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="@while"></a>@while</h3><p>表达式：<code>@while expression</code></p><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$i</span>: <span class="hljs-number">6</span>;<br><span class="hljs-keyword">@while</span> <span class="hljs-variable">$i</span> &gt; <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-selector-class">.item-</span>#&#123;<span class="hljs-variable">$i</span>&#125; &#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">2em</span> * <span class="hljs-variable">$i</span>; &#125;<br>  <span class="hljs-variable">$i</span>: <span class="hljs-variable">$i</span> - <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.item-6</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>; &#125;<br><span class="hljs-selector-class">.item-4</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">8em</span>; &#125;<br><span class="hljs-selector-class">.item-2</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">4em</span>; &#125;<br></code></pre></td></tr></table></figure><h3 id="each"><a href="#each" class="headerlink" title="@each"></a>@each</h3><p>表达式：<code>@each $var in $vars</code></p><p><code>$var</code> 可以是任何变量名</p><p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p><ul><li><p>一维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span> in puma, sea-slug, egret, salamander &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/puma.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/sea-slug.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/egret.png&#x27;</span>); &#125;<br><span class="hljs-selector-class">.salamander-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/salamander.png&#x27;</span>); &#125;<br></code></pre></td></tr></table></figure></li><li><p>二维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$animal</span>, <span class="hljs-variable">$color</span>, <span class="hljs-variable">$cursor</span> in (puma, black, default),<br>                                  (sea-slug, blue, pointer),<br>                                  (egret, white, move) &#123;<br>  .#&#123;<span class="hljs-variable">$animal</span>&#125;-<span class="hljs-attribute">icon</span> &#123;<br>    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-variable">$color</span>;<br>    <span class="hljs-attribute">cursor</span>: <span class="hljs-variable">$cursor</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-class">.puma-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/puma.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br>  <span class="hljs-attribute">cursor</span>: default; &#125;<br><span class="hljs-selector-class">.sea-slug-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/sea-slug.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid blue;<br>  <span class="hljs-attribute">cursor</span>: pointer; &#125;<br><span class="hljs-selector-class">.egret-icon</span> &#123;<br>  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&#x27;/images/egret.png&#x27;</span>);<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid white;<br>  <span class="hljs-attribute">cursor</span>: move; &#125;<br></code></pre></td></tr></table></figure></li><li><p>maps</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@each</span> <span class="hljs-variable">$header</span>, <span class="hljs-variable">$size</span> in (h1: <span class="hljs-number">2em</span>, h2: <span class="hljs-number">1.5em</span>, h3: <span class="hljs-number">1.2em</span>) &#123;<br>  #&#123;<span class="hljs-variable">$header</span>&#125; &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$size</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">2em</span>; &#125;<br><span class="hljs-selector-tag">h2</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.5em</span>; &#125;<br><span class="hljs-selector-tag">h3</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="混合指令-mixin与-include"><a href="#混合指令-mixin与-include" class="headerlink" title="混合指令@mixin与@include"></a>混合指令@mixin与@include</h2><blockquote><p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left&#123;float: left&#125;</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p></blockquote><p>注意：这不是函数！没有返回值！！</p><h3 id="1-定义普通的mixin"><a href="#1-定义普通的mixin" class="headerlink" title="1.定义普通的mixin"></a>1.定义普通的mixin</h3><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 格式：</span><br><span class="hljs-keyword">@mixin</span> name &#123;<br>    <span class="hljs-comment">// 样式....</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example：</span><br><span class="hljs-keyword">@mixin</span> large-text &#123;<br>  <span class="hljs-attribute">font</span>: &#123;<br>    family: Arial;<br>    size: <span class="hljs-number">20px</span>;<br>    weight: bold;<br>  &#125;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-引用混合样式"><a href="#2-引用混合样式" class="headerlink" title="2.引用混合样式"></a>2.引用混合样式</h3><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 格式：</span><br><span class="hljs-keyword">@include</span> name;<br><br><span class="hljs-comment">// 注：无参数或参数都有默认值时，带不带括号都可以</span><br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example：</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-keyword">@include</span> large-text;<br>&#125;<br><br><span class="hljs-comment">// compile:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: Arial;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-weight</span>: bold;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-带参数的mixin"><a href="#3-带参数的mixin" class="headerlink" title="3.带参数的mixin"></a>3.带参数的mixin</h3><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p><p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p><h4 id="a-位置传参"><a href="#a-位置传参" class="headerlink" title="a. 位置传参"></a>a. 位置传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-关键词传参"><a href="#b-关键词传参" class="headerlink" title="b.关键词传参"></a>b.关键词传参</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-参数默认值"><a href="#c-参数默认值" class="headerlink" title="c.参数默认值"></a>c.参数默认值</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">500px</span>) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$width</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-variable">$width</span>: <span class="hljs-number">300px</span>);<br>    <span class="hljs-comment">// or</span><br>    <span class="hljs-keyword">@include</span> mp(<span class="hljs-number">300px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d-不定参数"><a href="#d-不定参数" class="headerlink" title="d.不定参数"></a>d.不定参数</h4><blockquote><p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数<code>装包为一个数组类型的参数</code>处理。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> mar(<span class="hljs-variable">$value</span>...) &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-variable">$value</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-mixin中的”插槽”"><a href="#4-mixin中的”插槽”" class="headerlink" title="4.mixin中的”插槽”"></a>4.mixin中的”插槽”</h3><p>在引用混合样式的时候，可以先将一段代码插入到mixin的插槽中，然后再输出完整的mixin，插入内容将填充 <code>@content</code> 标志的地方</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@mixin</span> example &#123;<br>    <span class="hljs-selector-tag">html</span> &#123;<br>        <span class="hljs-keyword">@content</span>; 👈 <span class="hljs-comment">// 占位&quot;插槽&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">@include</span> example&#123;  👈 <span class="hljs-comment">// 用&#123;&#125;括起，向插槽中填充内容</span><br>    <span class="hljs-attribute">background-color</span>: red;<br>    <span class="hljs-selector-class">.logo</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 编译成css的结果👇</span><br><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><br><span class="hljs-selector-tag">html</span> <span class="hljs-selector-class">.logo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="函数指令"><a href="#函数指令" class="headerlink" title="函数指令"></a>函数指令</h2><h3 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1.内置函数"></a>1.内置函数</h3><h4 id="a-字符串函数"><a href="#a-字符串函数" class="headerlink" title="a. 字符串函数"></a>a. 字符串函数</h4><p>SassScript提供的字符串函数包括 引号处理、大小写转换、查询、插入、切片等功能。</p><table><thead><tr><th align="left">函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td align="left">quote($string)</td><td align="center">添加引号</td></tr><tr><td align="left">unquote($string)</td><td align="center">除去引号</td></tr><tr><td align="left">to-lower-case($string)</td><td align="center">变为小写</td></tr><tr><td align="left">to-upper-case($string)</td><td align="center">变为大写</td></tr><tr><td align="left">str-length($string)</td><td align="center">返回$string的长度(汉字算一个)</td></tr><tr><td align="left">str-index($string，$substring)</td><td align="center">返回$substring在$string的位置</td></tr><tr><td align="left">str-insert($string, $insert, $index)</td><td align="center">在$string的$index处插入$insert</td></tr><tr><td align="left">str-slice($string, $start-at, $end-at）</td><td align="center">截取$string的$start-at和$end-at之间的字符串</td></tr></tbody></table><blockquote><p>字符串的索引第一个为1，最后一个为-1；切片两边均为闭区间</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// str-slice 函数测试</span><br><span class="hljs-variable">$str</span>: <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">@debug</span> str-slice(<span class="hljs-variable">$str</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  &gt;&gt;&gt; abc<br></code></pre></td></tr></table></figure><h4 id="b-数字函数"><a href="#b-数字函数" class="headerlink" title="b. 数字函数"></a>b. 数字函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>percentage($number)</td><td align="center">转换为百分比形式</td></tr><tr><td>round($number)</td><td align="center">四舍五入为整数</td></tr><tr><td>ceil($number)</td><td align="center">数值向上取整</td></tr><tr><td>floor($number)</td><td align="center">数值向下取整</td></tr><tr><td>abs($number)</td><td align="center">获取绝对值</td></tr><tr><td>min($number…)</td><td align="center">获取最小值</td></tr><tr><td>max($number…)</td><td align="center">获取最大值</td></tr><tr><td>random($number?:number)</td><td align="center">不传入值：获得0-1的<code>随机小数</code>；<br>传入<code>正整数n</code>：获得0-n的<code>随机整数</code>（<code>左开右闭</code>）</td></tr></tbody></table><blockquote><p>round、ceil、floor、abs、max、min这些函数若传入带单位的数字，其返回值也会带单位。</p></blockquote><h4 id="c-数组函数"><a href="#c-数组函数" class="headerlink" title="c. 数组函数"></a>c. 数组函数</h4><p>提供了访问数组元素、查询指定元素、尾插、合并、对位组合等功能。</p><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>length($list)</td><td align="center">获取数组长度</td></tr><tr><td>nth($list, n) ⭐</td><td align="center">获取指定下标的元素</td></tr><tr><td>set-nth($list, $n, $value)⭐</td><td align="center">返回一个新数组，其值为$list的$n处设置为$value后的新数组。</td></tr><tr><td>join($list1, $list2, $separator)</td><td align="center">返回一个新数组，其值为拼接$list1和list2后的结果；<br>$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>append($list, $val, $separator)</td><td align="center">向$list的末尾添加$val；$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>index($list, $value)</td><td align="center">返回$value值在$list中的索引值</td></tr><tr><td>zip($lists…)</td><td align="center">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td></tr></tbody></table><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// zip 函数测试</span><br><span class="hljs-variable">$l1</span>: <span class="hljs-number">1px</span> solid black; <br><span class="hljs-variable">$l2</span>: <span class="hljs-number">2px</span> dashed red;<br><span class="hljs-keyword">@debug</span> zip(<span class="hljs-variable">$l1</span>, <span class="hljs-variable">$l2</span>);  &gt;&gt;&gt; 1px 2px, solid dashed, black red <span class="hljs-comment">// 这里表现为上下两两结合</span><br></code></pre></td></tr></table></figure><h4 id="d-映射函数"><a href="#d-映射函数" class="headerlink" title="d. 映射函数"></a>d. 映射函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>map-get($map, $key)  ⭐</td><td align="center">获取$map中$key对应的$value</td></tr><tr><td>map-merge($map1, $map2)</td><td align="center">合并$map1和$map2，返回一个新$map</td></tr><tr><td>map-remove($map, $key)⭐</td><td align="center">从$map中删除$key，返回一个新$map</td></tr><tr><td>map-keys($map)⭐</td><td align="center">返回$map所有的$key</td></tr><tr><td>map-values($map)⭐</td><td align="center">返回$map所有的$value</td></tr><tr><td>map-has-key($map, $key)</td><td align="center">判断$map中是否存在$key，返回对应的布尔值</td></tr><tr><td>keywords($args)</td><td align="center">返回一个函数的参数，并可以动态修改其值</td></tr></tbody></table><h4 id="e-颜色函数"><a href="#e-颜色函数" class="headerlink" title="e. 颜色函数"></a>e. 颜色函数</h4><ul><li><p><strong>RGB函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>rgb($red, $green, $blue)</td><td align="center">返回一个16进制颜色值</td></tr><tr><td>rgba($red,$green,$blue,$alpha)⭐</td><td align="center">返回一个rgba；$red,$green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td></tr><tr><td>red($color)</td><td align="center">从$color中获取其中红色值</td></tr><tr><td>green($color)</td><td align="center">从$color中获取其中绿色值</td></tr><tr><td>blue($color)</td><td align="center">从$color中获取其中蓝色值</td></tr><tr><td>mix($color1,$color2,$weight?)⭐</td><td align="center">按照$weight比例，将$color1和$color2混合为一个新颜色</td></tr></tbody></table></li><li><p><strong>HSL函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th>函数作用</th></tr></thead><tbody><tr><td>hsl($hue,$saturation,$lightness)</td><td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td></tr><tr><td>hsla($hue,$saturation,$lightness,$alpha)</td><td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td></tr><tr><td>saturation($color)</td><td>从一个颜色中获取饱和度（saturation）值</td></tr><tr><td>lightness($color)</td><td>从一个颜色中获取亮度（lightness）值</td></tr><tr><td>adjust-hue($color,$degrees)</td><td>通过改变一个颜色的色相值，创建一个新的颜色</td></tr><tr><td>lighten($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td></tr><tr><td>darken($color,$amount)</td><td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td></tr><tr><td>hue($color)</td><td>从一个颜色中获取亮度色相（hue）值</td></tr></tbody></table></li><li><p><strong>Opacity函数</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>alpha($color)/opacity($color)</td><td>获取颜色透明度值</td></tr><tr><td>rgba($color,$alpha)</td><td>改变颜色的透明度</td></tr><tr><td>opacify($color, $amount) / fade-in($color, $amount) ⭐</td><td>使颜色更不透明</td></tr><tr><td>transparentize($color, $amount) / fade-out($color, $amount) ⭐</td><td>使颜色更加透明</td></tr></tbody></table></li></ul><h4 id="f-Introspection函数"><a href="#f-Introspection函数" class="headerlink" title="f. Introspection函数"></a>f. Introspection函数</h4><table><thead><tr><th>函数名和参数类型</th><th align="center">函数作用</th></tr></thead><tbody><tr><td>type-of($value)⭐</td><td align="center">返回$value的类型</td></tr><tr><td>unit($number)⭐</td><td align="center">返回$number的单位</td></tr><tr><td>unitless($number)⭐</td><td align="center">判断$number是否不带单位，返回对应的布尔值</td></tr><tr><td>comparable($number1, $number2)</td><td align="center">判断$number1和$number2是否可以做加、减和合并，返回对应的布尔值</td></tr></tbody></table><h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2.自定义函数"></a>2.自定义函数</h3><blockquote><p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p><p>Params: 与Mixin一致</p><p>函数的作用在于将函数返回值作为scss规则的一部分。</p></blockquote><p><strong>基本格式：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@function</span> fn-name(<span class="hljs-variable">$params</span>...) &#123;<br>    <span class="hljs-keyword">@return</span> <span class="hljs-variable">$params</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// example:</span><br><span class="hljs-keyword">@function</span> fn-name(<span class="hljs-variable">$params</span>...) &#123;<br>    <span class="hljs-keyword">@return</span> nth(<span class="hljs-variable">$params</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">height</span>: fn-name(<span class="hljs-number">1px</span>);<br>&#125;<br><br><span class="hljs-comment">// compiled:</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="细节与展望"><a href="#细节与展望" class="headerlink" title="细节与展望"></a>细节与展望</h2><h3 id="1-细节"><a href="#1-细节" class="headerlink" title="1.细节"></a>1.细节</h3><p>a. @extend、@Mixin和@function的选择</p><p><a href="https://csswizardry.com/2016/02/mixins-better-for-performance/">原文链接</a></p><blockquote><p><code>minxins</code>在网络传输中比<code>@extend</code> 拥有更好的性能.尽管有些文件未压缩时更大，但使用<code>gzip</code>压缩后，依然可以保证我们拥有更好的性能。</p></blockquote><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p><blockquote><p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p><p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p></blockquote><h3 id="2-展望"><a href="#2-展望" class="headerlink" title="2.展望"></a>2.展望</h3><blockquote><p>以上内容算是”基础”部分，但是对于日常开发，我觉得是足够使用的了。</p><p>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.x组件化分析</title>
    <link href="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <url>/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue2-x组件化的实现"><a href="#Vue2-x组件化的实现" class="headerlink" title="Vue2.x组件化的实现"></a>Vue2.x组件化的实现</h1><h2 id="从-h-gt-h-app-说起"><a href="#从-h-gt-h-app-说起" class="headerlink" title="从 h =&gt; h(app)说起"></a>从 h =&gt; h(app)说起</h2><p>我们知道，由vue-cli3创建的runtime-only脚手架项目里的<code>main.js</code>文件有这样一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架项目顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router, <br>  store, <br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在我学习的过程中，常规的创建Vue实例的手段是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el: <span class="hljs-string">&#x27;#app&#x27;</span><br>    template: <span class="hljs-string">&#x27;&lt;app/&gt;&#x27;</span>,<br>    component: &#123;<br>    App<br>&#125;,<br>    router,<br>    store<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>而为什么vue-cli3没有这样做呢？</strong></p><p>因为是脚手架构建runtime-only版本的项目，对于js文件，webpack只是会压缩部分代码，但是不会像对待<code>*.vue</code>文件那样使用<code>vue-loader</code>将main.js中的模板进行编译成render函数。</p><p><strong>但是，那为何不像下面做呢？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-comment">// 此时App已经是一个具有render函数的extendOptions</span><br><span class="hljs-comment">// App: &#123;name: &#x27;Vue&#x27;, data()&#123;...&#125;, render: new Function(`with(this)&#123;...&#125;`)&#125;</span><br>App.router = router<br>App.store = store<br>App.el = <span class="hljs-string">&#x27;#app&#x27;</span><br><span class="hljs-keyword">new</span> Vue(App);<br><br></code></pre></td></tr></table></figure><p>答案是：你当然可以这样做。但相比于原版<code>main.js</code>中不够优雅，当越来越多额外的option选项（如Vuex的store、vue-router的router）需要传给Vue构造函数时，就会越来越丑陋，而且逻辑不够清晰。</p><p>其实我更推荐的做法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    ...App,<br>    store,<br>    router<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>); <span class="hljs-comment">/* 这样创建好的顶级组件实例的根vnode就是一个tag为div的vnode，</span><br><span class="hljs-comment">而不再是一个tag为app的组件vnode /*</span><br></code></pre></td></tr></table></figure><p><strong>接下来我们来从两个问题切入，分析原版的main.js：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span> <span class="hljs-comment">// 👈脚手架顶级组件App</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的vue-router内容</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span> <span class="hljs-comment">// 👈 我自己添加的Vuex内容</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  router, <br>  store, <br>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>第一个问题：</strong>为什么用<code>$mount(&#39;#app&#39;)</code>？</p><p>答案：其实这没啥，因为<code>$mount(&#39;#app&#39;)</code>和在options中设置<code>&#123;el: &#39;#app&#39;&#125;</code>效果是等价的。原因是Vue实例初始化的最后存在一个逻辑是<code>if (vm.$el) vm.$mount(vm.$el)</code>（即vm._init()方法最后几句代码）。</p><blockquote><p>vm.$el属性是在mountComponent(vm, el)时挂载到Vue实例上的：</p><p>el = el &amp;&amp; query(el)；</p><p>vm.$el = el；</p></blockquote><p>如果在创建Vue实例时不传入el属性，则组件实例调用$mount时只会创建自己根vnode和绑定的根elm，而不会将根elm插入到某个父亲DOM元素中。将来可以在某个时机将vnode.elm插入到某个父亲元素中。</p><p><font color='red'>vm.$mount(‘#app’)会调用mountComponent，而mountComponent中会创建vm的渲染watcher，即</font> <code>new Watcher(vm, ()=&gt; vm._update(vm.render()))</code><font color='red'>，Watcher的构造函数第二个参数是一个字符串或一个getter表达式，渲染watcher的getter就是调用一次vm的update方法。渲染watcher实例化时会立刻调用一次getter，这是为了获取初始的value，从而依次执行了update和render，继而使得vm的渲染的流程正式开始了。</font></p><p><strong>第二个问题：</strong>render: h =&gt; h(App)会执行哪些逻辑？h是什么？</p><p>答：h是vm.$createElement，而vm.$createElement是对createElement函数的封装，createElement又是对_createElement的封装。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318222745530.png" alt="image-20210318222745530"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318222705175.png" alt="image-20210318222705175"></p><p> <code>vm.$createElement</code>是一个闭包函数，含有对vm的引用，即保证内层的<code>createElement</code>函数在执行时的上下文环境永远是vm，而不会是其他组件实例。</p><p>而<code>createElement</code>又是对<code>_createElement</code>函数的封装，见下图：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318223450113.png" alt="image-20210318223450113"></p><p><strong>所以，h =&gt; h(App) 的逻辑是：在render函数执行时，将App作为参数tag传入给<code>_createElement</code>并执行。</strong></p><blockquote><p>这里注意为什么App在h中明明是第一个参数，却传给了第二个占位参数tag。</p><p>在vm.$createElement函数的定义中，参数位置发生了改变，并且vm作为自由变量被传入到_createElement参数的第一个位置，形成闭包。</p></blockquote><p>接下来我们就深入<code>_createElement</code>函数一探究竟。</p><h2 id="createElement"><a href="#createElement" class="headerlink" title="_createElement"></a>_createElement</h2><p>如果你了解模板编译，看到往上第二张图就会发现<code>$createElement</code>函数就是代码字符串的<code>_c</code>方法，只是在最后一个参数上不同。<code>vm._c</code>就是在模板编译情况下的render函数需要调用的方法。而不论是<code>$createElement</code>还是<code>vm._c</code>都将最后调用<code>_createElement</code></p><blockquote><p>代码字符串: <code>with(this)&#123; _c(tag, [data], [children])&#125;</code></p></blockquote><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210318225101219.png" alt="image-20210318225101219"></p><p><code>_createElement</code>逻辑比较复杂，我们还是从 <code>render: h =&gt; h(app)</code>执行时会发生什么切入。</p><p>我们刚才提到 <code>h =&gt; h(App) </code>的逻辑是：在render函数执行时，将App作为参数tag传入给<code>_createElement</code>并执行。所以tag是App，而App不是String类型，所以会进入上图所示的else部分，即执行createComponent。</p><blockquote><p>这里多说一句，我在一开始展示了另外一种main.js的写法，</p><p>即<code>new Vue(App)</code>，由于App.vue是经过vue-loader编译的，所以App组件的模板编译成了render函数，而App实例的根标签将会是div#app，所以如果使用<code>new Vue(App)</code>，顶层tag会是<code>&#39;div&#39;</code>，会进入上图里第一个if逻辑，即 <code>if (config.isReservedTag(&#39;div&#39;))</code>，从而执行<code>new Vnode(&#39;div&#39;, data, children)</code>。</p></blockquote><p>重新陈述一遍，由于App是编译后的extendOptions，所以是引用类型，h =&gt; h(app)最终要执行<code>createComponent(App, undefined, vm, undefined)</code>。</p><p><strong>这里我们小结一下：</strong><code>_createElement</code>函数的主要逻辑就是</p><p>① 如果tag是一个HTML内置标签，则创建以该标签为tag的根Vnode；</p><p>② 如果tag是String类型，但tag不是HTML内置标签，则认为该tag是组件标签，类似于’<cpn/>‘、’<my-component/>‘这些，则应该到当前vm实例的components属性上查找该子组件的定义并赋值给Ctor变量，Ctor变量的值可能会是子组件的构造函数或extendOptions，然后继续执行createComponent(Ctor, data, vm, children, tag)，创建一个根Vnode。</p><p>③如果tag不是String类型，则该Tag应该是一个子组件的构造函数或extendOptions，执行createComponent(App, undefined, vm, undefined)，创建一个根Vnode。</p><blockquote><p>①~③都会得到一个Vnode，<code>_createElement</code>会返回这个Vnode，最终一层层向上返回值，最终使得<code>vm._render</code>的返回值为该Vnode。</p></blockquote><h2 id="创建组件Vnode：createComponent"><a href="#创建组件Vnode：createComponent" class="headerlink" title="创建组件Vnode：createComponent"></a>创建组件Vnode：createComponent</h2><p>Vue源码中有两个createComponent函数，一个定义在vdom目录下的create-component.js中，另一个定义在vdom目录下的patch.js中的patch方法内部。我们这里将要分析的是前者，<font color='red'>它的作用是接收一些参数，创建一个组件Vnode</font>，而非元素Vnode或文本Vnode。</p><p>_createElement函数会在遇到组件标签或tag实参不是String类型时，执行createComponent。</p><p><strong>我们来分析一下createComponent函数的逻辑，以下为转载内容 + 参杂我的分析：</strong></p><p><a href="https://www.jianshu.com/p/b7535850cddc">参考链接</a></p><pre><code>**createComponent** 的逻辑会有一些复杂，但是分析源码比较推荐的是只分析核心流程，分支流程可以之后针对性的看，所以这里**针对组件渲染这个 case 主要就 3 个关键步骤：构造子类构造函数，安装组件钩子函数和实例化 vnode**。</code></pre><h3 id="新建一个子类"><a href="#新建一个子类" class="headerlink" title="新建一个子类"></a>新建一个子类</h3><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319104118330.png" alt="image-20210319104118330"></p><p>我们在编写一个组件的时候，通常都是创建一个普通对象，还是以我们的 App.vue 为例，代码如下：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319104314590.png" alt="image-20210319104314590"></p><p>这里HelloWorld是导入的一个extendOptions对象，所以 createComponent 里的代码逻辑会执行到 **baseCtor.extend(Ctor)**。当然， h =&gt; h(App)也是同理，App将会作为第一个实参传给createComponent，也就是赋值给了Ctor，isObject(App)为true，所以也会执行 Ctor = baseCtor.extend(App)。</p><p>在这里 <strong>baseCtor 实际上就是 Vue</strong>，这个的定义是在最开始初始化 Vue 的阶段，在 src/core/global-api/index.js 中的 initGlobalAPI 函数有这么一段逻辑：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319105227985.png" alt="image-20210319105227985"></p><p> <strong>这里定义的是 Vue.options，而vm.options_base能拿到Vue是经历了两个步骤。</strong></p><p><strong>第一步：首先Vue.extend方法会生成一个子类Ctor</strong>，<strong>extend方法执行过程中会将Vue.options浅复制到Ctor.options上。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extendOptions</span>) </span>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-keyword">const</span> Sub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VueComponent</span> (<span class="hljs-params">options</span>) </span>&#123; <br>      <span class="hljs-built_in">this</span>._init(options) <span class="hljs-comment">// 模板方法，_init实际是Vue.prototype的方法</span><br>    &#125;<br>    Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype)  <span class="hljs-comment">// 原型继承的逻辑</span><br>    Sub.prototype.constructor = Sub<br>Sub.superOptions = Super.options<br>    Sub.extendOptions = extendOptions<br>    Sub.sealedOptions = extend(&#123;&#125;, Sub.options)<br>    Sub.options = mergeOptions(<br>      Super.options,<br>      extendOptions<br>    )<br>    Sub[<span class="hljs-string">&#x27;super&#x27;</span>] = Super<br>    <span class="hljs-comment">//....</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们来看一下 <strong>Vue.extend</strong> 函数的定义，在 src/core/global-api/extend.js 中。</p><p> <strong>Vue.extend</strong> 的作用就是构造一个 Vue 的子类，它使用一种非常经典的<strong>原型继承</strong>的方式。子类的原型对象的<code>__proto__</code>属性指向父类的<code>prototype</code>对象，从而继承父类的实例方法。</p><p>然后对 Sub 这个构造函数本身扩展了一些属性（类的属性和方法），如扩展 options、添加全局 API 等；并且对配置中的 props 和 computed 做了规格化工作；最后对于这个 Sub 构造函数做了缓存，避免多次执行 Vue.extend 的时候对同一个extendOptions对象重复构造新的子类。</p><p>所以经过在createComponent调用 Vue.extend(CtorExtendOptions)，会将Vue的options与Ctor的options合并，在Ctor.options_base中保存了Vue。</p><p><strong>第二步：这样当我们去实例化Ctor 的时候，就会执行 this._init 逻辑再次走到了 Vue 实例的初始化逻辑。（这里用到了模板方法设计模式）而vm._init中有下图的这一段逻辑：</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319105309320.png" alt="image-20210319105309320"></p><pre><code>而我们的 createComponent 取的是 **context.$options**，实际上在 src/core/instance/init.js 里 Vue 原型上的 _init 函数中有这么一段逻辑：这样就又将Ctor.options扩展到了vm.$options上。所以我们也就能通过 vm.$options.\_base 拿到 Vue 这个构造函数了。 </code></pre><blockquote><p>小结：任何组件构造器都能通过 <code>options._base</code>拿到Vue，任何组件实例都能通过<code>$options._base</code>拿到Vue。</p></blockquote><h3 id="收集注入内容"><a href="#收集注入内容" class="headerlink" title="收集注入内容"></a>收集注入内容</h3><p>此部分暂时省略，主要逻辑就是将vm的状态以及子组件标签上需要的data进行融合，其目的主要就是产生propsData和parentListener，绑定到组件Vnode的componentOptions上。</p><p>当然还要处理插槽等额外的注入。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153125657.png" alt="image-20210319153125657"></p><h3 id="为组件Vnode安装钩子"><a href="#为组件Vnode安装钩子" class="headerlink" title="为组件Vnode安装钩子"></a>为组件Vnode安装钩子</h3><p>我们之前提到 Vue.js 使用的 Virtual DOM 参考的是开源库 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a>，它的一个特点是在 <strong>VNode 的 patch 流程中对外暴露了各种时机的钩子函数</strong>，<strong>方便我们做一些额外的事情</strong>，Vue.js 也是充分利用这一点，在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153446768.png" alt="image-20210319153446768"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153620358.png" alt="image-20210319153620358"></p><p>整个 <strong>installComponentHooks</strong> 的过程就是<strong>把 componentVNodeHooks 的钩子函数合并到 data.hook</strong> 中，在 VNode 执行 patch 的过程中执行相关的钩子函数，具体的执行我们稍后在介绍 patch 过程中会详细介绍。这里要注意的是<strong>合并策略</strong>，在合并过程中，如果某个时机的钩子已经存在 data.hook 中，那么通过执行 mergeHook 函数做合并，这个逻辑很简单，就是在最终执行的时候，依次执行这两个钩子函数即可。</p><p>这些钩子同样定义在vdom目录下的create-component.js中</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319153723962.png" alt="image-20210319153723962"></p><ul><li><p>init钩子用于为该组件Vnode创建一个组件实例。</p></li><li><p>prepatch钩子用于在patch组件Vnode时，更新组件Vnode的数据。</p></li><li><p>insert钩子与keep-alive、vue-router相关。</p></li><li><p>destroy钩子调用时会调用子组件Vnode的组件实例的$destroy()方法，如果用keep-alive包裹只是会取消该子组件的激活状态。</p></li></ul><h3 id="实例化VNode并返回"><a href="#实例化VNode并返回" class="headerlink" title="实例化VNode并返回"></a>实例化VNode并返回</h3><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319160651038.png" alt="image-20210319160651038"></p><p> 最后一步非常简单，通过 new VNode 实例化一个 vnode 并返回。需要注意的是和普通元素节点的 vnode 不同，组件的 vnode 是没有 children 的，这点很关键。</p><p>到此createComponent会将创建好的组件Vnode传给上层<code>_createElement</code>，然后继续向上返回，直到作为render函数的返回值。</p><p>对于 render：h =&gt; h(app)而言，它的返回值就是一个Vnode，类似于下面这种结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    tag: <span class="hljs-string">&#x27;Vue-component-0&#x27;</span><br>    data: &#123;<br>      hooks: &#123;<br>          init钩子，<br>          prepatch钩子,<br>          insert钩子,<br>          destroy钩子<br>      &#125;  <br>    &#125;,<br>    children: <span class="hljs-literal">undefined</span>,<br>    componentOptions: &#123;<br>        Ctor: App的构造函数<br>        propsData: &#123;...&#125;,<br>        listeners: &#123;...&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="执行vm-update-vm-render"><a href="#执行vm-update-vm-render" class="headerlink" title="执行vm._update(vm._render())"></a>执行vm._update(vm._render())</h2><p>流程走到<code>vm._update(vm._render)</code>，从之前的介绍可知，render: h =&gt; h(app)得到了一个VNode，接下来我们要对该VNode和旧的Vnode进行patch。等一下，哪来的旧的Vnode？对，此时确实是没有旧的VNode的，所以_update方法对patch做了一层封装。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319165736432.png" alt="image-20210319165736432"></p><p>如果没有preVnode，则调用 vm.$el = vm.<strong>patch</strong>(vm.$el, vnode)。图中解释了，对于第一个Vue实例而言，它是具有$el属性的，因为他使用了$mount(‘#app’)，HTML中的div#app此时就是vm.$el。</p><p>而当存在preVnode时，只需要对新旧Vnode进行patch。</p><blockquote><p>对于除去顶级组件的internalComponent而言，在第一次进行patch时，$el属性都为undefined，所以执行的是</p><p>vm.__patch__(undefined, vm.render())。</p></blockquote><h2 id="执行-patch-vm-el-vnode"><a href="#执行-patch-vm-el-vnode" class="headerlink" title="执行__patch__(vm.$el, vnode)"></a>执行__patch__(vm.$el, vnode)</h2><p>执行该方法会将HTML模板中的div#app替换为由vnode创建的DOM元素。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319170548586.png" alt="image-20210319170548586"></p><p><font color='red'>由于<code>vm.$el</code>是一个真实的DOM元素</font>，根据if else逻辑，代码会执行红框中的代码块。为了简单起见，我们忽略关于SSR的部分。<code>emptyNodeAt()</code>函数会以HTML文件中的div#app为参照，创建一个VNode，并命名为oldVnode。</p><p>Vue的思路是：认为以div#app为模板创建的Vnode是一个旧的vnode，而render函数生成的vnode是新的vnode，新的vnode和oldvnode不是同一个vnode，新的应该替换掉旧的。</p><p>所以接下来的逻辑就是以vnode创建一个DOM元素，替换掉div#app。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319171001006.png" alt="image-20210319171001006"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319171433536.png" alt="image-20210319171433536"></p><p>执行完该方法后，<code>vm.$el = vm._update(vm_render())</code>，即vm.$el等于由vm._render创建的vnode生成的新的DOM元素，也就是App组件实例第一次渲染后对应的DOM元素。</p><h2 id="createElm-vnode-queue-parentElm-refElm"><a href="#createElm-vnode-queue-parentElm-refElm" class="headerlink" title="createElm(vnode, queue, parentElm, refElm)"></a>createElm(vnode, queue, parentElm, refElm)</h2><p>组件第一次渲染时，patch 的过程会调用 <strong>createElm 根据新的vnode创建元素节点及其子节点</strong>。</p><p>来看一下 createElm 的实现，它的定义在 src/core/vdom/patch.js 中：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319194420225.png" alt="image-20210319194420225"></p><p>我们删掉多余的代码，只保留关键的逻辑，这里会判断 <strong>createComponent</strong>(vnode, insertedVnodeQueue, parentElm, refElm) 的返回值，如果为 true 则直接结束，那么接下来看一下 createComponent 方法的实现。</p><h2 id="创建组件实例：createComponent"><a href="#创建组件实例：createComponent" class="headerlink" title="创建组件实例：createComponent"></a>创建组件实例：createComponent</h2><p><code>createElm &gt;&gt; createComponent</code></p><p>createComponent的整体逻辑如下：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319194554511.png" alt="createComponent"></p><p>首先对Vnode进行检测，如果其data属性上挂载了hooks.init说明是一个组件Vnode，然后要调用其init钩子，初始化组件Vnode。</p><p>我们之前提到在vdom目录下的create-component.js中定义的createComponent在创建组件Vnode前会为组件Vnode的data属性挂载4个钩子，init钩子就是其中之一。该钩子函数的调用时机就是在执行createElm(Vnode)为一个Vnode创建元素时发现该Vnode是一个组件Vnode，就需要对该组件Vnode进行初始化操作。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210319195103101.png" alt="组件Vnode的init钩子"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init</code></p><p>init 钩子函数执行也很简单，我们先不考虑 keepAlive 的情况，它是通过 <strong>createComponentInstanceForVnode 为组件Vnode创建一个组件实例，然后调用 $mount 方法，先来看一下 createComponentInstanceForVnode</strong> 的实现。</p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init &gt;&gt; createComponentInstanceForVnode</code></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324144302581.png" alt="createComponentInstanceForVnode"></p><p> 忽略inline-template的部分，createComponentInstanceForVnode做了一件事，新建一个options，并新建一个组件实例。</p><ul><li><p>_isComponent: true 用于标记该组件为一个internalComponent，</p></li><li><p>_parentVnode: vnode 指示由组件vnode创建的组件实例的_parentVnode指向该vnode，</p></li><li><p>parent的实参值为activeInstance，activeInstance永远指向正在执行update方法的那一个vm，所以parent的含义是将vnode产生的组件实例的父组件实例。</p></li></ul><p>将这三个内容合并为一个options，然后创建一个Ctor实例，新建的实例将在构建函数中执行_init方法，这里我们回顾一下vm._init方法。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324191342131.png" alt="vm._init"></p><p>vm._init方法中，如果options._isComponent为true，则执行initInternalComponent。说明_isComponent === true是internalComponent的唯一标识，internalComponent可以理解为由模板中的子组件标签生成的组件，这种组件实例的创建统一交给了Vue来处理，而不是用new语法创建。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324191807618.png" alt="initInternalComponent"></p><p>initInternalComponent主要是处理options。</p><p>在vm._init函数中，需要对创建实例时传入的options进行处理，而Vue源码中有两种方式：</p><ul><li><p>一种是如果组件是internalComponent，则用initInternalComponent处理options；</p></li><li><p>另一种是使用mergeOptions合并传入的options和组件构造器的options。</p><blockquote><p>这两种方式的目的都是让创建的vm同时能访问组件构造器的options以及使用new实例化时传入的options参数。</p></blockquote></li></ul><p>initInternalComponent不是执行合并操作，而是将vm的$options原型指向组件构造器的options，然后向vm.$options挂载_parentVnode、parent、propsData以及_parentListeners等等一些内容。</p><blockquote><p>第一次渲染时，父组件向子组件注入数据就是在这一步。props以及父组件对子组件的监听器就是在这时候挂载到子组件实例上的。vm._init方法后面会继续执行initProps、initEvents等一系列初始化流程。</p></blockquote><p>由于原型链的存在，以后vm.$options可以访问到组件构造器中的options。</p><p>在initInternalComponent执行完后，vm._init会继续对数据进行规格化，对状态进行初始化。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324193544853.png" alt="vm._init的剩余流程"></p><p>由于我们单文件组件中一般不在组件options中书写el，options._el为undefined，所以vm._init不会挂载子组件。</p><p>到此，我们就完成了对 App组件实例的创建，该从createComponentInstance回到init钩子。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324194301580.png" alt="children.$mount()"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; init</code></p><p>init钩子最后执行了一句关键的child.$mount()。child就是我们刚刚创建好的子组件实例，它挂载到了组件vnode.componentInstance上。在非SSR环境下，此时child.$el还不存在，所以child.$mount()最终会执行 child.$el = child.__patch__(undefined, child.render())。这就开启了子组件的第一次渲染，但需要注意的是子组件创建的$el还不会插入到父组件中。</p><blockquote><p>child.$mount会依次执行vnode = child.render()、update.update(vnode)、patch(undefined, vnode)、createElm(vnode)，从而创建了一个组件及其根虚拟Vnode，以及根$el，这个$el是真实的创建好的DOM子树根节点。</p></blockquote><p>子组件实例调用$mount完成属于自己的第一次渲染后，就从组件Vnode的init钩子中跳出，执行子组件Vnode的剩余操作。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324193900834.png" alt="createComponent创建组件实例并初始化"></p><p><code>createElm &gt;&gt; createComponent &gt;&gt; initComponent</code></p><p>首先，由于子组件Vnode实例化了一个组件实例，一定具有componentInstance属性，因为该属性值指向与子组件Vnode绑定的组件实例。往下继续执行initComponent。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324200927306.png" alt="initComponent"></p><p>initComponent主要做了三件事：</p><ul><li><p>insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)</p><p>如果子组件在渲染的过程中由于插入了元素而将对应的vnode加入到了插入顺序队列中，则将子组件中所有安装了insert钩子的的vnode加入到父组件的插入顺序队列中。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324202145673.png" alt="invokeInsertHook"></p><blockquote><p>这是第一次渲染的特殊操作，每个组件第一次执行patch时，会将新的具有insert钩子的vnode加入到插入顺序队列中，子组件会将自己的插入顺序队列保存到组件Vnode.data.pendingInsert中。</p><p>详见 invokeInsertHook。</p><p>最终，所有具有insert钩子的vnode（父组件以及子孙组件的vnode）都按照从父亲到后代的顺序加入到了顶级组件的插入顺序队列中，而insert的调用顺序是从子到父。（队列结构）</p></blockquote></li><li><p>vnode.elm = vnode.componentInstance.$el</p><p>将子组件Vnode的elm属性指向子组件实例创建好的$el元素。</p></li><li><p>invokeCreateHooks(vnode, inseredVnodeQueue)</p><p>调用组件vnode的create钩子，如果本组件vnode具有insert钩子，也将添加到插入顺序队列中。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324202230704.png" alt="image-20210324202230704"></p></li></ul><p>initComponent完成后，跳回createComponent。</p><p><code>createElm &gt;&gt; createComponent</code></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324203302805.png" alt="image-20210324203302805"></p><p>接下来的逻辑就比较简单，将子组件Vnode的elm插入到父级DOM元素中。然后return true 跳回creatElm。</p><h2 id="第一次渲染完成"><a href="#第一次渲染完成" class="headerlink" title="第一次渲染完成"></a>第一次渲染完成</h2><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324214146624.png" alt="creatElm部分逻辑"></p><p>由于createComponent返回的是true，所以createElm也会直接return结束执行。</p><p><strong>到这里，我们就彻底完成了从new Vue( {render: h =&gt; h(App)]})，到App组件渲染成DOM并插入到body中的过程。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324215104859.png" alt="image-20210324215104859"></p><h2 id="回到-patch"><a href="#回到-patch" class="headerlink" title="回到__patch__"></a>回到__patch__</h2><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324223138108.png" alt="patch的剩余执行步骤"></p><p>new Vue({render: h =&gt; h(App)})经过一些列过程后，由createElm创建了一个Vnode。该Vnode没有子节点，而且是单一的子组件Vnode，并且该vnode已经创建好了组件实例和DOM元素，并且插入到了文档的body元素中。</p><p>接下来执行invokeInsertHook：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210324223534090.png" alt="invokeInsertHook"></p><p>我们之前在initComponent中提到过该函数，如果不是第一次渲染，该函数会调用插入顺序队列中的每个Vnode的insert钩子。</p><p>但是，我们需要明确的是，new Vue()得到的实例在这里会直接调用队列中所有vnode的insert钩子。不对？这里很奇怪？明明new Vue（）得到的实例在此时的确是第一次渲染，为什么会调用队列中的钩子？关键在于invokeInsertHook的initial参数，如果patch方法的第一个参数只要不是undefined，isInitialPatch这个实参的值等于false，initial接受的值就为false，invokeInsertHook函数就认为本次执行不是组件根vnode的第一次渲染。</p><p>调用过插入顺序队列中所有vnode的insert钩子之后，顶级组件及其子组件的第一次渲染流程就“真正”地完成了。</p><h2 id="props和listeners的第一次注入"><a href="#props和listeners的第一次注入" class="headerlink" title="props和listeners的第一次注入"></a>props和listeners的第一次注入</h2><p>父组件和子组件通信的最主要机制就是：父组件向子组件的props上注入数据，同时监听子组件的自定义事件，子组件通过emit自定义事件向父组件发送数据。</p><p>所以我们来看一下父级组件和子组件之间的这种通信机制是如何实现的（在哪个步骤实现的）。</p><p><strong>首先，需要注意的是：</strong>父组件render函数执行时，创建某一个元素Vnode/组件Vnode时，会根据模板编译出的AST，将data传入到_createElement的第二个参数位置，data此时已经是一个真实的JS数据，包含了props、attrs、styles、class、on/nativeOn等等，只是和子组件实例中要求的内容格式“暂时”不同。</p><p><strong>接下来，当我们使用_createElement(tag, data, children)创建组件Vnode时，会进一步调用createComponent(tag, data,children)。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325103154592.png" alt="creatComponent"></p><p>createComponent有上面标注的两段逻辑，第一段是将propsData从子组件Vnode的data中提取出来，此时data.props中已经生成好了将要注入到子组件中的通信数据；第二段逻辑是把子组件Vnode的data.on中的父组件事件监听器提取出来，再将data.on赋值为data.nativeOn，data.nativeOn中保存了父组件监听子组件的原生DOM监听器。</p><p>到这里其实已经得到了全部需要用到的父向子注入的数据以及父组件对子组件的事件监听器，只是尚未规格化而已。（规格化操作是由子组件初始化时完成的）</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325103659889.png" alt="创建子组件Vnode"></p><p><strong>最后创建子组件Vnode，并且将子组件的组件构造器、propsData、listeners等等全部挂载到组件Vnode的componentOptions上。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325104347165.png" alt="子组件实例拿到父组件注入的内容"></p><p>在子组件初始化时，通过子组件在父组件Vnode树中的占位Vnode拿到了父组件注入的数据，分别挂载到$options.propsData和options._parentListeners中。</p><blockquote><p>子组件实例的options._parentVnode指向自己在父组件Vnode树中的占位Vnode。</p></blockquote><p>值得注意的是，_parentListeners中的监听器函数应该是由高阶函数返回的函数，该函数内部封装了一个父组件的函数执行，其执行过程中this指向父组件。</p><p><strong>接下来就是分别使用initEvents和initProps初始化父组件向自己注入的内容。</strong></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325111517913.png">  <img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325111708770.png" alt="image-20210325111708770"></p><blockquote><ul><li><p>如果prop的值是基本类型，且模板中对该值有依赖，修改prop的值时，会触发子组件更新。但尽量不要随意修改，修改了会导致逻辑混乱。</p></li><li><p>如果prop的值是引用类型，可以修改该值的内容。如果该值是响应式数据，且模板中对该值有依赖，则该值的内容发生改变时，子组件会重新渲染并且影响父级组件以及依赖于该值的兄弟组件。如果该值不是响应式的，修改该值的内容不仅不会影响到其他组件，也不会触发子组件更新。</p></li></ul><p>总之，在子组件中避免出现 this.prop = xxx 的操作，但是可以执行 this.prop.foo = xxx（强烈不建议这样做）。</p></blockquote><h2 id="props的patch"><a href="#props的patch" class="headerlink" title="props的patch"></a>props的patch</h2><p>一般来说，父组件对子组件的事件监听器不会发生太多变化，我们这里简单分析一下在父组件的某个状态发生变化导致父组件更新时，父组件对子组件的props会产生什么影响。</p><p>当对子组件Vnode进行patch时，patchVnode函数中有这样一段代码：</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325120526393.png" alt="patchVnode"></p><p>在对text、children等内容进行patch前，patchVnode会对oldVnode和vnode的data进行patch，其中就包括了props。</p><p>如果Vnode具有prepatch钩子，则执行这个钩子。prepatch钩子一般只包含组件Vnode的prepatch钩子。组件Vnode的prepatch钩子是在createComponent创建组件Vnode时安装的四个钩子之一。</p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325121059597.png" alt="image-20210325121059597"></p><p><img src="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/image-20210325121328153.png" alt="updateChildComponent"> </p><p>在updateChildComponent中，对子组件实例vm._props进行了更新。</p><ul><li>如果vm._props中某个属性值为非undefined或null的基本类型，该值发生改变时，会触发子组件更新。</li><li>如果vm._props中某个属性值为引用类型，该引用类型的指向没有发生改变，不会触发子组件更新。除非该引用类型的值为响应式数据且内容发生了改变，则会触发子组件更新。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2.js进一步整理</title>
    <link href="/2021/03/01/Vue/vue2/"/>
    <url>/2021/03/01/Vue/vue2/</url>
    
    <content type="html"><![CDATA[<p>Vue简介</p><p>Vue是一个渐进式JavaScript框架。</p><p>高级功能和特点：</p><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><p><strong>Vue.js的Hello world</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello world&quot;</span></span><br>        &#125; <br>        &#125;);<br><span class="handlebars"><span class="xml">        <span class="hljs-comment">&lt;!-- 新建一个Vue对象，在构造函数中传入options对象--&gt;</span></span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font size="4" color="red">Vue采用声明式编程，不同于jQuery以及原生JS操作DOM的命令式编程</font></p><p><img src="/./image-20200811204642611.png" alt="image-20200811204642611"> </p><h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><img src="/./image-20200811163236900.png" alt="image-20200811163236900"></p><h2 id="Options对象"><a href="#Options对象" class="headerlink" title="Options对象"></a>Options对象</h2><ul><li><p><strong>el：</strong></p><p>类型：string | HTMLElement</p><p>作用：决定Vue实例会管理哪一个DOM对象</p></li><li><p><strong>data：</strong></p><p>类型：Object | Function</p><p>作用：Vue实例对应的数据对象</p></li><li><p><strong>methods</strong>：</p><p>类型：｛key : Function｝</p><p>作用：定义属于Vue实例的一些方法，可以在其他地方调用，也可以在指令中使用。</p></li><li><p><strong>computed：</strong></p><p>计算属性</p><p>类型：{key : Function}</p><p>作用：定义一些计算属性值供使用。<font color="red">计算属性具有缓存机制，如果计算属性使用的数据没有被修改，则计算属性不会计算多次，当访问该计算属性时，直接从缓存中取值。</font></p><p>==由于缓存机制的存在，当页面中显示的内容只是需要对数据进行简单变换时，尽量使用计算属性，而不是使用函数计算==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>书籍购物车的总价格:&#123;&#123;totalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">el:<span class="hljs-string">&quot;h2&quot;</span>,</span><br>data:&#123;<br>books:[<br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;代码大全&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;现代操作系统&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">50</span>&#125;</span><br>]<br>&#125;,<br>computed:&#123;<br><span class="javascript">totalPrice:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>    &#125;<br>            /*<br>            也可以使用ES6方法的简写<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">totalPrice</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>            &#125;<br>            */<br>&#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color='red'>computed中的计算属性底层的原理 可能 是使用了Proxy</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">comuputed:&#123;<br>    <span class="hljs-comment">//totalPrice:handler</span><br>    totalPrice:&#123;<br>        get&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br>                    pre+=cur.price;<br>                    <span class="hljs-keyword">return</span> pre;<br>                   &#125;,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//get:function()&#123;....&#125;</span><br>        <span class="hljs-comment">//还可以设置set方法</span><br>    &#125;<br>&#125;<span class="hljs-comment">//这种写法同样可以。</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>filters：</strong></p><p>类型：Function</p><p>作用：允许传入一个value，对该值进行过滤或附加处理，返回新的值。</p><p>使用： value | filterFunctionName </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;grade | assessment&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>data:&#123;<br>grade:&#x27;A&#x27;<br>&#125;<br>filters:&#123;<br>assessment(value)&#123;<br>if(value===&#x27;A&#x27;) return &#x27;优秀&#x27;;<br>else   return &#x27;其他&#x27;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/./image-20200819182643832.png" alt="image-20200819182643832"> </p></li><li><p><strong>components</strong>：</p><p>类型：Object</p><p>作用：定义局部组件</p></li><li><p><strong>watch：</strong></p><p>类型：Object</p><p>作用：监听data中的数据以及props中的通信属性的变化。</p></li><li><p><strong>生命周期函数</strong>：</p><p>如：beforeCreate、created、Mounted、Destroyed…..</p></li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="/./lifecycle.png"> </p><h2 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;,Mazheng<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--Mustache语法不仅仅可以写变量，还可以写表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27;&#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--另一种写法,不会忽略语法变量之间的空格，会忽略语法变量两端的空格--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <br>    <br>    <br>    <span class="hljs-comment">&lt;!--数值表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>总价：&#123;&#123;price * 2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="文本指令"><a href="#文本指令" class="headerlink" title="文本指令"></a>文本指令</h3><ol><li><p><strong>v-once</strong> </p><p>布尔属性，数据渲染一次后就不再保持绑定，内容不会再随数据改变。</p></li><li><p><strong>v-html</strong></p><p>v-html=”==data==”，会将字符串类型的字面量、变量或表达式当做html内容进行渲染。</p><p>（覆盖标签内原有的内容）。</p></li><li><p>**v-text **</p><p>v-text=”==data==”，会将字符串类型的字面量、变量或表达式作为使用该指令的dom元素的文本（覆盖标签内原有的内容）。</p></li><li><p><strong>v-pre</strong></p><p>v-pre布尔指令，会将标签中包裹的内容原原本本的展示。（忽略mustache语法）</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>hahaha<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-comment">&lt;!--会覆盖hahaha v-text不如mustache语法灵活--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>引入vue<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">       el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>       data:&#123;<br><span class="handlebars"><span class="xml">           message:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&quot;</span></span><br>       &#125; <br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h3><p>防止闪动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br><span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  在vue解析后会将v-cloak属性去掉  --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h3><pre><code>v-bind指令用于将DOM元素的属性值与数据绑定。语法糖 ==使用冒号代替v-bind==</code></pre><h4 id="动态绑定a-href属性与img-src属性"><a href="#动态绑定a-href属性与img-src属性" class="headerlink" title="动态绑定a:href属性与img:src属性"></a>动态绑定a:href属性与img:src属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">div#app<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>div#app<br><br>app=new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>imgURL:https://XXXXX.img,<br>aHref:https://www.baidu.com<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="动态绑定HTML元素的class属性"><a href="#动态绑定HTML元素的class属性" class="headerlink" title="动态绑定HTML元素的class属性"></a>动态绑定HTML元素的class属性</h4><ul><li><p><strong>对象写法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;属性名1:boolean,属性名2:boolean&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--与既有的class属性共存,v-bind使用语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>👇<br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--isLine为false--&gt;</span><br><br><span class="hljs-comment">&lt;!--v-bind:class取函数返回值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!--总之,v-bind绑定class的对象写法，属性值的形式为 &quot;Obeject&quot;  --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            isActive:<span class="hljs-literal">true</span>,</span><br><span class="javascript">            isLine:<span class="hljs-literal">false</span></span><br>        &#125;<br>        <br>        methods:&#123;<br>        getClasses ()&#123;<br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">active</span>:<span class="hljs-built_in">this</span>.isActive,<span class="hljs-attr">line</span>:<span class="hljs-built_in">this</span>.isLine&#125;;<span class="hljs-comment">//返回一个对象</span></span><br>    &#125;<br>    &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>数组写法</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--语法--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--list为一个含有字符串类型元素的数组--&gt;</span><br> <br> <span class="hljs-comment">&lt;!--例子--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;class1&#x27;,&#x27;class2&#x27;,...&#x27;classN&#x27;]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[classObj, ...list]&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--👈 数组写法中嵌套对象写法 --&gt;</span><br> data:&#123;<br> class1:&#x27;active&#x27;,<br> class2:&#x27;red&#x27;<br> list: [&#x27;className1&#x27;, &#x27;className2&#x27;],<br> classObj: &#123;<br>   active: true,<br> &#125;<br> &#125;<br> <br> methods:&#123;<br>getClasses()&#123;<br> return [this.class1,this.class2];<br> &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>应用在子组件标签上</strong></p><p>在子组件标签上的class类名会合并到子组件的根标签上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;cpn class&#x3D;&quot;cpn&quot; :class&#x3D;&quot;[&#39;active&#39;]&quot;&#x2F;&gt;<br><br>&lt;!-- 如果cpn组件的根标签是一个div元素，则类名&#96;cpn&#96;和&#96;active&#96;都会添加到该div元素上 --&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="动态绑定内联样式"><a href="#动态绑定内联样式" class="headerlink" title="动态绑定内联样式"></a>动态绑定内联样式</h4><ul><li><p>对象写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;css属性名:属性值(string类型)...&#125;&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     css属性名只能使用驼峰命名法!!!!!!</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;color:&#x27;red&#x27;,fontSize:&#x27;16px&#x27;&#125;&quot;</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;backgroundColor:backColor&#125;&quot;</span>&gt;</span><br>    <br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    backColor:&#x27;#fff&#x27;<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>数组写法（是基于对象写法）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...Obejects]&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[style1,style2]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...styles]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <br><br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    style1:&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,<br>    style2:&#123;color:&#x27;red&#x27;&#125;<br>styles:[&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,&#123;color:&#x27;red&#x27;&#125;]<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>   v-on:==事件名.修饰符== =”函数/单句表达式/Object”</p><p>  语法糖   ==用@代替v-on== </p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count--&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>add()&#123;<br>this.count++;<br>&#125;,<br>decrease()&#123;<br>this.count--;<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="事件响应函数的传参"><a href="#事件响应函数的传参" class="headerlink" title="事件响应函数的传参"></a>事件响应函数的传参</h4>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--实参和形参匹配时的正常调用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf&quot;</span>&gt;</span>没有实参和形参,当函数不带参数时，可省略括号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf()&quot;</span>&gt;</span>没有实参和形参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;y-printf(&quot;</span><span class="hljs-attr">hello</span>&quot;,&quot; <span class="hljs-attr">world</span>!&quot;)&quot;&gt;</span>处理两个参数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--实参和形参不匹配时的处理策略--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf(123)&quot;</span>&gt;</span>有形参，输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=123--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf&quot;</span>&gt;</span>有形参，但不输入实参，且不带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=$event,会把事件对象当做第一个参数传入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf()&quot;</span>&gt;</span>有形参，但不输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=undefined--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf($event)&quot;</span>&gt;</span>有形参，输入实参$event，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--val=$event 强制输入事件对象--&gt;</span><br>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>printf()&#123;<br>console.log(&quot;hello world&quot;);<br>&#125;,<br>x-printf(val)&#123;<br>console.log(val);<br>&#125;<br>y-printf(val,event)&#123;<br>console.log(val,event);<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="多事件处理"><a href="#多事件处理" class="headerlink" title="多事件处理"></a>多事件处理</h4><p>当对某个原生事件设置多个事件监听器，则需要显示地调用这些监听器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;one($event); two($event)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 👈 分号分割了两个JS语句，分别执行两个函数 --&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br>methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">one</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-comment">// first handler logic...</span><br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">two</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-comment">// second handler logic...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul><li><p><code>.stop</code>  </p><p>中断事件的传播，常用于取消事件冒泡。</p><p>@click.stop=”==fun==”</p><blockquote><p>❗ 某些事件的默认行为发生在冒泡后，但取消冒泡并不会阻止默认行为的发生。</p></blockquote></li></ul><ul><li><p><code>.capture</code></p><p>响应函数在捕获阶段执行。</p></li></ul><ul><li><p><code>.self</code></p><p>  只当在 event.target 是当前元素自身时触发处理函数。</p></li></ul><ul><li><p><code>.prevent</code> </p><p>取消默认行为（例如a标签的click跳转、summit的click提交表单、form表单submit事件的http请求）。</p></li></ul><ul><li><p><code>.native </code>    </p><p> 用在组件标签上，监听组件根元素的原生DOM事件</p></li></ul><ul><li><p><code>.once </code> 只触发一次该事件</p><p>@click.once=”==fun==”</p></li></ul><ul><li><p><code>.passive</code></p><p>  passive这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。</p><pre><code>【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】</code></pre></li></ul><pre><code>  通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上**passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。**  这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度。</code></pre><blockquote><p><strong>注：passive和prevent冲突，不能同时绑定在一个监听器上。</strong></p></blockquote><h4 id="键盘按键修饰符"><a href="#键盘按键修饰符" class="headerlink" title="键盘按键修饰符"></a>键盘按键修饰符</h4><p><code>@keyup</code>和<code>@keydown</code>事件可以使用以下修饰符。</p><ul><li><p><code>.enter</code></p><p>例如<code>@keyup.enter=&quot;xxx&quot;</code>表示控制当回车键松开时的行为</p><p>例如<code>@keydown.enter=&quot;xxx&quot;</code>表示控制当回车键按下时的行为</p><blockquote><p>此外还支持键名数字代号的修饰符，同按键别名同效果，如<code>.13</code> 等价于<code>.enter</code>。</p></blockquote></li></ul><p>此外还有：</p><ul><li><code>.tab</code></li></ul><ul><li><code>.delete</code> “删除”和“退格”键</li><li><code>.esc</code></li><li><code>.space</code> 空格键</li><li><code>.up</code> 上箭头</li><li><code>.down</code> 下箭头</li><li><code>.left</code> 左箭头</li><li><code>.right</code> 右箭头</li></ul><p>系统按键：</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><blockquote><p>提示</p><p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。</p><p>注意：在 Mac 系统键盘上，<code>meta</code> 对应 <code>command </code>键 (<code>⌘</code>)。在 Windows 系统键盘 <code>meta</code> 对应<code>Windows</code>徽标键 (<code>⊞</code>)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p></blockquote><ul><li><p><code>.exact</code></p><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h4><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><p>这些修饰符用来修饰点击事件，如<code>click</code>、<code>dbclick</code>，会限制处理函数仅响应特定的鼠标按钮。</p><h3 id="指令的动态参数"><a href="#指令的动态参数" class="headerlink" title="指令的动态参数"></a>指令的动态参数</h3><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。<br>--&gt;<br>&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p><blockquote><p>除了<code>v-bind</code>和<code>v-on</code>以外，<code>v-slot</code>指令可以设置参数，因此也可以使用到动态参数。详情见插槽相关内容。</p></blockquote><h4 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h4><p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p><h4 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h4><p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这会触发一个编译警告 --&gt;<br>&lt;a v-bind:[&#39;foo&#39; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>在 DOM 中使用模板时这段代码会被转换为 &#96;v-bind:[someattr]&#96;。<br>除非在实例中有一个名为“someattr”的 property，否则代码不会工作。<br>--&gt;<br>&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure><h3 id="v-if-条件渲染"><a href="#v-if-条件渲染" class="headerlink" title="v-if 条件渲染"></a>v-if 条件渲染</h3><p><strong>具有条件判断指令的标签，如果逻辑条件不符合，不会存在于DOM树中</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;score&gt;=90&quot;</span>&gt;</span><br>    成绩：优秀<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;score&gt;=60&quot;</span>&gt;</span><br>    成绩：及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    成绩：不及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>    成绩:&#123;&#123;grade&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>data:&#123;<br>score:70<br>&#125;<br>computed:&#123;<br>grade()&#123;<br>if(this.score&gt;=90) return &quot;优秀&quot;;<br>else if (this.score&gt;=60) return &quot;及格&quot;;<br>else return &quot;不及格&quot;;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="在-lt-template-gt-元素上使用-v-if"><a href="#在-lt-template-gt-元素上使用-v-if" class="headerlink" title="在 &lt;template&gt; 元素上使用 v-if"></a>在 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code></h4><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。<strong>最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show=”false”时，标签存在于DOM树中，但会添加内联样式 display:none</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>当需要在显示与隐藏之间切换很频繁时，使用v-show指令</p></li><li><p>当只有一次切换，或元素互斥存在时，使用v-if</p></li></ul><hr><h3 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h3><h4 id="遍历数组元素和对象属性"><a href="#遍历数组元素和对象属性" class="headerlink" title="遍历数组元素和对象属性"></a>遍历数组元素和对象属性</h4><p>可以使用v-for指令遍历数组和JS普通对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--根据需要，在Vue里可以使用类似&quot;元祖&quot;的语法遍历数组的元素及索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>&gt;</span>&#123;&#123; `$&#123;index&#125;.$&#123;item&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- ❗ 这里的index从1开始，而非0开始。--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--遍历对象的属性值、属性名及属性名的索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val,key,index) in obj&quot;</span>&gt;</span>&#123;&#123; `$&#123;key&#125;:$&#123;val&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">在v-for绑定的数据可能存在动态修改的情况时（如动态增加删除一个元素），建议为标签添加一个key属性，key的属性值应能唯一标识数据中的各个元素。添加key属性可以提高dom动态渲染性能。</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>==Vue是响应式的，当数据变化时，Vue会检测到数据的变化，并反应到视图上。==</p><p>==我们常用v-for指令绑定数组数据，Vue中包含了一组观察数组变化的方法。==</p><p>==当调用数组某些方法改变元素时，会触发视图的更新==</p><pre><code>包括：所有改变数组自身的方法(Vue中拦截了pop,push,unshift,shift, sort,reverse, splice这七种)注意：使用下标改变数组元素的方法不会被Vue监听到，&lt;font color=&quot;red&quot;&gt;数据会发生改变，但视图不会发生改变。&lt;/font&gt;❌  lis[0]=xxx;✔  Vue.set(lis,&#39;0&#39;,xxx)    **使用Vue的set方法改变对象的属性值会被检测到，并反应到视图上**</code></pre><hr><h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><p>某些特殊情况下，给Data中的响应式数组重新赋值，可能比修改数组的部分元素来的更高效。</p><p>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>map()</code>、<code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>    &lt;li v-for&#x3D;&quot;item in ls&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br><br>&lt;script&gt;<br>    &#x2F;&#x2F;...<br>    methods: &#123;<br>        update() &#123;<br>            ls &#x3D; ls.map(() &#x3D;&gt; &#123;&#x2F;*....*&#x2F;&#125;);<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="在-v-for-里使用值的范围"><a href="#在-v-for-里使用值的范围" class="headerlink" title="在 v-for 里使用值的范围"></a>在 v-for 里使用值的范围</h4><p><code>v-for</code> 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- ❗ 类似的，这n的索引值仍然从1开始，而非从0开始 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/./image-20210511201311023.png" alt="image-20210511201311023"></p><h4 id="在-lt-template-gt-中使用-v-for"><a href="#在-lt-template-gt-中使用-v-for" class="headerlink" title="在 &lt;template&gt;中使用 v-for"></a>在 &lt;template&gt;中使用 v-for</h4><p>类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;divider&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;presentation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在组件标签上使用-v-for"><a href="#在组件标签上使用-v-for" class="headerlink" title="在组件标签上使用 v-for"></a>在组件标签上使用 v-for</h4><p>在自定义组件上，你可以像在任何普通元素上一样使用 <code>v-for</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 props：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;my-component<br>  v-for=&quot;(item, index) in items&quot;<br>  :item=&quot;item&quot;<br>  :index=&quot;index&quot;<br>  :key=&quot;item.id&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>==要求：当点击一个li时，该li的color为红色，其他为默认颜色==</p><p><img src="/./image-20200816153838359.png" alt="image-20200816153838359"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.active</span>&#123;</span><br>            color: red;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:currentIndex===index&#125;&quot;</span></span><br><span class="hljs-tag">             @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;beActive(index)&quot;</span></span><br><span class="hljs-tag">         &gt;</span><br>         &#123;&#123;`$&#123;index&#125;.$&#123;item&#125;`&#125;&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                lis:[<span class="hljs-string">&#x27;mazheng&#x27;</span>,<span class="hljs-string">&#x27;ley&#x27;</span>],</span><br><span class="javascript">                currentIndex:<span class="hljs-number">0</span>         <span class="hljs-comment">//使用currentIndex记录上次点击的元素索引</span></span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">beActive</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.currentIndex=index;</span><br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="/./image-20200816171940331.png" alt="image-20200816171940331"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        table&#123;<br>            width: 600px;<br>            border-collapse: collapse;<br>        &#125;<br>        th,td&#123;<br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span> 10<span class="hljs-selector-tag">px</span>;</span><br>            text-align: left;<br>            border: 1px black solid;<br>        &#125;<br>        th&#123;<br>            background-color: silver;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>出版日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>购买数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in books&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>《&#123;&#123;item.title&#125;&#125;》<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.releaseDate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> &#123;&#123;item.price | showPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--当书籍数量小于等于1时，按钮不可用--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;item.num &lt;= 1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decOne(index)&quot;</span>&gt;</span><br>                            -<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                        &#123;&#123;item.num&#125;&#125;<br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addOne(index)&quot;</span>&gt;</span><br>                            +<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeBook(index)&quot;</span>&gt;</span><br>                            移除<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br>                books:[<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;算法导论&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-06&#x27;</span>,</span><br>                        price:85,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;UNIX编程艺术&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-02&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;代码大全&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2008-10&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;<br>                ]<br>            &#125;,<br><span class="javascript">            filters:&#123;  <span class="hljs-comment">//过滤器。跟计算属性类似，但是调用的方法不太一样</span></span><br><span class="handlebars"><span class="xml">                //<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span> | showPrice&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     使用&quot; | &quot;调用过滤器,左边为参数</span></span><br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">showPrice</span>(<span class="hljs-params">price</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-string">`￥<span class="hljs-subst">$&#123;price.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span>;</span><br>                &#125;<br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">addOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num+=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">decOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num-=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">removeBook</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books.splice(index,<span class="hljs-number">1</span>);</span><br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>主要用于实现表单元素的<strong>双向数据绑定</strong>。绑定的数据主要用于自定义的ajax请求，也可以供其他功能使用。</p><p>v-model其实是一个语法糖，它的背后本质是包含两个操作：</p><ol><li>监听表单元素的特征事件，如input、change，根据情况更新绑定的数据。</li><li>监测数据的变化，更新表单元素的属性值，如value、checked。</li></ol><blockquote><p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//使用两个命令的组合实现input标签的v-model的功能<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文本类表单项-text-textarea"><a href="#文本类表单项-text-textarea" class="headerlink" title="文本类表单项 (text/textarea)"></a>文本类表单项 (text/textarea)</h4><p>将input的value和message变量进行绑定。文本框改变value，message的值也随之改变。改变message的值，文本框中的内容也随之改变。（双向绑定）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//只使用v-model绑定数据，但不使用name标识表单元素，这种表单元素不会被表单提交（因为没有name属性）<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>textarea标签与input标签类似可以使用v-model指令实现上述功能</p></blockquote><h4 id="单选按钮-radio"><a href="#单选按钮-radio" class="headerlink" title="单选按钮 (radio)"></a>单选按钮 (radio)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--应当为每个单选按钮设置value属性--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这类没有name属性的radio不会随表单提交--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">radioVal:<span class="hljs-number">0</span>   <span class="hljs-comment">// 初始值为0，代表默认第一个按钮选中。数字、字符串都可以。</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>双向数据绑定思路:</strong></p><ol><li><p>初次渲染时，如果v-model绑定的数组与该radio的value相同，则该radio会被选中，否则不被选中（所以要求radio标签必须有value属性）。</p><p>radio元素通过代码选中的方式为设置该元素的checked为true，例如 <code>radioELem.checked = true;</code>，取消选中为<code>radioElem.checked = false</code>。</p></li><li><p>监听change事件<font color='red'>，需要注意的是在DOM中，radio的change事件只有在该radio从为选中变为选中状态时才会发出，而当radio从选中到非选中状态，是不会产生change事件的，这一点很关键。</font>所以当某个radio产生change事件时，只需要将v-model绑定的响应式数据赋值为该radio的value即可，而不需要关注另一个变为非选中状态的radio。</p><p>❓ 修改v-model绑定的数据是否会触发视图更新？</p></li></ol><h4 id="复选框-checkbox"><a href="#复选框-checkbox" class="headerlink" title="复选框 (checkbox)"></a>复选框 (checkbox)</h4><ul><li><p>单个复选框，宜使用v-model绑定一个bool类型的变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isChecked&quot;</span>&gt;</span><br>//当选中时，isChecked值会为true,不选中时为false<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">isChecked: <span class="hljs-literal">false</span>   <span class="hljs-comment">//isChecked默认值设为false，代表默认不选中</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>双向绑定思路：</p><ol><li><p>渲染时，如果checkbox标签使用v-model数据绑定的是<strong>非数组类型</strong>（假设为<code>isCheck</code>），则数据绑定到一个单个复选框，当作单选按钮使用。如果<code>isCheck</code>是<code>truthy</code>，则该checkbox会被选中。</p></li><li><p>设置change事件监听器，事件的回调函数直接执行语句：<code>isCheck = !!!isCheck</code>，直接取反布尔值。</p><p>change事件表示checkbox切换状态，由选中=&gt; 不选中 或 不选中 =&gt; 选中，change事件由click事件触发。</p></li></ol><p>注意：</p><p>所以强烈建议<code>isCheck</code>初始时就是一个<strong>Boolean类型</strong>的数据，否则当用户没有切换该单个复选框，isCheck会保持原类型并作为Ajax请求的一部分。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data:&#123;<br>isChecked: &#123;&#125;   <span class="hljs-comment">/** isChecked默认值设为&#123;&#125;，表现为该复选框被选中。一旦用户没有切换该复选框的状态，则isChecked的值会一直保持为&#123;&#125;，如果存在Ajax请求，后端接口规定isChecked字段为一个布尔值，而此时isChecked的字段值却为一个对象发送到后端，这显然会出现错误。 */</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>多个复选框（绑定同一个数据），宜使用v-model绑定一个<strong>空数组,**或</strong>具有初始值的数组**。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      data:&#123;<br><span class="javascript">          balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>] <span class="hljs-comment">//默认选中第一个复选框</span></span><br>      &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in origins&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span> &#123;&#123;item&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      data:&#123;<br>          balls:[],<br><span class="javascript">          origins:[<span class="hljs-string">&#x27;basketball&#x27;</span>,<span class="hljs-string">&#x27;football&#x27;</span>,<span class="hljs-string">&#x27;badminton&#x27;</span>]<span class="hljs-comment">//从后台获取</span></span><br>      &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>双向数据绑定思路：</strong></p><ol><li>初次渲染时，如果检测出checkbox中v-model绑定的数据是<strong>数组类型</strong>（假设为<code>checkboxVals</code>），则认为该数据绑定到多个checkbox，作为复选框使用。<strong>每个checkbox必须设置value属性</strong>，如果<code>checkboxVals</code>数组中含有该value，则该checkbox默认被选中，<code>checkBoxElem.checked = true</code>。</li><li>设置change事件监听器。响应函数主要逻辑为：如果<code>checkboxVals</code>含有该checkbox的value，则从数组中删除该value，如果数组中不含有该checkbox的value，则将value添加到数组中。</li></ol><p><strong>注意点：</strong></p><ol><li><p>checkbox标签中使用v-model属性，会使标签中的checked属性失效。复选框是否<strong>默认</strong>选中，只与v-model绑定的初始数据有关。</p></li><li><p>v-model绑定的数组指定初始元素，以表示默认选中的复选框，但初始元素的值应出自默认选中复选框的value。因为checkbox取消选中时只会删除数组中的响应value，而不会删除不存在于所有复选框value中的其他值。即初始化数组时，初始元素若不存在于所有value中，则会始终存在于绑定的数组里。</p></li></ol></li></ul><h4 id="选择框-select"><a href="#选择框-select" class="headerlink" title="选择框 (select)"></a>选择框 (select)</h4><p><strong>一、单选select</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 单选select标签没有multiple属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ball&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        ball:<span class="hljs-string">&quot;basketball&quot;</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>双向数据绑定思路：</strong></p><p>前提：select标签没有multipe属性。</p><ol><li>渲染时，将v-model绑定的值赋值给select标签的value。</li><li>监听select的change事件，将select标签的value属性赋值给v-model绑定的数据。</li></ol><p><a href="">Vue官方文档案例</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-select&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Please select one<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.createApp(&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      selected: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;).mount(<span class="hljs-string">&#x27;#v-model-select&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 <code>change</code> 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p></blockquote><p><strong>二、多选select</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--多选select,添加multiple布尔属性--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>]</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>双向数据绑定思路：</strong></p><p>前提：select标签有multiple属性。</p><ol><li><p>渲染时，如果option的value包含在v-model绑定的数组内，则该option的selected属性设置为true，如<code>optionElem.selected = true</code>。</p></li><li><p>设置select标签的change事件监听器，响应函数的主要逻辑是：遍历select标签的options，如果option的selected属性为true，如果数组中没有该value，则添加该value；</p><p>如果option的selected属性为false，如果数组中有该value，则删除该value。</p><blockquote><p>select标签的options属性可以访问到所有子option，，如<code>selecElm.options</code>，该属性值为一个伪数组<code>HTMLOptionsCollection</code>。</p></blockquote></li></ol><h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p><a href="https://vue3js.cn/docs/zh/guide/forms.html#%E5%80%BC%E7%BB%91%E5%AE%9A">Vue3官方文档-值绑定</a></p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ol><li><p>lazy修饰符，常与input text标签使用</p><p>作用：让标签在失去焦点或在input中敲回车时才更新数据</p><p>（默认情况下，v-model是在input事件发生时立刻更新数据，lazy可以减少更新次数）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>number修饰符，常与input text标签使用</p><p>作用：获取input text标签内的value，转为number类型后再更新数据，即v-model绑定的数据会是number类型</p><p>（input text的value永远是string类型）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;marks&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>trim修饰符，常与input Text标签使用</p><p>作用：获取input text的value，去除首尾的空格后再更新数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><img src="/./image-20200817190948735.png" alt="image-20200817190948735"></p><p><img src="/./image-20200818104015488.png" alt="image-20200818104015488">  </p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><img src="/./image-20200818104048034.png" alt="image-20200818104048034">  </p><p>全局组件可以在多个不同的Vue实例中使用。但<font color="red">Vue实例才是根组件</font>，因为全局组件必须在Vue实例中才能使用。</p><ol><li><p><strong>调用Vue.extend()方法<font color="red">创建组件构造器</font></strong></p><p>👇</p><ol start="2"><li><strong>调用Vue.component()方法<font color="red">注册组件</font></strong></li></ol><p>👇</p><ol start="3"><li><strong>在Vue实例或其他组件内<font color="red">使用组件</font></strong></li></ol></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--全局组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用全局组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>        <br><span class="javascript">        <span class="hljs-comment">//---------------------------------------------------------</span></span><br>        <br><span class="javascript"> <span class="hljs-comment">//创建组件构造器对象</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> cpnC=Vue.extend(option);  <span class="hljs-comment">//传入该对象，创建组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//注册全局组件，注册后cpn标签就可以在vue的实例以及各个组件内使用了</span></span><br>        <br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,cpnC);<span class="hljs-comment">//注册全局组件。第一个参数是组件标签名，第二个参数是组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-comment">&lt;!--注册全局组件的简写方式--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> P element <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">          &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>          template:template<br>      &#125;<br>      <br><span class="javascript">Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,option); <span class="hljs-comment">//将extendOptions对象直接传入，而不是组件构造器对象</span></span><br>      <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ol><li><p>创建模板</p><p>👇</p></li><li><p>创建extendOptions对象</p><p>👇</p></li><li><p>在Vue实例或父组件中注册</p><p>👇</p></li><li><p>在Vue实例或父组件中使用</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--局部组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用局部组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;;<br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>            components:&#123;<br><span class="javascript">            cpn:option            <span class="hljs-comment">//在components属性中注册组件</span></span><br>        &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h3><p><font color="red">子组件本质上就是局部组件</font></p><p><font color="red">祖先组件和后代组件之间不能越级使用，除非后代组件在祖先组件中注册过</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn1</span>&gt;</span> <span class="hljs-comment">&lt;!--父组件的使用--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> temp2=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`;</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn2=Vue.extend(&#123;</span><br>        template:temp2<br>    &#125;);<br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> temp1=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span>  <span class="hljs-comment">&lt;!--子组件的使用--&gt;</span>  </span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   `;        </span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=Vue.extend(&#123;</span><br>        template:temp1,<br>        components:&#123;<br>            cpn2<br>        &#125;<br>    &#125;);<br><br><br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br><span class="javascript">            cpn1     <span class="hljs-comment">//挂载cpn1父组件</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用传入extendOptions直接注册组件--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=&#123;</span><br>        template:`<br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`,</span></span><br>        components:&#123;<br>            cpn2:&#123;<br>                template:`<br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span></span><br>            &#125;<br>        &#125;<br>    &#125;;<br>    <br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br>            cpn1<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="模板的抽离"><a href="#模板的抽离" class="headerlink" title="模板的抽离"></a>模板的抽离</h3><ol><li><p>第一种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-template&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp1&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp1&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>第二种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp2&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h3><p>组件拥有自己的数据，组件中<strong>不能直接访问</strong>父级组件以及子组件的数据。</p><p>组件的extendOptions中的data属性的属性值必须是Function，这个Function是一个工厂函数，返回一个对象，对象中包含组件自己的数据。</p><p>（利用工厂函数的特点，即每次返回一个新的包含数据的对象，来防止相同组件数据相互干扰）</p><p><img src="/./image-20200818150856104.png" alt="image-20200818150856104"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">            template: <span class="hljs-string">&#x27;#temp2&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">            data: <span class="hljs-function">() =&gt;</span> (&#123;  <span class="hljs-comment">//用小括号把返回的对象扩起来，防止解析成代码块</span></span><br><span class="javascript">                message: <span class="hljs-string">&#x27;hello world&#x27;</span></span><br>            &#125;)<br>        &#125;)<br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                message:<span class="hljs-string">&#x27;hello Vue&#x27;</span></span><br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件之间的通信-props-emit"><a href="#父子组件之间的通信-props-emit" class="headerlink" title="父子组件之间的通信 props/$emit"></a>父子组件之间的通信 props/$emit</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p><strong>一、基本使用</strong></p><p>子组件的props属性挂载通信属性，父组件使用子组件时，在子组件标签中使用v-bind为通信属性绑定父组件的数据，在子组件中通信属性的同名变量就获取到了父组件传来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:message-c</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--   驼峰命名法→连字符   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;today&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;console.log(messageC)&quot;</span>&gt;</span>通信<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            <br>        &#125;),<br><span class="javascript">        props:[<span class="hljs-string">&#x27;messageC&#x27;</span>,<span class="hljs-string">&#x27;today&#x27;</span>]</span><br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">由于dom标签中不区分大小写，当props挂载的通信属性名有大写字母时，应注意：</font></p><ol><li><p>使用驼峰命名法时（第一个字符小写，后面单词首字母大写），v-bind绑定的组件标签属性的属性名使用<strong>连字符写法</strong>。例如，上面的demo中 messageC   ,在绑定该属性时使用了  v-bind:message-c 。若子组件属性标签中绑定”messageC”，则默认传的通信属性实际为 “messagec”。</p></li><li><p>若通信属性第一个字母大写，则v-bind绑定的子元素标签属性名第一个字母大小写都可以。</p></li></ol><p><u>归纳：通信属性名第一个字母不要大写，尽量使用一个单词命名通信属性。若使用驼峰命名法，v-bind绑定时在大写字母前使用连字符。</u></p><p><strong>二、子组件定义props的写法</strong></p><ol><li><p>数组写法</p><p>由于数组写法功能没有对象写法强大，所以较少使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">props:[&#x27;messageC&#x27;,&#x27;today&#x27;]<br></code></pre></td></tr></table></figure></li><li><p>对象写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//指定通信属性的类型  type</span><br>props:&#123;<br>    messageC: <span class="hljs-built_in">String</span>,<br>    today: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">Number</span>,<br>    books: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>], <span class="hljs-comment">//指定Array或String类型</span><br>    owner: <span class="hljs-built_in">Object</span><br>&#125;<br><br><span class="hljs-comment">//指定默认值  default 当指定Object以及Array类型的默认值时，default应是一个工厂函数返回默认值</span><br><span class="hljs-comment">//要想子组件在一开始时使用default中的默认值，则父组件传来的数据初始值应为undefinded</span><br>props:&#123;<br>    messageC:&#123;<br>        type: <span class="hljs-built_in">String</span>,<br>        <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;hello wolrd&#x27;</span><br>    &#125;<br>    books:&#123;<br>        type: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>]<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>    &#125;<br>    owner:&#123;<br>        type: <span class="hljs-built_in">Object</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指定必须传入 required</span><br>props:&#123;<br>    books:&#123;<br>        type: <span class="hljs-built_in">Array</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>        required: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义验证函数 validator</span><br><br></code></pre></td></tr></table></figure></li></ol><p><strong>三、父级组件向子组件prop传入数据</strong></p><p>假设父组件App向子组件 BlogPost的传入数据。</p><p>▲ <strong>传入静态数据</strong>：</p><ol><li>```vue<br><blog-post :likes="42"></blog-post> 👈 传入一个数字<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>2. ```html<br>   <span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Hello world&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> 👈 传入一个字符串<br>   <span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;&#x27;Hello world&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> 👈 传入一个字符串<br></code></pre></td></tr></table></figure></li><li>```html<br><blog-post :is-published="false"></blog-post> 👈 传入一个布尔值<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br><span class="hljs-number">4</span>. ```html<br>   &lt;blog-post <span class="hljs-symbol">:comment-ids=<span class="hljs-string">&quot;[234, 266, 273]&quot;</span>&gt;&lt;/blog-post&gt;</span> 👈 传入一个数组<br></code></pre></td></tr></table></figure></li><li><pre><code class="html">&lt;blog-post  :author=&quot;&#123;    name: &#39;Veronica&#39;,    company: &#39;Veridian Dynamics&#39;  &#125;&quot;&gt;&lt;/blog-post&gt; 👈 传入一个对象<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><br>&gt; 即便传入的是一个静态数据，当这个数据为一个<span class="hljs-type">JS</span>值或表达式时，仍然需要使用v-bind绑定该prop后再赋值。<br><br><br><br>▲ **传入动态数据**：<br><br>所谓传入动态数据，就是向子组件prop传入一个父组件的响应式数据（<span class="hljs-class"><span class="hljs-keyword">data</span>、prop、computed中的内容都可以）。写法上和传入静态的<span class="hljs-type">JS</span>表达式并没有太多区别，**但有一种简便的写法，可以传入一个响应式对象数据的所有属性：**</span><br><br>```js<br><span class="hljs-class"><span class="hljs-keyword">data</span>() &#123;</span><br><span class="hljs-class"><span class="hljs-title">return</span> &#123;</span><br><span class="hljs-class">        <span class="hljs-title">post</span>: &#123;</span><br><span class="hljs-class">            <span class="hljs-title">id</span>: 1,</span><br><span class="hljs-class">            <span class="hljs-title">title</span>: &#x27;<span class="hljs-type">My</span> <span class="hljs-type">Journey</span> <span class="hljs-title">with</span> <span class="hljs-type">Vue</span>&#x27;</span><br><span class="hljs-class">      &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>下面的模板：</code></pre></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> ⭐⭐<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;post.id&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>四、单向数据流</strong></p><p>props属性挂载的通信属性（变量），从设计的初衷来看，应该是只读属性。所以在组件里避免有代码可以修改通信属性的值。</p><ul><li><p>如果子组件内需要修改父组件传入的prop的值，则最好定义一个本地的 data property并将这个prop作为其初始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">props: [<span class="hljs-string">&#x27;initialCounter&#x27;</span>],<br><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    counter: <span class="hljs-built_in">this</span>.initialCounter<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">props: [<span class="hljs-string">&#x27;size&#x27;</span>],<br>computed: &#123;<br>  normalizedSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size.trim().toLowerCase()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意：在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p></blockquote></li></ul><p><strong>五、类型检查</strong></p><p><code>type</code> 可以是下列原生构造函数中的一个：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Array</code></li><li><code>Object</code></li><li><code>Date</code></li><li><code>Function</code></li><li><code>Symbol</code></li></ul><blockquote><p>父组件向子组件任何类型的prop传入<code>undefined</code>或<code>null</code>都能通过类型检查。</p></blockquote><p>额外的，<code>type</code> 还可以是一个<strong>自定义的构造函数</strong>，并且通过 <code>instanceof</code> 来进行检查确认，验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。例如，给定下列现成的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName<br>  <span class="hljs-built_in">this</span>.lastName = lastName<br>&#125;<br></code></pre></td></tr></table></figure><p>你可以使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;blog-post&#x27;</span>, &#123;<br>  props: &#123;<br>    author: Person<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>六、prop验证函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义验证函数</span><br>propF: &#123;<br>    validator: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="hljs-number">1</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>当 prop 验证失败的时候（validator返回false），(开发环境构建版本的) Vue 将会产生一个**<font color="orange">控制台的警告</font>**。👈 不是报错。</p><h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p><strong>一、基本使用</strong></p><ol><li><p>子组件监听DOM事件（如click），在事件响应函数中处理逻辑，然后通过<code>vm.$emit</code>发射自定义事件并传入通信数据。</p></li><li><p>父组件在子组件的标签内监听自定义事件并接收通信数据。自定义事件的响应函数不需要传参。</p></li></ol><p>**二、关于自定义事件命名 ❗ **</p><p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)。</p><p><font color='red'>所以Vue推荐始终使用 kebab-case (下划线格式)的事件名。</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">click-li</span>=<span class="hljs-string">&quot;getClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--  父组件监听子组件的自定义事件clickli   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in categories&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;myClick(item.id,item.name)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--事件响应函数--&gt;</span><br>            &#123;&#123;item.name&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            categories:[<br>                &#123;<br>                    id:1,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;mz&#x27;</span></span><br>                &#125;,<br>                &#123;<br>                    id:2,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;ley&#x27;</span></span><br>                &#125;<br>            ]<br>        &#125;),<br><span class="javascript">        <span class="hljs-comment">// 👇 可以显式地定义这个组件会向外发射的事件，这是可选的。</span></span><br><span class="javascript">        emits: [<span class="hljs-string">&#x27;clickli&#x27;</span>],</span><br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">myClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;click-li&#x27;</span>,id,name);  <span class="hljs-comment">//发生自定义事件，这里传入了两个通信数据id和name。</span></span><br>            &#125;<br>        &#125;<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">getClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(id,name);</span><br>            &#125;<br>        &#125;<br>        <br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>三、$event</strong></p><p>子组件自定义事件不存在事件对象，但父组件监听子组件的事件时，也可以访问$event，该参数的值是子组件发射事件时的第一个参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">clickli</span>=<span class="hljs-string">&quot;getClick, printEvent($event)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>所以强烈建议在使用<code>vm.$emit(&#39;event-name&#39;)</code>时，如果需要传递信息给父组件，尽量使用一个参数。如果有多个参数要传递，则宜使用<code>payload</code>对象的形式，将所有参数由一个对象返回：<code>vm.$emit(&#39;event-name&#39;, &#123;...&#125;)</code>。</p><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>实现父子组件之间的双向通信。</p><p>在父组件的输入框输入要传递的数据，在子组件的文本框显示。</p><p>在子组件的输入框输入要传递的数据，在父组件的文本框显示。</p><p>在子组件的watch属性中定义要监听的数据的同名函数，以监听子组件数据的变化，并发送给父组件。</p><p><img src="/./image-20200819181030339.png" alt="image-20200819181030339"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            向子传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>            子组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ctoday&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;today&quot;</span> @<span class="hljs-attr">cinput</span>=<span class="hljs-string">&quot;getCtoday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                向父传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;inputDate&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--懒监听--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                父组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                today:<span class="hljs-string">&#x27;2020-08-19&#x27;</span>,</span><br><span class="javascript">                ctoday:<span class="hljs-string">&#x27;&#x27;</span>,</span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">getCtoday</span>(<span class="hljs-params">value</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.ctoday=value;</span><br>                &#125;<br>            &#125;,<br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            inputDate:<span class="hljs-string">&#x27;&#x27;</span></span><br>                        &#125;<br>                    &#125;,<br>                    props:&#123;<br>                        today:&#123;<br><span class="javascript">                            type:<span class="hljs-built_in">String</span></span><br>                        &#125;<br>                    &#125;,<br>                    watch:&#123;<br><span class="javascript">                        <span class="hljs-comment">//在watch中定义inputDate的同名函数，监听该数据的变化，处理逻辑</span></span><br><span class="javascript">                        <span class="hljs-function"><span class="hljs-title">inputDate</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123; </span><br><span class="javascript">                            <span class="hljs-built_in">console</span>.log(oldValue,<span class="hljs-string">&#x27;=&gt;&#x27;</span>,newValue);</span><br><span class="javascript">                            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;cinput&#x27;</span>,newValue);</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件间的双向数据绑定"><a href="#父子组件间的双向数据绑定" class="headerlink" title="父子组件间的双向数据绑定"></a>父子组件间的双向数据绑定</h3><h4 id="组件的v-model"><a href="#组件的v-model" class="headerlink" title="组件的v-model"></a>组件的v-model</h4><p>组件的响应式数据可以和原生的DOM标签（如input:text, checkbox等）发送双向数据绑定。</p><p>而Vue提供了一种更加强大的功能，能够让父级组件的响应式数据和子组件的prop发生双向数据绑定，但这需要父级组件和子级组件之间的配合来实现。</p><blockquote><p>其实这没有什么神奇的地方，其实我们也可以通过已知的内容来实现：</p><ol><li>父组件向子组件的prop传入数据。</li><li>当子组件需要改变prop的值从而与父级组件产生联系时，不直接修改prop，而通过发出一个特殊名字的自定义事件，提醒父级组件更新数据。</li><li>父组件收到子组件的更新提醒，更新那个绑定到子组件prop的数据。</li></ol></blockquote><p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">Vue2 自定义组件的v-model</a></p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 定义子组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;button @click&#x3D;&quot;buttonClick&quot; &gt;触发自定义事件&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#39;HelloWorld&#39;,<br>  &#x2F;* ⭐ model option *&#x2F;  <br>  model: &#123;  <br>    prop: &#39;childDate&#39;, &#x2F;&#x2F; 👈 显示地定义v-model绑定到的prop名<br>    event: &#39;change&#39;, &#x2F;&#x2F; 👈 更新该prop的自定义事件名<br>  &#125;,<br>  &#x2F;* ⭐ props option 配合model option中的prop *&#x2F;  <br>  props: &#123;<br>    childDate: Date, &#x2F;&#x2F; 👈 必须在props中定义在model中规定的propName<br>  &#125;,<br>  methods: &#123;<br>    buttonClick() &#123;<br>      this.$emit(&#39;change&#39;, new Date()); &#x2F;&#x2F; 👈 触发自定义事件change，告知父组件更新v-model绑定到的值<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;!-- 定义父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;&quot; id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;p&gt;日期 &#123;&#123; date &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;HelloWorld v-model&#x3D;&quot;date&quot;&#x2F;&gt; 👈 &lt;!-- 一旦子组件触发了change event，则父级组件更新date的值 --&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    HelloWorld,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      date: new Date(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>❗ <strong>如果子组件不定义model option：</strong><br>         1. model.prop默认为 ‘value’<br>         2. model.event默认为 ‘input’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 不设置model的子组件，同样可以具备更新父级组件v-model数据的功能 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;button @click&#x3D;&quot;buttonClick&quot; &gt;触发自定义事件&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#39;HelloWorld&#39;,<br>  props: &#123;<br>    value: Date,<br>  &#125;,<br>  methods: &#123;<br>    buttonClick() &#123;<br>      this.$emit(&#39;input&#39;, new Date()); &#x2F;&#x2F; 👈 发出input事件，并且传回一个payload( new Date )<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;!-- 定义父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;&quot; id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;p&gt;日期 &#123;&#123; date &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;HelloWorld v-model&#x3D;&quot;date&quot;&#x2F;&gt; 👈 &lt;!--一旦子组件触发了input event，则父级组件更新date的值为payload --&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    HelloWorld,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      date: new Date(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h4 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h4><p>👆<font color='red'> 在Vue2中强烈 推荐使用，而不是使用v-model，可以用于开发基础组件</font>。</p><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p><p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:title&#x27;</span>, newTitle)<br></code></pre></td></tr></table></figure><p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document<br>  v-bind:title&#x3D;&quot;doc.title&quot;<br>  v-on:update:title&#x3D;&quot;doc.title &#x3D; $event&quot;<br>&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure><p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document v-bind:title.sync&#x3D;&quot;doc.title&quot;&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p></blockquote><p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document v-bind.sync&#x3D;&quot;doc&quot;&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure><p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p><blockquote><p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p></blockquote><h4 id="Vue3的改变"><a href="#Vue3的改变" class="headerlink" title="Vue3的改变"></a>Vue3的改变</h4><p><strong>1.</strong> <strong>支持对自定义事件的payload进行验证</strong></p><p>与 prop 类型验证类似，如果使用对象语法而不是数组语法定义发出的事件，则可以验证它。</p><p>要添加验证，将为事件分配一个函数，该函数接收传递给 <code>$emit</code> 调用的参数，并返回一个布尔值以指示事件是否有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;custom-form&#x27;</span>, &#123;<br>  emits: &#123;<br>    <span class="hljs-comment">// 没有验证</span><br>    click: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-comment">// 验证submit 事件</span><br>    submit: <span class="hljs-function">(<span class="hljs-params">&#123; email, password &#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (email &amp;&amp; password) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;Invalid submit event payload!&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">submitForm</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;submit&#x27;</span>, &#123; email, password &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>2. 默认的v-model prop 和 event发生改变</strong></p><p>在Vue2中可以定义子组件的<code>model option</code>，规定当父级组件使用在子组件标签上使用v-model指令时的行为。</p><p>Vue2中默认的<code>model option</code>设置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">model: &#123;<br>    prop: <span class="hljs-string">&#x27;value&#x27;</span>,<br>    event: <span class="hljs-string">&#x27;input&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>而Vue3中”规定“了<code>model option</code>的设置是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">model: &#123;<br>    prop: <span class="hljs-string">&#x27;modelValue&#x27;</span>,<br>    event: <span class="hljs-string">&#x27;update:modelValue&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>同时：</p><ol><li>Vue3中定义<code>model option</code>不再起效果。</li><li>子组件发出<code>$emit(&#39;update:modelValue&#39;, payload)</code>成为父子组件之间的双向数据绑定的默认方式。</li><li><code>modelValue</code>成为子组件的功能型prop，不是隐含的，如果需要v-model功能时，也必须在props中定义。</li></ol><p><strong>3.</strong> <strong>组件标签上的v-model语法的增强，替代 .sync 修饰符</strong></p><p><font color='red'>Vue3中已经不再使用.sync修饰符。</font></p><p>现在可以使用<code>v-model:prop=&quot;fatherData&quot;</code>语法代替<code>:propName.sync=&quot;fatherData&quot;</code>语法。</p><p>我们现在可以在单个组件实例上创建一个或多个 v-model 绑定。</p><p>每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;user-name<br>  v-model:first-name=&quot;firstName&quot;<br>  v-model:last-name=&quot;lastName&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">user-name</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class="hljs-string">&#x27;user-name&#x27;</span>, &#123;<br>  props: &#123;<br>    firstName: <span class="hljs-built_in">String</span>,<br>    lastName: <span class="hljs-built_in">String</span><br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input </span><br><span class="hljs-string">      type=&quot;text&quot;</span><br><span class="hljs-string">      :value=&quot;firstName&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      type=&quot;text&quot;</span><br><span class="hljs-string">      :value=&quot;lastName&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个非 prop 的 attribute 是指传向一个子组件，但是该子组件<strong>并没有相应 prop 定义的 attribute</strong>。</p><p>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，<strong>而这些 attribute 会被添加到这个组件的根元素上。</strong></p><p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&lt;bootstrap-<span class="hljs-built_in">date</span>-<span class="hljs-built_in">input</span> data-<span class="hljs-built_in">date</span>-picker=<span class="hljs-string">&quot;activated&quot;</span>&gt;&lt;/bootstrap-<span class="hljs-built_in">date</span>-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p><h4 id="替换-合并根标签已有的Attribute"><a href="#替换-合并根标签已有的Attribute" class="headerlink" title="替换 / 合并根标签已有的Attribute"></a>替换 / 合并根标签已有的Attribute</h4><p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;bootstrap-<span class="hljs-type">date</span>-<span class="hljs-keyword">input</span><br>  data-<span class="hljs-type">date</span>-picker=&quot;activated&quot;<br>  <span class="hljs-keyword">class</span>=&quot;date-picker-theme-dark&quot;<br>&gt;&lt;/bootstrap-<span class="hljs-type">date</span>-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure><p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p><ul><li><code>form-control</code>，这是在组件的模板内设置好的</li><li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li></ul><p><strong>对于绝大多数 attribute 来说</strong>，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！</p><p><strong>庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，</strong>即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p><h4 id="禁用attribute继承"><a href="#禁用attribute继承" class="headerlink" title="禁用attribute继承"></a>禁用attribute继承</h4><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  inheritAttrs: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  required: <span class="hljs-literal">true</span>,<br>  placeholder: <span class="hljs-string">&#x27;Enter your username&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a href="https://cn.vuejs.org/v2/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">基础组件</a>的时候是常会用到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;base-input&#x27;</span>, &#123;<br>  inheritAttrs: <span class="hljs-literal">false</span>,<br>  props: [<span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>],<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;label&gt;</span><br><span class="hljs-string">      &#123;&#123; label &#125;&#125;</span><br><span class="hljs-string">      &lt;input</span><br><span class="hljs-string">        v-bind=&quot;$attrs&quot;              👈 $attrs中所有的属性都会被绑定到该标签上</span><br><span class="hljs-string">        v-bind:value=&quot;value&quot;</span><br><span class="hljs-string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="hljs-string">      &gt;</span><br><span class="hljs-string">    &lt;/label&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>❗ <strong>注意：</strong><code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。在子组件根标签上的<code>class</code>和<code>style</code>属性仍然会合并到子组件的根标签上。</p></blockquote><h4 id="和Vue3中的区别"><a href="#和Vue3中的区别" class="headerlink" title="和Vue3中的区别"></a>和Vue3中的区别</h4><p><strong>1</strong>. <strong>定义上的区别</strong></p><p>Vue3对非prop的attribute的定义：一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 <a href="https://vue3js.cn/docs/zh/guide/component-props">props</a> 或 <a href="https://vue3js.cn/docs/zh/guide/component-custom-events.html#defining-custom-events">emits</a> 定义的 attribute。常见的示例包括 <code>class</code>、<code>style</code> 和 <code>id</code> 属性。</p><blockquote><p>Vue3中允许在组件选项中定义emits这个option，显示地表明该组件会发出哪些自定义事件。</p></blockquote><p><strong>2</strong>. <strong>Vue3允许组件模板有多个根节点</strong></p><p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。<strong>如果组件模板有多个根节点，同时模板中未显式绑定 <code>$attrs</code>，将发出运行时警告。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-layout</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom-layout&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这将发出警告</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br><br><span class="hljs-comment">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="父子组件间的直接访问-children-parent"><a href="#父子组件间的直接访问-children-parent" class="headerlink" title="父子组件间的直接访问 $children/$parent"></a>父子组件间的直接访问 $children/$parent</h3><p>==一、父组件直接访问子组件==</p><p>在父组件中，可以通过this.$children或this.$refs拿到所有子组件。</p><ul><li><p>$children属性是一个数组，可以像this.$children[index]的型式通过下标拿到子组件对象。（不常用）</p></li><li><p>$refs属性是一个对象，子组件标签中设置ref属性标识自己，父组件可以通过this.$refs[ref]的形式获取特定的子组件对象。（更常用）</p></li></ul><p>可访问到的子组件内容：几乎所有内容（数据、方法）。</p><p>==二、子组件直接访问父组件==</p><p>在子组件中，可以通过this.$parent拿到父组件对象。</p><p>同时可以使用this.$root直接拿到Vue实例对象。（Vue实例是根组件）</p><p>由于组件之间耦合度不应该太高，所以很少在子组件中访问父组件。</p><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><p><strong>一、provide</strong></p><p>父级组件向自己以及后代组件提供（provide）共享的数据。</p><p>语法：</p><ol><li>```js<br>provide: {<pre><code>provideData1: &#39;hello world&#39;</code></pre>}<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">2</span>. ```<span class="hljs-selector-tag">js</span><br>   <span class="hljs-selector-tag">provide</span>() &#123;<br>       <span class="hljs-selector-tag">return</span> &#123;<br>           <span class="hljs-attribute">provideData1</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>,<br>           <span class="hljs-attribute">provideData2</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attribute">age</span>: <span class="hljs-number">24</span> &#125;,<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li>```js<br>data() {<br>  return {<pre><code>  shared: &#123;      state1: &#39;xxx&#39;,      state2: &#39;foo&#39;  &#125;,  info: &#39;bar&#39;,</code></pre>  }<br>},<br>provide() {<pre><code>return &#123;    provideData1: &#39;hello world&#39;,    provideData2: &#123; name: &#39;mz&#39;, age: 24 &#125;,    shared: this.shared, // 👈 提供一个响应式的引用类型数据    info: this.info, // 👈 提供一个响应式的基本类型数据，后代组件对其应该是只读的。&#125;</code></pre>}<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs"><br>   <br><br>**二、inject**<br><br>后代组件定义inject，从而获取到祖先组件实例上提供的内容。<br><br>语法：<br><br>1. ```js<br>   inject: [&#x27;provideData1&#x27;, &#x27;provideData2&#x27;]<br></code></pre></td></tr></table></figure></li><li><pre><code class="js">inject: &#123;    data1: &#39;provideData1&#39;,    data2: &#39;provideData2&#39;&#125;<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-number">3</span>. ```js<br>   <span class="hljs-keyword">inject</span>: &#123;<br>       data1: &#123;<br>           <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;provideData1&#x27;</span>,<br>           <span class="hljs-keyword">default</span>: <span class="hljs-number">123</span>,<br>       &#125;<br>       data2: &#123;<br>           <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;provideData2&#x27;</span>,<br>           <span class="hljs-keyword">default</span>() &#123;<br>               <span class="hljs-keyword">return</span> &#123;&#125;;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol><blockquote><p>注意点：</p><ol><li>非顶级组件（Vue实例）定义provide时，必须是函数形式，函数返回一个对象，对象内是提供的数据。</li><li>provide的内容可以是基本类型的数据，也可以是引用类型的数据。</li><li>provide的内容可以是响应式的，也可以是非响应式的（推荐使用响应式的）。</li><li>当provide的数据是非响应式的，或者是基本类型的数据时，后代组件在inject中获取该数据后，避免对其进行修改（这种provide的数据应该是只读的）。</li></ol></blockquote><p><strong>三、案例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 定义provide的父级组件 --&gt;<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;hr&gt;<br>    &lt;child-1 &#x2F;&gt;<br>    &lt;hr&gt;<br>    &lt;child-2 &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import Child1 from &#39;.&#x2F;components&#x2F;Child1.vue&#39;;<br>import Child2 from &#39;.&#x2F;components&#x2F;Child2.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    Child1,<br>    Child2,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      colorReactive: &#39;red&#39;,<br>      styleReactive: &#123;<br>        color: &#39;red&#39;,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>  &#x2F;&#x2F; 👇 向后代组件提供四种类型的数据<br>  provide() &#123;<br>    return &#123;<br>      styleReactive: this.styleReactive, &#x2F;&#x2F; 响应式的引用类型数据<br>      colorReactive: this.colorReactive, &#x2F;&#x2F; 响应式的基本类型数据<br>      color: &#39;red&#39;, &#x2F;&#x2F; 非响应式的基本类型数据<br>      style: &#123; &#x2F;&#x2F; 非响应式的引用类型数据<br>        color: &#39;red&#39;,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* MethodsMixin */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">updateColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateStyle</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.style.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>      <span class="hljs-comment">// this.$forceUpdate();</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateColorReactive</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.colorReactive === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.colorReactive = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.colorReactive = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateStyleReactive</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.styleReactive.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.styleReactive.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.styleReactive.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 后代组件Child1 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;Child1&lt;&#x2F;h2&gt;<br>    &lt;ul&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;父组件provide的基本类型数据: &#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;style&quot;&gt;父组件provide的引用类型数据: &#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColorReactive&quot;&gt;updateColorReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color: colorReactive &#125;&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; colorReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>    &lt;&#x2F;ul&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import sharedMethods from &#39;.&#x2F;sharedMethods&#39;;<br><br>export default &#123;<br>  name: &#39;Child1&#39;,<br>  inject: [&#39;color&#39;, &#39;style&#39;, &#39;colorReactive&#39;, &#39;styleReactive&#39;],<br>  mixins: [sharedMethods],<br>  data() &#123;<br>    return &#123;<br>      &#x2F;&#x2F; styleData: this.style, &#x2F;&#x2F; 👈 在data中引用inject的数据会对该数据进行响应式化，变为第四种情况<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 后代组件Child2 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;Child2&lt;&#x2F;h2&gt;<br>    &lt;ul&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;父组件provide的基本类型数据: &#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;style&quot;&gt;父组件provide的引用类型数据: &#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColorReactive&quot;&gt;updateColorReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color: colorReactive &#125;&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; colorReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>    &lt;&#x2F;ul&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import sharedMethods from &#39;.&#x2F;sharedMethods&#39;;<br><br>export default &#123;<br>  name: &#39;Child2&#39;,<br>  inject: [&#39;color&#39;, &#39;style&#39;, &#39;colorReactive&#39;, &#39;styleReactive&#39;],<br>  mixins: [sharedMethods],<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br><br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure><blockquote><p>简单分析：</p><ol><li><p>父组件提供非响应式的基本类型数据，当在子组件中使用inject获取该数据（例如foo），在子组件中修改该数据的值时（如this.foo = …），这个操作会触发子组件更新，但不会影响其他使用foo的组件。</p></li><li><p>父组件提供非响应式的引用类型数据，子组件使用inject获取该数据（例如obj），并且修改该引用类型数据的内容时（如this.obj.foo = …），既不会触发子组件的视图更新，也不会影响其他使用obj的组件。但是如果进行this.obj = …的操作，会触发子组件更新。</p><p>值得注意的是：如果某个后代组件在data中引用了inject中的该非响应式的引用类型数据，会对该数据进行initData，从而使该数据从此变成响应式的。</p></li><li><p>父组件提供响应式的基本类型数据，在子组件中获取该数据并进行修改操作时，与父组件提供的是非响应式基本类型数据的情况是相同的。</p></li><li><p>父组件提供响应式的引用类型数据，在子组件中获取该数据（例如obj），在子组件中修改该数据的值时（例如this.obj.foo = …），既会触发子组件视图更新（前提是视图中依赖了该对象内容），也会影响到其他使用obj的组件，会引起这些其他组件的更新（主要是父级、兄弟、侄子组件）。</p></li></ol></blockquote><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 插槽它允许你像这样合成组件： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>然后你在 <span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span>&gt;</span> 的模板中可能会写为：<br><br>&lt;a<br>  v-bind:href=&quot;url&quot;<br>  class=&quot;nav-link&quot;<br>&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>当组件渲染的时候，<span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：<br><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>甚至其它的组件：<br><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 添加一个图标的组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>如果 <span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span>&gt;</span> 的 template 中没有包含一个 <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。<br></code></pre></td></tr></table></figure><ul><li><p>在子组件的模板中留下slot标签标识插槽。</p></li><li><p>使用时，父组件模板中在子组件标签内为插槽填充内容。</p></li><li><p>关于渲染作用域，请记住：</p><blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p></blockquote></li></ul><h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在当我在一个父级组件中使用 <code>&lt;submit-button</code> &gt; 并且不提供任何插槽内容时：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后备内容“Submit”将会被渲染：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是如果我们提供内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><br>  Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>则这个提供的内容将会被渲染从而取代后备内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把页头放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>具名插槽的name一般不会作为property或者变量名，所以应该使用<strong>中划线格式的命名方式</strong>。</p></blockquote><p><strong>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字<code>“default”</code>。</strong></p><p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。</p><p>渲染的 HTML 将会是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> 。</p><p>(只有<a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>：只向子组件的默认插槽中插入内容，<code>v-slot</code>指令可以用在子组件的标签上)，这一点和已经废弃的 <a href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95"><code>slot</code> attribute</a> 不同。</p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p><strong>应用情景：</strong>在父组件中为子组件的插槽中添加内容，但内容中需要访问子组件的内容。</p><p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span&gt;<br>  &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;&#x2F;slot&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure><p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。</p><p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span&gt;<br>  &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt;<br>    &#123;&#123; user.lastName &#125;&#125;<br>  &lt;&#x2F;slot&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure><p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>    &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p><h4 id="v-slot用于组件标签上"><a href="#v-slot用于组件标签上" class="headerlink" title="v-slot用于组件标签上"></a>v-slot用于组件标签上</h4><p>在上述情况下，当被提供的内容<strong>只有默认插槽时</strong>，组件的标签才可以被当作插槽的模板来使用。<strong>这样我们就可以把 <code>v-slot</code> 直接用在组件标签上：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p><strong>注意：默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 无效，会导致警告 --&gt;<br>&lt;current-user v-slot&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;template v-slot:other&#x3D;&quot;otherSlotProps&quot;&gt;<br>    slotProps is NOT available here<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>    &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;&#x2F;template&gt;<br><br>  &lt;template v-slot:other&#x3D;&quot;otherSlotProps&quot;&gt;<br>    ...<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><h4 id="插槽作用域解构"><a href="#插槽作用域解构" class="headerlink" title="插槽作用域解构"></a>插槽作用域解构</h4><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">slotProps</span>) </span>&#123;<br>  <span class="hljs-comment">// 插槽内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。<strong>在支持ES2015的环境下，你也可以使用 <code>ES2015 解构语法</code>来传入具体的插槽 prop</strong>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user: person &#125;&quot;&gt;<br>  &#123;&#123; person.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user &#x3D; &#123; firstName: &#39;Guest&#39; &#125; &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><blockquote><p>这里的“prop重命名”、“定义后背内容” 都是利用的<code>ES2015 解构语法</code>的高级特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;24&#x27;</span>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; name, age &#125; = obj; <span class="hljs-comment">// 解构</span><br><span class="hljs-built_in">console</span>.log(name, age);<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: n, <span class="hljs-attr">age</span>: a &#125; = obj; <span class="hljs-comment">// 改名为 n 和 a;</span><br><span class="hljs-built_in">console</span>.log(n, a);<br><br><span class="hljs-comment">// 回滚值，只有当obj.gender为undefined或obj不存在不存在该属性是，gender才为默认的回滚值。</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: name2, <span class="hljs-attr">age</span>: age2, gender = <span class="hljs-string">&#x27;男&#x27;</span> &#125; = obj; <span class="hljs-comment">// 需要注意 0, null, false均不回滚</span><br><br></code></pre></td></tr></table></figure></blockquote><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;base-layout&gt;<br>  &lt;template v-slot:[dynamicSlotName]&gt;<br>    ...<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;base-layout&gt;<br></code></pre></td></tr></table></figure><h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;base-layout&gt;<br>  &lt;template #header&gt;<br>    &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt;<br>  &lt;&#x2F;template&gt;<br><br>  &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt;<br>  &lt;p&gt;And another one.&lt;&#x2F;p&gt;<br><br>  &lt;template #footer&gt;<br>    &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;base-layout&gt;<br></code></pre></td></tr></table></figure><p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这样会触发一个警告 --&gt;<br>&lt;current-user #&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user #default&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure><h4 id="具名插槽与v-for配合使用"><a href="#具名插槽与v-for配合使用" class="headerlink" title="具名插槽与v-for配合使用"></a>具名插槽与v-for配合使用</h4><p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>  &lt;li<br>    v-for&#x3D;&quot;todo in filteredTodos&quot;<br>    v-bind:key&#x3D;&quot;todo.id&quot;<br>  &gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure><p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>  &lt;!-- 👇 只允许这一种情况，逻辑上子组件模板中允许出现多个同名的具名插槽 --&gt;  <br>  &lt;li<br>    v-for&#x3D;&quot;todo in filteredTodos&quot;<br>    v-bind:key&#x3D;&quot;todo.id&quot;<br>  &gt;<br>    &lt;!--<br>    我们为每个 todo 准备了一个插槽，<br>    将 &#96;todo&#96; 对象作为一个插槽的 prop 传入。<br>    --&gt;<br>    &lt;slot name&#x3D;&quot;todo-item&quot; v-bind:todo&#x3D;&quot;todo&quot;&gt;<br>      &lt;!-- 后备内容 --&gt;<br>      &#123;&#123; todo.text &#125;&#125;<br>    &lt;&#x2F;slot&gt;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure><p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;todo-list v-bind:todos&#x3D;&quot;todos&quot;&gt;<br>  &lt;template v-slot:todo-item&#x3D;&quot;&#123; todo &#125;&quot;&gt;  &lt;!-- 每个名为todo-item的插槽都按照以下格式渲染 --&gt;<br>    &lt;span v-if&#x3D;&quot;todo.isComplete&quot;&gt;✓&lt;&#x2F;span&gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;todo-list&gt;<br></code></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：</p><p><img src="/./image-20210516211310527.png" alt="image-20210516211310527"></p><p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>currentTabComponent</code> 可以是：</p><ol><li><p>已注册组件的名字（字符串）</p></li><li><p>一个组件的选项对象</p></li></ol><h4 id="在动态组件上使用-keep-alive"><a href="#在动态组件上使用-keep-alive" class="headerlink" title="在动态组件上使用 keep-alive"></a>在动态组件上使用 keep-alive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 失活的组件将会被缓存！--&gt;<br>&lt;keep-alive&gt;<br>  &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;async-example&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 向 `resolve` 回调传递组件定义</span><br>    resolve(&#123;<br>      template: <span class="hljs-string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span><br>    &#125;)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a href="https://webpack.js.org/guides/code-splitting/">webpack 的 code-splitting 功能</a>一起配合使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;async-webpack-example&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-comment">// 这个特殊的 `require` 语法将会告诉 webpack</span><br>  <span class="hljs-comment">// 自动将你的构建代码切割成多个包，这些包</span><br>  <span class="hljs-comment">// 会通过 Ajax 请求加载</span><br>  <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./my-async-component&#x27;</span>], resolve)<br>&#125;)<br></code></pre></td></tr></table></figure><p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<br>  <span class="hljs-string">&#x27;async-webpack-example&#x27;</span>,<br>  <span class="hljs-comment">// 这个动态导入会返回一个 `Promise` 对象。</span><br>  () =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><p>当使用<a href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C">局部注册</a>的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-comment">// ...</span><br>  components: &#123;<br>    <span class="hljs-string">&#x27;my-component&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="处理加载的状态"><a href="#处理加载的状态" class="headerlink" title="处理加载的状态"></a>处理加载的状态</h4><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AsyncComponent = <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span><br>  component: <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span>),<br>  <span class="hljs-comment">// 异步组件加载时使用的组件</span><br>  loading: LoadingComponent,<br>  <span class="hljs-comment">// 加载失败时使用的组件</span><br>  error: ErrorComponent,<br>  <span class="hljs-comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span><br>  delay: <span class="hljs-number">200</span>,<br>  <span class="hljs-comment">// 如果提供了超时时间且组件加载也超时了，</span><br>  <span class="hljs-comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span><br>  timeout: <span class="hljs-number">3000</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>Vue3中提供了<code>Suspense</code>组件来处理异步子组件的加载状态。</p></blockquote><p>##自定义指令</p><p>自定义指令的源码在 vdom/modules/directives中</p><h3 id="局部与全局注册自定义指令"><a href="#局部与全局注册自定义指令" class="headerlink" title="局部与全局注册自定义指令"></a>局部与全局注册自定义指令</h3><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p><p>举个聚焦输入框的例子，当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注册一个全局自定义指令 `v-focus`</span><br>Vue.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>  inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// 聚焦元素</span><br>    el.focus()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directives: &#123;<br>  focus: &#123;<br>    <span class="hljs-comment">// 指令的定义</span><br>    inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>      el.focus()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><p><code>bind</code>：⭐只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。指令的bind钩子在调用Vnode的create钩子时会触发，即使用了createElm或createComponent为Vnode创建DOM元素后立刻触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">invokeCreateHooks(vnode, insertedVnodeQueue) <span class="hljs-comment">/* 该函数中会执行各个module对create声明周期的监听函数，同时将具有insert钩子的Vnode加入insertedVnodeQueue插入队列。而具有inserted钩子的自定义指令绑定的元素所对应的Vnode会将指令的inserted钩子合并到Vnode.data.hooks.insert上。*/</span><br></code></pre></td></tr></table></figure></li><li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)<br><span class="hljs-comment">/* __patch__在返回vnode.elm之前，才会调用插入队列中所有vnode的insert钩子。</span><br><span class="hljs-comment">也就是在一轮组件patch结束之前才会按从子到父的顺序执行insert钩子，这个时机可能远远晚于某个vnode的elm被插入到自己的父亲中的时间点。*/</span><br></code></pre></td></tr></table></figure></li><li><p><code>update</code>：⭐所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 真正的update执行时机是在patchVnode主要逻辑之前。</span><br><span class="hljs-comment">此时还没有真正的对Vnode的text和children进行patch。</span><br><span class="hljs-comment">但是在执行自定义指令的update钩子之前，此Vnode的elm的attrs、class、style等等已经更新了。这是由于其他平台相关模块的钩子在指令钩子之前执行，所以说钩子的顺序也很重要。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) <br>  <span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) <br>&#125;<br><span class="hljs-keyword">if</span> (isUndef(vnode.text)) &#123; <br>    <span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 👇 patchVnode函数部分定义</span><br><span class="hljs-keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) <br>  <span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) <br>&#125;<br><span class="hljs-keyword">if</span> (isUndef(vnode.text)) &#123; <br>    <span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br><span class="hljs-keyword">if</span> (isDef(data)) &#123;<br><span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) <br>        i(oldVnode, vnode) <span class="hljs-comment">// 👈 执行vnode的postpatch钩子。此时vnode及其子vnode已经patch完成了。</span><br>&#125;<br><br><span class="hljs-comment">/*自定义指令的componentUpdated钩子会安装到绑定该指令的vnode的postpatch钩子上，</span><br><span class="hljs-comment">* 即componentUpdated钩子真正执行的时机是patchVnode(old, new)的最后时刻。</span><br><span class="hljs-comment">* 此时vnode及其子vnode都已经patch完成了，此时vnode.elm为更新过后的最新正确状态。</span><br><span class="hljs-comment">* 所以当自定义指令绑定在父容器上，并且会对其子元素产生影响时，最好使用componentUpdated钩子，而不是update钩子。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><p>接下来我们来看一下钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code>)。</p><h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><p>指令钩子函数会被传入以下参数：</p><ul><li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下 property：<ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li></ul></li><li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</li><li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li></ul><blockquote><p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset"><code>dataset</code></a> 来进行。</p></blockquote><p>这是一个使用了这些 property 的自定义钩子样例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hook-arguments-example&quot;</span> <span class="hljs-attr">v-demo:foo.a.b</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;demo&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">JSON</span>.stringify<br>    el.innerHTML =<br>      <span class="hljs-string">&#x27;name: &#x27;</span>       + s(binding.name) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;value: &#x27;</span>      + s(binding.value) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;expression: &#x27;</span> + s(binding.expression) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;argument: &#x27;</span>   + s(binding.arg) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;modifiers: &#x27;</span>  + s(binding.modifiers) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;vnode keys: &#x27;</span> + <span class="hljs-built_in">Object</span>.keys(vnode).join(<span class="hljs-string">&#x27;, &#x27;</span>)<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#hook-arguments-example&#x27;</span>,<br>  data: &#123;<br>    message: <span class="hljs-string">&#x27;hello!&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="/./image-20210322221045773.png" alt="image-20210322221045773"></p><h3 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h3><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p><p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;baseexample&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Scroll down the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;pin&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    el.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span><br>    el.style.top = binding.value + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#baseexample&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dynamicexample&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin:</span>[<span class="hljs-attr">direction</span>]=<span class="hljs-string">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;pin&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    el.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span><br>    <span class="hljs-keyword">var</span> s = (binding.arg == <span class="hljs-string">&#x27;left&#x27;</span> ? <span class="hljs-string">&#x27;left&#x27;</span> : <span class="hljs-string">&#x27;top&#x27;</span>)<br>    el.style[s] = binding.value + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#dynamicexample&#x27;</span>,<br>  data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      direction: <span class="hljs-string">&#x27;left&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h3><p>在很多时候，你可能想在 <code>bind</code> 和 <code>update</code> 时触发相同行为，而不关心其它的钩子。比如这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;color-swatch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) </span>&#123;<br>  el.style.backgroundColor = binding.value<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。<strong>同时，对象字面量中可以引用组件实例的状态。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-demo</span>=<span class="hljs-string">&quot;&#123; color: &#x27;white&#x27;, text &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;demo&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(binding.value.color) <span class="hljs-comment">// =&gt; &quot;white&quot;</span><br>  <span class="hljs-built_in">console</span>.log(binding.value.text)  <span class="hljs-comment">// =&gt; &quot;hello!&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-comment">//...</span><br>    data: &#123;<br>        text: <span class="hljs-string">&#x27;hello world&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>依赖于Node环境，并全局安装webpack</li><li>npm intsall -g @vue/cli</li></ol><p>以上是安装脚手架3的步骤，如果需要兼容脚手架2的语法，需要额外执行第三条：</p><ol start="3"><li>npm install -g @vue/cli-init</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试</span><br>vue --version<br></code></pre></td></tr></table></figure><h3 id="使用cli2初始化一个项目"><a href="#使用cli2初始化一个项目" class="headerlink" title="使用cli2初始化一个项目"></a>使用cli2初始化一个项目</h3><ol><li><pre><code class="dos">vue init webpack $项目名称   👉会在当前目录创建同名文件夹<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>![image<span class="hljs-number">-20200828201856002</span>](./image<span class="hljs-number">-20200828201856002.</span>png)<br><br><br><br>### 使用cli3初始化一个项目<br><br><span class="hljs-number">1.</span> ```dos<br>   vue create $项目名称<br></code></pre></td></tr></table></figure>![image-20200922221753466](./image-20200922221753466.png)</code></pre></li></ol><hr><h2 id="Vue-router-前端路由"><a href="#Vue-router-前端路由" class="headerlink" title="Vue-router 前端路由"></a>Vue-router 前端路由</h2><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><p>后端渲染阶段</p><p>👇   +ajax</p><p>前后端分离阶段</p><p>👇   +前端路由</p><p>SPA 单页面富应用阶段</p><p><strong>如何实现前端路由？</strong></p><p>要实现前端路由，需要解决两个核心：</p><ul><li>如何改变 URL 却不引起页面刷新？</li><li>如何检测 URL 变化了？</li></ul><p>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p><ol><li><h5 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h5><ul><li>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新。</li><li>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过<code>&lt;a&gt;</code>标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件。⭐</li></ul></li><li><h5 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h5><ul><li>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。⭐</li></ul></li></ol><p>==参考资料：==[<a href="https://www.cnblogs.com/lguow/p/10921564.html]">https://www.cnblogs.com/lguow/p/10921564.html]</a></p><hr><h3 id="vue-router-安装与基本使用"><a href="#vue-router-安装与基本使用" class="headerlink" title="vue-router 安装与基本使用"></a>vue-router 安装与基本使用</h3><p><img src="/./image-20200829225840412.png" alt="image-20200829225840412"></p><p>目录结构：</p><p>project</p><p>—components目录</p><p>——Home.vue    //组件</p><p>——About.vue   //组件</p><p>—router目录</p><p>——index.js    //路由配置文件</p><p>—main.js</p><p>—App.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># main.js<br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>   <span class="hljs-comment">//根组件</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index.js&#x27;</span>  <span class="hljs-comment">//可省略index.js</span><br><br>Vue.config.productionTip=<span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router:router,  <span class="hljs-comment">//挂载路由</span><br>    render:<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>h(App)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p><img src="/./image-20200829231314899.png" alt="image-20200829231314899"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># index.js<br><br><span class="hljs-comment">//事先准备好Home和About两个组件</span><br><br><span class="hljs-comment">/*路由组件与路由的映射 </span><br><span class="hljs-comment">/home  👉  Home.vue</span><br><span class="hljs-comment">/about 👉  About.vue</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span> <br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About.vue&#x27;</span><br><br><br><span class="hljs-comment">// 1.通过Vue.use(插件)，安装插件</span><br>Vue.use(VueRouter);<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>]<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &#x2F;&#x2F;router-link是由vue-router注册的全局组件，控制前端路由。默认会渲染为一个a标签<br>        &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;    <br>        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;&lt;&#x2F;router-link&gt;<br>        <br>        &#x2F;&#x2F;router-view是占位组件，可显示前端路由绑定的组件<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br>    <br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p><img src="/./image-20200830144015434.png" alt="image-20200830144015434"></p><h3 id="默认路由（路由重定向）"><a href="#默认路由（路由重定向）" class="headerlink" title="默认路由（路由重定向）"></a>默认路由（路由重定向）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <span class="hljs-comment">//   根目录重定向到&#x27;/home&#x27;</span><br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p><p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p><p>上面对应的路由配置为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attr">component</span>: A, <span class="hljs-attr">alias</span>: <span class="hljs-string">&#x27;/b&#x27;</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p><h3 id="hash与HTMl5的history模式"><a href="#hash与HTMl5的history模式" class="headerlink" title="hash与HTMl5的history模式"></a>hash与HTMl5的history模式</h3><p>在不刷新页面的前提下，改变URL有两种方式：</p><p>1.改变url的hash（锚点），本质上是改变location对象的hash属性。（location.hash=xxx）</p><p>2.使用HTML5的history模式中的API。</p><pre><code>BOM中使用栈结构保存访问资源的历史记录，并使用一个指针指向当前的URL。</code></pre><ul><li>history.pushState( { } , ‘’ ,’home’)    ==’/home’ 压栈==</li><li>history.back( )              ==指针下移==</li><li>history.forward( )         ==指针上移==</li><li>history.go(n)                 ==指针跳转==</li><li>history.replaceState({ },’’, ‘home’)      ==’/home’ 替换栈顶==</li></ul><h3 id="在vue-router中使用history模式"><a href="#在vue-router中使用history模式" class="headerlink" title="在vue-router中使用history模式"></a>在vue-router中使用history模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>                    <span class="hljs-comment">//在创建路由对象时，配置history模式。默认值为&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h3><ol><li><p><strong>to属性</strong></p><p>用于声明式前端路由跳转，to属性指定跳转的绝对path、query以及hash。</p><p>&lt;router-link ==to===”/home”&gt;     &lt;/ router-link&gt;</p></li></ol><ol start="2"><li><p><strong>tag属性</strong></p><p>用于指定router-link标签最终被渲染成的dom标签类型，默认情况下会被渲染成a标签。</p><p>&lt;router-link to=”/home” ==tag===”button”&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>replace布尔属性</strong></p><p>在url跳转时使用history.replace方法，替换BOM历史记录栈结构的栈顶记录。</p><p>&lt;router-link to=”/home” tag=”button” ==replace==&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>active-class属性</strong></p><p>用于指定router-link渲染出的标签在活跃（被点击）时的class属性值。默认为router-link-active。</p><p><img src="/./image-20200830165640888.png" alt="image-20200830165640888"></p><p>👇</p><p>&lt;router-link to=”/home” tag=”button” ==active-class=”active”==&gt;   &lt;/ router-link&gt;</p><p><img src="/./image-20200830165558560.png" alt="image-20200830165558560"></p></li></ol><p>   <em>在路由对象中全局修改所有router-link的active-class：</em></p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>,<br>    linkActiveClass:<span class="hljs-string">&#x27;active&#x27;</span>  <span class="hljs-comment">//修改linkActiveClass属性</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="router和-route"><a href="#router和-route" class="headerlink" title="$router和$route"></a>$router和$route</h3><p><strong>一、区别</strong></p><p><code>this.$router</code>是VueRouter的实例。</p><p>当导航到不同url，可以使用<code>this.$router.push</code>方法，这个方法则会向history栈里面添加一条记录，当点击浏览器回退按钮或者<code>this.$router.back()</code>就会回退之前的url。</p><p><code>this.$route</code>相当于当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如name,path,query,params等。</p><p><strong>二、联系</strong></p><p><code>$router</code>和<code>$route</code>是Vue原型对象上的属性，而所有组件都是Vue及其子类的实例，所以我们能通过组件的隐式原型链访问到这两个属性。</p><p><strong>三、常见使用</strong></p><p><code>this.$router</code></p><ol><li><p>push方法</p><p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>是等同的，会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.push(path)<br></code></pre></td></tr></table></figure></li><li><p>go方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//页面路由跳转 前进或者后退</span><br><span class="hljs-built_in">this</span>.$router.go(n)<br></code></pre></td></tr></table></figure></li><li><p>replace方法</p><p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的记录，并置为history栈顶。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.replace(path)<br></code></pre></td></tr></table></figure></li></ol><p><code>this.$route</code></p><p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p><ol><li><strong>$route.path</strong></li></ol><p>类型: <code>string</code></p><p>   字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</p><ol start="2"><li><p><strong>$route.params</strong></p><p>类型: <code>Object</code></p><p>一个 key/value 对象，包含了 动态片段 和 全匹配片段，<br>如果没有路由参数，就是一个空对象。</p></li><li><p><strong>$route.query</strong></p><p>类型: <code>Object</code></p><p>一个 key/value 对象，表示 URL 查询参数。<br>例如，对于路径 /foo?user=1，则有 $route.query.user == 1，<br>如果没有查询参数，则是个空对象。</p></li><li><p><strong>$route.hash</strong></p><p>类型: <code>string</code></p><p>当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</p></li><li><p><strong>$route.fullPath</strong></p><p>类型: <code>string</code></p><p>完成解析后的路径，包含path、查询参数和 hash 的完整路径。</p></li><li><p><strong>$route.matched</strong></p><p>类型: <code>Array&lt;RouteRecord&gt;</code></p><p>一个数组，包含当前路由的所有嵌套路径片段的<strong>路由记录</strong> 。路由记录就是 <code>routes</code> 配置数组中的对象副本 (还有在 <code>children</code> 数组)。</p></li><li><p><strong>$route.name</strong>  </p><p>当前路由的名称，如果有的话。</p></li><li><p><strong>$route.meta</strong></p><p>类型：<code>Object</code></p><p>一个键值对，内容$route匹配的那条路由纪录的元数据，如果有的话。</p><p>如果$route匹配的那条路由没有元数据，则本属性值为一个空对象。</p></li></ol><h3 id="编程式前端路由跳转"><a href="#编程式前端路由跳转" class="headerlink" title="编程式前端路由跳转"></a>编程式前端路由跳转</h3><p>即通过代码调用api跳转路由。</p><p>而在router-link标签中通过to属性跳转路由称作声明式前端路由跳转，其本质还是调用了$router.push方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &lt;button @click&#x3D;&quot;clickhome&quot;&gt;去主页&lt;&#x2F;button&gt;  &#x2F;&#x2F;使用按钮而不是router-link<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>        router:router,<br>        methods:&#123;<br>            clickHome()&#123;<br>                &#x2F;&#x2F;调用组件的$router的push方法跳转路由<br>                &#x2F;&#x2F;相当于执行了history.pushState(&#39;&#x2F;home&#39;)<br>                &#x2F;&#x2F;相应的还有$router.replace(path)方法<br>                this.$router.push(&#39;&#x2F;home&#39;);    <br>                &#x2F;&#x2F;this.$router.replace(&#39;&#x2F;home&#39;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><strong>Vue官方解析</strong></p><p><code>router.push(location, onComplete?, onAbort?)</code></p><p><strong>注意</strong>：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>push/replace方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&#x27;home&#x27;</span>)<br><br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br><br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;123&#x27;</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user/123</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/123</span><br><span class="hljs-comment">// 这里的 params 不生效</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>push方法中的<code>path</code>可以是相对路径。例如：</p><ol><li><p>若当前<code>path</code>为<code>/user</code>,则使用<code>$router.push(&#39;./user/mz&#39;)</code>可以跳转到<code>/user/mz</code>。</p><p>原因是<code>/user</code>的当前目录仍然为==根目录 /== 。</p></li><li><p>若当前path为<code>/user/</code>,则使用<code>$router.push(&#39;./mz&#39;)</code>就能跳转到<code>/user/mz</code></p></li></ol><p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p><p><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，组件的生命周期钩子不会触发，你需要使用组件的 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 钩子来响应这个变化 (比如发出请求抓取用户信息并更新组件视图)。</p><p><strong>坑</strong>🕳：</p><p><font color='red'>在vue-router中，使用$router.push/replace时会检查是否重复跳转至当前所在路由，如果是，则会抛出异常，但不影响功能使用</font></p><p>解决方法：</p><p>方法1.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"># 在router目录下的index.js (路由文件最后加载以下代码片段)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    let router = new VueRouter(&#123;...&#125;)</span><br><span class="hljs-comment">    ....</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> originalPush = VueRouter.prototype.push; <span class="hljs-comment">//解决push方法的bug</span><br>VueRouter.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-keyword">const</span> originalReplace = VueRouter.prototype.replace;  <span class="hljs-comment">//解决replace方法的bug</span><br>VueRouter.prototype.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalReplace.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-comment">// export default router</span><br></code></pre></td></tr></table></figure><p>方法2.</p><pre><code>下载指定版本的vue-router  </code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i vue-router@<span class="hljs-number">3</span>.<span class="hljs-number">0</span> --save<br></code></pre></td></tr></table></figure><p>[<a href="https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1%5D">https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1]</a></p><h3 id="动态路由与路由参数"><a href="#动态路由与路由参数" class="headerlink" title="动态路由与路由参数"></a>动态路由与路由参数</h3><p>==（以动态二级路由为例）==</p><p>动态路由的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>  <span class="hljs-comment">//导入User组件</span><br><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>    path:<span class="hljs-string">&#x27;/user&#x27;</span>,<br>        component:Login,<br>        children:[<br>            &#123;<br>                name:<span class="hljs-string">&#x27;userInfo1&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;:userId&#x27;</span>,<br>                component:User<br>            &#125;<br>        ]<br>    &#125;,<br>    <br>    &#123;<br>        name:<span class="hljs-string">&#x27;userInfo2&#x27;</span><br>        path:<span class="hljs-string">&#x27;/user/:userId&#x27;</span>, <span class="hljs-comment">//UserInfo2永远不会起作用，因为优先级比userInfo1低。哪一条路由先设置，哪一条路由的优先级较高。</span><br>        component:User<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>一级路由组件向二级路由传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Login.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;login&quot;&gt;<br>        <br>        &lt;!-- 指定跳转的完整绝对路径 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        &lt;!--相当于👇--&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;path:&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&#125;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        <br>        <br>        &lt;!-- 指定跳转到名为userInfo1的路由，并设置参数 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;name:&#39;userInfo1&#39;,params:&#123;userId&#125;&#125;&quot;&gt;登录2&lt;&#x2F;router-link&gt;<br>        <br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>二级路由组件获取路由参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue"># User.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;user&quot;&gt;<br>        &lt;div&gt;头像&lt;&#x2F;div&gt;<br>        &lt;!-- 获取当前路由中的参数  $route.params  --&gt;<br>        &lt;h2&gt;id:&lt;span&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;&#x2F;span&gt;  <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        name:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:App,<br>        <span class="hljs-comment">//开始嵌套</span><br>        children:[                 <span class="hljs-comment">//在路由配置对象中的children属性，可以设置子路由</span><br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /home</span><br>                name:<span class="hljs-string">&#x27;homepage&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,       <span class="hljs-comment">//子路由配置中，路径使用相对路径 </span><br>                component:Home<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /user/...</span><br>                name:<span class="hljs-string">&#x27;userinfo&#x27;</span>,      <span class="hljs-comment">//为路由设置name属性 唯一标识该条路由</span><br>                path:<span class="hljs-string">&#x27;user/:userId&#x27;</span>,  <span class="hljs-comment">// 子路由配置中，使用动态路由</span><br>                component:User<br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p><code>路由的嵌套只是用一种结构化的方式配置前端路由信息，将逻辑上有层次关系的路由放在一起，但相应的路由组件不存在绝对的层次化渲染关系。</code></p><p><code>子路由对应的component如何显示，只与该路由是在哪一个组件中跳转有关，子路由组件在该组件中的router-view中显示。</code></p><p><font color='red'>为了避免组件渲染后的层次关系混乱，父级路由对应的组件与子路由对应的组件也应该具有相应的父子关系。</font></p><blockquote><p>当route中有两条路由配置可以匹配同一个URL时，谁先在routes中定义，就匹配拿一条。</p><p>如 {path: ‘/user’, component: Login, children: [ {path: ‘:userId’, component: User} ]},</p><p>{path: ‘/user/:userId’, component: User} 这两条路由都可以匹配 /user/1，但前一条先定义，则匹配前一条，Login组件将嵌套User组件显示。</p><p>如果将第二条路由先定义，则直接显示User组件。</p></blockquote><h3 id="路由组件懒加载"><a href="#路由组件懒加载" class="headerlink" title="路由组件懒加载"></a>路由组件懒加载</h3><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><p>在Vue Cli的默认配置情况下，所有的开发组件vue文件 (包括main.js)会被打包到一个app.js中，这就使得该js文件十分庞大。</p><p>(除了app.js会被第一时间请求外，还有第三方包的打包文件vendor.js以及模块化底层支撑的文件manifest.js会被第一时间请求至前端)</p><p>在使用组件懒加载后，每个懒加载的组件会被单独打包到一个js文件中（而不是app.js），浏览器会根据前端路由，按需向服务器请求组件的js打包文件。</p><p><img src="/./image-20200901110233735.png" alt="image-20200901110233735"></p><p><img src="/./image-20200901110610641.png" alt="image-20200901110610641"></p><p><strong>基本语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> Home=<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>)<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;<br>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h4><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 <a href="https://webpack.js.org/guides/code-splitting-require/#chunkname">命名 chunk</a>，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> Bar = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Bar.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> Baz = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Baz.vue&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>参考资料：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p><h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"># router 👉 index.js<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:Index,<br>        meta:&#123;    <span class="hljs-comment">//在元数据meta中保存一些路由信息</span><br>            title:<span class="hljs-string">&#x27;首页&#x27;</span><br>        &#125;<br>        children:[<br>            &#123;<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,<br>                component:Home,<br>                meta:&#123;<br>                    title:<span class="hljs-string">&#x27;主页&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>        <br>    &#125;<br>];<br><br><span class="hljs-keyword">let</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">/* beforeEach方法加载前置守卫 */</span><br>router.beforeEach( guard:<span class="hljs-built_in">Function</span> );  <span class="hljs-comment">//钩子（守卫）的用法类似于中间件，可挂载多个钩子</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p><strong>前置钩子</strong>（守卫）要传入三个参数，分别为：</p><pre><code>  1. **to：Route对象** ，将要跳转到的下一个活跃路由  2. from： Route对象，当前的活跃路由，即$route对象  3. **next ：Function  下一个钩子函数**，必须使在钩子内调用一下 next( )。执行效果依赖 next 方法的调用参数。  - **`next()`**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。  - **`next(false)`**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。  - **`next(&#39;/&#39;)` 或者 `next(&#123; path: &#39;/&#39; &#125;)`**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: &#39;home&#39;` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。  - **`next(error)`**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。</code></pre><p><strong>案例：在跳转到各条路由时更新标签页的标题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    <br>    <span class="hljs-built_in">console</span>.log(to);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">from</span>);<br>    <br>    <span class="hljs-built_in">document</span>.title=to.meta.title;<br>   <br>    <span class="hljs-comment">//document.title=to.matched[0].meta.title </span><br>   <span class="hljs-comment">//matched是一个数组，保存了所有匹配的路由</span><br>    <br>    next();<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h4><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB</a></p><p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = &#123;<br>  template: <span class="hljs-string">`...`</span>,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span><br>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>  &#125;,<br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;,<br>  beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-comment">// just use `this`</span><br>  <span class="hljs-built_in">this</span>.name = to.params.name<br>  next()<br>&#125;<br></code></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-keyword">const</span> answer = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (answer) &#123;<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next(<span class="hljs-literal">false</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B</a></p><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="keep-alive包裹router-view"><a href="#keep-alive包裹router-view" class="headerlink" title="keep-alive包裹router-view"></a>keep-alive包裹router-view</h3><p><code>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染（维持生命周期）。</code></p><p>使用keep-alive包裹一个需要反复使用的一个组件，可以避免组件在不活跃时被销毁，在活跃时被新建。同时该组件会具有新的生命周期函数actived和deactived。</p><p><strong>案例：组件在失活时记录组件状态，组件重新活跃时返回至上一状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Home.vue<br># &lt;keep-alive&gt;标签包裹了Home.vue的父级组件中的&lt;router-view&#x2F;&gt;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>    &#123;&#123;path&#125;&#125;  <br>&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;Home&#39;,<br>        data()&#123;<br>            return &#123;<br>                path:&#39;&#x2F;home&#39;<br>            &#125;<br>        &#125;,<br>        actived()&#123;<br>            this.$router.replace(this.path);   &#x2F;&#x2F;返回至失活前的状态<br>        &#125;,<br>        beforeRouteLeave(to, from, next)&#123;         &#x2F;&#x2F;组件内的后置勾子<br>            this.path&#x3D;this.$route.path;<br>            next();<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;    <br></code></pre></td></tr></table></figure><p><strong>keep-alive标签的exclude和include属性</strong></p><p>keep-alive标签可以利用exclude与include属性指定排除或包含哪些组件的生命周期会被维持，属性值为逗号分隔的字符串，对应组件定义时的name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;<br>&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;<br>    &lt;router-view&#x2F;&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p><ul><li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li><li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li></ul><p>从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p><h4 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h4><p>当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p><p>假设我们有一个 <code>Post</code> 组件，需要基于 <code>$route.params.id</code> 获取文章数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loading&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span><br>      Loading...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><br>      &#123;&#123; error &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      loading: false,<br>      post: null,<br>      error: null<br>    &#125;<br>  &#125;,<br>  created () &#123;<br>    // 组件创建完后获取数据，<br>    // 此时 data 已经被 observed 了<br>    this.fetchData()<br>  &#125;,<br>  watch: &#123;<br>    // 如果路由有变化，会再次执行该方法<br>    &#x27;$route&#x27;: &#x27;fetchData&#x27;<br>  &#125;,<br>  methods: &#123;<br>    fetchData () &#123;<br>      this.error = this.post = null<br>      this.loading = true<br>      // replace getPost with your data fetching util / API wrapper<br>      getPost(this.$route.params.id, (err, post) =&gt; &#123;<br>        this.loading = false<br>        if (err) &#123;<br>          this.error = err.toString()<br>        &#125; else &#123;<br>          this.post = post<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h4><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      post: <span class="hljs-literal">null</span>,<br>      error: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    getPost(to.params.id, <span class="hljs-function">(<span class="hljs-params">err, post</span>) =&gt;</span> &#123;<br>      next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.setData(err, post))<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-comment">// 路由改变前，组件就已经渲染完了</span><br>  <span class="hljs-comment">// 逻辑稍稍不同</span><br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-built_in">this</span>.post = <span class="hljs-literal">null</span><br>    getPost(to.params.id, <span class="hljs-function">(<span class="hljs-params">err, post</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.setData(err, post)<br>      next()<br>    &#125;)<br>  &#125;,<br>  methods: &#123;<br>    setData (err, post) &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">this</span>.error = err.toString()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.post = post<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>定义路由的时候可以配置 <code>meta</code> 字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      children: [<br>        &#123;<br>          path: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>          component: Bar,<br>          <span class="hljs-comment">// a meta field</span><br>          meta: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span> &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>那么如何访问这个 <code>meta</code> 字段呢？</p><p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p><p>例如，根据上面的路由配置，<code>/foo/bar</code> 这个 URL 将会匹配父路由记录以及子路由记录。</p><p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p><p>下面例子展示在全局导航守卫中检查元字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.some(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;<br>    <span class="hljs-comment">// this route requires auth, check if logged in</span><br>    <span class="hljs-comment">// if not, redirect to login page.</span><br>    <span class="hljs-keyword">if</span> (!auth.loggedIn()) &#123;<br>      next(&#123;<br>        path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        query: &#123; <span class="hljs-attr">redirect</span>: to.fullPath &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next()<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next() <span class="hljs-comment">// 确保一定要调用 next()</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>不宜修改meta。</p></blockquote><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p> <img src="/./image-20200926103349466.png" alt="image-20200926103349466"></p><p><img src="/./image-20200926103508601.png" alt="image-20200926103508601"></p><blockquote><p>在Vuex中保存的状态（数据）是响应式的。</p></blockquote><p><strong>应用场景👇</strong></p><p><img src="/./image-20200926103551896.png" alt="image-20200926103551896"></p><p><strong>单个组件的状态管理:</strong></p><p><img src="/./image-20200926104012022.png" alt="image-20200926104012022"></p><blockquote><p>Vue已经帮我们做好了单个页面的状态管理，即组件的数据是比较独立的，可以通过各种Action的回调函数去修改State（数据），并通过响应式去更新View。</p><p>但如果是多个界面（组件）的状态管理就可能需要Vuex。</p></blockquote><p><strong>Vuex的基本思想：</strong></p><p><img src="/./image-20200926104500158.png" alt="image-20200926104500158"></p><p><img src="/./image-20200926104627320.png" alt="image-20200926104627320"></p><h3 id="什么情况下应该使用Vuex？"><a href="#什么情况下应该使用Vuex？" class="headerlink" title="什么情况下应该使用Vuex？"></a>什么情况下应该使用Vuex？</h3><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8">store 模式</a>就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p><h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vuex --save<br></code></pre></td></tr></table></figure><p>在 Vue 的单页面应用中使用，需要使用<code>Vue.use(Vuex)</code>调用插件。</p><p>之后新建一个Vuex.Store实例，将其注入到Vue根实例中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  getter: &#123;<br>    doneTodos: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;,<br>  mutations: &#123;<br>    increment (state, payload) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">addCount</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-comment">// 可以包含异步操作</span><br>      <span class="hljs-comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 注入到根实例</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br>  store,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>  components: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后通过mutations改变状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在项目中使用Vuex，常常在src目录下创建store文件夹统一管理Vuex的单一状态树的内容。</p></blockquote><hr><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>State，Getter，Mutation，Action，Module，</code></p><p><strong>Vuex 有五部分核心内容：</strong></p><ol><li>state：包含了<code>store</code>中存储的各个状态。</li><li>getters: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。</li><li>mutations: 一组方法，是改变<code>store</code>中状态的执行者，<strong>只能是同步操作</strong>。</li><li>actions: 一组方法，其中可以<strong>包含异步操作</strong>,但只允许通过提交mutations修改状态。</li><li>modules：多个模块，每个模块拥有自己的state、getter、mutations、actions。</li></ol><hr><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 使用 <code>state</code> 来存储应用中需要共享的状态。</p><p>在根组件（Vue实例）以及子组件中使用<code>this.$store.state</code>访问共享状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; Cpn.vue<br>&#x2F;*<br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0,<br>obj: &#123;name: &#39;mz&#39;, age: 23&#125;<br>&#125;<br>&#125;)<br><br>*&#x2F;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;h2&gt; &#123;&#123;count&#125;&#125; &lt;&#x2F;h2&gt; <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>        name: &#39;Cpn&#39;,<br>        computed: &#123;<br>            count()&#123;<br>                return this.$store.state.count  &#x2F;&#x2F; 访问state中的count<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>在state初始化时就已经定义的数据以及数据的属性才会被添加到响应式系统。</p><p>( 在Vue中所有需要响应式的数据都是这样 )</p><p>所以通过this.$store.state.obj[‘xxx’]的方式为数据添加额外的属性值时，虽然数据确实变化了，但不会更新View。</p><p>此时，需要通过Vue.set方法来修改状态的属性，可以确保数据是响应式的。</p><p>Vue.set(obj, propName, value)</p><p>删除状态的属性需要通过Vue.delete方法实现响应式。</p><p>Vue.delete(obj, propName)</p></blockquote><hr><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>类似于 Vue 中的 计算属性（可以认为是 store 的计算属性），getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>getter 方法接受<code>state</code>作为其第一个参数，<code>state</code>参数即Store对象中的state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>getter 方法接受<code>getters</code>作为其第二个参数，<code>getters</code>参数即Store对象中的getters，该参数允许我们在某个getter中访问其他getter：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done);<br>    &#125;,<br>    doneTodosCount: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> getters.doneTodos.length;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>在组件中访问getters：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">cpnDoneTodos</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodos;<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">cpnDoneTodosCount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodosCount;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>getter方法返回一个函数，实现给getter传参：</strong></p><p>这种做法在对 store 里的数组进行查询时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getters: &#123;<br>  <span class="hljs-comment">// ...</span><br>  getTodoById: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id === id)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在组件中为getter返回的函数传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$store.getters.getTodoById(<span class="hljs-number">2</span>) <span class="hljs-comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><p>在Vuex中约定必须通过mutation修改状态，不允许通过<code>$store.state.xxx = xxx</code>的形式直接修改。（虽然这样没什么可怕的后果，只是通过mutation修改能保存修改日志与状态快照）</p><blockquote><p><code>state</code>和<code>getter</code>都是状态值本身，<code>mutations</code>才是改变状态的执行者。</p><p><strong>注意：<code>mutations</code>只能是同步地更改状态。</strong></p></blockquote><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">1</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 变更状态</span><br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在组件中提交mutation，并执行回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>commit</code>方法中第一个参数可以是<code>事件类型名(String)</code>；</p><p>第二个参数是传递的<code>载荷</code>，可以作为实参传递给mutation的回调函数，第二个参数<code>是可选的</code>。</p><blockquote><p>提交mutation时，不可以像发送action一样能够获取mutation回调函数的返回值。</p><p>即在mutation的回调函数中返回值是无意义的。</p></blockquote><p><strong>规范地提交mutation并传参：</strong></p><p>在规范中，mutation的回调函数支持传入第二个参数payload，作为载荷。载荷中可以保存向mutation回调函数传递的实参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br>        state.count += payload.n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的形式1：提交mutation的事件类型，传递载荷，触发回调函数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;); 👉 传递的实参的值： &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 推荐的形式2：使用对象风格的提交方式，传递参数名与值   </span><br><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>    type: <span class="hljs-string">&#x27;increment&#x27;</span>, 👉 传递的实参的值： &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br>    n: <span class="hljs-number">1</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>向提交简单参数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, n</span>)</span> &#123;<br>        state.count += n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不能再通过对象风格来传递参数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>总结： 在向mutation传递参数时，需要回调函数与提交方式的配合。</p></blockquote><h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mutation-types.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_MUTATION = <span class="hljs-string">&#x27;SOME_MUTATION&#x27;</span><br><span class="hljs-comment">// store.js</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> &#123; SOME_MUTATION &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutation-types&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123; ... &#125;,<br>  mutations: &#123;<br>    <span class="hljs-comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br>    [SOME_MUTATION] (state) &#123;<br>      <span class="hljs-comment">// mutate state</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p><h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  methods: &#123;<br>    ...mapMutations([<br>      <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span><br><br>      <span class="hljs-comment">// `mapMutations` 也支持载荷：</span><br>      <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span><br>    ]),<br>    ...mapMutations(&#123;<br>      add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>想要<strong>异步地更改状态</strong>，就需要使用<code>action</code>。<code>action</code>并不直接改变<code>state</code>，而是发起<code>mutation</code>。</p><blockquote><p>action既可以异步地提交mutation，也可以同步提交，但更主要的是利用它来异步修改状态</p></blockquote><p><strong>注册一个简单的 action：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>          context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="发起简单的action"><a href="#发起简单的action" class="headerlink" title="发起简单的action"></a>发起简单的action</h4><p>发起<code>action</code>的方法形式和发起<code>mutation</code>一样，只是换了个名字<code>dispatch</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>Actions 支持同样的载荷方式和对象方式<code>进行分发</code>并<code>传递参数</code>：</strong></p><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 context 对象为什么不是 store 实例本身了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations:&#123;<br>      <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span>&#123;<br>          state.count += payload.n<br>      &#125;  <br>    &#125;,<br>actions: &#123;<br>      <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context, payload</span>)</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>            context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, payload)  <span class="hljs-comment">// 实参的类型要与mutation中的形参一致</span><br>         &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐使用载荷的方式向action传参</span><br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-comment">// 不建议使用下面这种对象风格的方式，因为payload形参的type不再是mutation的type，需要进行调整</span><br><span class="hljs-built_in">this</span>.$store.dispatch(&#123;<br>    type: <span class="hljs-string">&#x27;asyncIncrement&#x27;</span>,<br>    n: <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>可见，向action或mutation传参，以载荷的方式更直观，同时能避免差错。</p></blockquote><p><strong>对context进行解构：</strong></p><p>实践中，我们会经常用到 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>context具有store 实例的相同方法和属性，包括commit, dispatch, getters, state。</p><p>此外还具有rootGetters以及rootState；</p><p>这些属性和方法都可以进行解构获取。</p><p><img src="/./image-20200926153828952.png" alt="image-20200926153828952"> </p></blockquote><h4 id="分发多重-mutation"><a href="#分发多重-mutation" class="headerlink" title="分发多重 mutation"></a>分发多重 mutation</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">actions: &#123;<br>  checkout (&#123; commit, state &#125;, products) &#123;<br>    <span class="hljs-comment">// 把当前购物车的物品备份起来</span><br>    <span class="hljs-keyword">const</span> savedCartItems = [...state.cart.added]<br>    <span class="hljs-comment">// 发出结账请求，然后乐观地清空购物车</span><br>    commit(types.CHECKOUT_REQUEST)<br>    <span class="hljs-comment">// 购物 API 接受一个成功回调和一个失败回调</span><br>    shop.buyProducts(<br>      products,<br>      <span class="hljs-comment">// 成功操作</span><br>      () =&gt; commit(types.CHECKOUT_SUCCESS),<br>      <span class="hljs-comment">// 失败操作</span><br>      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Action处理异步的正确使用方式"><a href="#Action处理异步的正确使用方式" class="headerlink" title="Action处理异步的正确使用方式"></a>Action处理异步的正确使用方式</h4><p>想要使用<code>action</code>处理异步工作很简单，只需要将异步操作放到<code>action</code>中执行（如上面代码中的<code>setTimeout</code>）。</p><p><strong>要想在异步操作完成后继续进行相应的流程操作</strong>，有两种方式:</p><ol><li><p>在action中返回一个Promise</p><p><code>store.dispatch</code>返回相应<code>action</code>的执行结果，而当action的处理函数返回的是一个Promise实例时，就可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">actionA</span>(<span class="hljs-params">&#123;commit&#125;, payload</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">()=&gt;</span> &#123;<br>             commit(<span class="hljs-string">&#x27;mutation1&#x27;</span>, payload);<br>                resolve();<br>         &#125;, <span class="hljs-number">1000</span>)<br>        &#125;)<br> &#125;<br>&#125;<br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>, payload).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>   在另外一个 action 中也可以：</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  <span class="hljs-comment">// ...</span><br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>      commit(<span class="hljs-string">&#x27;someOtherMutation&#x27;</span>)<br>    &#125;) <span class="hljs-comment">// dispatch(&#x27;ActionB&#x27;) 仍然会返回一个Promise</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>利用<code>async/await</code> 进行组合action。代码更加简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><br>actions: &#123;<br>  <span class="hljs-keyword">async</span> actionA (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())<br>  &#125;,<br>  <span class="hljs-keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span><br>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个 <code>$store.dispatch</code> 可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote></li></ol><h4 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h4><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  methods: &#123;<br>    ...mapActions([<br>      <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span><br><br>      <span class="hljs-comment">// `mapActions` 也支持载荷：</span><br>      <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span><br>    ]),<br>    ...mapActions(&#123;<br>      add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;,<br>  getters: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> moduleB = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    a: moduleA,<br>    b: moduleB<br>  &#125;<br>&#125;)<br><br>store.state.a <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.state.b <span class="hljs-comment">// -&gt; moduleB 的状态</span><br></code></pre></td></tr></table></figure><h4 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;),<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 这里的 `state` 对象是模块的局部状态</span><br>      state.count++<br>    &#125;<br>  &#125;,<br><br>  getters: &#123;<br>    doubleCount (state) &#123;<br>      <span class="hljs-keyword">return</span> state.count * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-comment">// ...</span><br>  actions: &#123;<br>    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;<br>      <span class="hljs-keyword">if</span> ((state.count + rootState.count) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>        commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-comment">// ...</span><br>  getters: &#123;<br>    sumWithRootCount (state, getters, rootState) &#123;<br>      <span class="hljs-keyword">return</span> state.count + rootState.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    account: &#123;<br>      namespaced: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// account是一个独立模块</span><br><br>      <span class="hljs-comment">// 模块内容（module assets）</span><br>      state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;), <span class="hljs-comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span><br>      getters: &#123;<br>        isAdmin () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span><br>      &#125;,<br>      actions: &#123;<br>        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span><br>      &#125;,<br>      mutations: &#123;<br>        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; commit(&#x27;account/login&#x27;)</span><br>      &#125;,<br><br>      <span class="hljs-comment">// 嵌套模块</span><br>      modules: &#123;<br>        <span class="hljs-comment">// 继承父模块的命名空间 ⭐ 这是是一个独立命名模块下的非独立命名模块</span><br>        myPage: &#123;<br>          state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>          getters: &#123;<br>            profile () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/profile&#x27;]</span><br>          &#125;<br>        &#125;,<br><br>        <span class="hljs-comment">// 进一步嵌套命名空间</span><br>        posts: &#123;           <span class="hljs-comment">// ⭐ 这是是一个独立命名模块下的独立命名模块</span><br>          namespaced: <span class="hljs-literal">true</span>,<br><br>          state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>          getters: &#123;<br>            popular () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p><h4 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h4><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p><p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>&#123; root: true &#125;</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">modules: &#123;<br>  foo: &#123;<br>    namespaced: <span class="hljs-literal">true</span>,<br><br>    getters: &#123;<br>      <span class="hljs-comment">// 在这个模块的 getter 中，`getters` 被局部化了</span><br>      <span class="hljs-comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span><br>      someGetter (state, getters, rootState, rootGetters) &#123;<br>        getters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span><br>        rootGetters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;someOtherGetter&#x27;</span><br>      &#125;,<br>      someOtherGetter: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; ... &#125;<br>    &#125;,<br><br>    actions: &#123;<br>      <span class="hljs-comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span><br>      <span class="hljs-comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span><br>      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;<br>        getters.someGetter <span class="hljs-comment">// -&gt; &#x27;foo/someGetter&#x27;</span><br>        rootGetters.someGetter <span class="hljs-comment">// -&gt; &#x27;someGetter&#x27;</span><br><br>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span><br>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someOtherAction&#x27;</span><br><br>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someMutation&#x27;</span><br>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someMutation&#x27;</span><br>      &#125;,<br>      someOtherAction (ctx, payload) &#123; ... &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>python3笔记</title>
    <link href="/2021/02/19/python3/python3/"/>
    <url>/2021/02/19/python3/python3/</url>
    
    <content type="html"><![CDATA[<p> <img src="/2021/02/19/python3/python3/image-20200902103321060.png" alt="image-20200902103321060"></p><h1 id="Python3基础"><a href="#Python3基础" class="headerlink" title="Python3基础"></a>Python3基础</h1><h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>作用：运行py文件（代码）</p><p>种类：</p><ul><li><p>CPython，C语言开发的官方解释器</p></li><li><p>IPython，基于CPython的一种交互式的解释器</p></li><li><p>其他</p><p><img src="/2021/02/19/python3/python3/image-20200902103623327.png" alt="image-20200902103623327"></p></li></ul><p>下载：</p><pre><code>    官方网站下载python解释器</code></pre><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>使用本机内任意的pip安装 virtualenv 和 virtualenvwrapper-win</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pip install virtualenv virtualenvwrapper-win<br></code></pre></td></tr></table></figure><ol start="2"><li>在磁盘中新建一个空文件夹，虚拟环境以后将保存在这里。例如 D:\Envs</li><li>在系统环境变量中添加  变量名：WORKON_HOME  值：D:\Envs </li></ol><h3 id="新建、查看、进入、退出"><a href="#新建、查看、进入、退出" class="headerlink" title="新建、查看、进入、退出"></a>新建、查看、进入、退出</h3><ol><li><p>查看当前已有的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ workon  <br></code></pre></td></tr></table></figure></li><li><p>新建一个虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkvirtualenv myfirstEnv<br></code></pre></td></tr></table></figure><p>使用指定的python解释器新建虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkvirtualenv myfirstEnv2 --python [解释器的完整路径]<br></code></pre></td></tr></table></figure></li><li><p>切换到（进入）建立好的虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ workon myfirstEnv<br></code></pre></td></tr></table></figure></li><li><p>退出虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ deactivate<br></code></pre></td></tr></table></figure></li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><p>单行注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注释</span><br></code></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">第一种写法</span><br><span class="hljs-string">&quot;&quot;“</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">第二种写法</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h2></li></ol><ul><li><p>由数字、字母、下划线组成</p></li><li><p>不能数字开头</p></li><li><p>不能使用内置关键字</p><p><img src="/2021/02/19/python3/python3/image-20200902154853675.png" alt="image-20200902154853675"></p></li><li><p>严格区分大小写</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2021/02/19/python3/python3/image-20200902161227614.png" alt="image-20200902161227614"></p><p>Python中，万物皆对象！万物皆对象！万物皆对象！</p><p>每个对象包含3个属性，id，type，value</p><p>id就是对象地址，可以通过内置函数id()查看对象引用的地址。</p><p>type就是对象类型，可以通过内置函数type()查看对象的类型。</p><p>value就是对象的值。</p><h3 id="不可变类型与可变类型"><a href="#不可变类型与可变类型" class="headerlink" title="不可变类型与可变类型"></a>不可变类型与可变类型</h3><p><img src="/2021/02/19/python3/python3/image-20200903133739365.png" alt="image-20200903133739365"></p><p><img src="/2021/02/19/python3/python3/image-20200903133758908.png" alt="image-20200903133758908"></p><p><img src="/2021/02/19/python3/python3/image-20200903133815481.png" alt="image-20200903133815481"></p><p><img src="/2021/02/19/python3/python3/image-20200903133831420.png" alt="image-20200903133831420"></p><h3 id="不可变-immutable-类型"><a href="#不可变-immutable-类型" class="headerlink" title="不可变(immutable)类型"></a>不可变(immutable)类型</h3><ul><li>int</li><li>float</li><li>decimal</li><li>complex</li><li>bool</li><li><strong>str</strong></li><li><strong>tuple</strong></li><li>range</li><li><strong>frozenset</strong></li><li>bytes</li></ul><h3 id="可变-mutable-类型"><a href="#可变-mutable-类型" class="headerlink" title="可变(mutable)类型"></a>可变(mutable)类型</h3><ul><li>list</li><li>dict</li><li>set</li><li>bytearray</li><li>user-defined classes (unless specifically made immutable)</li></ul><h3 id="判断数据的类型"><a href="#判断数据的类型" class="headerlink" title="判断数据的类型"></a>判断数据的类型</h3><ol><li><p>type()</p><p>type函数传入一个对象，返回对象的类型  即其class</p></li><li><p>使用type函数判断一个对象是否为指定类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 是否为int 类型 </span><br><span class="hljs-built_in">type</span>(x) == <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">type</span>(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">int</span><br><br><span class="hljs-comment"># 是否为string类型</span><br><span class="hljs-built_in">type</span>(x) == <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;a&#x27;</span>) <br><span class="hljs-built_in">type</span>(x) <span class="hljs-keyword">is</span> <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>isinstance(_obj, _class_or_tuple)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">其第一个参数为对象，第二个参数为类型名或包含多个类型名的元组。</span><br><span class="hljs-string">其返回值为布尔型。若对象的类型与参数二的类型相同则返回True。</span><br><span class="hljs-string">若参数二为一个元组，则若对象类型与元组中类型名之一相同即返回True。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>lst = []<br>print(<span class="hljs-built_in">isinstance</span>(lst, <span class="hljs-built_in">list</span>))<br>print(<span class="hljs-built_in">isinstance</span>(lst, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>,<span class="hljs-built_in">list</span>)))<br><br>print(<span class="hljs-built_in">isinstance</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">int</span>))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p><img src="/2021/02/19/python3/python3/image-20200902174834356.png" alt="image-20200902174834356"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. float() -- 将数据转换成浮点型</span><br>num1 = <span class="hljs-number">1</span><br>str1 = <span class="hljs-string">&#x27;10&#x27;</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">float</span>(num1)))  <span class="hljs-comment"># float</span><br>print(<span class="hljs-built_in">float</span>(num1))  <span class="hljs-comment"># 1.0</span><br><br>print(<span class="hljs-built_in">float</span>(str1))  <span class="hljs-comment"># 10.0</span><br><br><br><span class="hljs-comment"># 2. str() -- 将数据转换成字符串型</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">str</span>(num1)))  <span class="hljs-comment"># str</span><br><br><br><span class="hljs-comment"># 3. tuple() -- 将一个序列转换成元组</span><br>list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>print(<span class="hljs-built_in">tuple</span>(list1))<br><br><br><span class="hljs-comment"># 4. list() -- 将一个序列转换成列表</span><br>t1 = (<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>)<br>print(<span class="hljs-built_in">list</span>(t1))<br><br><br><span class="hljs-comment"># 5. eval() -- 计算在字符串中的有效Python表达式,并返回一个对象</span><br>str2 = <span class="hljs-string">&#x27;1&#x27;</span><br>str3 = <span class="hljs-string">&#x27;1.1&#x27;</span><br>str4 = <span class="hljs-string">&#x27;(1000, 2000, 3000)&#x27;</span><br>str5 = <span class="hljs-string">&#x27;[1000, 2000, 3000]&#x27;</span><br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str2)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str3)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str4)))<br>print(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">eval</span>(str5)))<br></code></pre></td></tr></table></figure><h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>总体来说，<code>is</code>比较的是<code>id</code>是不是一样，<code>==</code>比较的是<code>type</code>和<code>value</code>是不是一样。</p><ol><li><p>对于整型、小数、字符串</p><p>此类数据类型是不可变数据类型，理论上，在不存在两个变量间相互赋值的情况下，id是一定不一样的。</p><p>但是python<code>交互编程时</code>解释器会缓存[-5,256]间的整数，在<code>脚本编程时</code>会先解析脚本，缓存重复使用的值，因此对于此类数据类型使用 <code>is</code>时会出现相等的情况（id相等返回True）</p></li><li><p>对于元组</p><p>在<code>脚本编程时</code>，两个元组t1和t2分别<code>赋以相同的值</code>，若元组值中不存在可变数据类型，则 t1和 t2 在缓存机制的影响下，id相同。若元组中存在可变数据类型，则id一定不同。</p></li><li><p>若可变类型的对象之间使用 <code>==</code>判断：</p><p>可变类型往往是容器，对两个容器使用<code>==</code>比较，需要规定如何比较。</p><p>例如列表、字典以及集合，就是对两个容器中的对应成员使用 <code>==</code>比较，成员类型应该规定了使用<code>==</code>比较的规则，否则比较失败。</p></li><li><p>判断一个对象是否为None要使用<code>is</code></p></li></ol><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 准备数据</span><br><span class="hljs-string">2. 格式化符号输出数据</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>age = <span class="hljs-number">18</span><br>name = <span class="hljs-string">&#x27;TOM&#x27;</span><br>weight = <span class="hljs-number">75.5</span><br>stu_id = <span class="hljs-number">1</span><br>stu_id2 = <span class="hljs-number">1000</span><br><br><span class="hljs-comment"># 1. 今年我的年龄是x岁 -- 整数 %d</span><br>print(<span class="hljs-string">&#x27;今年我的年龄是%d岁&#x27;</span> % age)<br><br><span class="hljs-comment"># 2. 我的名字是x -- 字符串 %s</span><br>print(<span class="hljs-string">&#x27;我的名字是%s&#x27;</span> % name)<br><br><br><span class="hljs-comment"># 3. 我的体重是x公斤 -- 浮点数 %f</span><br>print(<span class="hljs-string">&#x27;我的体重是%.3f公斤&#x27;</span> % weight)<br><br><span class="hljs-comment"># 4. 我的学号是x -- %d</span><br>print(<span class="hljs-string">&#x27;我的学号是%d&#x27;</span> % stu_id)<br><br><span class="hljs-comment"># 4.1 我的学号是001</span><br>print(<span class="hljs-string">&#x27;我的学号是%03d&#x27;</span> % stu_id)<br>print(<span class="hljs-string">&#x27;我的学号是%03d&#x27;</span> % stu_id2)<br><br><br><span class="hljs-comment"># 5. 我的名字是x，今年x岁了</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%d岁了&#x27;</span> % (name, age))<br><span class="hljs-comment"># 5.1 我的名字是x，明年x岁了</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，明年%d岁了&#x27;</span> % (name, age + <span class="hljs-number">1</span>))<br><br><br><span class="hljs-comment"># 6. 我的名字是x，今年x岁了，体重x公斤，学号是x</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%d岁了，体重%.2f公斤，学号是%06d&#x27;</span> % (name, age, weight, stu_id))<br><br><span class="hljs-comment"># 6.1我的名字是x，今年x岁了，体重x公斤</span><br>print(<span class="hljs-string">&#x27;我的名字是%s，今年%s岁了，体重%s公斤&#x27;</span> % (name, age, weight))<br></code></pre></td></tr></table></figure><p><strong>整数与小数的用’0’补齐</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">print(<span class="hljs-string">&#x27;%04d&#x27;</span> %<span class="hljs-number">123</span>) <br><span class="hljs-comment"># 0123       总共占4位，整数位3位，左侧补齐一个0</span><br><br>print(<span class="hljs-string">&#x27;%06.3f&#x27;</span> %<span class="hljs-number">3.14</span>)<br><span class="hljs-comment"># 03.140      总共占6位，保留小数3位，小数点1位，整数位1位，左侧补齐一个0</span><br><br><span class="hljs-comment"># 超出允许的列数时，按其他要求真实输出。</span><br><br>print(<span class="hljs-string">&#x27;%04.3f&#x27;</span>,<span class="hljs-number">3.14</span>)<br><span class="hljs-comment"># 3.140</span><br></code></pre></td></tr></table></figure><h3 id="f-字符串"><a href="#f-字符串" class="headerlink" title="f-字符串"></a>f-字符串</h3><p>python3.6新增，效率比上述的%s效率要高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&#x27;hello world&#x27;</span><br>print(<span class="hljs-string">f&#x27;我想说<span class="hljs-subst">&#123;str1&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment">#相当于 </span><br><br>print(<span class="hljs-string">&#x27;我想说&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(str1))<br></code></pre></td></tr></table></figure><h3 id="print结束符"><a href="#print结束符" class="headerlink" title="print结束符"></a>print结束符</h3><p><img src="/2021/02/19/python3/python3/image-20200902173925580.png" alt="image-20200902173925580"></p><p>默认end=’\n’</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><img src="/2021/02/19/python3/python3/image-20200902174120530.png" alt="image-20200902174120530"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><p>算数运算符</p></li><li><p>赋值运算符</p></li><li><p>复合赋值运算符</p></li><li><p>比较运算符</p></li><li><p>逻辑运算符</p></li></ul><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902175959148.png" alt="image-20200902175959148"></p><p><img src="/2021/02/19/python3/python3/image-20200902180046786.png" alt="image-20200902180046786"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902180152402.png" alt="image-20200902180152402"></p><p><img src="/2021/02/19/python3/python3/image-20200902180259719.png" alt="image-20200902180259719"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a和b交换值</span><br>a=<span class="hljs-number">1</span><br>b=<span class="hljs-number">2</span><br>a,b=b,a<br>print(a,<span class="hljs-string">&#x27;:&#x27;</span>,b)<br><span class="hljs-comment"># 2:1</span><br></code></pre></td></tr></table></figure><h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902181846251.png" alt="image-20200902181846251"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902181934373.png" alt="image-20200902181934373"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="/2021/02/19/python3/python3/image-20200902182015593.png" alt="image-20200902182015593"></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if语句语法"><a href="#if语句语法" class="headerlink" title="if语句语法"></a>if语句语法</h3><p><img src="/2021/02/19/python3/python3/image-20200902193415037.png" alt="image-20200902193415037"></p><p><img src="/2021/02/19/python3/python3/image-20200902193458780.png" alt="image-20200902193458780"></p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p><img src="/2021/02/19/python3/python3/image-20200902194038565.png" alt="image-20200902194038565"></p><h3 id="if-elif-else"><a href="#if-elif-else" class="headerlink" title="if elif else"></a>if elif else</h3><p><img src="/2021/02/19/python3/python3/image-20200902194326654.png" alt="image-20200902194326654"></p><h3 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h3><p><img src="/2021/02/19/python3/python3/image-20200902194842893.png" alt="image-20200902194842893"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">2</span><br>b = <span class="hljs-number">1</span><br>print(a) <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> print(b)<br><br><span class="hljs-comment"># 控制台输出 👉 2</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><font color='red' size='4'>Python中没有switch case语法</font></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>作用：控制代码重复执行</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><img src="/2021/02/19/python3/python3/image-20200902200651067.png" alt="image-20200902200651067"></p><h3 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h3><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><img src="/2021/02/19/python3/python3/image-20200902203452852.png" alt="image-20200902203452852"></p><h3 id="while-else"><a href="#while-else" class="headerlink" title="while else"></a>while else</h3><p><img src="/2021/02/19/python3/python3/image-20200902205225313.png" alt="image-20200902205225313"></p><p><strong>语法</strong></p><p><img src="/2021/02/19/python3/python3/image-20200902205243152.png" alt="image-20200902205243152"></p><p><strong>在while else语法结构中，break与continue退出</strong></p><p><img src="/2021/02/19/python3/python3/image-20200902205536541.png" alt="image-20200902205536541"></p><p><img src="/2021/02/19/python3/python3/image-20200902205623421.png" alt="image-20200902205623421"></p><ol start="2"><li>continue</li></ol><p><img src="/2021/02/19/python3/python3/image-20200902210952819.png" alt="image-20200902210952819"></p><h3 id="for-else"><a href="#for-else" class="headerlink" title="for else"></a>for else</h3><p>for else的使用以及与break、continue配合的表现都与while else相同。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>可以使用一对双引号<code>&quot;&quot;</code>、一对单引号<code>&#39;&#39;</code>、三引号<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>或<code>&quot;&quot;&quot; &quot;&quot;&quot;</code>来标识字符串。</p><p>三引号的作用在于能够保存编辑代码时的换行符，输出时会显示原原本本的字符串格式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">str1=<span class="hljs-string">&quot;&quot;&quot;i am mz,</span><br><span class="hljs-string">hello world</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>print(str1)<br><br>👇<br><span class="hljs-comment"># i am mz,</span><br><span class="hljs-comment"># hello world</span><br><br><br></code></pre></td></tr></table></figure><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>python中的字符串属于常见的序列类型之一，可以通过下标以及切片对其访问。</p><p><img src="/2021/02/19/python3/python3/image-20200903100827674.png" alt="image-20200903100827674"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 序列名[开始位置的下标:结束位置的下标:步长]</span><br><br>str1 = <span class="hljs-string">&#x27;012345678&#x27;</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">1</span>])  <span class="hljs-comment"># 234</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># 24</span><br>print(str1[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 234</span><br>print(str1[:<span class="hljs-number">5</span>])  <span class="hljs-comment"># 01234 -- 如果不写开始，默认从0开始选取</span><br>print(str1[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 2345678 -- 如果不写结束，表示选取到最后</span><br>print(str1[:])  <span class="hljs-comment"># 012345678 -- 如果不写开始和结束，表示选取所有</span><br><br>负数测试<br>print(str1[::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 876543210 -- 如果步长为负数，表示倒叙选取</span><br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 567 -- 下标-1表示最后一个数据，依次向前类推</span><br><br><span class="hljs-comment"># 终极测试</span><br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">1</span>])  <span class="hljs-comment"># 567</span><br><br>!!!!!<br>print(str1[-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 不能选取出数据：从-4开始到-1结束，选取方向为从左到右，但是-1步长：从右向左选取</span><br><span class="hljs-comment"># **** 如果选取方向(下标开始到结束的方向) 和 步长的方向冲突，则无法选取数据</span><br><br>如果想要逆序获取字符串序列<br>print(str1[-<span class="hljs-number">1</span>:-<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>])  <span class="hljs-comment"># 876</span><br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="/2021/02/19/python3/python3/image-20200903110829006.png" alt="image-20200903110829006"></p><p>字符串的常用操作方法由查找、返回新数据（由于不能修改）、判断三大类。</p><h4 id="一、查找"><a href="#一、查找" class="headerlink" title="一、查找"></a><strong>一、查找</strong></h4><ol><li><p>find()</p><p><img src="/2021/02/19/python3/python3/image-20200903103935277.png" alt="image-20200903103935277"></p></li></ol><ol start="2"><li><p>index( )</p><p>用法与find相同，唯一不同的是当字串不存在时，index方法不会返回-1，而是<strong>会报错</strong>，</p><p> <img src="/2021/02/19/python3/python3/image-20200903104530591.png" alt="image-20200903104530591"></p></li></ol><ol start="3"><li>count()</li></ol><p><img src="/2021/02/19/python3/python3/image-20200903104442971.png" alt="image-20200903104442971"></p><h4 id="二、返回新内容"><a href="#二、返回新内容" class="headerlink" title="二、返回新内容"></a><strong>二、返回新内容</strong></h4><ol><li><p><strong>replace()  返回新的字符串 。替换掉字符串内的指定字串。</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111139313.png" alt="image-20200903111139313"></p></li></ol><p><font color='red'>由于python中字符串方法不会修改原串，如果需要修改原字符串，需要 str1=str1.replace( …..)</font></p><ol start="2"><li><strong>split()  返回一个数组。以指定字串分割字符串。</strong></li></ol><p><img src="/2021/02/19/python3/python3/image-20200903111403167.png" alt="image-20200903111403167"></p><p><img src="/2021/02/19/python3/python3/image-20200903111419469.png" alt="image-20200903111419469"></p><ol start="3"><li><p><strong>join()  以该字符串连接一个字符串序列。</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111724592.png" alt="image-20200903111724592"></p></li></ol><ol start="4"><li><p><strong>大小写相关</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903111808737.png" alt="image-20200903111808737"></p></li></ol><p>   <img src="/2021/02/19/python3/python3/image-20200903111850677.png" alt="image-20200903111850677"></p><p>   <img src="/2021/02/19/python3/python3/image-20200903111909823.png" alt="image-20200903111909823"></p><p>   <img src="/2021/02/19/python3/python3/image-20200903111925783.png" alt="image-20200903111925783"></p><ol start="5"><li><p><strong>去除左右空白</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903130746820.png" alt="image-20200903130746820"></p></li></ol><ol start="6"><li><p><strong>对齐与补齐</strong></p><p><img src="/2021/02/19/python3/python3/image-20200903130819326.png" alt="image-20200903130819326"></p><pre><code>    ![image-20200903130830475](./image-20200903130830475.png)    ![image-20200903130941185](./image-20200903130941185.png)</code></pre></li></ol><h4 id="三、判断"><a href="#三、判断" class="headerlink" title="三、判断"></a><strong>三、判断</strong></h4><p><img src="/2021/02/19/python3/python3/image-20200903131215973.png" alt="image-20200903131215973"><img src="/2021/02/19/python3/python3/image-20200903131232290.png" alt="image-20200903131232290"></p><p><img src="/2021/02/19/python3/python3/image-20200903131315678.png" alt="image-20200903131315678"></p><p><img src="/2021/02/19/python3/python3/image-20200903131330582.png" alt="image-20200903131330582"></p><ul><li><p>in 和 not in</p><p>判断是否存在某个字串</p></li></ul><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[数据<span class="hljs-number">1</span>, 数据<span class="hljs-number">2</span>, 数据<span class="hljs-number">3</span>, 数据<span class="hljs-number">4.</span>.....]<br></code></pre></td></tr></table></figure><p>列表可以一次性存储多个数据，且可以为不同数据类型。</p><h3 id="下标访问与切片"><a href="#下标访问与切片" class="headerlink" title="下标访问与切片"></a>下标访问与切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list[<span class="hljs-number">0</span>])  <span class="hljs-comment"># Tom</span><br>print(name_list[<span class="hljs-number">1</span>])  <span class="hljs-comment"># Lily</span><br>print(name_list[<span class="hljs-number">2</span>])  <span class="hljs-comment"># Rose</span><br><br>print(name_list[<span class="hljs-number">0</span>::<span class="hljs-number">2</span>]) <span class="hljs-comment"># [&#x27;Tom&#x27;, &#x27;Lily&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="列表长度"><a href="#列表长度" class="headerlink" title="列表长度"></a>列表长度</h3><p>len( ==list==)</p><h3 id="判断是否存在某个元素"><a href="#判断是否存在某个元素" class="headerlink" title="判断是否存在某个元素"></a>判断是否存在某个元素</h3><ul><li>in：判断指定数据在某个列表序列，如果在返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-comment"># 结果：True</span><br>print(<span class="hljs-string">&#x27;Lily&#x27;</span> <span class="hljs-keyword">in</span> name_list)<br><br><span class="hljs-comment"># 结果：False</span><br>print(<span class="hljs-string">&#x27;Lilys&#x27;</span> <span class="hljs-keyword">in</span> name_list)<br></code></pre></td></tr></table></figure><ul><li>not in：判断指定数据不在某个列表序列，如果不在返回True，否则返回False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-comment"># 结果：False</span><br>print(<span class="hljs-string">&#x27;Lily&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name_list)<br><br><span class="hljs-comment"># 结果：True</span><br>print(<span class="hljs-string">&#x27;Lilys&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name_list)<br></code></pre></td></tr></table></figure><h3 id="查找元素索引"><a href="#查找元素索引" class="headerlink" title="查找元素索引"></a>查找元素索引</h3><ul><li>index()：返回指定数据所在位置的下标 。</li></ul><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.index(数据, 开始位置下标, 结束位置下标)<br></code></pre></td></tr></table></figure><ol start="2"><li>快速体验</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list.index(<span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：如果查找的数据不存在则报错。</p><p>所以在使用index前最好先判断所查找元素是否存在。或者需要处理异常。</p></blockquote><h3 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h3><ul><li>count()：统计指定数据在当前列表中出现的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>print(name_list.count(<span class="hljs-string">&#x27;Lily&#x27;</span>))  <span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h3 id="增加与插入"><a href="#增加与插入" class="headerlink" title="增加与插入"></a>增加与插入</h3><ul><li><strong>append ( ) 列表结尾添加一个元素</strong></li></ul><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.append(数据)<br></code></pre></td></tr></table></figure><ol start="2"><li>体验</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.append(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><p><img src="/2021/02/19/python3/python3/image-20190130160154636.png" alt="image-20190130160154636"></p><blockquote><p>列表追加数据的时候，直接在原列表里面追加了指定数据，即修改了原列表，故列表为可变类型数据。</p></blockquote><ol start="3"><li>注意点</li></ol><p>如果append()追加的数据是一个序列，则追加整个序列到列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.append([<span class="hljs-string">&#x27;xiaoming&#x27;</span>, <span class="hljs-string">&#x27;xiaohong&#x27;</span>])<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, [&#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><ul><li><p><strong>extend ( ) 列表结尾追加元素。可传入一个可迭代类型，将所有元素将逐一尾插</strong></p><blockquote><p> 若该数据是一个序列，则这个序列的数据逐一添加到列表。**</p></blockquote><p>语法：</p><ol><li><p>添加一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.extend(<span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;x&#x27;, &#x27;i&#x27;, &#x27;a&#x27;, &#x27;o&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;, &#x27;g&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li><li><p>添加一个序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.extend([<span class="hljs-string">&#x27;xiaoming&#x27;</span>, <span class="hljs-string">&#x27;xiaohong&#x27;</span>])<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;xiaoming&#x27;, &#x27;xiaohong&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><strong>insert ( )指定位置新增数据。</strong></li></ul><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.insert(位置下标, 数据)<br></code></pre></td></tr></table></figure></li><li><p>快速体验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.insert(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;xiaoming&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;xiaoming&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure><blockquote><p>插入一个序列类型时，不会对序列进行解构。会在指定位置插入该序列对象。</p></blockquote></li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p><strong>del</strong></p><blockquote><p>常用del语法删除一个变量，但同时del可以删除列表的某个元素</p></blockquote><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> 目标<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br><span class="hljs-keyword">del</span> name_list[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 结果：[&#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>pop()：删除指定下标的数据（默认为最后一个），并返回该数据。</strong></p><ol><li><p>语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.pop(下标)<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>del_name = name_list.pop(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 结果：Lily</span><br>print(del_name)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>remove()：移除列表中某个数据的第一个匹配项。</strong></p><ol><li>语法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.remove(数据)<br></code></pre></td></tr></table></figure><ol start="2"><li>使用</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list.remove(<span class="hljs-string">&#x27;Rose&#x27;</span>)<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li><p><strong>下标修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_list[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaa&#x27;</span><br><br><span class="hljs-comment"># 结果：[&#x27;aaa&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_list)<br></code></pre></td></tr></table></figure></li></ul><h3 id="逆置、排序、拷贝"><a href="#逆置、排序、拷贝" class="headerlink" title="逆置、排序、拷贝"></a>逆置、排序、拷贝</h3><ul><li><p><strong>逆置：reverse()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_list = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br><br>num_list.reverse()<br><br><span class="hljs-comment"># 结果：[8, 6, 3, 2, 5, 1]</span><br>print(num_list)<br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>排序：sort()</strong></p><ol><li><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">列表序列.sort( key=<span class="hljs-literal">None</span>, reverse=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：reverse表示排序规则，<strong>reverse = True</strong> 降序， <strong>reverse = False</strong> 升序（默认）</p></blockquote></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">num_list = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br><br>num_list.sort()<br><br><span class="hljs-comment"># 结果：[1, 2, 3, 5, 6, 8]</span><br>print(num_list)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;]<br>ls.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;age&#x27;</span>], reverse=<span class="hljs-literal">True</span>)<br>print(ls)<br><span class="hljs-meta">&gt;&gt;&gt; </span>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>&#125;]<br></code></pre></td></tr></table></figure></li></ol></li></ul><ul><li><p><strong>复制：copy()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Lily&#x27;</span>, <span class="hljs-string">&#x27;Rose&#x27;</span>]<br><br>name_li2 = name_list.copy()<br><br><span class="hljs-comment"># 结果：[&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;]</span><br>print(name_li2)<br></code></pre></td></tr></table></figure><blockquote><p>列表的copy方法是浅拷贝。</p></blockquote></li></ul><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h2><blockquote><p>元组是序列类型，可以存储多个元素，但元组无法被修改。</p></blockquote><p><img src="/2021/02/19/python3/python3/image-20200903165757617.png" alt="image-20200903165757617"></p><h3 id="定义元组"><a href="#定义元组" class="headerlink" title="定义元组"></a>定义元组</h3><p>元组特点：定义元组使用==小括号==，且==逗号==隔开各个数据，数据可以是不同的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多个数据元组</span><br>t1 = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)<br><br><span class="hljs-comment"># 单个数据元组</span><br>t2 = (<span class="hljs-number">10</span>,)<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果定义的元组只有一个数据，那么这个数据后面也好添加逗号，否则数据类型为唯一的这个数据的数据类型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">t2 = (<span class="hljs-number">10</span>,)<br>print(<span class="hljs-built_in">type</span>(t2))  <span class="hljs-comment"># tuple</span><br><br>t3 = (<span class="hljs-number">20</span>)<br>print(<span class="hljs-built_in">type</span>(t3))  <span class="hljs-comment"># int</span><br><br>t4 = (<span class="hljs-string">&#x27;hello&#x27;</span>)<br>print(<span class="hljs-built_in">type</span>(t4))  <span class="hljs-comment"># str</span><br></code></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>元组数据不支持修改，只支持查找，具体如下：</p><ul><li>按下标查找数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1[<span class="hljs-number">0</span>])  <span class="hljs-comment"># aa</span><br></code></pre></td></tr></table></figure><ul><li>index()：查找某个数据，如果数据存在返回对应的下标，<code>不存在时会报错</code>，语法和列表、字符串的index方法相同。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1.index(<span class="hljs-string">&#x27;aa&#x27;</span>))  <span class="hljs-comment"># 0</span><br></code></pre></td></tr></table></figure><ul><li>count()：统计某个数据在当前元组出现的次数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(tuple1.count(<span class="hljs-string">&#x27;bb&#x27;</span>))  <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><ul><li>len()：统计元组中数据的个数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>print(<span class="hljs-built_in">len</span>(tuple1))  <span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：元组内的直接数据如果修改则立即报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple1 = (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>)<br>tuple1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>但是如果元组里面有可变数据类型（例如：列表），修改该元组的元素的值是被允许的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tuple2 = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, [<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>], <span class="hljs-number">50</span>, <span class="hljs-number">30</span>)<br>print(tuple2[<span class="hljs-number">2</span>])  <span class="hljs-comment"># 访问到列表</span><br><br><span class="hljs-comment"># 结果：(10, 20, [&#x27;aaaaa&#x27;, &#x27;bb&#x27;, &#x27;cc&#x27;], 50, 30)</span><br>tuple2[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;aaaaa&#x27;</span><br>print(tuple2)<br></code></pre></td></tr></table></figure><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>数据装包 &lt;=&gt; 拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组拆包</span><br><br>t = (<span class="hljs-string">&#x27;mazheng&#x27;</span>, <span class="hljs-number">23</span>)<br>name, age = t<br>print(name, age)<br>👇<br><span class="hljs-comment"># mazheng 23</span><br><br><br></code></pre></td></tr></table></figure><h2 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典 dict"></a>字典 dict</h2><p>字典特点：</p><ul><li>符号为==大括号==</li><li>数据为==键值对==形式出现</li><li>各个键值对之间用==逗号==隔开</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有数据字典</span><br>dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br><span class="hljs-comment"># 空字典</span><br>dict2 = &#123;&#125;<br><br>dict3 = <span class="hljs-built_in">dict</span>()<br></code></pre></td></tr></table></figure><h3 id="增加键值对"><a href="#增加键值对" class="headerlink" title="增加键值对"></a>增加键值对</h3><p>写法：==字典序列[key] = 值==</p><blockquote><p>注意：如果key存在则修改这个key对应的值；如果key不存在则新增此键值对。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br>dict1[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;Rose&#x27;</span><br><span class="hljs-comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;&#125;</span><br>print(dict1)<br><br>dict1[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-number">110</span><br><br><span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;Rose&#x27;, &#x27;age&#x27;: 20, &#x27;gender&#x27;: &#x27;男&#x27;, &#x27;id&#x27;: 110&#125;</span><br>print(dict1)<br></code></pre></td></tr></table></figure><blockquote><p>注意：字典为可变类型。</p></blockquote><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li>del() / del：删除字典或删除字典中指定键值对。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br><span class="hljs-keyword">del</span> dict1[<span class="hljs-string">&#x27;gender&#x27;</span>]<br><span class="hljs-comment"># 结果：&#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 20&#125;</span><br>print(dict1)<br></code></pre></td></tr></table></figure><ul><li>clear()：清空字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><br>dict1.clear()<br>print(dict1)  <span class="hljs-comment"># &#123;&#125;</span><br></code></pre></td></tr></table></figure><ul><li>pop(key)：根据键名取出键值对</li></ul><h3 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h3><p>写法：==字典序列[key] = 值==</p><blockquote><p>注意：如果key存在则修改这个key对应的值 ；如果key不存在则新增此键值对。</p></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ol><li><p>按key值查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1[<span class="hljs-string">&#x27;name&#x27;</span>])  <span class="hljs-comment"># Tom</span><br>print(dict1[<span class="hljs-string">&#x27;id&#x27;</span>])  <span class="hljs-comment"># 报错</span><br></code></pre></td></tr></table></figure><blockquote><p>如果当前查找的key存在，则返回对应的值；否则则报错。</p></blockquote></li></ol><ol start="2"><li><p>get()方法</p><ul><li>语法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">字典序列.get(key, 默认值)<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果当前查找的key不存在则返回第二个参数(默认值)，如果省略第二个参数，则返回None。</p></blockquote><ul><li>快速体验</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.get(<span class="hljs-string">&#x27;name&#x27;</span>))  <span class="hljs-comment"># Tom</span><br>print(dict1.get(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-number">110</span>))  <span class="hljs-comment"># 110</span><br>print(dict1.get(<span class="hljs-string">&#x27;id&#x27;</span>))  <span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><ol><li><p>keys()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.keys())  <span class="hljs-comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;gender&#x27;])</span><br></code></pre></td></tr></table></figure></li><li><p>values()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.values())  <span class="hljs-comment"># dict_values([&#x27;Tom&#x27;, 20, &#x27;男&#x27;])</span><br></code></pre></td></tr></table></figure></li><li><p>items()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;<br>print(dict1.items()) <br><span class="hljs-comment"># dict_items([(&#x27;name&#x27;, &#x27;Tom&#x27;), (&#x27;age&#x27;, 20), (&#x27;gender&#x27;, &#x27;男&#x27;)])</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>字典对象本身也是可迭代对象，每次迭代返回一个key</strong></p></blockquote><h3 id="字典拆包"><a href="#字典拆包" class="headerlink" title="字典拆包"></a>字典拆包</h3><p><img src="/2021/02/19/python3/python3/image-20200903201210168.png" alt="image-20200903201210168"></p><p><strong>应用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#将字典的所有key保存在一个列表中</span><br>d = <span class="hljs-built_in">dict</span>(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">23</span>, <span class="hljs-number">0</span>: <span class="hljs-number">123</span>&#125;)<br><br>(*keys,) = d<br>print(keys,<span class="hljs-built_in">type</span>(keys))<br><span class="hljs-comment"># 👉[&#x27;name&#x27;, &#x27;age&#x27;, 0] &lt;class &#x27;list&#x27;&gt;</span><br><br>dictKeys = d.keys()<br>print(dictKeys,<span class="hljs-built_in">type</span>(dictKeys))<br><span class="hljs-comment"># 👉dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, 0]) &lt;class &#x27;dict_keys&#x27;&gt;</span><br><br><br></code></pre></td></tr></table></figure><h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>创建集合使用<code>&#123;&#125;</code>或<code>set()</code>， 但是如果要创建空集合只能使用<code>set()</code>，因为<code>&#123;&#125;</code>用来创建空字典。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>集合可以去掉重复数据；</li><li>集合数据是无序的，故不支持下标</li></ol><h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><ul><li><p><strong>add()</strong></p><p>add方法传入==一个可哈希类型==的数据，并将该数据添加到集合中，重复值会被去重。</p></li><li><p><strong>update()</strong></p><p>update方法传入==一个可迭代==的数据，并将该数据的所有迭代返回值添加到集合中，重复值会被去重。==同时该方法要求传入的可迭代对象的每次迭代的返回值都是可哈希的，否则报错==</p></li></ul><blockquote><p>可哈希的数据类型，即不可变的数据结构，包括：数字、字符串、元组以及对象集objects。</p><p>不可哈希的数据类型，即可变的数据结构，包括：字典、列表、集合。</p></blockquote><blockquote><p>可迭代的数据类型，包括：字符串、列表、元组、字典、集合等。</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">str1 = <span class="hljs-string">&#x27;12345&#x27;</span><br>s1 = <span class="hljs-built_in">set</span>()<br>s2 = <span class="hljs-built_in">set</span>()<br><br>s1.add(str1)<span class="hljs-comment"># 传入可哈希类型</span><br>s2.update(str1)<span class="hljs-comment"># 传入可迭代类型</span><br><br>print(<span class="hljs-string">&#x27;s1:&#x27;</span>, s1)&gt;&gt;&gt; s1: &#123;<span class="hljs-string">&#x27;12345&#x27;</span>&#125;<br>print(<span class="hljs-string">&#x27;s2:&#x27;</span>, s2)&gt;&gt;&gt; s2: &#123;<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;<br><br> <br>s3 = <span class="hljs-built_in">set</span>()<br>dic1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">321</span>&#125;<br>s3.update(dic1)<span class="hljs-comment"># 传入可迭代类型，迭代字典返回key</span><br>print(s3)&gt;&gt;&gt;&#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li><p><strong>remove()</strong></p><p>remove方法传入一个可哈希类型的数据，删除集合中的该数据，数据不存在时==报错==。</p></li><li><p><strong>discard()</strong></p><p>discard方法传入一个可哈希类型的数据，删除集合中的该数据，数据不存在时==不报错==。</p></li><li><p><strong>pop()</strong></p><p>pop方法会取出集合中的第一个迭代值（输出时最左边的值）。</p><blockquote><p>新建一个集合以及由其他容器转来的集合，数据的排列方式各有不同。</p></blockquote></li></ul><h3 id="判断数据是否存在"><a href="#判断数据是否存在" class="headerlink" title="判断数据是否存在"></a>判断数据是否存在</h3><ul><li><strong>in：</strong>判断数据在集合序列</li><li><strong>not in：</strong>判断数据不在集合序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;<br><br>print(<span class="hljs-number">10</span> <span class="hljs-keyword">in</span> s1)<br>print(<span class="hljs-number">10</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s1)<br></code></pre></td></tr></table></figure><h2 id="容器小结"><a href="#容器小结" class="headerlink" title="容器小结"></a>容器小结</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>容器</th><th>是否可哈希</th><th>是否可迭代</th><th>迭代返回的数据</th></tr></thead><tbody><tr><td>字符串</td><td>✔</td><td>✔</td><td>字符</td></tr><tr><td>列表</td><td></td><td>✔</td><td>元素</td></tr><tr><td>元组</td><td>✔</td><td>✔</td><td>元素</td></tr><tr><td>字典</td><td></td><td>✔</td><td>key</td></tr><tr><td>集合</td><td></td><td>✔</td><td>元素</td></tr></tbody></table><h3 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h3><blockquote><p> 公共函数要求传入一个可迭代对象，而python内置的容器都是可迭代对象。</p></blockquote><ol><li><p>len() </p><p>返回容器的长度，即可迭代的次数</p></li><li><p>max()</p><p>返回容器中的最大值，==要求容器的所有迭代值可以相互比较，否则报错==</p></li><li><p>min()</p><p>类似于max，返回容器中的最小值</p></li><li><p>enumerate()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">enumerate</span>(可迭代对象,start=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>enumerate方法第一个参数要求传入一个可迭代对象，第二个参数start为一个整数。</p><p>该方法会返回一个可迭代对象，该对象的迭代值为一个元组，元组具有固定格式：</p><p>（整数索引值，第一个参数的每个迭代值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">321</span>&#125;<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dic1,start=<span class="hljs-number">0</span>):<br>    print(t)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>)<br><br>lis = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">for</span> index,val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lis,start=<span class="hljs-number">1</span>):<br>    print(index,val)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">2</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">支持的容器类型</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">合并</td><td align="center">字符串、列表、元组</td></tr><tr><td align="center">*</td><td align="center">倍增</td><td align="center">字符串、列表、元组</td></tr><tr><td align="center">in</td><td align="center">元素是否存在</td><td align="center">字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td align="center">元素是否不存在</td><td align="center">字符串、列表、元组、字典</td></tr></tbody></table><ul><li><p> <code>*</code> 是用于==整数==和==序列类型==之间的计算，可以左边使用运算符，也可以右边使用。</p></li><li><p><code>in</code>和<code>not in</code>对于==字符串==使用是==判断子串是否存在==；</p></li><li><p><code>in</code>和<code>not in</code>对于==字典==使用是==判断键是否存在==；</p></li></ul><h3 id="容器类型转换"><a href="#容器类型转换" class="headerlink" title="容器类型转换"></a>容器类型转换</h3><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple()"></a>tuple()</h4><p>作用：将某个可迭代对象转换成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>]<br>s1 = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;<br><br>print(<span class="hljs-built_in">tuple</span>(list1))<br>print(<span class="hljs-built_in">tuple</span>(s1))<br></code></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h4><p>作用：将某个可迭代对象转换成列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br>s1 = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;<br><br>print(<span class="hljs-built_in">list</span>(t1))<br>print(<span class="hljs-built_in">list</span>(s1))<br></code></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>作用：将某个可迭代对象转换成集合，并去重。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>]<br>t1 = (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><br>print(<span class="hljs-built_in">set</span>(list1))<br>print(<span class="hljs-built_in">set</span>(t1))<br></code></pre></td></tr></table></figure><blockquote><p>注意：若传入set方法中的可迭代对象的某个迭代值不可哈希，则会报错。</p></blockquote><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><ul><li>推导式的作用：简化代码</li><li>推导式写法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表推导式</span><br>[xx <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>()]<br><br><span class="hljs-comment"># 字典推导式</span><br>&#123;xx1: xx2 <span class="hljs-keyword">for</span> ... <span class="hljs-keyword">in</span> ...&#125;<br><br><span class="hljs-comment"># 集合推导式</span><br>&#123;xx <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> ...&#125;<br></code></pre></td></tr></table></figure><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><ol><li><p><strong>基本使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>带if语句的列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><strong>多个for循环嵌套的列表推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)]<br>print(list1)<br></code></pre></td></tr></table></figure></li></ol><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><ol><li><p><strong>基本使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>]<br>list2 = [<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;man&#x27;</span>]<br><br>dict1 = &#123;list1[i]: list2[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list1))&#125;<br>print(dict1)<br><br><br>vals = [(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;mz&#x27;</span>), (<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-number">23</span>)]<br>dict2 = &#123; key: val <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> vals &#125;<br>print(dict2)<br><span class="hljs-comment"># 输出 &#123;&#x27;name&#x27;: &#x27;mz&#x27;, &#x27;age&#x27;: 23&#125;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>带if语句的字典推导式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">counts = &#123;<span class="hljs-string">&#x27;MBP&#x27;</span>: <span class="hljs-number">268</span>, <span class="hljs-string">&#x27;HP&#x27;</span>: <span class="hljs-number">125</span>, <span class="hljs-string">&#x27;DELL&#x27;</span>: <span class="hljs-number">201</span>, <span class="hljs-string">&#x27;Lenovo&#x27;</span>: <span class="hljs-number">199</span>, <span class="hljs-string">&#x27;acer&#x27;</span>: <span class="hljs-number">99</span>&#125;<br><br><span class="hljs-comment"># 需求：提取上述电脑数量大于等于200的字典数据</span><br>count1 = &#123;key: value <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> counts.items() <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">200</span>&#125;<br>print(count1)  <span class="hljs-comment"># &#123;&#x27;MBP&#x27;: 268, &#x27;DELL&#x27;: 201&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><ol><li><p>基本使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>set1 = &#123;i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list1&#125;<br>print(set1)  <span class="hljs-comment"># &#123;1, 4&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：集合有数据去重功能。</p></blockquote></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    ...<br>    ...<br></code></pre></td></tr></table></figure><h3 id="先定义，再调用"><a href="#先定义，再调用" class="headerlink" title="先定义，再调用"></a>先定义，再调用</h3><p>在python中，脚本从上到下解释执行，在调用函数前应先定义。</p><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    ...<br>    [<span class="hljs-keyword">return</span>  ...]<br></code></pre></td></tr></table></figure><p>在python中函数可以不返回值、返回一个值或返回多个值</p><ol><li><p>没有return语句或使用return但不返回值</p><p>==返回None==</p></li><li><p>return返回一个值</p><p>==用一个变量接收==</p></li><li><p>return返回多个值时，会以元组的形式返回</p><p>==用一个变量接收元组、或使用元组拆包==</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><br><br>x = foo()<br>x1, x2, x3 = foo()<br>(y, *t) = foo()<br><br>print(x)<br>print(x1, x2, x3)<br>print(y, t)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">1</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="函数说明文档"><a href="#函数说明文档" class="headerlink" title="函数说明文档"></a>函数说明文档</h3><ul><li><p>定义函数的说明文档</p><p>==在函数代码块的第一行以三双引号开始书写函数说明==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 说明文档的位置 &quot;&quot;&quot;</span><br>    代码<br>    ......<br>    <br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> 函数名(<span class="hljs-params">参数</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">    多行说明文档</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    代码<br>    ......<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>查看函数的说明文档</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">help</span>(函数名)<br></code></pre></td></tr></table></figure></li><li><p>举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum_num</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 求和函数 &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-built_in">help</span>(sum_num)<br><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>sum_num(a,b)<br>求和函数<br></code></pre></td></tr></table></figure></li></ul><h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><p>根据作用域（变量生效的范围）可以将变量分为==局部变量==和==全局变量==</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span> <span class="hljs-comment"># 全局变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    a = <span class="hljs-number">200</span> <span class="hljs-comment"># 局部变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    a = <span class="hljs-number">300</span><br>    foo()<br>    print(a)<br>    <br>print(a)<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ol><li>在不加声明的情况下，python函数中对某个变量进行了定义（初始化、赋值操作），则该变量就成为了局部变量。</li><li>如果函数内不存在对某个变量的定义，但访问了该变量，则解释器会向全局作用域中查找该变量，若全局作用域中也不存在对该变量的定义，则报错。</li></ol></blockquote><p><strong>在函数中声明全局变量：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    a = <span class="hljs-number">200</span> <br>      <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>():</span><br>    <span class="hljs-keyword">global</span> a<br>    a = <span class="hljs-number">200</span><br>    <br>foo()<br>print(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">100</span><br><br>bar()<br>print(a)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">200</span><br>    <br></code></pre></td></tr></table></figure><h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p><strong>一、位置参数</strong></p><p>位置参数：调用函数时根据函数定义的形参的位置与含义来传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender</span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：在使用位置参数进行传参时，实参和形参的顺序及个数必须一致。</p></blockquote><p><strong>二、使用关键字传参</strong></p><p>函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender</span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;Rose&#x27;</span>, age=<span class="hljs-number">20</span>, gender=<span class="hljs-string">&#x27;女&#x27;</span>)<br>user_info(<span class="hljs-string">&#x27;小明&#x27;</span>, gender=<span class="hljs-string">&#x27;男&#x27;</span>, age=<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。</p></blockquote><p><strong>三、参数默认值</strong></p><p>为形参提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">name, age, gender=<span class="hljs-string">&#x27;男&#x27;</span></span>):</span><br>    print(<span class="hljs-string">f&#x27;您的名字是<span class="hljs-subst">&#123;name&#125;</span>, 年龄是<span class="hljs-subst">&#123;age&#125;</span>, 性别是<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br><br><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">20</span>)<br>user_info(<span class="hljs-string">&#x27;Rose&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;女&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>注意：函数调用时，如果为缺省参数传值则修改默认参数值；否则使用这个默认值。</p></blockquote><p><strong>四、不定长参数</strong></p><p>不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。</p><blockquote><p>无论是包裹位置传递还是包裹关键字传递，都是一个组包的过程。</p></blockquote><ol><li><p>包裹位置传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">语法：*不定长参数名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">*args</span>):</span><br>    print(args)<br><br><br><span class="hljs-comment"># (&#x27;TOM&#x27;,)</span><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>)<br><span class="hljs-comment"># (&#x27;TOM&#x27;, 18)</span><br>user_info(<span class="hljs-string">&#x27;TOM&#x27;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><blockquote><p>传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组。</p><p>python编程中也常用args包裹位置不定长参数</p></blockquote></li><li><p>包裹关键字传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">语法：**不定长参数名<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">user_info</span>(<span class="hljs-params">**kwargs</span>):</span><br>    print(kwargs)<br><br><br><span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;TOM&#x27;, &#x27;age&#x27;: 18, &#x27;id&#x27;: 110&#125;</span><br>user_info(name=<span class="hljs-string">&#x27;TOM&#x27;</span>, age=<span class="hljs-number">18</span>, <span class="hljs-built_in">id</span>=<span class="hljs-number">110</span>)<br></code></pre></td></tr></table></figure><blockquote><p>kwargs是一个字典类型，以key：val的形式包裹不定长参数。</p><p>python编程中也常用kwargs包裹关键字不定长参数</p></blockquote></li></ol><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式也称作匿名函数，用于简化函数的书写。</p><blockquote><p>使用场景要求：函数可有多个参数，使用一个表达式的结果作为返回值。</p></blockquote><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 参数列表:表达式<br></code></pre></td></tr></table></figure><blockquote><p>所有python函数的传参方式都适用于lambda表达式</p></blockquote><ol><li><p>无参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span>: <span class="hljs-number">100</span><br>print(fn1())<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> a: a<br>print(fn1(<span class="hljs-string">&#x27;hello world&#x27;</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">func = <span class="hljs-keyword">lambda</span> name, age: (name, age)<br>x = func(age=<span class="hljs-number">23</span>, name=<span class="hljs-string">&#x27;mz&#x27;</span>)<br>print(x)<br></code></pre></td></tr></table></figure><blockquote><p>在pep8编码规范中，不建议使用<code>functioname = lambda表达式</code>的型式定义函数。</p></blockquote></li></ol><ol start="4"><li><p>默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> a, b, c=<span class="hljs-number">100</span>: a + b + c<br>print(fn1(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>可变参数 args</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn1 = <span class="hljs-keyword">lambda</span> *args: args<br>print(fn1(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>))<br></code></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>可变参数 kwargs</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">fn1 = <span class="hljs-keyword">lambda</span> **kwargs: kwargs<br>print(fn1(name=<span class="hljs-string">&#x27;python&#x27;</span>, age=<span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure></li></ol><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ol><li><p><strong>all(==iterable==)</strong></p><p>传入一个可迭代对象，若所有迭代值为True，则返回True</p></li><li><p><strong>any</strong>(==iterable==)</p><p>传入一个可迭代对象，若存在一个值为True，则返回True</p></li><li><p><strong>dir(==object==)</strong></p><p>传入一个对象，返回对象的所有属性和方法。不传参时，返回全局变量与函数。</p></li><li><p>enumerate(==iterable,  [start = 0]==)</p><p>枚举函数，在迭代对象的时候，额外提供一个序列号的输入。</p></li><li><p>frozenset(==iterable==)</p><p>返回一个不能增加和修改的集合对象。</p></li><li><p>isinstance(==object, classname==)</p><p>判断一个对象是否是某个类的实例</p></li><li><p>issubclass(==sonclass, baseclass==)</p><p>判断一个类是否是另一个类的子类</p></li><li><p>reversed(==iterable==)</p><p>传入一个可迭代对象，返回该可迭代对象的反转对象（即迭代顺序相反）</p></li><li><p>slice(==start, end, step==)</p><p>返回一个切片对象，相当于 start: end: step</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>s = <span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>)<br>print(ls[s])<br>&gt;&gt;&gt;[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></li></ol><h3 id="内置高阶函数-map-、filter、reduce、sorted"><a href="#内置高阶函数-map-、filter、reduce、sorted" class="headerlink" title="内置高阶函数 map 、filter、reduce、sorted"></a>内置高阶函数 map 、filter、reduce、sorted</h3><p><strong>一、map</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(func, *iterables) <span class="hljs-comment">#返回一个可迭代对象 &lt;map object&gt;</span><br></code></pre></td></tr></table></figure><p>传入一个可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span><br><br>result = <span class="hljs-built_in">map</span>(func, list1)<br><br>print(result)  &gt;&gt;&gt; &lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000013769653198</span>&gt;<br>print(<span class="hljs-built_in">list</span>(result)) &gt;&gt;&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>]<br></code></pre></td></tr></table></figure><p>传入多个可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>dict1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">0</span>&#125;<br><br>result = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> item, key: (key, item), ls, dict1 )<br><br>print(result)  &gt;&gt;&gt; &lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000013769653198</span>&gt;<br>print(<span class="hljs-built_in">dict</span>(result)) &gt;&gt;&gt; &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、filter</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">filter</span>(func, iterable) <span class="hljs-comment">#返回一个可迭代对象 &lt;filter object&gt;</span><br></code></pre></td></tr></table></figure><p><strong>三、reduce</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br>functools.reduce(func, iterable, [initVal]) <span class="hljs-comment">#返回一个值</span><br></code></pre></td></tr></table></figure><blockquote><p>当传入可迭代对象为空时，若不指定initVal，则会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br>ls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>result = functools.reduce(<span class="hljs-keyword">lambda</span> pre, cur:pre+cur, ls, <span class="hljs-number">0</span>)<br>print(result) &gt;&gt;&gt; <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>四、sorted</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>, [key , reverse=<span class="hljs-literal">False</span>])<br></code></pre></td></tr></table></figure><p>类似于列表的sort方法，返回排序后的列表, ==不会修改参数中的list==。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象三大特性：封装、继承和多态。</p><p>由于python是动态语言，天生具有多态的特性，不需要额外语法实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;xxx&#x27;</span>)<br>        <br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;hengheng&#x27;</span>)<br>        <br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dospeak</span>(<span class="hljs-params">animal</span>):</span><br>    animal.speak()<br>    <br>p = Pig()<br>a = Animal()<br><br>dospeak(p)  <span class="hljs-comment"># 鸭子模型</span><br>dospeak(a)<br><br></code></pre></td></tr></table></figure><h3 id="类的定义与实例化"><a href="#类的定义与实例化" class="headerlink" title="类的定义与实例化"></a>类的定义与实例化</h3><ol><li><p>定义类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名:</span><br>    <span class="hljs-comment"># 代码</span><br>    <span class="hljs-comment"># ......</span><br>    <span class="hljs-keyword">pass</span><br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wash</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;我会洗衣服&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>不由任意内置类型派生出的类，称之为经典类</p></blockquote></li><li><p>实例化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">对象名 = 类名()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建对象</span><br>haier1 = Washer()<br><br><span class="hljs-comment"># &lt;__main__.Washer object at 0x0000018B7B224240&gt;</span><br>print(haier1)<br><br><span class="hljs-comment"># haier对象调用实例方法</span><br>haier1.wash()<br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>self参数</p><p>在python中定义实例方法，第一个位置传入self参数，代表实例对象本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.age = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">self</span>):</span><br>        print(self.age)<br><br>per = Person()<br>per.printAge()<br></code></pre></td></tr></table></figure></li></ol><h3 id="实例的属性"><a href="#实例的属性" class="headerlink" title="实例的属性"></a>实例的属性</h3><blockquote><p>在python中，实例对象的属性不在类内定义，但可以在类的实例方法中初始化、修改、删除实例的属性。</p></blockquote><ol><li><p>类内初始化、访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.age = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAge</span>(<span class="hljs-params">self</span>):</span><br>        print(self.age)<br></code></pre></td></tr></table></figure></li><li><p>类外定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">per = Person()<br>per.name = <span class="hljs-string">&#x27;mz&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="类的属性（静态属性）"><a href="#类的属性（静态属性）" class="headerlink" title="类的属性（静态属性）"></a>类的属性（静态属性）</h3><p>类属性就是 <strong>类对象</strong> 所拥有的属性，它被 <strong>该类的所有实例对象 所共有</strong>。</p><p>类属性可以使用 <strong>类对象</strong> 或 <strong>实例对象</strong> 访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    tooth = <span class="hljs-number">10</span><br>    <br>wangcai = Dog()<br>xiaohei = Dog()<br><br>print(Dog.tooth)  <span class="hljs-comment"># 10</span><br>print(wangcai.tooth)  <span class="hljs-comment"># 10</span><br>print(xiaohei.tooth)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><blockquote><p>类属性的优点</p><ul><li><strong>记录的某项数据 始终保持一致时</strong>，则定义类属性。</li><li><strong>实例属性</strong> 要求 <strong>每个对象</strong> 为其 <strong>单独开辟一份内存空间</strong> 来记录数据，而 <strong>类属性</strong> 为全类所共有 ，<strong>仅占用一份内存</strong>，<strong>更加节省内存空间</strong>。</li></ul></blockquote><blockquote><p>注意：不能通过实例修改类的属性，如果这样操作，实则是创建了一个实例属性。</p></blockquote><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>需要用装饰器<code>@classmethod</code>来标识其为类方法，对于类方法，<strong>第一个参数必须是调用者本身（类对象）</strong>，一般以<code>cls</code>作为第一个参数。</p><blockquote><p>只有使用类名才能调用类的方法</p></blockquote><p><strong>使用场景：</strong></p><ul><li><p>当方法中 <strong>需要使用类对象</strong> (如访问私有类属性等)时，定义类方法</p></li><li><p>类方法一般和类属性配合使用</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __tooth = <span class="hljs-number">10</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_tooth</span>(<span class="hljs-params">cls</span>):</span><br>        <span class="hljs-keyword">return</span> cls.__tooth<br><br>wangcai = Dog()<br>result = wangcai.get_tooth()<br>print(result)  <span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>需要通过装饰器<code>@staticmethod</code>来进行修饰，<strong>静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）</strong>。</p><blockquote><p>使用实例与类名都能够调用静态方法</p></blockquote><p><strong>使用场景：</strong></p><ul><li>当方法中 <strong>既不需要使用实例对象</strong>(如实例对象，实例属性)，<strong>也不需要使用类对象</strong> (如类属性、类方法、创建实例等)时，定义静态方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info_print</span>():</span><br>        print(<span class="hljs-string">&#x27;这是一个狗类，用于创建狗实例....&#x27;</span>)<br><br><br>wangcai = Dog()<br><span class="hljs-comment"># 静态方法既可以使用对象访问又可以使用类访问</span><br>wangcai.info_print()<br>Dog.info_print()<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><strong>取消不需要的参数传递</strong>，有利于 <strong>减少不必要的内存占用和性能消耗</strong></li></ul><hr><h3 id="特殊成员与魔法方法"><a href="#特殊成员与魔法方法" class="headerlink" title="特殊成员与魔法方法"></a>特殊成员与魔法方法</h3><p><strong>一、<code>__init__()</code></strong></p><p>作用：初始化对象的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_info</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">f&#x27;洗衣机的宽度是<span class="hljs-subst">&#123;self.width&#125;</span>&#x27;</span>)<br>        print(<span class="hljs-string">f&#x27;洗衣机的高度是<span class="hljs-subst">&#123;self.height&#125;</span>&#x27;</span>)<br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>haier1.print_info()<br><br><br>haier2 = Washer(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)<br>haier2.print_info()<br></code></pre></td></tr></table></figure><p><strong>二、<code>__str__()</code></strong></p><p>当使用print输出对象的时候，默认打印对象的内存地址。如果类定义了<code>__str__</code>方法，那么就会打印从在这个方法中 return 的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是海尔洗衣机的说明书&#x27;</span><br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>print(haier1) &gt;&gt;&gt; 这是海尔洗衣机的说明书<br></code></pre></td></tr></table></figure><p><strong>三、<code>__del__()</code></strong></p><p>当删除对象时，python解释器也会默认调用<code>__del__()</code>方法。（析构函数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Washer</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, width, height</span>):</span><br>        self.width = width<br>        self.height = height<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self&#125;</span>对象已经被删除&#x27;</span>)<br><br><br>haier1 = Washer(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">del</span> haier1<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># &lt;__main__.Washer object at 0x0000026118223278&gt;对象已经被删除</span><br></code></pre></td></tr></table></figure><p><strong>四、<code>__doc__</code></strong></p><p>属性，类的说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;A的说明&quot;&quot;&quot;</span>    <span class="hljs-comment"># __doc__属性是该位置的类的说明</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_A</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;A&#x27;</span>)<br>        <br>print(A.__doc__)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>A的说明<br></code></pre></td></tr></table></figure><p><strong>五、<code>__setitem__() </code> 、<code>__getitem__()</code>、<code>__delitem__()</code></strong></p><p>可以让实例对象像字典一样使用。</p><p><strong>六、<code>__iter__()</code></strong></p><p>返回一个迭代器，使实例可以用for循环遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p><strong>七、<code>__len__()</code></strong></p><p>当对象实例传入len()函数时返回的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,<span class="hljs-built_in">len</span></span>):</span><br>        this.__len = <span class="hljs-built_in">len</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__len<br>    <br>a = A(<span class="hljs-number">10</span>)<br>print(<span class="hljs-built_in">len</span>(a))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>八、运算符重载</strong></p><p><code>__add__()</code>重载<code> +</code> 运算符</p><p><code>__sub__()</code>重载<code>-</code> 运算符</p><p><code>__mul__()</code>重载<code> *</code> 运算符</p><p><code>__div__()</code>重载<code> /</code> 运算符</p><p><code>__mod__()</code>重载<code> %</code> 运算符</p><p><code>__pow__()</code>重载<code> **</code> 运算符</p><p><code>__cmp__()</code>重载比较运算</p><p><strong>九、<code>__mro__</code></strong></p><p>继承关系，返回一个列表。</p><p>**十、<code>__getattr__()</code>和<code>__getattribute__()</code>**、</p><p>控制获取实例的属性的逻辑。</p><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>python中，子类会继承父类<strong>所有方法</strong>（实例方法、类的方法、静态方法、<strong>魔法方法</strong>）。</p><p>同时会继承父类的属性（<strong>不包括实例属性</strong>）。</p><p><strong>一、单继承</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.name = name<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span><br>        print(<span class="hljs-string">&#x27;animal:%s&#x27;</span> % self.name)<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span>(<span class="hljs-params">Animal</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        Animal.__init__(self, name)  <span class="hljs-comment"># 借用父类的构造函数</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">speak</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 重写父类的实例方法</span><br>        print(<span class="hljs-string">&#x27;horse:%s&#x27;</span> % self.name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">basespeak</span>(<span class="hljs-params">self</span>):</span><br>        Animal.speak(self)  <span class="hljs-comment"># 调用父类的实例方法</span><br><br><br>h = Horse(<span class="hljs-string">&#x27;ley&#x27;</span>)<br>h.speak()<br>h.basespeak()<br><span class="hljs-meta">&gt;&gt;&gt; </span>horse:ley<br><span class="hljs-meta">&gt;&gt;&gt; </span>animal:ley<br><br></code></pre></td></tr></table></figure><p><strong>二、多继承</strong></p><p>在python3中支持多继承，但在实际开发中，一个类往往最多继承两个类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Horse</span>():</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Donkey</span>():</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mule</span>(<span class="hljs-params">Horse,Donkey</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><hr><h3 id="实例的方法和属性的查找顺序"><a href="#实例的方法和属性的查找顺序" class="headerlink" title="实例的方法和属性的查找顺序"></a>实例的方法和属性的查找顺序</h3><blockquote><p>注意：在一个类中，类的方法、类的静态方法、类的属性、实例的属性以及实例的方法<strong>不能重名，否则会覆盖。</strong></p></blockquote><p><strong>一、方法查找</strong></p><blockquote><p><strong>MRO：方法解析顺序 python采用c3算法</strong></p></blockquote><p>由于多继承机制的存在，在python中调用实例的方法时采用<strong>c3算法</strong>进行解析查找：</p><ol><li><p>首先在实例内部查找，如果没有找到，则向父类中查找。</p></li><li><p>根据定义继承关系时的顺序，以<strong>深度优先</strong>的方式逐一查找父类。</p></li><li><p>在多个父类继承自同一个类时，<strong>采用深度优先与广度优先结合的算法</strong>。</p></li><li><p>在定义的继承关系中都没找到，最后到object中查找。</p><p>==2和3合在一起成为MRO==</p></li></ol><p>基本继承模型的实例方法查找顺序：</p><p><img src="/2021/02/19/python3/python3/image-20200908200041362.png" alt="image-20200908200041362"> <img src="/2021/02/19/python3/python3/image-20200908200146328.png" alt="image-20200908200146328">共有的祖先最后才查找</p><p>复杂继承关系拆分成基本继承关系：</p><p><img src="/2021/02/19/python3/python3/image-20200908200310621.png" alt="image-20200908200310621"></p><p><strong>二、属性查找</strong></p><p>在访问实例的属性时，首先会在实例内部查找，如果不存在，则查找类的属性。</p><p>如果还不存在，使用c3算法向上查找父类的属性（类的属性）。</p><blockquote><p>可以使用实例的<code>__dict__</code>属性查看实例自身具有的属性。 </p><p>同时可以使用<code>dir函数</code>查看通过实例可访问到的所有属性和方法。</p></blockquote><hr><h3 id="成员保护和访问限制"><a href="#成员保护和访问限制" class="headerlink" title="成员保护和访问限制"></a>成员保护和访问限制</h3><p>私有成员：</p><ol><li>属性或方法</li><li>不能被外部访问</li><li>不会被继承</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span><br>    __title = <span class="hljs-string">&#x27;myclass&#x27;</span>  <span class="hljs-comment"># 私有的类的属性</span><br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">cls</span>):</span><br>        print(cls.__title)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name     <span class="hljs-comment"># 实例的私有属性</span><br></code></pre></td></tr></table></figure><blockquote><p>python中不存在完全严格的私有成员，只是做了一层假保护。</p><p>例如 ：上述的私有的类的属性可以通过  Myclass._MyClass__title访问到。(  _类名__属性名 )</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>:</span><br>    __title = <span class="hljs-string">&#x27;myclass&#x27;</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">info</span>(<span class="hljs-params">cls</span>):</span><br>        print(cls.__title)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name</span>):</span><br>        self.__name = name  <span class="hljs-comment"># 实例的私有属性</span><br><br>MyClass.info()<br>print(MyClass._MyClass__title)<br>a = MyClass(<span class="hljs-string">&#x27;mz&#x27;</span>)<br>print(a._MyClass__name)<br></code></pre></td></tr></table></figure><p><strong>类与下划线：</strong></p><ol><li><code>_name</code>、<code>_name_</code>、<code>_name__</code> 是简易性的私有成员，不要在外部访问。</li><li><code>__name</code>、<code>__name_</code>是强制的私有成员，但是你依然可以蛮横地在外部危险访问。</li><li><code>__name__</code>是特殊成员，与私有性质无关，例如<code>__doc__</code>和<code>__init__</code>等。</li><li><code>name_</code>、<code>name__</code>没有任何特殊性，普通的标识符，但最好不要这么取名。</li></ol><blockquote><p>Tips：在类如 for i in range(10000):的这种循环代码块中，如果在循环体内部使用不到 i ，为了节省内存开辟内存的时间，可以使用 下划线 _ 代替 i </p></blockquote><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>作用：将方法伪装成属性，常与私有属性配合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, age</span>):</span><br>        self.__name = name<br>        self.__age = age<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.__age<br><br><span class="hljs-meta">    @age.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self, val</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(val, <span class="hljs-built_in">int</span>):<br>            self.__age = val<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;请输入一个整数&#x27;</span>)<br><br><span class="hljs-meta">    @age.deleter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">age</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self.__age<br><br><br>p = People(<span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-number">24</span>)<br>print(p.age) &gt;&gt;&gt; <span class="hljs-number">24</span><br>p.age = <span class="hljs-number">18</span><br>print(p.age) &gt;&gt;&gt; <span class="hljs-number">18</span><br><span class="hljs-keyword">del</span> p.age<br>print(p.age) &gt;&gt;&gt; AttributeError:<span class="hljs-string">&#x27;People&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;_People__age&#x27;</span><br><br></code></pre></td></tr></table></figure><p><strong>property函数</strong></p><p>作用与属性装饰器相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 属性装饰器写法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._x = <span class="hljs-literal">None</span><br> <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self._x<br> <br><span class="hljs-meta">    @x.setter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self, value</span>):</span><br>        self._x = value<br> <br><span class="hljs-meta">    @x.deleter</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self._x<br></code></pre></td></tr></table></figure><p>👇👇👇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># property函数写法</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._x = <span class="hljs-literal">None</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getx</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._x<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setx</span>(<span class="hljs-params">self, value</span>):</span><br>        self._x = value<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delx</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">del</span> self._x<br> <br>    x = <span class="hljs-built_in">property</span>(getx, setx, delx, <span class="hljs-string">&quot;I&#x27;m the &#x27;x&#x27; property.&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> ErrorType1 <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> ErrorType2 <span class="hljs-keyword">as</span> e:   <br><span class="hljs-comment"># except ErrorType3 as e:   </span><br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(<span class="hljs-string">&#x27;捕获异常基类,异常信息:&#x27;</span>, e)<br><span class="hljs-keyword">except</span>:<br>    print(<span class="hljs-string">&#x27;未知异常&#x27;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    a = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e: <span class="hljs-comment"># 捕获NameError</span><br>    print(e)<br><span class="hljs-keyword">except</span> (ValueError, ZeroDivisionError) <span class="hljs-keyword">as</span> e: <span class="hljs-comment"># 捕获异常分组</span><br> print(e)<br><span class="hljs-keyword">except</span>:<br>    print(<span class="hljs-string">&#x27;未知异常&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">try</span>:<br>        a = <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>        print(e)<br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:   <span class="hljs-comment"># 可以捕获内部没有捕获的异常</span><br>    print(e)<br>        <br></code></pre></td></tr></table></figure><h3 id="内置异常"><a href="#内置异常" class="headerlink" title="内置异常"></a>内置异常</h3><p><img src="/2021/02/19/python3/python3/image-20200908214525411.png" alt="image-20200908214525411"></p><h3 id="else与finally"><a href="#else与finally" class="headerlink" title="else与finally"></a>else与finally</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    print(e)<br><span class="hljs-keyword">else</span>:<br>    print(<span class="hljs-string">&#x27;没有异常发生&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    print(<span class="hljs-string">&#x27;无论是否发生异常，执行最后的处理&#x27;</span>)<br>    <br></code></pre></td></tr></table></figure><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyError</span>(<span class="hljs-params">Exception</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, msg</span>):</span><br>        self.msg = msg<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.msg<br><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> MyError(<span class="hljs-string">&#x27;自定义异常&#x27;</span>)<br><span class="hljs-keyword">except</span> MyError <span class="hljs-keyword">as</span> e:<br>    print(e)<br></code></pre></td></tr></table></figure><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h3><p><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</p><p>返回一个file-like对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(filepath,mode=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-comment"># f即为一个文件句柄</span><br><span class="hljs-keyword">pass</span><br>f.close()<br></code></pre></td></tr></table></figure><p><strong>mode:</strong></p><p><img src="/2021/02/19/python3/python3/image-20200908221431298.png" alt="image-20200908221431298"></p><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><ol><li><p>read()</p><p>读取所有内容</p></li><li><p>readline()</p><p>读取一行内容，返回一个字符串（二进制时是byte类型）最后一个字符是<code>\n</code></p><p>（最后一行不一定有<code>\n</code>）</p></li><li><p>readlines()</p><p>读取所有行，返回一个列表，每个元素的最后一个字符是换行符<code>\n</code></p><p>（最后一行不一定带<code>\n</code>）</p></li><li><p>tell()</p><p>返回当前文件指针距离文件开头位置的字节数。</p></li><li><p>seek()</p><p>移动文件指针</p></li></ol><blockquote><p>文件对象是一个可迭代对象，每个迭代值返回一行的内容。</p></blockquote><h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./test.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;人生苦短，我用python&#x27;</span>.encode(<span class="hljs-string">&#x27;gbk&#x27;</span>))<br>f.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/test.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>content = f.read().decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><h3 id="使用with关键字"><a href="#使用with关键字" class="headerlink" title="使用with关键字"></a>使用with关键字</h3><p>with关键字用于python的上下文管理器机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;d:\test.txt) as f:</span><br><span class="hljs-string">data = f.read()</span><br><span class="hljs-string">print(data) </span><br><span class="hljs-string">    # 不需要使用close方法，上下文管理器会帮助我们合理关闭文件</span><br></code></pre></td></tr></table></figure><p>打开多个文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath1, mode=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f1, <span class="hljs-built_in">open</span>(filepath2, mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f2:<br>    f2.write(f1.read())<br></code></pre></td></tr></table></figure><h2 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h2><p>一个模块就是一个py文件。</p><p>分为：内置模块、第三方模块、自定义模块</p><h3 id="导入模块的方式"><a href="#导入模块的方式" class="headerlink" title="导入模块的方式"></a>导入模块的方式</h3><ol><li><p>import </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名<br><span class="hljs-comment"># 使用👇</span><br>模块名.功能/成员<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>from … import …</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能<span class="hljs-number">1</span>, 功能<span class="hljs-number">2</span>, 成员<span class="hljs-number">1.</span>..<br><span class="hljs-comment"># 使用👇</span><br>功能<span class="hljs-number">1</span>()<br>功能<span class="hljs-number">2</span>()<br>print(成员<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入所有功能 </span><br><span class="hljs-comment"># ❌ 但不建议使用</span><br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> * <br></code></pre></td></tr></table></figure></li><li><p>as 定义别名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> 模块名 <span class="hljs-keyword">as</span> 模块别名<br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能 <span class="hljs-keyword">as</span> 功能别名<br></code></pre></td></tr></table></figure></li></ol><h3 id="模块的-name-属性"><a href="#模块的-name-属性" class="headerlink" title="模块的__name__属性"></a>模块的__name__属性</h3><p><code>__name__</code>是系统变量，是模块的标识符：</p><ol><li><p>模块作为入口文件时，其<code>__name__</code>属性的值为<code>__main__</code></p></li><li><p>当模块是作为导入模块时，该模块的<code>__name__</code>的值为该模块的文件名（相对于执行文件所在目录的<code>包名.模块名</code>）</p></li></ol><p>可以利用该属性，为模块添加测试信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><h3 id="绝对导入"><a href="#绝对导入" class="headerlink" title="绝对导入"></a>绝对导入</h3><p>在python的执行文件或模块中，使用类似<code>import 模块名</code>、<code>import 包名.模块名</code> 、</p><p><code>from 包名.模块名 import 内容</code>等导入语法时，就是在用绝对路径导入模块。</p><p><strong>执行绝对导入时的模块搜索顺序：</strong></p><ol><li><p>执行文件所在的目录（执行文件可以理解为入口脚本，或者main函数所在的脚本。）</p></li><li><p>PYTHONPATH的环境变量里的路径 </p><p><a href="https://blog.csdn.net/csdnhuizhu/article/details/104525634/">https://blog.csdn.net/csdnhuizhu/article/details/104525634/</a></p></li><li><p> 如果都找不到，Python会察看默认路径，在python安装时已经配置好。</p></li><li><p>虚拟环境中的第三方包路径。</p></li></ol><blockquote><p>简而言之，使用绝对导入，python会：</p><p>先从内存找，</p><p>再从sys.path中找，sys.path是一个列表，保存了上述的1-4的所有绝对路径。</p><p>一定要分清楚谁是执行文件，谁是被导入文件。</p></blockquote><h3 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h3><p>使用相对导入，就不需要考虑执行文件到底是谁了，只需要知道模块与模块之间的相对位置。</p><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> module  <span class="hljs-comment"># 导入当前目录下的module</span><br><span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入上一级目录下的module</span><br><span class="hljs-keyword">from</span> ... <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入爷爷目录下的module</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .module <span class="hljs-keyword">import</span> content <span class="hljs-comment"># 导入当前目录下模块的内容</span><br><span class="hljs-keyword">from</span> ..dir1.module <span class="hljs-keyword">import</span> content <span class="hljs-comment"># 导入父级目录下的dir1目录下的模块中的内容</span><br><span class="hljs-keyword">from</span> ..dir1.dir2 <span class="hljs-keyword">import</span> module <span class="hljs-comment"># 导入父级目录下的dir1目录下的dir2目录下的模块</span><br>...<br></code></pre></td></tr></table></figure><p>⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐</p><p><strong>相对导入的语法很强大，但是需要注意的是：</strong></p><ol><li><p>相对导入不能在执行文件中使用，只能在被导入的模块中使用。</p></li><li><p>根据相对路径的查找过程中的目录不一定得是一个python包，可以是一个普通目录。</p></li><li><p>但是，<strong>顶级包之间不能互相访问</strong>——与执行文件处于一个目录下的包是顶级包。</p><p>例如目录结构：</p><p><code>myPackage/</code></p><p>—-<code>A/</code></p><p>——–<code>__init__.py</code></p><p>——–<code>a.py</code></p><p>—-<code>B/</code></p><p>——–<code>__init__.py</code></p><p>——–<code>b.py</code></p><p>—-<code>main.py</code>  </p><p><img src="/2021/02/19/python3/python3/image-20200909221050602.png" alt="image-20200909221050602"> </p><p>执行main.py，即main.py所在目录下的A包和B包是顶级包，不能互相访问，所以a.py不能导入B包中的b.py。</p><p>如果出现顶级包之间的互相访问,python解释器会报错：</p><p><code>ValueError: attempted relative import beyond top-level package</code></p></li></ol><p>   不得已的方法：</p><pre><code>   实在是想实现顶级包之间的相互访问，就需要向sys.path添加目标模块所在的目录，再使用绝对导入来加载目标模块。</code></pre><p><font size='5'>参考文章</font><a href="https://blog.csdn.net/qq_39852676/article/details/102502320">https://blog.csdn.net/qq_39852676/article/details/102502320</a></p><p>​        </p><h3 id="模块和包的-all-属性"><a href="#模块和包的-all-属性" class="headerlink" title="模块和包的__all__属性"></a>模块和包的__all__属性</h3><p>在模块中写上一句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [content1, content2,...]<br></code></pre></td></tr></table></figure><p>表示当使用*导入该模块的所有内容时，所允许加载的内容。</p><p>在包的__init__.py中写上一句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [module1, module2,...]<br></code></pre></td></tr></table></figure><p>表示当使用*导入该模块的所有模块时，所允许加载的模块。</p><h3 id="reflect反射机制"><a href="#reflect反射机制" class="headerlink" title="reflect反射机制"></a>reflect反射机制</h3><p>使用方法：</p><ol><li><code>getattr(module, member_Str)</code> 使用字符串获取模块中的成员</li><li><code>hasattr(module, member_Str) </code>判断是否模块有该成员<ol start="3"><li><code>__import__(module_Str[,fromlist=flase])</code>  传入一个字符串，加载该字符串标识的模块</li></ol></li></ol><p>工作目录： for_teach</p><p><img src="/2021/02/19/python3/python3/image-20200908210320313.png" alt="image-20200908210320313"> </p><p>commons.py中定义了多个工具函数</p><p><img src="/2021/02/19/python3/python3/image-20200908210349150.png" alt="image-20200908210349150"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在test.py中调用commons.py中的函数</span><br><br><span class="hljs-keyword">from</span> reflect <span class="hljs-keyword">import</span> commons<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入你想要访问的页面url路径:&#x27;</span>).strip()<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hasattr</span>(commons, inp)):<br>        func = <span class="hljs-built_in">getattr</span>(commons, inp) <span class="hljs-comment"># inp是一个字符串</span><br>    func()<br><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>run()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据url路径调用指定模块中的指定函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入你想要访问的页面url路径:&#x27;</span>).strip()<br>    moduleStr, funcStr = inp.split(<span class="hljs-string">&#x27;/&#x27;</span>)<br>    m = <span class="hljs-built_in">__import__</span>(module)  <span class="hljs-comment"># __import__函数可以根据字符串加载一个模块</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hasattr</span>(m, funcStr)):<br>        func = <span class="hljs-built_in">getattr</span>(commons, inp) <span class="hljs-comment"># inp是一个字符串</span><br>    func()<br><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>run()<br></code></pre></td></tr></table></figure><h1 id="python3高级"><a href="#python3高级" class="headerlink" title="python3高级"></a>python3高级</h1><h2 id="object、class以及type的关系"><a href="#object、class以及type的关系" class="headerlink" title="object、class以及type的关系"></a>object、class以及type的关系</h2><p>在python中，函数和类是一等公民。</p><p>以下的type、object、list、str等都是类，其继承关系以及实例化顺序如图：</p><p><code>&lt;class &#39;type&#39;&gt;是克隆怪，自己实例化自己，同时也实例化除object以外的其他类</code></p><p><code>除object外的其他类都继承自object类</code></p><p><code>&lt;class &#39;object&#39;&gt;是上帝，创造了一切，不继承任何父类</code></p><p><img src="/2021/02/19/python3/python3/image-20200910120312999.png" alt="image-20200910120312999"></p><blockquote><p><strong>到这里就可理解，</strong> <strong>内置函数type传入一个对象，返回的是该对象是哪个类的实例</strong></p></blockquote><h2 id="多继承时的super方法"><a href="#多继承时的super方法" class="headerlink" title="多继承时的super方法"></a>多继承时的super方法</h2><p><a href="https://blog.csdn.net/qq_26442553/article/details/81775449">https://blog.csdn.net/qq_26442553/article/details/81775449</a></p><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p><em>查阅资料</em></p><h2 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h2><p><em>查阅资料</em></p><h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>迭代器是访问容器内元素的一种方式，一般用来遍历实例内部的数据。</p><p>但迭代器和下标访问不同，它提供了一种惰性访问数据的方式。</p><h3 id="关键魔法函数"><a href="#关键魔法函数" class="headerlink" title="关键魔法函数"></a>关键魔法函数</h3><p>可迭代类型的<code>__iter__()</code>，相当于需要部署该接口</p><p>迭代器类型的<code>__next__()</code>，相当于迭代器要具有一个next方法。</p><h3 id="为一个类部署迭代接口"><a href="#为一个类部署迭代接口" class="headerlink" title="为一个类部署迭代接口"></a>为一个类部署迭代接口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, employees</span>):</span><br>        self.employees = employees<br>        <br><span class="hljs-comment"># 部署迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span> <br>        <span class="hljs-keyword">return</span> MyIterator(self.employees) <span class="hljs-comment"># 返回一个迭代器实例</span><br><br><br><span class="hljs-comment"># 实现一个按下标访问的迭代器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>(<span class="hljs-params">Iterator</span>):</span> <span class="hljs-comment"># 继承Iterator抽象类，必须实现抽象类中的__next__方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, lis</span>):</span><br>        self.__lis = lis<br>        self.__index = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            item = self.__lis[self.__index]<br>        <span class="hljs-keyword">except</span> IndexError:<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        <span class="hljs-keyword">else</span>:<br>            self.__index += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> item<br><br><br>c = Company([<span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-string">&#x27;ley&#x27;</span>])<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> c:<br>    print(p)<br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器函数：函数里只要有yield关键字，就是一个生成器函数。</p><p><strong>生成器实现原理：</strong>   <em>查阅资料</em></p><blockquote><p>简单说是生成器对象保存了两个指针，一个指向字节码对象，一个指向保存在堆中的栈帧对象，栈帧对象中保存了<strong>当前函数运行到的字节码位置</strong>以及函数中的局部变量。由于保存了函数代码运行到的位置(已执行的字节码长度)，所以可以控制函数的暂停和运行。</p></blockquote><p><strong>应用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 斐波那契数列</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span>(<span class="hljs-params">count</span>):</span><br>    index = <span class="hljs-number">0</span><br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> index &lt; count:<br>        <span class="hljs-keyword">yield</span> a<br>        index += <span class="hljs-number">1</span><br>        a, b = b, a+b<br>    <span class="hljs-keyword">return</span> a<br><br><br>g = fib(<span class="hljs-number">10</span>)<br>print(g.gi_frame.f_lasti)<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    i = <span class="hljs-built_in">next</span>(g)<br>    print(i)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 分段读取大文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myreadlines</span>(<span class="hljs-params">f, length, sep</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;f为文件句柄，length为每次读取的字节长度，sep为分隔标识字符串&quot;&quot;&quot;</span><br>    buf = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">while</span> newline <span class="hljs-keyword">in</span> buf:<br>            pos = buf.index(newline)<br>            <span class="hljs-keyword">yield</span> buf[:pos]<br>            buf = buf[pos + <span class="hljs-built_in">len</span>(newline):]<br>chunk = f.read(length)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk:<br>            <span class="hljs-keyword">yield</span> buf<br>            <span class="hljs-keyword">break</span><br>    buf += chunk<br><br>        <br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;input.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> myreadlines(f, <span class="hljs-number">4096</span>, <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>生成器的send方法</strong></p><p>生成器的send方法调用时相当于对生成器调用了一次next函数。</p><p>但是send方法比next函数更高级，它可以传入一个参数，作为上一次<code>yield表达式的左值</code>。</p><ol><li>send()方法的传入值由生成器外部逻辑决定，可以将上一次生成器的yield返回值作为参考。</li><li>生成器内部下一次yield的返回值，可以根据send方法传入的参数决定。</li></ol><blockquote><p>但注意的时，如果一个生成器刚刚启动（没有返回第一个值），调用send方法时必须传入None。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_generator</span>(<span class="hljs-params">init_val</span>):</span><br>    sended = init_val<br>    <span class="hljs-keyword">while</span> sended:<br>        ret = sended<br>        sended = <span class="hljs-keyword">yield</span> ret<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <br>    g = my_generator(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment"># 调用生成器函数时传入一个参数，作为第一个yield表达式的值。</span><br>    print(g.send(<span class="hljs-literal">None</span>)) <span class="hljs-comment"># 生成器刚刚启动，返回第一个值时必须传入None。</span><br>    print(g.send(<span class="hljs-string">&#x27;world&#x27;</span>))<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>world<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_generator</span>(<span class="hljs-params">dic</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> dic[<span class="hljs-string">&#x27;end&#x27;</span>]:<br>        dic = <span class="hljs-keyword">yield</span> dic[<span class="hljs-string">&#x27;val&#x27;</span>]<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    g = my_generator(&#123;<span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;val&#x27;</span>: <span class="hljs-string">&#x27;hello&#x27;</span>&#125;)<br>    print(g.send(<span class="hljs-literal">None</span>))<br>    print(g.send(&#123;<span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-literal">False</span>, <span class="hljs-string">&#x27;val&#x27;</span>: <span class="hljs-string">&#x27;world&#x27;</span>&#125;))<br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式时一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><p>正则表达式的设计思想时用一种描述性的语言来给字符串定义一个规则。</p><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><p><strong>一、特殊元字符</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td><code>\</code></td><td>转义字符</td></tr><tr><td><code>.</code></td><td>匹配任意一个字符，除了 \n</td></tr><tr><td><code>[]</code></td><td>匹配[]中列举的字符</td></tr><tr><td><code>[0-9]</code></td><td>数字</td></tr><tr><td><code>[a-z]</code></td><td>小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>大写字母</td></tr><tr><td><code>\d</code></td><td>匹配数字，即[0-9]</td></tr><tr><td><code>\D</code></td><td>匹配非数字</td></tr><tr><td><code>\s</code></td><td>匹配空白，即空格、制表符、换页符</td></tr><tr><td><code>\S</code></td><td>匹配非空白</td></tr><tr><td><code>\w</code></td><td>匹配单词字符，即数字、字母、下划线</td></tr><tr><td><code>\W</code></td><td>匹配非单词字符</td></tr><tr><td><code>\.</code></td><td>匹配<code>.</code></td></tr><tr><td><code>\*</code></td><td>匹配<code>*</code></td></tr><tr><td><code>\+</code></td><td>匹配<code>+</code></td></tr><tr><td><code>\?</code></td><td>匹配<code>?</code></td></tr><tr><td><code>\b</code></td><td>匹配单词边界</td></tr></tbody></table><p><strong>二、量词元字符</strong></p><table><thead><tr><th>数词</th><th>功能</th></tr></thead><tbody><tr><td><code>* </code></td><td>匹配前一个字符串出现0次或n次，即可有可无</td></tr><tr><td><code>+ </code></td><td>匹配前一个字符串出现1次或n次，即至少有1次</td></tr><tr><td><code>?</code></td><td>匹配前一个字符串出现1次或0次，即是否出现在该位置未知</td></tr><tr><td><code>&#123;m&#125;</code></td><td>匹配前一个字符出现m次</td></tr><tr><td><code>&#123;m,n&#125;</code></td><td>匹配前一个字符出现m到n次，包括n次</td></tr><tr><td><code>&#123;m,&#125;</code></td><td>匹配前一个字符出现m到多次</td></tr></tbody></table><blockquote><p><code>?</code> 相当于{0,1}</p><p><code>+</code> 相当于{1,}</p><p><code>*</code> 相当于{0,}</p></blockquote><p><strong>三、匹配开头和结尾</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td><code>^ </code></td><td>匹配字符串开头</td></tr><tr><td><code>$</code></td><td>匹配字符串结尾</td></tr></tbody></table><blockquote><p>在中括号<code>[]</code>中，如果出现<code>^</code>，<code>^</code>修饰的后面字符作为排除字符。</p><p>注意：在中括号内部，需要排除的字符要写在可匹配字符的前面。</p></blockquote><p><strong>四、匹配分组</strong></p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>`</td><td>`</td></tr><tr><td><code>() </code></td><td>将括号中的规则作为一个分组, 例如：`r’@(126</td></tr><tr><td><code>\分组号</code></td><td>使用指定的分组.当规则被重复使用时，可将其放在小括号内作为分组，再匹配时，用<code>\分组号</code>匹配该分组。例如<code>r&#39;&lt;(div)&gt;.*&lt;/\1&gt;&#39;</code>可匹配一个div标签（<code>div</code>是由<code>()</code>括起来的第一个分组）。<br><code>r&#39;&lt;(div)&gt;&lt;(span)&gt;&lt;/\2&gt;&lt;(/\1)&gt;&#39;</code>可匹配<code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></td></tr><tr><td><code>(?P&lt;name&gt;)    </code></td><td>给分组起别名</td></tr><tr><td><code>(?P=name)</code></td><td>引用别名为name的分组</td></tr></tbody></table><p>分组别名的使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment">#           定义分组别名使用分组别名</span><br><span class="hljs-comment">#    👇👇</span><br>pattern = <span class="hljs-string">r&#x27;&lt;(?P&lt;d&gt;div)&gt;&lt;(?P&lt;s&gt;span)&gt;hello world&lt;/(?P=s)&gt;&lt;/(?P=d)&gt;&#x27;</span><br>target = <span class="hljs-string">&#x27;&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;&#x27;</span><br><br>result = re.match(pattern, target)<br><br>print(result.group()) &gt;&gt;&gt; &lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;<br><br><span class="hljs-comment"># 使用分组号</span><br>print(result.group(<span class="hljs-number">1</span>)) &gt;&gt;&gt; div<br>print(result.group(<span class="hljs-number">2</span>)) &gt;&gt;&gt; span<br><br><span class="hljs-comment"># 使用分别名</span><br>print(result.group(<span class="hljs-string">&#x27;d&#x27;</span>)) &gt;&gt;&gt; div<br>print(result.group(<span class="hljs-string">&#x27;s&#x27;</span>)) &gt;&gt;&gt; span<br></code></pre></td></tr></table></figure><p>启发：打印分组信息的作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pattern = <span class="hljs-string">r&#x27;.*@(126|163|qq)\.com&#x27;</span><br>target = <span class="hljs-string">&#x27;mzLeman@126.com&#x27;</span><br>result = re.match(pattern, target)<br>print(<span class="hljs-string">&#x27;邮箱代号：%s&#x27;</span> % result.group(<span class="hljs-number">1</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>邮箱代号：<span class="hljs-number">126</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配</title>
    <link href="/2021/01/23/CSS/mobile_adapt/"/>
    <url>/2021/01/23/CSS/mobile_adapt/</url>
    
    <content type="html"><![CDATA[<h1 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h1><h2 id="设备屏幕相关概念"><a href="#设备屏幕相关概念" class="headerlink" title="设备屏幕相关概念"></a>设备屏幕相关概念</h2><h3 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h3><p>对角线的物理长度，单位英寸，1英寸等于2.54厘米。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕的像素点数</p><ul><li>高清：1920 * 1080</li><li>4K：也叫QHD或UHD（超高清），最小分辨率为3840 * 2160</li></ul><p>iphone6/7/8 分辨率为 1334 * 750，iphone6+/7+/8+的分辨率为1920 * 1080。</p><blockquote><p>我们在书写设备分辨率参数时，往往较大数字写在前面。对于PC来说，横向较长，所以第一个参数指代的时宽度。而对于手机和平板而言，纵向较长，所以第二个参数才指代的是宽度。</p></blockquote><h3 id="DPI-PPI"><a href="#DPI-PPI" class="headerlink" title="DPI/PPI"></a>DPI/PPI</h3><p>Dots Per Inch / Pixels Per Inch，即屏幕上每英寸的像素数量，也就是像素密度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">DPI</span><span class="hljs-operator">/</span><span class="hljs-variable">PPI</span> <span class="hljs-operator">=</span> 屏幕对角线分辨率 <span class="hljs-operator">/</span> 屏幕尺寸<br></code></pre></td></tr></table></figure><h3 id="物理像素与逻辑像素"><a href="#物理像素与逻辑像素" class="headerlink" title="物理像素与逻辑像素"></a>物理像素与逻辑像素</h3><ol><li>物理像素指的是屏幕设备的一个物理发光单元，每个发光点是由红绿蓝进行组合从而可以显示不同的颜色。</li><li>在前端开发中，逻辑像素就是CSS像素。<code>一个逻辑像素可能对应多个物理像素</code>。</li></ol><blockquote><p>我们常说的分辨率就是设备在长和宽方向物理像素的个数。</p></blockquote><h3 id="设备独立像素-DIP"><a href="#设备独立像素-DIP" class="headerlink" title="设备独立像素 DIP"></a>设备独立像素 DIP</h3><p>设备独立像素（DIP，device-independent pixel），即<code>独立于设备的逻辑上衡量像素的单位</code>，<code>是对逻辑像素更加官方的、概念化的描述</code>。在<code>移动Web开发中</code>，就是指的是<code>CSS的逻辑像素</code>。</p><h3 id="设备像素比-DPR-⭐"><a href="#设备像素比-DPR-⭐" class="headerlink" title="设备像素比 DPR ⭐"></a>设备像素比 DPR ⭐</h3><p>设备像素比（Device Pixel Ratio）是默认<code>缩放为100%情况下</code>，<code>物理像素与逻辑像素的比值</code>。</p><blockquote><p>在移动端，手机和平板很少调节分辨率，即调节逻辑像素的大小。所以DPR就比较固定，就有了两倍屏、三倍屏的说法。</p></blockquote><hr><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>视口可以理解为设备或文档对象的逻辑尺寸。</p><p>前端ppk大神认为，移动设备上有三个viewport（视口）。</p><p>但可以换句话说，可以缩放的浏览器中都具有三个视口概念，分别是 布局视口、视觉视口、理想视口。</p><h3 id="1-布局视口-layout-viewport"><a href="#1-布局视口-layout-viewport" class="headerlink" title="1. 布局视口 layout viewport"></a>1. 布局视口 layout viewport</h3><p>布局视口可以理解为文档对象的逻辑尺寸，单位为逻辑像素（CSS像素）。</p><p><code>在PC端上，布局视口宽度默认等于浏览器窗口的宽度。</code>而在移动端上，由于要使为PC端浏览器设计的网站能够完全显示在移动端的小屏幕里，此时的布局视口会远大于移动设备的屏幕，就会出现滚动条。</p><p>由于历史原因，一些<code>移动设备的浏览器</code>具有<code>默认的布局视口宽度</code>（单位CSS像素）：</p><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229180124466.png" alt="image-20201229180124466"> </p><p>获取布局视口的DOM API：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.documentElement.clientWidth)</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229170641389.png" alt="image-20201229170641389"> </p><h3 id="2-理想视口-ideal-viewport"><a href="#2-理想视口-ideal-viewport" class="headerlink" title="2. 理想视口 ideal viewport"></a>2. 理想视口 ideal viewport</h3><p>理想视口是与设备相关的，是布局视口的一个理想尺寸，只有当布局视口的尺寸等于设备屏幕的尺寸时（<code>逻辑尺寸，即有多少个逻辑像素</code>），才是理想视口，此时文档对象宽度与屏幕宽度相同。</p><p>移动设备一般具有固定的DPR，即在缩放100%时，用多少个物理像素显示一个逻辑像素，在Web开发中就是用多少个物理像素去显示一个CSS像素。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">理想视口宽度 <span class="hljs-operator">=</span> 移动设备横向分辨率 <span class="hljs-operator">/</span> <span class="hljs-variable">DPR</span><br></code></pre></td></tr></table></figure><p> 获取理想视口的DOM API：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.screen.width);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229170613912.png" alt="image-20201229170613912"> </p><h3 id="3-视觉视口-visual-viewport"><a href="#3-视觉视口-visual-viewport" class="headerlink" title="3. 视觉视口 visual viewport"></a>3. 视觉视口 visual viewport</h3><p>用户正在看到的网页的区域。用户可以通过缩放来查看网站的内容。如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。<code>不管用户如何缩放，都不会影响到布局视口的宽度。</code></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">视觉视口的宽度 <span class="hljs-operator">=</span> 理想视口宽度 <span class="hljs-operator">/</span> 缩放比例<br></code></pre></td></tr></table></figure><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229172033985.png" alt="image-20201229172033985"> </p><hr><h2 id="利用meta标签控制视口"><a href="#利用meta标签控制视口" class="headerlink" title="利用meta标签控制视口"></a>利用meta标签控制视口</h2><p>移动设备的默认布局视口往往大于理想视口，此时就会在横向出现滚动条才能完整的容纳页面。<code>我们需要的是将页面的布局视口设置为理想视口</code>，这就改轮到meta标签出场了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>该meta标签的作用是让layout viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让layout viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的布局视口默认值，也就是说会出现横向滚动条。</p><p>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。</p><p><font color="red">meta viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的。</font></p><p>在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：</p><table><thead><tr><th>属性名</th><th>取值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>正整数或device-width</td><td>定义视口的宽度，单位为像素</td></tr><tr><td>height</td><td>正整数或device-height</td><td>定义视口的高度，单位为像素，一般不用</td></tr><tr><td>initial-scale</td><td>[0.0-10.0]</td><td>定义初始缩放值</td></tr><tr><td>minimum-scale</td><td>[0.0-10.0]</td><td>定义放大最大比例，它必须小于或等于maximum-scale设置</td></tr><tr><td>maximum-scale</td><td>[0.0-10.0]</td><td>定义缩小最小比例，它必须大于或等于minimum-scale设置</td></tr><tr><td>user-scalable</td><td>yes / no</td><td>定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><p>这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。</p><hr><h3 id="width属性"><a href="#width属性" class="headerlink" title="width属性"></a>width属性</h3><p>width属性用于设置页面的布局视口宽度，属性值不带单位，默认单位为像素。</p><p>其<code>默认值</code>在不同浏览器中不同，但<code>大多数为980</code>。</p><p><img src="/2021/01/23/CSS/mobile_adapt/image-20201229180124466.png" alt="image-20201229180124466"> </p><p>但需要注意的是（以下结论都基于Chrome的测试工具）：</p><ol><li><p><code>当只设置width属性值，而不指定initial-scale属性值时，大多数浏览器会自动缩放。</code></p><p>如果width属性值大于理想视口宽度，则视觉视口放大为width的值，计算得到scale小于1.0；</p><p>如果width属性值小于理想视口宽度，则视觉视口缩小为width的值，计算得到scale大于1.0；</p><p>这么做的目的是让设备屏幕把完整的页面呈现出来（页面横向塞满屏幕，计算得到scale），此时：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">布局视口宽度 <span class="hljs-operator">=</span> 视觉视口宽度 <span class="hljs-operator">=</span>  理想视口宽度 <span class="hljs-operator">/</span> 缩放比例<br></code></pre></td></tr></table></figure><blockquote><p>设置width而不指定initial-scale时， 设置minimum-scale = 1.0会能够阻止浏览器放大视觉视口，设置maximum-scale = 1.0 能够阻止浏览器缩小视觉视口。（这里有点绕，可以联想下放大镜）</p></blockquote></li><li><p>将width属性值设置为<code>device-width</code>时，大多数浏览器都能把页面的布局视口宽度变为当前设备的理想视口宽度。</p><blockquote><p>但在iphone和ipad上，无论是竖屏还是横屏，<code>device-width</code>宽度都是竖屏时理想视口的宽度。</p></blockquote></li></ol><hr><h3 id="initial-scale属性"><a href="#initial-scale属性" class="headerlink" title="initial-scale属性"></a>initial-scale属性</h3><p>initial-scale属性用于设置页面初始的缩放比例，缩放比例为<code>理想视口</code>与<code>视觉视口</code>的比值。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">即：<span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> <span class="hljs-variable">idealViewport</span> <span class="hljs-operator">/</span> <span class="hljs-variable">visualViewport</span><br></code></pre></td></tr></table></figure><p><strong>但需要注意的是（以下结论都基于Chrome的测试工具）：</strong></p><ol><li>当只指定<code>initial-scale属性</code>，而不设置<code>width属性</code>时，浏览器会将<code>布局视口宽度</code>设置为视觉视口宽度，以将页面正好铺满屏幕。<strong>可以认为这是一条定律。</strong> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathmetic">布局视口宽度 &#x3D; 设备理想视口宽度 &#x2F; initial-scale<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>当指定<code>initial-scale = 1</code>，而<code>不设置width属性</code>时，大部分浏览器会将<code>布局视口宽度</code>设置为<code>设备理想视口宽度</code>。<strong>这是由推导得来的。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathmatic">因为 initial-scale &#x3D; 1<br>所以 视觉视口 &#x3D; 理想视口 ÷ 1.0 &#x3D; 理想视口<br>又因为 没有设置width<br>所以 视觉视口 &#x3D; 布局视口<br>所以 视觉视口 &#x3D; 布局视口 &#x3D; 理想视口<br></code></pre></td></tr></table></figure><blockquote><p>但是WP7系统的IE浏览器中使用横屏时，当指定initial-scale = 1，而不指定width属性时，理应的结果应该是视觉视口等于理想视口时，但偏偏此时的布局视口宽度是竖屏时的理想视口宽度。</p></blockquote></li></ol><ol start="3"><li><p>❗ 当设置<code>initial-scale=1 </code>且同时<code>设置width属性</code>时，如果由<code>理想视口除以init-scale计算得到的视觉视</code>大于<code>width</code>，则<code>width会被浏览器重置为视觉视口</code>。（如果计算得到的视觉视口小于布局视口，就不会出现问题，只是会出现滚动条）原因是 👇</p><pre><code>&gt; 如果视觉视口大于布局视口，就存在逻辑上的问题。</code></pre><blockquote><p>比如说，我iphone8设备理想视口为375px，页面init-scale设置为0.75，那么视觉视口等于375/0.75 = 500px，若width设置为375或device-width，也就是出现了视觉视口大于布局视口的情况。</p><p>那浏览器就纳闷了，你要让我显示500px范围宽的页面，但你告诉我页面实际上只有375px宽，不是奇了怪了吗？所以当视觉视口大于布局视口时，布局视口宽度width会被重置成视觉视口宽度，这应该是浏览器的策略，用于避免显示上的逻辑问题。</p></blockquote></li></ol><hr><h3 id="width-device-width-initial-scale-1"><a href="#width-device-width-initial-scale-1" class="headerlink" title="width=device-width, initial-scale=1"></a>width=device-width, initial-scale=1</h3><p><strong>目的</strong>：</p><p>让我们写的页面在水平方向上恰好与各个设备的屏幕严丝合缝，需要将页面布局视口设置为设备理想视口。</p><p><strong>但是</strong>：</p><ul><li>只设置<code>width = device-width</code> 苹果移动设备横屏时会有bug</li><li>只设置<code>init-scale = 1</code> WP7系统IE浏览器横屏会有bug</li></ul><p><strong>终极方案</strong>：</p><p>将<code>meta:vp标签</code>的属性值设置为<code>width=device-width, initial-scale=1</code>就不仅能够将页面的布局视口自动设置为各个移动设备的理想视口，还能够同时兼容iphone、ipad的Safari以及WP7 IE浏览器的横屏问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="移动端屏幕宽度适配方案"><a href="#移动端屏幕宽度适配方案" class="headerlink" title="移动端屏幕宽度适配方案"></a>移动端屏幕宽度适配方案</h2><h3 id="1-固定大小-px"><a href="#1-固定大小-px" class="headerlink" title="1. 固定大小 px"></a>1. 固定大小 px</h3><ul><li><p>按照最小的屏幕宽度进行布局，让主题内容居中，这样做能保证排版不会发生错误。</p><blockquote><p>大屏幕时两边会存在留白。</p></blockquote></li><li><p>配合媒体查询，在大屏幕时进行布局修改，适当减小两边留白。</p></li></ul><h3 id="2-百分比"><a href="#2-百分比" class="headerlink" title="2. 百分比"></a>2. 百分比</h3><ul><li>高度固定</li><li>border-box</li></ul><h3 id="3-rem"><a href="#3-rem" class="headerlink" title="3. rem"></a>3. rem</h3><p>根据设备屏幕的理想视口动态控制rem大小。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* phone.js */</span><br><span class="hljs-comment">/* 在设计稿上是n像素，在写css时就是0.01n rem */</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, win</span>) </span>&#123; <br>   <span class="hljs-keyword">let</span> rem;<br>   <span class="hljs-keyword">let</span> designWidth = <span class="hljs-number">750</span>;  <span class="hljs-comment">// 根据设计稿进行设置</span><br>   <span class="hljs-keyword">let</span> ratio = <span class="hljs-number">100</span>; <span class="hljs-comment">// ratio为人为放大的比例，防止rem小于浏览器限制的最小尺寸，同时要使计算方便。</span><br>   <span class="hljs-keyword">const</span> html = doc.documentElement,<br>         resizeEvt = <span class="hljs-string">&#x27;orientationchange&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>? <span class="hljs-string">&#x27;orientationchange&#x27;</span> : <span class="hljs-string">&#x27;resize&#x27;</span>;<br>    <br>   win.addEventListener(resizeEvt, cb, <span class="hljs-literal">false</span>);<br>   doc.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, cb, <span class="hljs-literal">false</span>);<br>   <br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span> (<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">const</span> _deviceWidth = html.clientWidth; <span class="hljs-comment">// 获取布局视口大小,meta标签设置的device-width</span><br>     <span class="hljs-keyword">if</span>( !_deviceWidth ) <span class="hljs-keyword">return</span>;<br>     <span class="hljs-keyword">if</span>( _deviceWidth &gt;= <span class="hljs-number">750</span> ) &#123;  <span class="hljs-comment">// device-width&gt;=750，平板或者桌面</span><br>         rem = <span class="hljs-string">&#x27;100px&#x27;</span>; <span class="hljs-comment">// 平板或者桌面rem设置为100px;</span><br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         rem = ratio * _deviceWidth  / designWidth + <span class="hljs-string">&#x27;px&#x27;</span>;<br>     &#125;<br>     html.style.fontSize = rem;<br>   &#125;<br>    <br>&#125;)(<span class="hljs-built_in">document</span>, <span class="hljs-built_in">window</span>);<br><br></code></pre></td></tr></table></figure><h3 id="4-vw适配"><a href="#4-vw适配" class="headerlink" title="4. vw适配"></a>4. vw适配</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/*</span><br><span class="hljs-comment">计算公式 rem = ratio * 100 / designWidth</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15.625vw</span>; <span class="hljs-comment">/* 设计稿为640， 放大100倍*/</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">13.333333vw</span>; <span class="hljs-comment">/* 设计稿为750， 放大100倍 */</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">9.259259vw</span>; <span class="hljs-comment">/* 设计稿为1080，放大100倍*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动端盒子布局常用方法"><a href="#移动端盒子布局常用方法" class="headerlink" title="移动端盒子布局常用方法"></a>移动端盒子布局常用方法</h2><h3 id="1-弹性盒子"><a href="#1-弹性盒子" class="headerlink" title="1. 弹性盒子"></a>1. 弹性盒子</h3><h3 id="2-百分比-1"><a href="#2-百分比-1" class="headerlink" title="2. 百分比"></a>2. 百分比</h3><h3 id="3-尺寸大小单位用rem"><a href="#3-尺寸大小单位用rem" class="headerlink" title="3. 尺寸大小单位用rem"></a>3. 尺寸大小单位用rem</h3>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS中client-offset-scroll等属性的区别</title>
    <link href="/2021/01/06/CSS/client-offset-scroll/"/>
    <url>/2021/01/06/CSS/client-offset-scroll/</url>
    
    <content type="html"><![CDATA[<h1 id="client-offset-scroll等属性的区别"><a href="#client-offset-scroll等属性的区别" class="headerlink" title="client-offset-scroll等属性的区别"></a>client-offset-scroll等属性的区别</h1><h2 id="需要记的边角料小结论"><a href="#需要记的边角料小结论" class="headerlink" title="需要记的边角料小结论"></a>需要记的边角料小结论</h2><p><strong>以下内容都基于将自己写的小Demo在浏览器内进行测试后得到的结论：</strong></p><ul><li><p>⭐ 接下来要讨论的client、offset、scroll前缀的属性，其属性值都不带单位，默认单位为css像素。</p></li><li><p>PC端，如果页面中某个元素出现滚动条，滚动条的宽度默认是由各个浏览器决定的。Chrome中是17px。</p></li><li><p>不确定❓ 移动端，滚动条好像不占宽度 ❓</p></li><li><p>对于开启了绝对定位的元素，left和right属性都为auto时，left值可以认为等于包含块的padding-left。top同理</p></li></ul><h2 id="client前缀的四个属性"><a href="#client前缀的四个属性" class="headerlink" title="client前缀的四个属性"></a>client前缀的四个属性</h2><h3 id="clientWidth和clientHeight"><a href="#clientWidth和clientHeight" class="headerlink" title="clientWidth和clientHeight"></a>clientWidth和clientHeight</h3><p>这两个属性是所有DOM元素的自有属性，包括html标签<code>(document.documentElement对象)</code>。</p><p>简单来说，这两个属性表示DOM元素的<code>可视区域的横向尺寸和纵向尺寸</code>。</p><p><strong>对一般DOM元素而言：</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">可视区域长度 <span class="hljs-operator">=</span> 左右<span class="hljs-variable">padding</span> <span class="hljs-operator">+</span> 内容区宽度 <span class="hljs-operator">-</span> 纵向滚动条宽度<span class="hljs-punctuation">(</span>若存在滚动条，<span class="hljs-variable">Chrome</span>默认<span class="hljs-number">17</span><span class="hljs-variable">px</span>。否则为<span class="hljs-number">0</span><span class="hljs-variable">px</span><span class="hljs-punctuation">)</span><br><br>可视区域高度 <span class="hljs-operator">=</span> 上下<span class="hljs-variable">padding</span> <span class="hljs-operator">+</span> 内容区高度 <span class="hljs-operator">-</span> 横向滚动条宽度<span class="hljs-punctuation">(</span>若存在滚动条，<span class="hljs-variable">Chrome</span>默认<span class="hljs-number">17</span><span class="hljs-variable">px</span>。否则为<span class="hljs-number">0</span><span class="hljs-variable">px</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="html的clientWidth和clientHeight"><a href="#html的clientWidth和clientHeight" class="headerlink" title="html的clientWidth和clientHeight"></a>html的clientWidth和clientHeight</h3><p><strong>对于html标签而言，<code>可视区域的定义比较特殊</code>：</strong></p><p>❗  <code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeght</code>是整个DOM参考的最外层盒子尺寸，即为html元素设置尺寸的值为一个百分比时，参考的是自己的clientWidth和clientHeight属性。</p><p><em>一般来说也不会为html元素设置border、margin、padding，所以可以认为html宽度为父容器的百分之百，即默认情况下 html.width  = clientWidth。</em></p><ul><li>⭐移动端</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span> <span class="hljs-operator">=</span> 布局视口宽度<br><br><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientHeight</span> <span class="hljs-operator">=</span> 布局视口高度 <br></code></pre></td></tr></table></figure><blockquote><p>布局视口高度可以在meta viewport标签中通过height属性设置。如果只指定viewport的width和init-scale分别为一个数字，而不指定height，则 布局视口高度 = 布局视口宽度 × 设备屏幕纵横比例</p></blockquote><ul><li>⭐PC端</li></ul><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">可视区域宽度 <span class="hljs-operator">=</span> 浏览器窗口中页面区域宽度（浏览器视口） <span class="hljs-operator">-</span> <span class="hljs-variable">html</span>自己的纵向滚动条宽度<br><br>可视区域高度 <span class="hljs-operator">=</span> 浏览器窗口中页面区域高度（浏览器视口） <span class="hljs-operator">-</span> <span class="hljs-variable">html</span>自己的横向滚动条高度<br></code></pre></td></tr></table></figure><p><em>只有当html的scrollHeight和scrollWidth大于浏览器视口（html.clientHeight、html.clientWidth）才会出现属于html元素的滚动条</em></p><blockquote><p>注意：是浏览器显示页面区域，而非整个屏幕，因为浏览器一般都会有菜单、选项卡、地址栏等区域。</p><p>❓由于选项卡、地址栏之类浏览器控件的存在，所以在<strong>移动端</strong> document.ducomentElement.clientHeight只代表布局视口高度，不能代表浏览器窗口中网页页面区域的高度。</p></blockquote><ol><li><p>对于body标签而言：</p><p>body标签也属于一般的块级DOM元素，其可视区域为padding+content，只不过他的父元素为html标签对象。</p><p>body标签默认宽度为html的100%, 高度由内容撑开。</p></li></ol><h3 id="clientLeft和clientTop"><a href="#clientLeft和clientTop" class="headerlink" title="clientLeft和clientTop"></a>clientLeft和clientTop</h3><p>这两个属性是所由DOM元素的自有属性，其属性值分别等于DOM元素的左边框宽度和上边框宽度（不带单位px）。</p><h2 id="offset前缀的五个属性"><a href="#offset前缀的五个属性" class="headerlink" title="offset前缀的五个属性"></a>offset前缀的五个属性</h2><h3 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h3><ol><li><p>除html、body以外的元素：</p><p>offsetParent指向第一个开启定位的祖先元素，如果没有开启定位的祖先元素，则包含块为body元素</p></li><li><p>html、body元素的offsetParent属性值为null</p></li><li><p>开启固定定位的元素的offsetParent属性值为null</p></li></ol><blockquote><p>❗ offsetParent不同于之前学的包含块的概念。</p><p>其实可以认为开启固定定位的offsetParent是浏览器视口，因为开启固定定位的元素的offsetLeft和offsetTop是基于浏览器视口计算偏移量的。</p></blockquote><h3 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a>offsetWidth和offsetHeight</h3><p><code>offsetWidth</code>和<code>offsetHeight</code>分别表示<strong>DOM元素的盒模型横向、纵向尺寸</strong>。</p><p>对于所有DOM元素（包括html、body），offsetWidth和offsetHeight属性值计算方法如下：</p><p>offsetWidth = 左右boder + 左右padding + contentWidth</p><p>offsetHeight = 上下boder + 上下padding + contentHeight</p><h3 id="html的offsetWidth和offsetHeight"><a href="#html的offsetWidth和offsetHeight" class="headerlink" title="html的offsetWidth和offsetHeight"></a>html的offsetWidth和offsetHeight</h3><blockquote><p>最特殊的盒子一定是html，因为他是最外面的盒子。那么html的盒模型尺寸怎么算 ❓</p></blockquote><p>⭐ <strong>html盒模型的计算方法：</strong></p><p><font color="red">前提：html没有设置margin、border、padding，一般也不会设置</font></p><ul><li><p>宽度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetWidth</span> <span class="hljs-operator">=</span> <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">width</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 设置为 <span class="hljs-variable">n</span> <span class="hljs-variable">px</span>时，其内容区宽度就为<span class="hljs-variable">n</span> <span class="hljs-variable">px</span>。<br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 设置为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> 时，其内容区宽度为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> × <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">width</span> 默认为 <span class="hljs-variable">auto</span> 时，<span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetWidth</span> <span class="hljs-operator">=</span> <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientWidth</span><br></code></pre></td></tr></table></figure></li><li><p>高度</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">offsetHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">height</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 设置为 <span class="hljs-variable">n</span> <span class="hljs-variable">px</span>时，其内容区高度就为<span class="hljs-variable">n</span> <span class="hljs-variable">px</span>。<br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 设置为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> 时，其内容区高度为 <span class="hljs-variable">n</span><span class="hljs-operator">%</span> × <span class="hljs-variable">html</span><span class="hljs-operator">.</span><span class="hljs-variable">clientHeight</span><br>当为 <span class="hljs-variable">html</span> 的 <span class="hljs-variable">height</span> 默认为 <span class="hljs-variable">auto</span> 时，其内容区高度为由<span class="hljs-variable">body</span>撑开。<br></code></pre></td></tr></table></figure></li></ul><h3 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h3><p>offsetLeft和offsetTop属性表示DOM元素相对于offsetParent可视区域左边界、上边界的偏移量，不带单位px。</p><p>简单来说，offsetParent可视区域的左边界、上边界就是offsetParent内边距的外侧。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 举例1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    *&#123;<br>        padding: 0;<br>        margin: 0;<br>    &#125;<br>    body &#123;<br>        padding-left: 10px;<br>        padding-top: 10px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.box</span> &#123;</span><br>        width: 200px;<br>        height: 200px;<br><span class="css">        <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000</span>;</span><br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.content</span> &#123;</span><br>        width: 100px;<br>        height: 100px;<br>        margin-left: 50px;<br>        margin-top: 50px;<br>        background-color: pink<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- ⭐此时div.content的offsetLeft和offsetTop为61 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210105202533732.png" alt="image-20210105202533732"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 举例2 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    *&#123;<br>        padding: 0;<br>        margin: 0;<br>    &#125;<br>    body &#123;<br>        padding-left: 10px;<br>        padding-top: 10px;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.box</span> &#123;</span><br>        position: relative;<br>        width: 200px;<br>        height: 200px;<br><span class="css">        <span class="hljs-selector-tag">border</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000</span>;</span><br>        padding: 10px;<br>        background-color: grey;<br>        background-clip: content-box;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.content</span> &#123;</span><br>        position: absolute;<br><span class="css">        <span class="hljs-selector-tag">left</span><span class="hljs-selector-pseudo">:50px</span>;</span><br>        width: 100px;<br>        height: 100px;<br>        margin-left: 50px;<br>        margin-top: 50px;<br>        background-color: pink<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br>        <span class="hljs-comment">&lt;!-- ⭐此时div.content的offsetLeft和offsetTop为100 </span><br><span class="hljs-comment">等于left + margin-left，因为绝对定位定位原点是div.box的padding左上角</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210105202429426.png" alt="image-20210105202429426"> </p><blockquote><p>html、body元素的offsetLeft和offsetTop值在不同浏览器中计算方法不同。（火狐和Chrome就不相同）</p></blockquote><blockquote><p>❗ 注意：当为body、html设置了padding、border等情况时，offsetParent为body的元素的offsetLeft和offsetTop值会和意想的不一样，所以尽量不要为body和html设置padding和margin还有border。</p></blockquote><h2 id="scroll前缀的四个属性"><a href="#scroll前缀的四个属性" class="headerlink" title="scroll前缀的四个属性"></a>scroll前缀的四个属性</h2><p>scrollWidth和scrollHeight这两个属性用来获取指定元素<code>内容层的真实宽度和高度</code>。</p><blockquote><p>“内容层”不是内容区，是一个抽象概念。</p></blockquote><h3 id="scrollHeight和scrollHeight"><a href="#scrollHeight和scrollHeight" class="headerlink" title="scrollHeight和scrollHeight"></a>scrollHeight和scrollHeight</h3><p><strong>MDN官方解释</strong>：</p><p>The <strong><code>Element.scrollHeight</code></strong> read-only property is a measurement of the height of an element’s content, including content not visible on the screen due to overflow.</p><p>翻译：Element.scrollHeight 这个只读属性是一个元素内容高度的度量，包括由于溢出导致的不可见内容。</p><p>The <strong><code>Element.scrollWidth</code></strong> read-only property is a measurement of the width of an element’s content, including content not visible on the screen due to overflow.</p><p>翻译：Element.scrollHeight 这个只读属性是一个元素内容宽度的度量，包括由于溢出导致的不可见内容。</p><p><strong>以scrollHeight为例：</strong></p><ol><li><p><strong><code>scrollHeight </code>的值等于该元素在不使用滚动条的情况下为了适应视口中所有内容所需的最小高度（包括padding，不包括border、margin和滚动条）。</strong> </p></li><li><p><strong>没有垂直滚动条的情况下（没有设置height或没有溢出的情况发生），scrollHeight值与元素视图填充所有内容所需要的最小值<code>clientHeight</code>相同。包括元素的padding，但不包括元素的border、margin、scrollHeight和滚动条，也包括 <code>::before</code>和 <code>::after</code>这样的伪元素。</strong></p></li></ol><p><strong>scrollHeight的计算方法：</strong></p><ol><li>Chrome中：</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">隐藏的高度 <span class="hljs-operator">=</span> 可见的后代元素在布局之后溢出该元素内容区的最大高度<br><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">top</span> <span class="hljs-operator">+</span> <span class="hljs-variable">contentHeight</span> <span class="hljs-operator">+</span> 隐藏内容的高度 <span class="hljs-operator">+</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">bottom</span><br></code></pre></td></tr></table></figure><ol start="2"><li>火狐、Edge：</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">=</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">top</span> <span class="hljs-operator">+</span> <span class="hljs-variable">contentHeight</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">Max</span><span class="hljs-punctuation">(</span>隐藏内容的高度<span class="hljs-operator">,</span> <span class="hljs-variable">padding</span><span class="hljs-operator">-</span><span class="hljs-variable">bottom</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><blockquote><p>感觉Chrome更为合理。</p><p>火狐和Edge在隐藏区域的高度小于padding-bottom时是无法滚动的。</p></blockquote><h3 id="scrollTop和scrollLeft"><a href="#scrollTop和scrollLeft" class="headerlink" title="scrollTop和scrollLeft"></a>scrollTop和scrollLeft</h3><p><code>scrollTop</code>：对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，即在出现了纵向滚动条的情况下，滚动条拉动的距离。</p><p><code>scrollLeft</code>：对象的最左边到对象在当前窗口显示的范围内的左边的距离，即在出现了横向滚动条的情况下，滚动条拉动的距离。</p><p><strong>以scrollTop为例：</strong></p><p>该值等于当前容器的内容区顶部那条线</p><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210106211636474.png" alt="image-20210106211636474"> </p><p>❗ <strong>最佳实践</strong>：判断一个容器box是否正好滚动到了某个后代元素盒模型顶部（border-top）</p><ol><li><p>容器box开启定位,，如 position: relative</p></li><li><p>后代元素child不存在其他的开启定位的中间祖先元素，其offsetParent指向box</p></li><li><p>box.scrollTop = child.offsetTop - box.padding-top ⭐⭐（因为offsetTop是相对于offsetParent的padding）</p><blockquote><p>注意，一些布局在容器相对靠下位置的后代元素是永远不会滑动到容器内容区顶部的。</p></blockquote></li></ol><p>❗  <strong>最佳实践：</strong>元素滑到底了：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">scrollHeight</span> <span class="hljs-operator">-</span> <span class="hljs-variable">scrollTop</span> <span class="hljs-operator">==</span> <span class="hljs-variable">clientHeight</span><br></code></pre></td></tr></table></figure><p>❗ <strong>最佳实践</strong>：对可能会发生纵向滚动的页面设置样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">overflow-y</span>: scroll; <span class="hljs-comment">/* 一开始就加上滚动条，防止滚动条的出现和消失影响body.width的计算值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>❗ <strong>最佳实践</strong>：不允许页面整体发生滚动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h2><p><img src="/2021/01/06/CSS/client-offset-scroll/image-20210106211714854.png" alt="image-20210106211714854"></p>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器内核</title>
    <link href="/2020/12/29/CSS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <url>/2020/12/29/CSS/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h1><h2 id="五大浏览器"><a href="#五大浏览器" class="headerlink" title="五大浏览器"></a>五大浏览器</h2><ul><li>IE (Internet Explorer)</li><li>火狐 (Firefox)</li><li>谷歌浏览器 (Chrome)</li><li>苹果浏览器 (Safari)</li><li>欧朋浏览器 (Opera)</li></ul><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h3 id="内核的组成"><a href="#内核的组成" class="headerlink" title="内核的组成"></a>内核的组成</h3><p>浏览器内核可以分成两部分:</p><ol><li>渲染引擎，其职责有：<ul><li>取得网页的内容（HTML、XML、图像等）</li><li>整理讯息（例如加入CSS等）</li><li>计算网页的显示方式</li></ul></li><li>JS引擎，其职责为：<ul><li>解析JavaScript语言，执行JavaScript脚本来实现网页的动态效果。</li></ul></li></ol><blockquote><p>最开始渲染引擎和JS引擎没有区分的很明确，后来JS引擎越来越独立，<code>内核就倾向于只指渲染引擎。</code></p></blockquote><h3 id="主流内核"><a href="#主流内核" class="headerlink" title="主流内核"></a>主流内核</h3><ol><li><p>Trident</p><p>代表作：IE</p></li><li><p>Gecko</p><p>代表作：火狐</p></li><li><p>Webkit</p><p>代表作：Safari + 旧版Chrome</p></li><li><p>Blink</p><p>代表作：Opera + 新版Chrome</p></li></ol><h3 id="国产浏览器内核"><a href="#国产浏览器内核" class="headerlink" title="国产浏览器内核"></a>国产浏览器内核</h3><ol><li><code>搜狗浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li><li><code>QQ浏览器</code>  Trident（兼容模式）+ Webkit(高速模式)</li><li><code>UC浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li><li><code>360浏览器</code> IE + Chrome双内核</li><li><code>百度浏览器</code> IE内核</li><li><code>猎豹浏览器</code> IE+Chrome双内核</li><li><code>世界之窗浏览器</code> IE内核</li><li><code>遨游浏览器</code> Trident（兼容模式）+ Webkit(高速模式)</li></ol><h3 id="手机操作系统自带浏览器的内核"><a href="#手机操作系统自带浏览器的内核" class="headerlink" title="手机操作系统自带浏览器的内核"></a>手机操作系统自带浏览器的内核</h3><ul><li><p>Android：使用率最高的是Webkit，即使大部分国产手机厂商宣称系统浏览器用的是自己的内核，但也属于Webkit二次开发。</p></li><li><p>IOS：一般是Safari的Webkit。</p></li><li><p>WP7：一般是IE的Trident。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js笔记</title>
    <link href="/2020/12/24/Vue/vue/"/>
    <url>/2020/12/24/Vue/vue/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p>Vue是一个渐进式JavaScript框架。</p><p>高级功能和特点：</p><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><p><strong>Vue.js的Hello world</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello world&quot;</span></span><br>        &#125; <br>        &#125;);<br><span class="handlebars"><span class="xml">        <span class="hljs-comment">&lt;!-- 新建一个Vue对象，在构造函数中传入options对象--&gt;</span></span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font size="4" color="red">Vue采用声明式编程，不同于jQuery以及原生JS操作DOM的命令式编程</font></p><p><img src="/2020/12/24/Vue/vue/image-20200811204642611.png" alt="image-20200811204642611"> </p><h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><img src="/2020/12/24/Vue/vue/image-20200811163236900.png" alt="image-20200811163236900"></p><h2 id="Options对象"><a href="#Options对象" class="headerlink" title="Options对象"></a>Options对象</h2><ul><li><p><strong>el：</strong></p><p>类型：string | HTMLElement</p><p>作用：决定Vue实例会管理哪一个DOM对象</p></li><li><p><strong>data：</strong></p><p>类型：Object | Function</p><p>作用：Vue实例对应的数据对象</p></li><li><p><strong>methods</strong>：</p><p>类型：｛key : Function｝</p><p>作用：定义属于Vue实例的一些方法，可以在其他地方调用，也可以在指令中使用。</p></li><li><p><strong>computed：</strong></p><p>计算属性</p><p>类型：{key : Function}</p><p>作用：定义一些计算属性值供使用。<font color="red">计算属性具有缓存机制，如果计算属性使用的数据没有被修改，则计算属性不会计算多次，当访问该计算属性时，直接从缓存中取值。</font></p><p>==由于缓存机制的存在，当页面中显示的内容只是需要对数据进行简单变换时，尽量使用计算属性，而不是使用函数计算==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>书籍购物车的总价格:&#123;&#123;totalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">el:<span class="hljs-string">&quot;h2&quot;</span>,</span><br>data:&#123;<br>books:[<br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;代码大全&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="javascript">&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;现代操作系统&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">50</span>&#125;</span><br>]<br>&#125;,<br>computed:&#123;<br><span class="javascript">totalPrice:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>    &#125;<br>            /*<br>            也可以使用ES6方法的简写<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">totalPrice</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>            &#125;<br>            */<br>&#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color='red'>computed中的计算属性底层的原理 可能 是使用了Proxy</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">comuputed:&#123;<br>    <span class="hljs-comment">//totalPrice:handler</span><br>    totalPrice:&#123;<br>        get&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br>                    pre+=cur.price;<br>                    <span class="hljs-keyword">return</span> pre;<br>                   &#125;,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//get:function()&#123;....&#125;</span><br>        <span class="hljs-comment">//还可以设置set方法</span><br>    &#125;<br>&#125;<span class="hljs-comment">//这种写法同样可以。</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p><strong>filters：</strong></p><p>类型：Function</p><p>作用：允许传入一个value，对该值进行过滤或附加处理，返回新的值。</p><p>使用： value | filterFunctionName </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;grade | assessment&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>data:&#123;<br>grade:&#x27;A&#x27;<br>&#125;<br>filters:&#123;<br>assessment(value)&#123;<br>if(value===&#x27;A&#x27;) return &#x27;优秀&#x27;;<br>else   return &#x27;其他&#x27;;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="/2020/12/24/Vue/vue/image-20200819182643832.png" alt="image-20200819182643832"> </p></li><li><p><strong>components</strong>：</p><p>类型：Object</p><p>作用：定义局部组件</p></li><li><p><strong>watch：</strong></p><p>类型：Object</p><p>作用：监听data中的数据以及props中的通信属性的变化。</p></li><li><p><strong>生命周期函数</strong>：</p><p>如：beforeCreate、created、Mounted、Destroyed…..</p></li></ul><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="/2020/12/24/Vue/vue/lifecycle.png"> </p><h2 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;,Mazheng<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--Mustache语法不仅仅可以写变量，还可以写表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27;&#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--另一种写法,不会忽略语法变量之间的空格，会忽略语法变量两端的空格--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <br>    <br>    <br>    <span class="hljs-comment">&lt;!--数值表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>总价：&#123;&#123;price * 2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="文本指令"><a href="#文本指令" class="headerlink" title="文本指令"></a>文本指令</h3><ol><li><p><strong>v-once</strong> </p><p>布尔属性，数据渲染一次后就不再保持绑定，内容不会再随数据改变。</p></li><li><p><strong>v-html</strong></p><p>v-html=”==data==”，会将字符串类型的字面量、变量或表达式当做html内容进行渲染。</p><p>（覆盖标签内原有的内容）。</p></li><li><p>**v-text **</p><p>v-text=”==data==”，会将字符串类型的字面量、变量或表达式作为使用该指令的dom元素的文本（覆盖标签内原有的内容）。</p></li><li><p><strong>v-pre</strong></p><p>v-pre布尔指令，会将标签中包裹的内容原原本本的展示。（忽略mustache语法）</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>hahaha<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-comment">&lt;!--会覆盖hahaha v-text不如mustache语法灵活--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>引入vue<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">       el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>       data:&#123;<br><span class="handlebars"><span class="xml">           message:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&quot;</span></span><br>       &#125; <br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h3><p>防止闪动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br><span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  在vue解析后会将v-cloak属性去掉  --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h3><pre><code>v-bind指令用于将DOM元素的属性值与数据绑定。语法糖 ==使用冒号代替v-bind==</code></pre><ol><li><p><strong>动态绑定a元素的href属性以及img元素的src属性</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">div#app<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>div#app<br><br>app=new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>imgURL:https://XXXXX.img,<br>aHref:https://www.baidu.com<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>动态绑定HTML元素的class属性</strong></p><ul><li><p>对象写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;属性名1:boolean,属性名2:boolean&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--与既有的class属性共存,v-bind使用语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>👇<br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--isLine为false--&gt;</span><br><br><span class="hljs-comment">&lt;!--v-bind:class取函数返回值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!--总之,v-bind绑定class的对象写法，属性值的形式为 &quot;Obeject&quot;  --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            isActive:<span class="hljs-literal">true</span>,</span><br><span class="javascript">            isLine:<span class="hljs-literal">false</span></span><br>        &#125;<br>        <br>        methods:&#123;<br>        getClasses ()&#123;<br><span class="javascript">        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">active</span>:<span class="hljs-built_in">this</span>.isActive,<span class="hljs-attr">line</span>:<span class="hljs-built_in">this</span>.isLine&#125;;<span class="hljs-comment">//返回一个对象</span></span><br>    &#125;<br>    &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>数组写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--语法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--list为一个含有字符串类型元素的数组--&gt;</span><br><br><span class="hljs-comment">&lt;!--例子--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[class1,class2,...classN]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>data:&#123;<br>class1:&#x27;active&#x27;,<br>class2:&#x27;red&#x27;<br>&#125;<br><br>methods:&#123;<br>getClasses()&#123;<br>return [this.class1,this.class2];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li><p><strong>动态绑定样式</strong></p><ul><li><p>对象写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;css属性名:属性值(string类型)...&#125;&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     css属性名只能使用驼峰命名法!!!!!!</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;color:&#x27;red&#x27;,fontSize:&#x27;16px&#x27;&#125;&quot;</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;backgroundColor:backColor&#125;&quot;</span>&gt;</span><br>    <br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    backColor:&#x27;#fff&#x27;<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>数组写法（是基于对象写法）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...Obejects]&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[style1,style2]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...styles]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <br><br>    new Vue(&#123;<br>    el:&#x27;#app&#x27;,<br>    data:&#123;<br>    style1:&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,<br>    style2:&#123;color:&#x27;red&#x27;&#125;<br>styles:[&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,&#123;color:&#x27;red&#x27;&#125;]<br>    &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h3><p>   语法糖   ==用@代替v-on== </p><p>   <strong>基本使用</strong>：v-on:==事件名.修饰符== =”函数/单句表达式/Object”</p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count--&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>add()&#123;<br>this.count++;<br>&#125;,<br>decrease()&#123;<br>this.count--;<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>   <strong>事件响应函数的传参问题</strong></p>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--实参和形参匹配时的正常调用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf&quot;</span>&gt;</span>没有实参和形参,当函数不带参数时，可省略括号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf()&quot;</span>&gt;</span>没有实参和形参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;y-printf(&quot;</span><span class="hljs-attr">hello</span>&quot;,&quot; <span class="hljs-attr">world</span>!&quot;)&quot;&gt;</span>处理两个参数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--实参和形参不匹配时的处理策略--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf(123)&quot;</span>&gt;</span>有形参，输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=123--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf&quot;</span>&gt;</span>有形参，但不输入实参，且不带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=$event,会把事件对象当做第一个参数传入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf()&quot;</span>&gt;</span>有形参，但不输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=undefined--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf($event)&quot;</span>&gt;</span>有形参，输入实参$event，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--val=$event 强制输入事件对象--&gt;</span><br>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>el:&quot;#app&quot;,<br>data:&#123;<br>count=0<br>&#125;<br>methods=&#123;<br>printf()&#123;<br>console.log(&quot;hello world&quot;);<br>&#125;,<br>x-printf(val)&#123;<br>console.log(val);<br>&#125;<br>y-printf(val,event)&#123;<br>console.log(val,event);<br>&#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>   <strong>修饰符</strong>：</p><ul><li><p><strong>.stop</strong>  取消事件冒泡</p><p>@click.stop=”==fun==”</p></li><li><p><strong>.prevent</strong> 取消默认行为</p><p>@click.prevent=”==fun==” 取消dom元素的默认行为</p></li><li><p>**.键盘键号   **</p><p>@keyup.enter=”==fun==” 指定当enter键松开时的行为</p><p>@keyup.13=”==fun==”      enter的代号为13</p></li><li><p>**.native **    监听组件根元素的原生事件</p></li><li><p>**.once **  只触发一次该事件</p><p>@click.once=”==fun==”</p></li></ul><hr><h3 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h3><p><strong>具有条件判断指令的标签，如果逻辑条件不符合，不会存在于DOM树中</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;score&gt;=90&quot;</span>&gt;</span><br>    成绩：优秀<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;score&gt;=60&quot;</span>&gt;</span><br>    成绩：及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    成绩：不及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>    成绩:&#123;&#123;grade&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>data:&#123;<br>score:70<br>&#125;<br>computed:&#123;<br>grade()&#123;<br>if(this.score&gt;=90) return &quot;优秀&quot;;<br>else if (this.score&gt;=60) return &quot;及格&quot;;<br>else return &quot;不及格&quot;;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h3 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h3><p>v-show=”false”时，标签存在于DOM树中，但会添加内联样式 display:none</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>当需要在显示与隐藏之间切换很频繁时，使用v-show指令</p></li><li><p>当只有一次切换，或元素互斥存在时，使用v-if</p></li></ul><hr><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>可以使用v-for指令遍历数组和JS普通对象。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--根据需要，在Vue里可以使用类似&quot;元祖&quot;的语法遍历数组的元素及索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>&gt;</span>&#123;&#123; `$&#123;index&#125;.$&#123;item&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--遍历对象的属性值、属性名及属性名的索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val,key,index) in obj&quot;</span>&gt;</span>&#123;&#123; `$&#123;key&#125;:$&#123;val&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">在v-for绑定的数据可能存在动态修改的情况时（如动态增加删除一个元素），建议为标签添加一个key属性，key的属性值应能唯一标识数据中的各个元素。添加key属性可以提高dom动态渲染性能。</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>==Vue是响应式的，当数据变化时，Vue会检测到数据的变化，并反应到视图上。==</p><p>==我们常用v-for指令绑定数组数据，Vue中包含了一组观察数组变化的方法。==</p><p>==当调用数组某些方法改变元素时，会触发视图的更新==</p><pre><code>包括：所有改变数组自身的方法(pop,push,unshift,sort,reverse等等)注意：使用下标改变数组元素的方法不会被Vue监听到，&lt;font color=&quot;red&quot;&gt;数据会发生改变，但视图不会发生改变。&lt;/font&gt;❌  lis[0]=xxx;✔  Vue.set(lis,&#39;0&#39;,xxx)    **使用Vue的set方法改变对象的属性值会被检测到，并反应到视图上**</code></pre><hr><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>==要求：当点击一个li时，该li的color为红色，其他为默认颜色==</p><p><img src="/2020/12/24/Vue/vue/image-20200816153838359.png" alt="image-20200816153838359"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.active</span>&#123;</span><br>            color: red;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:currentIndex===index&#125;&quot;</span></span><br><span class="hljs-tag">             @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;beActive(index)&quot;</span></span><br><span class="hljs-tag">         &gt;</span><br>         &#123;&#123;`$&#123;index&#125;.$&#123;item&#125;`&#125;&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                lis:[<span class="hljs-string">&#x27;mazheng&#x27;</span>,<span class="hljs-string">&#x27;ley&#x27;</span>],</span><br><span class="javascript">                currentIndex:<span class="hljs-number">0</span>         <span class="hljs-comment">//使用currentIndex记录上次点击的元素索引</span></span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">beActive</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.currentIndex=index;</span><br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="/2020/12/24/Vue/vue/image-20200816171940331.png" alt="image-20200816171940331"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        table&#123;<br>            width: 600px;<br>            border-collapse: collapse;<br>        &#125;<br>        th,td&#123;<br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span> 10<span class="hljs-selector-tag">px</span>;</span><br>            text-align: left;<br>            border: 1px black solid;<br>        &#125;<br>        th&#123;<br>            background-color: silver;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>出版日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>购买数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in books&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>《&#123;&#123;item.title&#125;&#125;》<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.releaseDate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> &#123;&#123;item.price | showPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--当书籍数量小于等于1时，按钮不可用--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;item.num &lt;= 1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decOne(index)&quot;</span>&gt;</span><br>                            -<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                        &#123;&#123;item.num&#125;&#125;<br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addOne(index)&quot;</span>&gt;</span><br>                            +<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeBook(index)&quot;</span>&gt;</span><br>                            移除<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br>                books:[<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;算法导论&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-06&#x27;</span>,</span><br>                        price:85,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;UNIX编程艺术&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-02&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;代码大全&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2008-10&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;<br>                ]<br>            &#125;,<br><span class="javascript">            filters:&#123;  <span class="hljs-comment">//过滤器。跟计算属性类似，但是调用的方法不太一样</span></span><br><span class="handlebars"><span class="xml">                //<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span> | showPrice&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     使用&quot; | &quot;调用过滤器,左边为参数</span></span><br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">showPrice</span>(<span class="hljs-params">price</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-string">`￥<span class="hljs-subst">$&#123;price.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span>;</span><br>                &#125;<br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">addOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num+=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">decOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num-=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">removeBook</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books.splice(index,<span class="hljs-number">1</span>);</span><br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><p>实现表单元素的双向绑定。绑定的数据主要用于自定义的ajax请求，也可以供其他功能使用。</p><p>如果表单元素仍然使用表单提交请求，则请求发送的仍然是表单元素的value值，跟v-model绑定的数据并无关系。</p><p>==1.与文本类表单元素结合使用==</p><p>将input的value和message变量进行绑定。文本框改变value，message的值也随之改变。改变message的值，文本框中的内容也随之改变。（双向绑定）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//只使用v-model绑定数据，但不使用name标识表单元素，这种表单元素不会被表单提交（因为没有name属性）<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原理</strong></p><p>v-model其实是一个语法糖，它的背后本质是包含两个操作：</p><ol><li><p>监听表单元素的特征事件，根据情况更新绑定的数据</p></li><li><p>监测数据的变化，更新表单元素的属性值 如value checked…（属性值的改变会体现到视图上）。</p><p> 例如：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//使用两个命令的组合实现input标签的v-model的功能<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span>&gt;</span><br><br>data:&#123;<br>message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p><u>textarea标签与input标签类似可以使用v-model指令实现上述功能</u></p><p>==2.与单选按钮结合使用==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--应当为每个单选按钮设置value属性--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这类没有name属性的radio不会随表单提交--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">radioVal:<span class="hljs-number">0</span>   <span class="hljs-comment">// 初始值为0，代表默认第一个按钮选中。数字、字符串都可以。</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>==3.与checkbox结合使用==</p><ul><li><p>单个复选框，宜使用v-model绑定一个bool类型的变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isChecked&quot;</span>&gt;</span><br>//当选中时，isChecked值会为true,不选中时为false<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">isChecked=<span class="hljs-literal">false</span>   <span class="hljs-comment">//isChecked默认值设为false，代表默认不选中</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>多个复选框（绑定同一个数据），宜使用v-model绑定一个<strong>空数组,**或</strong>具有初始值的数组**。</p><p><font color="red">（可以为数组指定初始元素，以表示默认选中的复选框，但初始元素的值应出自默认选中复选框的value。因为checkbox取消选中时只会删除数组中的响应value，而不会删除不存在于所有复选框value中的其他值。即初始化数组时，初始元素若不存在于所有value中，则会始终存在于绑定的数组里）</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>] <span class="hljs-comment">//默认选中第一个复选框</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in origins&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span> &#123;&#123;item&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br>        balls:[],<br><span class="javascript">        origins:[<span class="hljs-string">&#x27;basketball&#x27;</span>,<span class="hljs-string">&#x27;football&#x27;</span>,<span class="hljs-string">&#x27;badminton&#x27;</span>]<span class="hljs-comment">//从后台获取</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p><u>checkbox标签中使用v-model属性，会使checked属性失效。复选框是否<strong>默认</strong>选中，只与v-model绑定的数据有关。</u></p><p>==4.与select标签结合使用==</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--单选select--&gt;</span> 类似于radio button<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ball&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">basketball</span>&quot;&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">football</span>&quot;&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">badminton</span>&quot;&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        ball:<span class="hljs-string">&quot;basketball&quot;</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--多选select,添加multiple布尔属性--&gt;</span> 类似于checkbox<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">basketball</span>&quot;&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">football</span>&quot;&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value:</span>&quot;<span class="hljs-attr">badminton</span>&quot;&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>]</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修饰符</strong></p><ol><li><p>lazy修饰符，常与input text标签使用</p><p>作用：让标签在失去焦点或在input中敲回车时才更新数据</p><p>（默认情况下，v-model是在input事件发生时立刻更新数据，lazy可以减少更新次数）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>number修饰符，常与input text标签使用</p><p>作用：获取input text标签内的value，转为number类型后再更新数据，即v-model绑定的数据会是number类型</p><p>（input text的value永远是string类型）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;marks&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>trim修饰符，常与input Text标签使用</p><p>作用：获取input text的value，去除首尾的空格后再更新数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><hr><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><img src="/2020/12/24/Vue/vue/image-20200817190948735.png" alt="image-20200817190948735"></p><p><img src="/2020/12/24/Vue/vue/image-20200818104015488.png" alt="image-20200818104015488">  </p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><img src="/2020/12/24/Vue/vue/image-20200818104048034.png" alt="image-20200818104048034">  </p><p>全局组件可以在多个不同的Vue实例中使用。但<font color="red">Vue实例才是根组件</font>，因为全局组件必须在Vue实例中才能使用。</p><ol><li><p><strong>调用Vue.extend()方法<font color="red">创建组件构造器</font></strong></p><p>👇</p><ol start="2"><li><strong>调用Vue.component()方法<font color="red">注册组件</font></strong></li></ol><p>👇</p><ol start="3"><li><strong>在Vue实例或其他组件内<font color="red">使用组件</font></strong></li></ol></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--全局组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用全局组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>        <br><span class="javascript">        <span class="hljs-comment">//---------------------------------------------------------</span></span><br>        <br><span class="javascript"> <span class="hljs-comment">//创建组件构造器对象</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> cpnC=Vue.extend(option);  <span class="hljs-comment">//传入该对象，创建组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//注册全局组件，注册后cpn标签就可以在vue的实例以及各个组件内使用了</span></span><br>        <br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,cpnC);<span class="hljs-comment">//注册全局组件。第一个参数是组件标签名，第二个参数是组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-comment">&lt;!--注册全局组件的简写方式--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> P element <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">          &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>          template:template<br>      &#125;<br>      <br><span class="javascript">Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,option); <span class="hljs-comment">//将extendOptions对象直接传入，而不是组件构造器对象</span></span><br>      <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ol><li><p>创建模板</p><p>👇</p></li><li><p>创建extendOptions对象</p><p>👇</p></li><li><p>在Vue实例或父组件中注册</p><p>👇</p></li><li><p>在Vue实例或父组件中使用</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--局部组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用局部组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;;<br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>            components:&#123;<br><span class="javascript">            cpn:option            <span class="hljs-comment">//在components属性中注册组件</span></span><br>        &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h3><p><font color="red">子组件本质上就是局部组件</font></p><p><font color="red">祖先组件和后代组件之间不能越级使用，除非后代组件在祖先组件中注册过</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn1</span>&gt;</span> <span class="hljs-comment">&lt;!--父组件的使用--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript"><span class="hljs-keyword">let</span> temp2=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`;</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn2=Vue.extend(&#123;</span><br>        template:temp2<br>    &#125;);<br>    <br><span class="javascript"><span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> temp1=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span>  <span class="hljs-comment">&lt;!--子组件的使用--&gt;</span>  </span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   `;        </span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=Vue.extend(&#123;</span><br>        template:temp1,<br>        components:&#123;<br>            cpn2<br>        &#125;<br>    &#125;);<br><br><br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br><span class="javascript">            cpn1     <span class="hljs-comment">//挂载cpn1父组件</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用传入extendOptions直接注册组件--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=&#123;</span><br>        template:`<br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`,</span></span><br>        components:&#123;<br>            cpn2:&#123;<br>                template:`<br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span></span><br>            &#125;<br>        &#125;<br>    &#125;;<br>    <br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br>            cpn1<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="模板的抽离"><a href="#模板的抽离" class="headerlink" title="模板的抽离"></a>模板的抽离</h3><ol><li><p>第一种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-template&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp1&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp1&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>第二种写法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp2&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h3><p>组件拥有自己的数据，组件中<strong>不能直接访问</strong>父级组件以及子组件的数据。</p><p>组件的extendOptions中的data属性的属性值必须是Function，这个Function是一个工厂函数，返回一个对象，对象中包含组件自己的数据。</p><p>（利用工厂函数的特点，即每次返回一个新的包含数据的对象，来防止相同组件数据相互干扰）</p><p><img src="/2020/12/24/Vue/vue/image-20200818150856104.png" alt="image-20200818150856104"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">            template: <span class="hljs-string">&#x27;#temp2&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">            data: <span class="hljs-function">() =&gt;</span> (&#123;  <span class="hljs-comment">//用小括号把返回的对象扩起来，防止解析成代码块</span></span><br><span class="javascript">                message: <span class="hljs-string">&#x27;hello world&#x27;</span></span><br>            &#125;)<br>        &#125;)<br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                message:<span class="hljs-string">&#x27;hello Vue&#x27;</span></span><br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><p>==<font size="4">一、父传子：在子组件props属性挂载通信属性</font>== </p><p>子组件的props属性挂载通信属性，父组件使用子组件时，在子组件标签中使用v-bind为通信属性绑定父组件的数据，在子组件中通信属性的同名变量就获取到了父组件传来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:message-c</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--   驼峰命名法→连字符   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;today&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;console.log(messageC)&quot;</span>&gt;</span>通信<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            <br>        &#125;),<br><span class="javascript">        props:[<span class="hljs-string">&#x27;messageC&#x27;</span>,<span class="hljs-string">&#x27;today&#x27;</span>]</span><br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><font color="red">由于dom标签中不区分大小写，当props挂载的通信属性名有大写字母时，应注意：</font></p><ol><li><p>使用驼峰命名法时（第一个字符小写，后面单词首字母大写），v-bind绑定的组件标签属性的属性名使用<strong>连字符写法</strong>。例如，上面的demo中 messageC   ,在绑定该属性时使用了  v-bind:message-c 。若子组件属性标签中绑定”messageC”，则默认传的通信属性实际为 “messagec”。</p></li><li><p>若通信属性第一个字母大写，则v-bind绑定的子元素标签属性名第一个字母大小写都可以。</p></li></ol><p><u>归纳：通信属性名第一个字母不要大写，尽量使用一个单词命名通信属性。若使用驼峰命名法，v-bind绑定时在大写字母前使用连字符。</u></p><p><strong>props属性的写法</strong></p><ol><li><p>数组写法</p><p>由于数组写法功能没有对象写法强大，所以较少使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">props:[&#x27;messageC&#x27;,&#x27;today&#x27;]<br></code></pre></td></tr></table></figure></li><li><p>对象写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//指定通信属性的类型  type</span><br>props:&#123;<br>    messageC: <span class="hljs-built_in">String</span>,<br>    today: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">Number</span>,<br>    books: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>], <span class="hljs-comment">//指定Array或String类型</span><br>    owner: <span class="hljs-built_in">Object</span><br>&#125;<br><br><span class="hljs-comment">//指定默认值  default 当指定Object以及Array类型的默认值时，default应是一个工厂函数返回默认值</span><br><span class="hljs-comment">//要想子组件在一开始时使用default中的默认值，则父组件传来的数据初始值应为undefinded</span><br>props:&#123;<br>    messageC:&#123;<br>        type: <span class="hljs-built_in">String</span>,<br>        <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;hello wolrd&#x27;</span><br>    &#125;<br>    books:&#123;<br>        type: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>]<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>    &#125;<br>    owner:&#123;<br>        type: <span class="hljs-built_in">Object</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指定必须传入 required</span><br>props:&#123;<br>    books:&#123;<br>        type: <span class="hljs-built_in">Array</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>        required: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义验证函数 validator</span><br><br></code></pre></td></tr></table></figure></li></ol><ul><li><p><strong>props属性挂载的通信属性（变量），从设计的初衷来看，应该是只读属性。</strong></p><p><strong>所以在组件里避免有代码可以修改通信属性的值。</strong></p></li><li><p><strong>通信属性的值和父组件的数据是动态绑定的，一旦父组件数据发生改变，会立刻传递给子组件。</strong></p></li></ul><p>==<font size="4">二、子传父：发射（emit）自定义事件</font>== </p><p>1.子组件监听DOM事件（如click），在事件响应函数中处理逻辑，然后发射自定义事件并传入通信数据。</p><p>👇</p><p>2.父组件在子组件的标签内监听自定义事件并接收通信数据。自定义事件的响应函数不需要传参。</p><p><font color="red">（虽然没有使用括号调用，但自定义事件的响应函数不会像dom事件一样默认传入事件对象，因为自定义事件没有事件对象。）</font></p><p><font color="red" size="5">注意：由于dom标签无法识别大小写，在没有使用Vue cli的情况下，自定义事件名不允许出现大写字母。例如 不允许出现”clickLi”这种事件名</font></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">clickli</span>=<span class="hljs-string">&quot;getClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--  父组件监听子组件的自定义事件clickli   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in categories&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;myClick(item.id,item.name)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--事件响应函数--&gt;</span><br>            &#123;&#123;item.name&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   </span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            categories:[<br>                &#123;<br>                    id:1,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;mz&#x27;</span></span><br>                &#125;,<br>                &#123;<br>                    id:2,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;ley&#x27;</span></span><br>                &#125;<br>            ]<br>        &#125;),<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">myClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;clickli&#x27;</span>,id,name);  <span class="hljs-comment">//发生自定义事件，这里传入了两个通信数据id和name。</span></span><br>            &#125;<br>        &#125;<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">getClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(id,name);</span><br>            &#125;<br>        &#125;<br>        <br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>实现父子组件之间的双向通信。</p><p>在父组件的输入框输入要传递的数据，在子组件的文本框显示。</p><p>在子组件的输入框输入要传递的数据，在父组件的文本框显示。</p><p>在子组件的watch属性中定义要监听的数据的同名函数，以监听子组件数据的变化，并发送给父组件。</p><p><img src="/2020/12/24/Vue/vue/image-20200819181030339.png" alt="image-20200819181030339"> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            向子传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>            子组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ctoday&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;today&quot;</span> @<span class="hljs-attr">cinput</span>=<span class="hljs-string">&quot;getCtoday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                向父传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;inputDate&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--懒监听--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                父组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                today:<span class="hljs-string">&#x27;2020-08-19&#x27;</span>,</span><br><span class="javascript">                ctoday:<span class="hljs-string">&#x27;&#x27;</span>,</span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">getCtoday</span>(<span class="hljs-params">value</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.ctoday=value;</span><br>                &#125;<br>            &#125;,<br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            inputDate:<span class="hljs-string">&#x27;&#x27;</span></span><br>                        &#125;<br>                    &#125;,<br>                    props:&#123;<br>                        today:&#123;<br><span class="javascript">                            type:<span class="hljs-built_in">String</span></span><br>                        &#125;<br>                    &#125;,<br>                    watch:&#123;<br><span class="javascript">                        <span class="hljs-comment">//在watch中定义inputDate的同名函数，监听该数据的变化，处理逻辑</span></span><br><span class="javascript">                        <span class="hljs-function"><span class="hljs-title">inputDate</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123; </span><br><span class="javascript">                            <span class="hljs-built_in">console</span>.log(oldValue,<span class="hljs-string">&#x27;=&gt;&#x27;</span>,newValue);</span><br><span class="javascript">                            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;cinput&#x27;</span>,newValue);</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="父子组件之间的直接访问"><a href="#父子组件之间的直接访问" class="headerlink" title="父子组件之间的直接访问"></a>父子组件之间的直接访问</h3><p>==一、父组件直接访问子组件==</p><p>在父组件中，可以通过this.$children或this.$refs拿到所有子组件。</p><ul><li><p>$children属性是一个数组，可以像this.$children[index]的型式通过下标拿到子组件对象。（不常用）</p></li><li><p>$refs属性是一个对象，子组件标签中设置ref属性标识自己，父组件可以通过this.$refs[ref]的形式获取特定的子组件对象。（更常用）</p></li></ul><p>可访问到的子组件内容：几乎所有内容（数据、方法）。</p><p>==二、子组件直接访问父组件==</p><p>在子组件中，可以通过this.$parent拿到父组件对象。</p><p>同时可以使用this.$root直接拿到Vue实例对象。（Vue实例是根组件）</p><p>由于组件之间耦合度不应该太高，所以很少在子组件中访问父组件。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p><strong>基本使用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;cpn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>以下是一个插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>插槽默认内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li><p>在组件的模板中留下slot标签标识插槽</p></li><li><p>插槽中可以留有默认内容</p></li><li><p>使用时在组件标签内为插槽填充内容</p></li></ul><p><strong>具名插槽</strong></p><p>定义：具有name属性的slot标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"> <br><br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>            左插槽的div<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!----&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左插槽的span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>为组件的各个插槽标签填写name属性，标识具名插槽。</li><li>在使用组件时，在组件标签内为插槽填充内容，各个内容（html标签）的slot属性标明要往哪个插槽添加内容。</li><li>可以为同一个插槽添加多条内容（标签），具有相同slot属性的内容会全部添加到同一个插槽中。</li><li>如果添加的内容（标签）没有slot属性，则添加到所有不具名的插槽中。</li></ul><p><strong>作用域插槽</strong></p><p>应用情景：在父组件中为子组件的插槽中添加内容，但内容中需要访问子组件的内容。</p><p>旧版Vue方法：</p><ol><li><p>子组件模板中在作用域插槽绑定子组件数据，语法为 :data1=”==子组件数据1==” :data2=”==子组件数据2==”。data1、data2可以改各种任意名字，前面使用v-bind，代表作用域插槽中的变量名。</p></li><li><p>要想使用作用域插槽，必须使用template标签来替换插槽中的内容。</p></li><li><p>template标签中为slot-slope属性赋值，值为作用域对象变量名，之后便可以使用该对象拿到作用域插槽中的子组件数据。</p><template  slot="s1" slot-scope="s1scope">    <span></span>    <span></span></template></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;s1scope&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;s1scope.lans.join(&#x27;-&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">:lans</span>=<span class="hljs-string">&quot;languages&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;lan in languages&quot;</span>&gt;</span><br>                    &#123;&#123;lan&#125;&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            languages:[<span class="hljs-string">&#x27;C#&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>]</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新版Vue的写法：</p><p>使用v-slot指令代替原本的slot属性+slot-scope属性。</p><p>v-slot:==插槽的name===”==作用域对象变量名==”</p><template  v-slot:s1="s1scope">    <span></span>    <span></span></template><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:s1</span>=<span class="hljs-string">&quot;s1scope&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;s1scope.lans.join(&#x27;-&#x27;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;s1&quot;</span> <span class="hljs-attr">:lans</span>=<span class="hljs-string">&quot;languages&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;lan in languages&quot;</span>&gt;</span><br>                    &#123;&#123;lan&#125;&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            languages:[<span class="hljs-string">&#x27;C#&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>]</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>At its core,webpack is a static module bundler for modern JavaScript applications.</p><p>webpack是一个现代的JS应用的静态模块打包工具。</p><p><strong>核心：让我们可能进行模块化开发，并帮助处理模块间的依赖关系。</strong></p><p>而且不仅仅是js文件，css、图片、json等等在webpack中都可以被当做模块来使用。</p><p>支持AMD、CMD、CommonJS以及ES6模块化规范。</p><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><ul><li><p>依赖于Node环境。Node版本&gt;8.9。</p></li><li><p>全局安装webpack </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack@3.6.0 -g<br></code></pre></td></tr></table></figure></li><li><p>局部安装（开发时依赖）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack@3.6.0 --save-dev<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><ol><li><p>在项目目录新建文件夹</p><p>dist    发布</p><p>src     源码</p></li><li><pre><code class="bash">webpack ./src/main.js ./dist/bundle.js<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>   根据main.js中的依赖，去打包所有需要的模块。<br><br><br><br>------<br><br><span class="hljs-comment">### webpack.config.js与package.json</span><br><br><br><br>**webpack的配置**<br><br>需求：设置默认的入口文件，执行webpack命令时打包该文件。<br><br>```javascript<br><span class="hljs-regexp">//</span>webpack.config.js  配置webpack的文件<br><br>const NodePath=require(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br>module.exports=&#123;<br>    entry:<span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<span class="hljs-regexp">//</span>默认的入口文件，路径可以是相对路径<br>    output:&#123;<br>        path:NodePath.join(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>),<span class="hljs-regexp">//</span>输出文件的目录，必须使用绝对路径<br>        filename:<span class="hljs-string">&#x27;bundle.js&#x27;</span><span class="hljs-regexp">//</span>输出的文件名<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ol><p><strong>将webpack命令与npm命令绑定映射</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200827231027114.png" alt="image-20200827231027114"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br></code></pre></td></tr></table></figure><p>相当于执行了 webpack指令，同时只有这样配置并使用该指令，才会优先使用局部（本地）中的webpack。（node_modules的bin目录下的控制台指令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">webpack<br></code></pre></td></tr></table></figure><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>依赖于Node环境，并全局安装webpack</li><li>npm intsall -g @vue/cli</li></ol><p>以上是安装脚手架3的步骤，如果需要兼容脚手架2的语法，需要额外执行第三条：</p><ol start="3"><li>npm install -g @vue/cli-init</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试</span><br>vue --version<br></code></pre></td></tr></table></figure><h3 id="使用cli2初始化一个项目"><a href="#使用cli2初始化一个项目" class="headerlink" title="使用cli2初始化一个项目"></a>使用cli2初始化一个项目</h3><ol><li><pre><code class="dos">vue init webpack $项目名称   👉会在当前目录创建同名文件夹<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>![image<span class="hljs-number">-20200828201856002</span>](./image<span class="hljs-number">-20200828201856002.</span>png)<br><br><br><br>### 使用cli3初始化一个项目<br><br><span class="hljs-number">1.</span> ```dos<br>   vue create $项目名称<br></code></pre></td></tr></table></figure>![image-20200922221753466](./image-20200922221753466.png)</code></pre></li></ol><hr><h2 id="Vue-router-前端路由"><a href="#Vue-router-前端路由" class="headerlink" title="Vue-router 前端路由"></a>Vue-router 前端路由</h2><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p><p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p><p>后端渲染阶段</p><p>👇   +ajax</p><p>前后端分离阶段</p><p>👇   +前端路由</p><p>SPA 单页面富应用阶段</p><p><strong>如何实现前端路由？</strong></p><p>要实现前端路由，需要解决两个核心：</p><ul><li>如何改变 URL 却不引起页面刷新？</li><li>如何检测 URL 变化了？</li></ul><p>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p><ol><li><h5 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h5><ul><li>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新。</li><li>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过<code>&lt;a&gt;</code>标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件</li></ul></li><li><h5 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h5><ul><li>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。</li><li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li></ul></li></ol><p>==参考资料：==[<a href="https://www.cnblogs.com/lguow/p/10921564.html]">https://www.cnblogs.com/lguow/p/10921564.html]</a></p><hr><h3 id="vue-router-安装与基本使用"><a href="#vue-router-安装与基本使用" class="headerlink" title="vue-router 安装与基本使用"></a>vue-router 安装与基本使用</h3><p><img src="/2020/12/24/Vue/vue/image-20200829225840412.png" alt="image-20200829225840412"></p><p>目录结构：</p><p>project</p><p>—components目录</p><p>——Home.vue    //组件</p><p>——About.vue   //组件</p><p>—router目录</p><p>——index.js    //路由配置文件</p><p>—main.js</p><p>—App.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># main.js<br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>   <span class="hljs-comment">//根组件</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index.js&#x27;</span>  <span class="hljs-comment">//可省略index.js</span><br><br>Vue.config.productionTip=<span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router:router,  <span class="hljs-comment">//挂载路由</span><br>    render:<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>h(App)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p><img src="/2020/12/24/Vue/vue/image-20200829231314899.png" alt="image-20200829231314899"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># index.js<br><br><span class="hljs-comment">//事先准备好Home和About两个组件</span><br><br><span class="hljs-comment">/*路由组件与路由的映射 </span><br><span class="hljs-comment">/home  👉  Home.vue</span><br><span class="hljs-comment">/about 👉  About.vue</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span> <br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About.vue&#x27;</span><br><br><br><span class="hljs-comment">// 1.通过Vue.use(插件)，安装插件</span><br>Vue.use(VueRouter);<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>]<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &#x2F;&#x2F;router-link是由vue-router注册的全局组件，控制前端路由。默认会渲染为一个a标签<br>        &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;    <br>        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;&lt;&#x2F;router-link&gt;<br>        <br>        &#x2F;&#x2F;router-view是占位组件，可显示前端路由绑定的组件<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br>    <br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><p><img src="/2020/12/24/Vue/vue/image-20200830144015434.png" alt="image-20200830144015434"></p><h3 id="默认路由（路由重定向）"><a href="#默认路由（路由重定向）" class="headerlink" title="默认路由（路由重定向）"></a>默认路由（路由重定向）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <span class="hljs-comment">//   根目录重定向到&#x27;/home&#x27;</span><br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="hash与HTMl5的history模式"><a href="#hash与HTMl5的history模式" class="headerlink" title="hash与HTMl5的history模式"></a>hash与HTMl5的history模式</h3><p>在不刷新页面的前提下，改变URL有两种方式：</p><p>1.改变url的hash（锚点），本质上是改变location对象的hash属性。（location.hash=xxx）</p><p>2.使用HTML5的history模式中的API。</p><pre><code>BOM中使用栈结构保存访问资源的历史记录，并使用一个指针指向当前的URL。</code></pre><ul><li>history.pushState( { } , ‘’ ,’home’)    ==’/home’ 压栈==</li><li>history.back( )              ==指针下移==</li><li>history.forward( )         ==指针上移==</li><li>history.go(n)                 ==指针跳转==</li><li>history.replaceState({ },’’, ‘home’)      ==’/home’ 替换栈顶==</li></ul><h3 id="在vue-router中使用history模式"><a href="#在vue-router中使用history模式" class="headerlink" title="在vue-router中使用history模式"></a>在vue-router中使用history模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>                    <span class="hljs-comment">//在创建路由对象时，配置history模式。默认值为&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h3 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h3><ol><li><p><strong>to属性</strong></p><p>用于声明式前端路由跳转，to属性指定跳转的绝对path、query以及hash。</p><p>&lt;router-link ==to===”/home”&gt;     &lt;/ router-link&gt;</p></li></ol><ol start="2"><li><p><strong>tag属性</strong></p><p>用于指定router-link标签最终被渲染成的dom标签类型，默认情况下会被渲染成a标签。</p><p>&lt;router-link to=”/home” ==tag===”button”&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>replace布尔属性</strong></p><p>在url跳转时使用history.replace方法，替换BOM历史记录栈结构的栈顶记录。</p><p>&lt;router-link to=”/home” tag=”button” ==replace==&gt;   &lt;/ router-link&gt;</p></li><li><p><strong>active-class属性</strong></p><p>用于指定router-link渲染出的标签在活跃（被点击）时的class属性值。默认为router-link-active。</p><p><img src="/2020/12/24/Vue/vue/image-20200830165640888.png" alt="image-20200830165640888"></p><p>👇</p><p>&lt;router-link to=”/home” tag=”button” ==active-class=”active”==&gt;   &lt;/ router-link&gt;</p><p><img src="/2020/12/24/Vue/vue/image-20200830165558560.png" alt="image-20200830165558560"></p></li></ol><p>   <em>在路由对象中全局修改所有router-link的active-class：</em></p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>,<br>    linkActiveClass:<span class="hljs-string">&#x27;active&#x27;</span>  <span class="hljs-comment">//修改linkActiveClass属性</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="router和-route"><a href="#router和-route" class="headerlink" title="$router和$route"></a>$router和$route</h3><p><strong>一、区别</strong></p><p><code>this.$router</code>是VueRouter的实例。</p><p>当导航到不同url，可以使用<code>this.$router.push</code>方法，这个方法则会向history栈里面添加一条记录，当点击浏览器回退按钮或者<code>this.$router.back()</code>就会回退之前的url。</p><p><code>this.$route</code>相当于当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如name,path,query,params等。</p><p><strong>二、联系</strong></p><p><code>$router</code>和<code>$route</code>是Vue原型对象上的属性，而所有组件都是Vue类的实例，所以我们能通过组件的隐式原型链访问到这两个属性。</p><p><strong>三、常见使用</strong></p><p><code>this.$router</code></p><ol><li><p>push方法</p><p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>是等同的，会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.push(path)<br></code></pre></td></tr></table></figure></li><li><p>go方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//页面路由跳转 前进或者后退</span><br><span class="hljs-built_in">this</span>.$router.go(n)<br></code></pre></td></tr></table></figure></li><li><p>replace方法</p><p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的记录，并置为history栈顶。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.replace(path)<br></code></pre></td></tr></table></figure></li></ol><p><code>this.$route</code></p><p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p><ol><li><p>$route.path<br>   字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</p></li><li><p>$route.params<br>   一个 key/value 对象，包含了 动态片段 和 全匹配片段，<br>   如果没有路由参数，就是一个空对象。</p></li><li><p>$route.query<br>   一个 key/value 对象，表示 URL 查询参数。<br>   例如，对于路径 /foo?user=1，则有 $route.query.user == 1，<br>   如果没有查询参数，则是个空对象。</p></li><li><p>$route.hash<br>   当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</p></li><li><p>$route.fullPath<br>   完成解析后的 URL，包含查询参数和 hash 的完整路径。</p></li><li><p>$route.matched<br>   数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</p></li><li><p>$route.name  当前路径名字</p></li><li><p>$route.meta 路由元信息</p></li></ol><h3 id="编程式前端路由跳转"><a href="#编程式前端路由跳转" class="headerlink" title="编程式前端路由跳转"></a>编程式前端路由跳转</h3><p>即通过代码调用api跳转路由。</p><p>而在router-link标签中通过to属性跳转路由称作声明式前端路由跳转，其本质还是调用了$router.push方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &lt;button @click&#x3D;&quot;clickhome&quot;&gt;去主页&lt;&#x2F;button&gt;  &#x2F;&#x2F;使用按钮而不是router-link<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>        router:router,<br>        methods:&#123;<br>            clickHome()&#123;<br>                &#x2F;&#x2F;调用组件的$router的push方法跳转路由<br>                &#x2F;&#x2F;相当于执行了history.pushState(&#39;&#x2F;home&#39;)<br>                &#x2F;&#x2F;相应的还有$router.replace(path)方法<br>                this.$router.push(&#39;&#x2F;home&#39;);    <br>                &#x2F;&#x2F;this.$router.replace(&#39;&#x2F;home&#39;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p><strong>Vue官方解析</strong></p><p><code>router.push(location, onComplete?, onAbort?)</code></p><p><strong>注意</strong>：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p><p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p><p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td><code>router.push(...)</code></td></tr></tbody></table><p>push/replace方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&#x27;home&#x27;</span>)<br><br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br><br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;123&#x27;</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user/123</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/123</span><br><span class="hljs-comment">// 这里的 params 不生效</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong>push方法中的<code>path</code>可以是相对路径。例如：</p><ol><li><p>若当前<code>path</code>为<code>/user</code>,则使用<code>$router.push(&#39;./user/mz&#39;)</code>可以跳转到<code>/user/mz</code>。</p><p>原因是<code>/user</code>的当前目录仍然为==根目录 /== 。</p></li><li><p>若当前path为<code>/user/</code>,则使用<code>$router.push(&#39;./mz&#39;)</code>就能跳转到<code>/user/mz</code></p></li></ol><p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p><p><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，你需要使用 <a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 来响应这个变化 (比如抓取用户信息)。</p><p><strong>坑</strong>🕳：</p><p><font color='red'>在vue-router中，使用$router.push/replace时会检查是否重复跳转至当前所在路由，如果是，则会抛出异常，但不影响功能使用</font></p><p>解决方法：</p><p>方法1.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"># 在router目录下的index.js (路由文件最后加载以下代码片段)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    let router = new VueRouter(&#123;...&#125;)</span><br><span class="hljs-comment">    ....</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> originalPush = VueRouter.prototype.push; <span class="hljs-comment">//解决push方法的bug</span><br>VueRouter.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-keyword">const</span> originalReplace = VueRouter.prototype.replace;  <span class="hljs-comment">//解决replace方法的bug</span><br>VueRouter.prototype.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalReplace.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-comment">// export default router</span><br></code></pre></td></tr></table></figure><p>方法2.</p><pre><code>下载指定版本的vue-router  </code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i vue-router@<span class="hljs-number">3</span>.<span class="hljs-number">0</span> --save<br></code></pre></td></tr></table></figure><p>[<a href="https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1%5D">https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1]</a></p><h3 id="动态路由与路由参数"><a href="#动态路由与路由参数" class="headerlink" title="动态路由与路由参数"></a>动态路由与路由参数</h3><p>==（以动态二级路由为例）==</p><p>动态路由的配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>  <span class="hljs-comment">//导入User组件</span><br><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>    path:<span class="hljs-string">&#x27;/user&#x27;</span>,<br>        component:Login,<br>        children:[<br>            &#123;<br>                name:<span class="hljs-string">&#x27;userInfo1&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;:userId&#x27;</span>,<br>                component:User<br>            &#125;<br>        ]<br>    &#125;,<br>    <br>    &#123;<br>        name:<span class="hljs-string">&#x27;userInfo2&#x27;</span><br>        path:<span class="hljs-string">&#x27;/user/:userId&#x27;</span>, <span class="hljs-comment">//二级路由，只有当userId占位处不为空串时，才匹配该条路由</span><br>        component:User<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>一级路由组件向二级路由传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Login.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;login&quot;&gt;<br>        <br>        &lt;!-- 指定跳转的完整绝对路径 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        &lt;!--相当于👇--&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;path:&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&#125;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        <br>        <br>        &lt;!-- 指定跳转到名为userInfo2的路由，并设置参数 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;name:&#39;userInfo&#39;,params:&#123;userId&#125;&#125;&quot;&gt;登录2&lt;&#x2F;router-link&gt;<br>        <br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>二级路由组件获取路由参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue"># User.vue<br><br>&lt;template&gt;<br>&lt;div class&#x3D;&quot;user&quot;&gt;<br>        &lt;div&gt;头像&lt;&#x2F;div&gt;<br>        &lt;!-- 获取当前路由中的参数  $route.params  --&gt;<br>        &lt;h2&gt;id:&lt;span&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;&#x2F;span&gt;  <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        name:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:App,<br>        <span class="hljs-comment">//开始嵌套</span><br>        children:[                 <span class="hljs-comment">//在路由配置对象中的children属性，可以设置子路由</span><br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /home</span><br>                name:<span class="hljs-string">&#x27;homepage&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,       <span class="hljs-comment">//子路由配置中，路径使用相对路径 </span><br>                component:Home<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /user/...</span><br>                name:<span class="hljs-string">&#x27;userinfo&#x27;</span>,      <span class="hljs-comment">//为路由设置name属性 唯一标识该条路由</span><br>                path:<span class="hljs-string">&#x27;user/:userId&#x27;</span>,  <span class="hljs-comment">// 子路由配置中，使用动态路由</span><br>                component:User<br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p><code>路由的嵌套只是用一种结构化的方式配置前端路由信息，将逻辑上有层次关系的路由放在一起，但相应的路由组件不存在绝对的层次化渲染关系。</code></p><p><code>子路由对应的component如何显示，只与该路由是在哪一个组件中跳转有关，子路由组件在该组件中的router-view中显示。</code></p><p><font color='red'>为了避免组件渲染后的层次关系混乱，父级路由对应的组件与子路由对应的组件也应该具有相应的父子关系。</font></p><h3 id="路由组件懒加载"><a href="#路由组件懒加载" class="headerlink" title="路由组件懒加载"></a>路由组件懒加载</h3><p><a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p><p>在Vue Cli的默认配置情况下，所有的开发组件vue文件 (包括main.js)会被打包到一个app.js中，这就使得该js文件十分庞大。</p><p>(除了app.js会被第一时间请求外，还有第三方包的打包文件vendor.js以及模块化底层支撑的文件manifest.js会被第一时间请求至前端)</p><p>在使用组件懒加载后，每个懒加载的组件会被单独打包到一个js文件中（而不是app.js），浏览器会根据前端路由，按需向服务器请求组件的js打包文件。</p><p><img src="/2020/12/24/Vue/vue/image-20200901110233735.png" alt="image-20200901110233735"></p><p><img src="/2020/12/24/Vue/vue/image-20200901110610641.png" alt="image-20200901110610641"></p><p><strong>基本语法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> Home=<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>)<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;<br>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>参考资料：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p><p><strong>一、全局导航守卫（钩子）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"># router 👉 index.js<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:Index,<br>        meta:&#123;    <span class="hljs-comment">//在元数据meta中保存一些路由信息</span><br>            title:<span class="hljs-string">&#x27;首页&#x27;</span><br>        &#125;<br>        children:[<br>            &#123;<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,<br>                component:Home,<br>                meta:&#123;<br>                    title:<span class="hljs-string">&#x27;主页&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>        <br>    &#125;<br>];<br><br><span class="hljs-keyword">let</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">/* beforeEach方法加载前置守卫 */</span><br>router.beforeEach( guard:<span class="hljs-built_in">Function</span> );  <span class="hljs-comment">//钩子（守卫）的用法类似于中间件，可挂载多个钩子</span><br><br><span class="hljs-comment">/*afterEach方法加载后置钩子*/</span><br>router.afterEach(hook:<span class="hljs-built_in">Function</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 前置钩子（守卫）要传入三个参数，分别为：</p><ol><li><p>to：Route对象 ，将要跳转到的下一个活跃路由</p></li><li><p>from： Route对象，当前的活跃路由，即$route对象</p></li><li><p>next ：Function  下一个钩子函数，必须使在钩子内调用一下 next( )</p><pre><code>后置钩子要传入两个参数，分别为to  和from。</code></pre></li></ol><p>​      </p><p><strong>案例：在跳转到各条路由时更新标签页的标题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    <br>    <span class="hljs-built_in">console</span>.log(to);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">from</span>);<br>    <br>    <span class="hljs-built_in">document</span>.title=to.meta.title;<br>   <br>    <span class="hljs-comment">//document.title=to.matched[0].meta.title </span><br>   <span class="hljs-comment">//matched是一个数组，保存了所有匹配的路由</span><br>    <br>    next();<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>二、路由独享守卫</strong></p><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><p><strong>三、组件内的守卫</strong></p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB</a></p><p><strong>四、完整的导航解析流程</strong></p><p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B</a></p><h3 id="keep-alive包裹router-view"><a href="#keep-alive包裹router-view" class="headerlink" title="keep-alive包裹router-view"></a>keep-alive包裹router-view</h3><p><code>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染（维持生命周期）。</code></p><p>使用keep-alive包裹一个需要反复使用的一个组件，可以避免组件在不活跃时被销毁，在活跃时被新建。同时该组件会具有新的生命周期函数actived和deactived。</p><p><strong>案例：组件在失活时记录组件状态，组件重新活跃时返回至上一状态</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Home.vue<br># &lt;keep-alive&gt;标签包裹了Home.vue的父级组件中的&lt;router-view&gt;<br><br>&lt;template&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;Home&#39;,<br>        data()&#123;<br>            return &#123;<br>                path:&#39;&#x2F;home&#39;<br>            &#125;<br>        &#125;,<br>        actived()&#123;<br>            this.$router.replace(this.path);   &#x2F;&#x2F;返回至失活前的状态<br>        &#125;,<br>        beforeRouteLeave(to,from,next)&#123;         &#x2F;&#x2F;组件内的后置勾子<br>            this.path&#x3D;this.$route.path;<br>            next();<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;    <br></code></pre></td></tr></table></figure><p><strong>keep-alive标签的exclude和include属性</strong></p><p>keep-alive标签可以利用exclude与include属性指定排除或包含哪些组件的生命周期会被维持，属性值为逗号分隔的字符串，对应组件定义时的name属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;<br>&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;<br>    &lt;router-view&#x2F;&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p> <img src="/2020/12/24/Vue/vue/image-20200926103349466.png" alt="image-20200926103349466"></p><p><img src="/2020/12/24/Vue/vue/image-20200926103508601.png" alt="image-20200926103508601"></p><blockquote><p>在Vuex中保存的状态（数据）是响应式的。</p></blockquote><p><strong>应用场景👇</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926103551896.png" alt="image-20200926103551896"></p><p><strong>单个组件的状态管理:</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926104012022.png" alt="image-20200926104012022"></p><blockquote><p>Vue已经帮我们做好了单个页面的状态管理，即组件的数据是比较独立的，可以通过各种Action的回调函数去修改State（数据），并通过响应式去更新View。</p><p>但如果是多个界面（组件）的状态管理就可能需要Vuex。</p></blockquote><p><strong>Vuex的基本思想：</strong></p><p><img src="/2020/12/24/Vue/vue/image-20200926104500158.png" alt="image-20200926104500158"></p><p><img src="/2020/12/24/Vue/vue/image-20200926104627320.png" alt="image-20200926104627320"></p><h3 id="什么情况下应该使用Vuex？"><a href="#什么情况下应该使用Vuex？" class="headerlink" title="什么情况下应该使用Vuex？"></a>什么情况下应该使用Vuex？</h3><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8">store 模式</a>就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vuex --save<br></code></pre></td></tr></table></figure><p>在 Vue 的单页面应用中使用，需要使用<code>Vue.use(Vuex)</code>调用插件。</p><p>之后新建一个Vuex.Store实例，将其注入到Vue根实例中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  getter: &#123;<br>    doneTodos: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;,<br>  mutations: &#123;<br>    increment (state, payload) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">addCount</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-comment">// 可以包含异步操作</span><br>      <span class="hljs-comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 注入到根实例</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br>  store,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>  components: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后通过mutations改变状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在项目中使用Vuex，常常在src目录下创建store文件夹统一管理Vuex的单一状态树的内容。</p></blockquote><hr><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>State，Getter，Mutation，Action，Module，</code></p><p><strong>Vuex 主要有四部分：</strong></p><ol><li>state：包含了<code>store</code>中存储的各个状态。</li><li>getter: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。</li><li>mutation: 一组方法，是改变<code>store</code>中状态的执行者，<strong>只能是同步操作</strong>。</li><li>action: 一组方法，其中可以<strong>包含异步操作</strong>,但只允许通过提交mutations修改状态。</li></ol><hr><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 使用 <code>state</code> 来存储应用中需要共享的状态。</p><p>在根组件（Vue实例）以及子组件中使用<code>this.$store.state</code>访问共享状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; Cpn.vue<br>&#x2F;*<br>const store &#x3D; new Vuex.Store(&#123;<br>  state: &#123;<br>    count: 0,<br>obj: &#123;name: &#39;mz&#39;, age: 23&#125;<br>&#125;<br>&#125;)<br><br>*&#x2F;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>        &lt;h2&gt; &#123;&#123;count&#125;&#125; &lt;&#x2F;h2&gt; <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>        name: &#39;Cpn&#39;,<br>        computed: &#123;<br>            count()&#123;<br>                return this.$store.state.count  &#x2F;&#x2F; 访问state中的count<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>在state初始化时就已经定义的数据以及数据的属性才会被添加到响应式系统。</p><p>( 在Vue中所有需要响应式的数据都是这样 )</p><p>所以通过this.$store.state.obj[‘xxx’]的方式为数据添加额外的属性值时，虽然数据确实变化了，但不会更新View。</p><p>此时，需要通过Vue.set方法来修改状态的属性，可以确保数据是响应式的。</p><p>Vue.set(obj, propName, value)</p><p>删除状态的属性需要通过Vue.delete方法实现响应式。</p><p>Vue.delete(obj, propName)</p></blockquote><hr><h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>类似于 Vue 中的 计算属性（可以认为是 store 的计算属性），getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>getter 方法接受<code>state</code>作为其第一个参数，<code>state</code>参数即Store对象中的state：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>getter 方法接受<code>getters</code>作为其第二个参数，<code>getters</code>参数即Store对象中的getters：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done);<br>    &#125;,<br>    doneTodosCount: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> getters.doneTodos.length;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>在组件中访问getters：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">cpnDoneTodos</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodos;<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">cpnDoneTodosCount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodosCount;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>getter方法返回一个函数，实现给getter传参：</strong></p><p>这种做法在对 store 里的数组进行查询时非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getters: &#123;<br>  <span class="hljs-comment">// ...</span><br>  getTodoById: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id === id)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在组件中为getter返回的函数传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$store.getters.getTodoById(<span class="hljs-number">2</span>) <span class="hljs-comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span><br></code></pre></td></tr></table></figure><hr><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>在Vuex中约定必须通过mutation修改状态，不允许通过<code>$store.state.xxx = xxx</code>的形式直接修改。（虽然这样没什么可怕的后果，只是通过mutation修改能保存修改日志与状态快照）</p><blockquote><p><code>state</code>和<code>getter</code>都是状态值本身，<code>mutations</code>才是改变状态的执行者。</p><p><strong>注意：<code>mutations</code>只能是同步地更改状态。</strong></p></blockquote><p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">1</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 变更状态</span><br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在组件中提交mutation，并执行回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>commit</code>方法中第一个参数可以是<code>事件类型名(String)</code>；</p><p>第二个参数是传递的<code>载荷</code>，可以作为实参传递给mutation的回调函数，第二个参数<code>是可选的</code>。</p><blockquote><p>提交mutation时，不可以像发送action一样能够获取mutation回调函数的返回值。</p><p>即在mutation的回调函数中返回值是无意义的。</p></blockquote><p><strong>规范地提交mutation并传参：</strong></p><p>在规范中，mutation的回调函数支持传入第二个参数payload，作为载荷。载荷中可以保存向mutation回调函数传递的实参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br>        state.count += payload.n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的形式1：提交mutation的事件类型，传递载荷，触发回调函数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;); 👉 传递的实参的值： &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 推荐的形式2：使用对象风格的提交方式，传递参数名与值   </span><br><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>    type: <span class="hljs-string">&#x27;increment&#x27;</span>, 👉 传递的实参的值： &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br>    n: <span class="hljs-number">1</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>向提交简单参数：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, n</span>)</span> &#123;<br>        state.count += n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不能再通过对象风格来传递参数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>总结： 在向mutation传递参数时，需要回调函数与提交方式的配合。</p></blockquote><hr><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>想要<strong>异步地更改状态</strong>，就需要使用<code>action</code>。<code>action</code>并不直接改变<code>state</code>，而是发起<code>mutation</code>。</p><blockquote><p>action既可以异步地提交mutation，也可以同步提交，但更主要的是利用它来异步修改状态</p></blockquote><p><strong>注册一个简单的 action：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>          context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>发起简单的action：</strong></p><p>发起<code>action</code>的方法形式和发起<code>mutation</code>一样，只是换了个名字<code>dispatch</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>Actions 支持同样的载荷方式和对象方式<code>进行分发</code>并<code>传递参数</code>：</strong></p><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 context 对象为什么不是 store 实例本身了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations:&#123;<br>      <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span>&#123;<br>          state.count += payload.n<br>      &#125;  <br>    &#125;,<br>actions: &#123;<br>      <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context, payload</span>)</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>            context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, payload)  <span class="hljs-comment">// 实参的类型要与mutation中的形参一致</span><br>         &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐使用载荷的方式向action传参</span><br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-comment">// 不建议使用下面这种对象风格的方式，因为payload形参的type不再是mutation的type，需要进行调整</span><br><span class="hljs-built_in">this</span>.$store.dispatch(&#123;<br>    type: <span class="hljs-string">&#x27;asyncIncrement&#x27;</span>,<br>    n: <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>可见，向action或mutation传参，以载荷的方式更直观，同时能避免差错。</p></blockquote><p><strong>对context进行解构：</strong></p><p>实践中，我们会经常用到 ES2015 的 <a href="https://github.com/lukehoban/es6features#destructuring">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>context具有store 实例的相同方法和属性，包括commit, dispatch, getters, state。</p><p>此外还具有rootGetters以及rootState；</p><p>这些属性和方法都可以进行解构获取。</p><p><img src="/2020/12/24/Vue/vue/image-20200926153828952.png" alt="image-20200926153828952"> </p></blockquote><h4 id="Action处理异步的正确使用方式"><a href="#Action处理异步的正确使用方式" class="headerlink" title="Action处理异步的正确使用方式"></a>Action处理异步的正确使用方式</h4><p>想要使用<code>action</code>处理异步工作很简单，只需要将异步操作放到<code>action</code>中执行（如上面代码中的<code>setTimeout</code>）。</p><p>要想在异步操作完成后继续进行相应的流程操作，有两种方式:</p><ol><li><p>在action中返回一个Promise</p><p><code>store.dispatch</code>返回相应<code>action</code>的执行结果，而当action的处理函数返回的是一个Promise实例时，就可以写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><p>   在另外一个 action 中也可以：</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  <span class="hljs-comment">// ...</span><br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>      commit(<span class="hljs-string">&#x27;someOtherMutation&#x27;</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>利用<code>async/await</code> 进行组合action。代码更加简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><br>actions: &#123;<br>  <span class="hljs-keyword">async</span> actionA (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())<br>  &#125;,<br>  <span class="hljs-keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span><br>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一个 <code>$store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS字符串常用方法</title>
    <link href="/2020/12/24/JavaScript/js-string/"/>
    <url>/2020/12/24/JavaScript/js-string/</url>
    
    <content type="html"><![CDATA[<h1 id="JS字符串常用方法"><a href="#JS字符串常用方法" class="headerlink" title="JS字符串常用方法"></a>JS字符串常用方法</h1><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>返回字符串的长度</p><h2 id="查找子串索引"><a href="#查找子串索引" class="headerlink" title="查找子串索引"></a>查找子串索引</h2><h3 id="indexOf-substr-start-0"><a href="#indexOf-substr-start-0" class="headerlink" title="indexOf (substr, [ start = 0 ])"></a>indexOf (<em>substr</em>, [ <em>start</em> = 0 ])</h3><p><code>indexOf</code>方法搜索并(如果找到)返回字符串中搜索到的字符或子字符串的索引。如果没有找到，则返回<code>-1</code>。<code>start</code>是一个可选参数，指定字符串中开始搜索的位置，默认值为<code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//indexOf(char/substring)</span><br><span class="hljs-keyword">var</span> sentence=<span class="hljs-string">&quot;Hi, my name is Sam!&quot;</span><br><span class="hljs-keyword">if</span> (sentence.indexOf(<span class="hljs-string">&quot;Sam&quot;</span>)!=-<span class="hljs-number">1</span>)<br>alert(<span class="hljs-string">&quot;Sam is in there!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="lastIndexOf-substr-start-length-1"><a href="#lastIndexOf-substr-start-length-1" class="headerlink" title="lastIndexOf (substr, [ start = length-1] )"></a>lastIndexOf (<em>substr</em>, [ <em>start</em> = length-1] )</h3><p><code>lastIndexOf()</code> 方法返回指定文本在字符串中最后一次出现的索引, 如果未找到，则返回<code>-1</code>。 “<code>start</code>”是一个可选参数，指定字符串中开始搜索的位置, 默认值为<code>string.length-1</code>。若指定<code>start</code>，则在<code>0~start</code>之间的子串中查找目标子串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//lastIndexOf(substr, [start])</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;javascript rox&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myString.lastIndexOf(<span class="hljs-string">&#x27;r&#x27;</span>));<br><span class="hljs-comment">//output: 11</span><br></code></pre></td></tr></table></figure><h2 id="子串切片"><a href="#子串切片" class="headerlink" title="子串切片"></a>子串切片</h2><h3 id="charAt-index"><a href="#charAt-index" class="headerlink" title="charAt (index)"></a>charAt (<em>index</em>)</h3><p><code>charAt(x)</code>返回字符串中<code>x</code>位置的字符，下标从 <code>0</code> 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//charAt(x)</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;jQuery FTW!!!&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myString.charAt(<span class="hljs-number">7</span>));<br><span class="hljs-comment">//output: F</span><br></code></pre></td></tr></table></figure><h3 id="slice-start-end-length"><a href="#slice-start-end-length" class="headerlink" title="slice (start, [ end = length ])"></a>slice (<em>start</em>, [ <em>end</em> = length ])</h3><p><code>slice()</code> 方法可提取字符串的某个部分，返回一个新的字符串。包括字符串从 <code>start</code> 开始（包括 start）到 <code>end</code> 结束（不包括 <code>end</code>）为止的所有字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//slice(start, end)</span><br><span class="hljs-keyword">var</span> text=<span class="hljs-string">&quot;excellent&quot;</span><br>text.slice(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;exce&quot;</span><br>text.slice(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;ce&quot;</span><br></code></pre></td></tr></table></figure><h3 id="substr-start-len-length"><a href="#substr-start-len-length" class="headerlink" title="substr (start, [ len = length ])"></a>substr (<em>start</em>, [ <em>len</em> = length ])</h3><p><code>substr()</code> 方法可在字符串中抽取从 <code>start</code> 下标开始的指定数目的字符。返回一个新的字符串，包含从 <code>start</code>（包括 start 所指的字符） 处开始的 <code>length</code> 个字符。如果没有指定 <code>length</code>，那么返回的字符串包含从 <code>start</code> 到该字符串的结尾的字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//substr(from, to)</span><br><span class="hljs-keyword">var</span> text=<span class="hljs-string">&quot;excellent&quot;</span><br>text.substr(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;exce&quot;</span><br>text.substr(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">//returns &quot;cell&quot;</span><br></code></pre></td></tr></table></figure><h3 id="substring-from-to-length"><a href="#substring-from-to-length" class="headerlink" title="substring (from, [ to = length ])"></a>substring (<em>from</em>, [ <em>to</em> = length ])</h3><p><code>substring()</code> 方法用于<code>返回</code>一个字符串中介于两个指定下标之间的字符，方返回的子串包括 <code>start</code> 处的字符，但不包括 <code>to</code> 处的字符，<code>to</code> 可选，如果省略该参数，那么返回的子串会一直到字符串的结尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//substring(from, [to])</span><br><span class="hljs-keyword">var</span> myString = <span class="hljs-string">&#x27;javascript rox&#x27;</span>;<br>myString = myString.substring(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log(myString)<br><span class="hljs-comment">//output: javascript</span><br></code></pre></td></tr></table></figure><h3 id="slice、substr、substring三个方法的区别"><a href="#slice、substr、substring三个方法的区别" class="headerlink" title="slice、substr、substring三个方法的区别"></a>slice、substr、substring三个方法的区别</h3><ol><li>slice和substring参数分别为(起始位置索引值，结束位置索引值)，substr的参数则为(起始位置索引值，截取长度)；</li><li>slice不能颠倒参数顺序，substring可以；<ul><li>slice方法中，<code>start</code> 不可以大于等于 <code>end</code>，否则返回空串。</li><li>substring方法中，<code>from</code>若大于等于<code>to</code>，但返回的结果为<code>[to, from)</code>范围内的子串。</li></ul></li><li>slice和substring的参数为负时，结果不同。<ul><li>slice方法允许参数为负，<code>负参数与length相加</code>得到实际的形参值。<code>如果相加结果仍为负数，则等效为0。</code></li><li>substring方法不允许参数为负，<code>负实参</code>的形参值为<code>0</code>。</li></ul></li></ol><h2 id="内容检测"><a href="#内容检测" class="headerlink" title="内容检测"></a>内容检测</h2><blockquote><p>以下方法都是对searchString大小写敏感的。</p></blockquote><h3 id="includes-searchString-position-0"><a href="#includes-searchString-position-0" class="headerlink" title="includes (searchString, [ position = 0 ])"></a>includes (<em>searchString</em>, [ <em>position</em> = 0 ])</h3><p><code>includes()</code> 方法用于检查字符串是否包含指定的字符串或字符。<code>position</code>为从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 <code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//endsWith()</span><br><span class="hljs-keyword">var</span> mystr = <span class="hljs-string">&quot;List of javascript functions&quot;</span>;<br><span class="hljs-keyword">var</span> n = mystr.endsWith(<span class="hljs-string">&quot;functions&quot;</span>);<br><span class="hljs-comment">//output: True</span><br></code></pre></td></tr></table></figure><h3 id="startsWith-searchString-postion-0"><a href="#startsWith-searchString-postion-0" class="headerlink" title="startsWith (searchString, [ postion = 0 ])"></a>startsWith (<em>searchString</em>, [ <em>postion</em> = 0 ])</h3><p><strong>参数</strong></p><ul><li><p><code>searchString</code></p><p>要搜索的子字符串。</p></li><li><p><code>position</code> 可选</p><p>在 <code>str</code> 中搜索 <code>searchString</code> 的开始位置，默认值为 0。</p></li></ul><p><strong>返回值</strong></p><p>如果在字符串的开头找到了给定的字符则返回**<code>true</code><strong>；否则返回</strong><code>false</code>**。</p><h3 id="endsWith-searchString-len-length"><a href="#endsWith-searchString-len-length" class="headerlink" title="endsWith ( searchString, [ len = length] )"></a>endsWith ( <em>searchString</em>, [ <em>len</em> = length] )</h3><p><code>endWith</code>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</p><p><strong>参数</strong></p><ul><li><p><code>searchString</code></p><p>要搜索的子字符串。</p></li><li><p><code>length</code> 可选</p><p>在字符串的前length个字符中进行判断。默认值为 <code>str.length</code>。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">&#x27;Cats are the best!&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(str1.endsWith(<span class="hljs-string">&#x27;best&#x27;</span>, <span class="hljs-number">17</span>));<br><span class="hljs-comment">// expected output: true</span><br><br><span class="hljs-keyword">const</span> str2 = <span class="hljs-string">&#x27;12345&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str2.endsWith(<span class="hljs-string">&#x27;34&#x27;</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// length = 4</span><br><span class="hljs-comment">// expected output: true</span><br><br></code></pre></td></tr></table></figure><blockquote><p>注意： 以上两个方法名是end<font color = 'red'>s</font>With 以及 start<font color = 'red'>s</font>With</p></blockquote><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><h3 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase ()"></a>toUpperCase ()</h3><h3 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase ()"></a>toLowerCase ()</h3><p>返回一个新的字符串。</p><h2 id="填充与修剪"><a href="#填充与修剪" class="headerlink" title="填充与修剪"></a>填充与修剪</h2><blockquote><p>注意： 以下方法只会返回新字符串，不会修改原字符串。</p></blockquote><h3 id="padStart-targetLength-padString"><a href="#padStart-targetLength-padString" class="headerlink" title="padStart (targetLength [, padString])"></a>padStart (<em>targetLength</em> [, <em>padString</em>])</h3><p>该方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。</p><p><strong>参数</strong></p><p><code>targetLength</code></p><p>当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p><code>padString</code> 可选</p><p>填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的默认值为 <code>&quot; &quot;</code>（U+0020），<code>即空格</code>。</p><p><strong>返回值</strong></p><p>在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。</p><h3 id="padEnd-targetLength-padString"><a href="#padEnd-targetLength-padString" class="headerlink" title="padEnd (targetLength [, padString])"></a>padEnd (<em>targetLength</em> [, <em>padString</em>])</h3><p>用法与padStart类似</p><h3 id="trim-、trimEnd-、trimStart"><a href="#trim-、trimEnd-、trimStart" class="headerlink" title="trim()、trimEnd()、trimStart()"></a>trim()、trimEnd()、trimStart()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;   Hello world!   &#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(greeting);<br><span class="hljs-comment">// expected output: &quot;   Hello world!   &quot;;</span><br><br><span class="hljs-built_in">console</span>.log(greeting.trim());<br><span class="hljs-comment">// expected output: &quot;Hello world!&quot;;</span><br><br><span class="hljs-built_in">console</span>.log(greeting.trimStart());<br>expected output: <span class="hljs-string">&quot;Hello world!   &quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(greeting.trimEnd());<br><span class="hljs-comment">// expected output: &quot;   Hello world!&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="拼接与分割"><a href="#拼接与分割" class="headerlink" title="拼接与分割"></a>拼接与分割</h2><h3 id="concat-str2-…strN"><a href="#concat-str2-…strN" class="headerlink" title="concat(str2, [, …strN])"></a>concat(<em>str2</em>, [, <em>…strN</em>])</h3><p><strong>参数</strong></p><ul><li><p><code>str2 [, ...strN]</code></p><p>需要连接到 <code>str</code> 的字符串。</p></li></ul><p><strong>返回值</strong></p><p>一个新的字符串，包含参数所提供的连接字符串。</p><p><strong>描述</strong></p><p><code>concat</code> 方法将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。 <code>concat</code> 方法并不影响原字符串。</p><p>如果参数不是字符串类型，它们在连接之前将会被转换成字符串。</p><h3 id="repeat-count"><a href="#repeat-count" class="headerlink" title="repeat(count)"></a>repeat(<em>count</em>)</h3><p><code>repeat()</code> 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//repeat()</span><br><span class="hljs-keyword">var</span> string = <span class="hljs-string">&quot;Welcome to Edureka&quot;</span>;<br><span class="hljs-built_in">console</span>.log(string.repeat(<span class="hljs-number">2</span>));<br><span class="hljs-comment">//output: Welcome to EdurekaWelcome to Edureka</span><br></code></pre></td></tr></table></figure><blockquote><p>注意： 以上方法只会返回新字符串，不会修改原字符串。</p></blockquote><h3 id="split-separator-‘’-limit-INFINIT"><a href="#split-separator-‘’-limit-INFINIT" class="headerlink" title="split([ separator = ‘’ ], [ limit = INFINIT ] )"></a>split([ <em>separator = ‘’</em> ], [ <em>limit = INFINIT</em> ] )</h3><p><strong>参数</strong></p><ul><li><p><code>separator</code></p><p>指定表示每个拆分应发生的点的字符串。<code>separator</code> 可以是一个字符串或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp">正则表达式</a>。</p><ol><li>如果没有找到或者省略了分隔符，则该数组包含一个由整个字符串组成的元素。</li><li>如果分隔符为空字符串，则将str转换为字符数组。</li><li>如果分隔符出现在字符串的开始或结尾，或两者都分开，分别返回的数组以空字符串开头，结尾或两者开始和结束。因此，如果字符串仅由一个分隔符实例组成，则该数组由两个空字符串组成。</li></ol></li><li><p><code>limit</code></p><p>一个整数，限定返回的分割片段数量。当提供此参数时，split 方法会在指定分隔符的每次出现时分割该字符串，但在限制条目已放入数组时停止。如果在达到指定限制之前达到字符串的末尾，它可能仍然包含少于限制的条目。新数组中不返回剩下的文本。</p></li></ul><p><strong>返回值</strong></p><p>返回源字符串以分隔符出现位置分隔而成的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> </p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><blockquote><p>注意：以下方法只会将替换的结果返回，不会改变原字符串。</p></blockquote><h3 id="replace-substr-newSubStr"><a href="#replace-substr-newSubStr" class="headerlink" title="replace( substr, newSubStr)"></a>replace( <em>substr</em>, <em>newSubStr</em>)</h3><p><strong>参数</strong></p><ul><li><p><code>substr </code>(pattern)</p><p>一个将被 <code>newSubStr</code> 替换的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。其被视为一整个字符串，而不是一个正则表达式。仅第一个匹配项会被替换。</p></li><li><p><code>newSubStr</code> (replacement)</p><p>用于替换掉第一个参数在原字符串中的匹配部分的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。</p></li></ul><p><strong>返回值</strong></p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p><strong>描述</strong></p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><h3 id="replaceAll-substr-replacement"><a href="#replaceAll-substr-replacement" class="headerlink" title="replaceAll (substr, replacement )"></a>replaceAll (substr, <em>replacement</em> )</h3><p>该方法返回一个新字符串，即使substr不是一个正则表达式，新字符串所有与 <code>substr</code> 相同的部分都会被<code>replacement</code> 替换。</p><blockquote><p>注意，在Node环境中，Node.js 15.0以上版本才支持此方法</p></blockquote><p><strong>参数</strong></p><ul><li><p><code>substr </code></p><p>一个将被 <code>newSubStr</code> 替换的 字符串。</p></li><li><p><code>newSubStr</code> (replacement)</p><p>用于替换掉第一个参数在原字符串中的匹配部分的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>字符串</code></a>。</p></li></ul><p><strong>返回值</strong></p><p>一个部分或全部匹配由替代模式所取代的新的字符串。</p><p><strong>描述</strong></p><p>该方法并不改变调用它的字符串本身，而只是返回一个新的替换后的字符串。</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw"></a>String.raw</h2><p>在JS中，<code>String.raw</code>后面跟上一个<code>反引号</code>括起的字符串，其作用类似于python中的 <code>r</code>修饰符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python</span><br>s1 = <span class="hljs-string">r&#x27;c:\home&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>.raw <span class="hljs-string">`c:\home`</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS正则表达式</title>
    <link href="/2020/12/23/JavaScript/js-regexp/"/>
    <url>/2020/12/23/JavaScript/js-regexp/</url>
    
    <content type="html"><![CDATA[<h1 id="JS正则相关"><a href="#JS正则相关" class="headerlink" title="JS正则相关"></a>JS正则相关</h1><p><strong>Regular Expression：RegExp</strong></p><h2 id="创建JS正则表达式对象"><a href="#创建JS正则表达式对象" class="headerlink" title="创建JS正则表达式对象"></a>创建JS正则表达式对象</h2><ol><li><p><code>/正则表达式/修饰符</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^\d+$/mg</span>;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><code>使用构造函数</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;正则表达式的字符串形式&#x27;</span>, [修饰符])<br><span class="hljs-comment">// 例：</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;^\\d+$&#x27;</span>, <span class="hljs-string">&#x27;gm&#x27;</span>);<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw<span class="hljs-string">`^\d+$`</span>, <span class="hljs-string">&#x27;gm&#x27;</span>);<br>或<br><span class="hljs-keyword">let</span> pattern = <span class="hljs-string">&#x27;^\\d+$&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw <span class="hljs-string">`<span class="hljs-subst">$&#123;pattern&#125;</span>`</span>, <span class="hljs-string">&#x27;gm&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(reg);<br><span class="hljs-comment">// 输出👉 /^d+$/gm</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="量词元字符"><a href="#量词元字符" class="headerlink" title="量词元字符"></a>量词元字符</h2><table><thead><tr><th>元字符</th><th>匹配出现次数</th></tr></thead><tbody><tr><td><code>*</code></td><td>0到多次</td></tr><tr><td><code>+</code></td><td>1到多次</td></tr><tr><td><code>?</code></td><td>0或1次</td></tr><tr><td><code>&#123;n&#125;</code></td><td>出现n次</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>出现n到m次，包含m</td></tr><tr><td><code>&#123;n,&#125;</code></td><td>出现n到多次</td></tr></tbody></table><h2 id="特殊元字符"><a href="#特殊元字符" class="headerlink" title="特殊元字符"></a>特殊元字符</h2><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>转义符，<code>\\</code>匹配一个反斜杠</td></tr><tr><td><code>.</code></td><td>匹配除<code>\n</code>以外的任意单个字符</td></tr><tr><td><code>^</code></td><td>匹配字符串开头位置</td></tr><tr><td><code>$</code></td><td>匹配字符串结尾位置</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符</td></tr><tr><td><code>\d</code></td><td>匹配0~9之间的一个数字字符</td></tr><tr><td><code>\D</code></td><td>匹配除0~9之外的一个字符</td></tr><tr><td><code>\w</code></td><td>匹配数字、字母、下划线中的任意一个字符</td></tr><tr><td><code>\W</code></td><td>匹配除了数字、字母、下划线外的一个字符</td></tr><tr><td><code>\s</code></td><td>匹配空白字符，包括<code>\n</code>,<code>\r回车</code>,<code>\f换页</code>,<code>\t</code>,<code>\v</code>等</td></tr><tr><td><code>\S</code></td><td>匹配除空白字符以外的一个字符</td></tr><tr><td><code>\b</code></td><td>匹配单词边界位置</td></tr><tr><td><code>[xyz]</code></td><td>匹配中括号内的一个字符</td></tr><tr><td><code>[^xyz]</code></td><td>中括号内带<code>^</code>表示匹配中括号内以外的一个字符</td></tr><tr><td><code>[0-9]</code></td><td>匹配一个0~9数字，还可以写<code>[0-35-9]</code>用于排除一个数字</td></tr><tr><td><code>[a-zA-Z]</code></td><td>匹配一个英文字母，还可以写<code>[a-cD-Z]</code>等指定范围内的字母</td></tr><tr><td><code>\特殊含义字符</code></td><td><code>\.</code>匹配<code>.</code>，此外还有<code>\*</code>  <code>\+</code>  <code>\?</code> <code>\^</code> <code>\$</code> <code>\&#123;</code> <code>\&#125;</code> <code>\(</code> <code>\)</code></td></tr><tr><td>( x | y )</td><td>匹配左右中的一种规则，`</td></tr><tr><td><code>\数字num</code></td><td>匹配从左到右第num个分组</td></tr></tbody></table><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th>修饰符</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td><code>i</code></td><td>ignoreCase</td><td>忽略大小写</td></tr><tr><td><code>g</code></td><td>global</td><td>全局匹配，消除懒惰性</td></tr><tr><td><code>m</code></td><td>multiline</td><td>多行匹配，主要是修改<code>^</code>和<code>$</code>在正则表达式中的作用，让它们分别表示行首和行尾。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;This is an\n antzone good&quot;</span>;<br><span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/an$/</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//以上代码不能够匹配字符串&quot;an&quot;，尽管&quot;an&quot;后面已经换行了，但是并没有采用多行匹配，所以不是字符串行的结尾。</span><br><br><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;This is an\n antzone good&quot;</span>;<br><span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/an$/m</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//以上代码可以匹配字符串&quot;an&quot;，因为采用了多行匹配。</span><br></code></pre></td></tr></table></figure><h2 id="用括号进行分组"><a href="#用括号进行分组" class="headerlink" title="用括号进行分组"></a>用括号进行分组</h2><p><strong>使用索引进行反向引用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/&lt;([a-z]+)&gt;.*&lt;\/\1&gt;/</span>;  <span class="hljs-comment">// `\1`可以匹配第一个分组</span><br><span class="hljs-built_in">console</span>.log(reg.exec(str));<br><span class="hljs-comment">//输出👇</span><br>[<br>  <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br>  index: <span class="hljs-number">0</span>,<br>  input: <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  groups: <span class="hljs-literal">undefined</span><br>]<br></code></pre></td></tr></table></figure><p><strong>使用分组名进行反向引用</strong></p><blockquote><p>命名捕获分组自身的语法是 <code>(?&lt;name&gt;pattern)</code>，比普通的分组多了一个 <code>?&lt;name&gt; </code>字样，其中 name 的起法就和你平时起变量名一样即可（不过在这里关键字也可用）。</p><p>反向引用一个命名分组的语法是 <code>\k&lt;name&gt;</code>，注意命名分组同样可以通过数字索引来反向引用。</p><p>比如： <code>/(?&lt;foo&gt;a)\k&lt;foo&gt;\1/.test(&quot;aaa&quot;) // true</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/&lt;(?&lt;group1&gt;[a-z]+)&gt;.*&lt;\/\k&lt;group1&gt;&gt;/</span>;  <span class="hljs-comment">// \k&lt;group1&gt;可以匹配分组名为group1的分组</span><br><span class="hljs-built_in">console</span>.log(reg.exec(str));<br><span class="hljs-comment">// 输出👇</span><br>[<br>  <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-string">&#x27;div&#x27;</span>,<br>  index: <span class="hljs-number">0</span>,<br>  input: <span class="hljs-string">&#x27;&lt;div&gt;hello&lt;/div&gt;&#x27;</span>,<br>  groups: [<span class="hljs-built_in">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-attr">group1</span>: <span class="hljs-string">&#x27;div&#x27;</span> &#125; <span class="hljs-comment">// group1分组保存在了exec返回值的groups属性中</span><br>]<br></code></pre></td></tr></table></figure><h2 id="括号的更多作用"><a href="#括号的更多作用" class="headerlink" title="括号的更多作用"></a>括号的更多作用</h2><ol><li><p><strong>提高优先级</strong></p><p>特别是在与<code>|</code>配合使用时，提高优先级避免歧义。</p></li><li><p><strong>分组匹配</strong></p><p>在括号内的规则被视为一个分组，在分组捕获时能够提取到分组中的内容。</p></li><li><p><strong>只匹配不捕获</strong></p><p>即<code>(?:)</code>，只提高优先级，但不会在分组捕获时被捕获</p></li><li><p><strong>正向预查（定义指定右边界）</strong></p><p>即<code>(?=合法边界pattern)</code></p></li><li><p><strong>负向预查（定义排除右边界）</strong></p><p>即<code>(?!不合法边界pattern)</code></p></li><li><p><strong>正向预查（定义指定左边界）</strong></p><p>即<code>(?&lt;=指定边界pattern)</code></p></li><li><p><strong>逆、反向预查（定义排除左边界）</strong></p><p>即<code>(?&lt;!排除边界pattern)</code></p></li></ol><p><a href="https://www.cnblogs.com/wjw-blog/p/7526994.html">正向预查和反向预查</a></p><p>日常工作当中，大多数IDE自带的查找工作都能满足大多数需要。</p><p>加上正则匹配简直如虎添翼。匹配个邮箱，电话号什么的不在话下。有时候我们可能会遇到稍微特殊的场景。</p><p>文本：</p><p>Windows 1.03 and Windows 2.0 fisrt Released in 1985 and 1987 respectively.<br>Windows 95 and Windows 98 are the successor.<br>Then Windows 2000 and Windows Xp Windows appeared.<br>Windows Vista is the Latest version of the family.</p><p><strong>例如上面这一段话，有几个场景：</strong></p><ul><li><p>我们想匹配 Windows 后面是数字版本号的Windows 和这些字符。如 Windows 1.03 等等。</p><p>用<code>?: </code>捕获不匹配， 即 Windwos (?:[\d.]+\b)如下图，这是直接匹配结果 , 匹配出了Windows 1.03,Windows 2.0, Windows 95,Windows 98,Windows 2000,但是没有匹配到Windows Xp, Windows Vista,等</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222134739502.png" alt="image-20201222134739502"> </p></li></ul><ul><li><p>我们只想匹配满足这些条件的’Window’ ，但不包括后面的字符。</p><p>用<code>(?= pattern)</code> 即 <code>Windows (?=[\d.]+\b) </code>他把Windows的空格也匹配了。这一过程就是==正向预查==。</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222135004359.png" alt="image-20201222135004359"> </p></li></ul><ul><li><p>如果我想匹配这些Windows 字段，它==后面跟的不是数字或者版本号==，</p><p>我改用<code>(?!pattern)</code>即<code>Windows (?![\d.]+\b)</code>这一过程叫做==反向预查==, 它匹配后面跟着不满足pattern（ [\d.]+\b) 的Windows。</p></li></ul><ul><li><p>我想匹配Windows前面是数字的Windows</p><p>我们用 <code>(?&lt;=[\d].) Windows</code>这叫==正向预查定义左边界==(<code>&lt;</code>左箭头就说明了是从右往左，即负向)，他们匹配Windows==前面是一个或者多个数字==的’Windows’.</p><p>如图这里只匹配到了 和11挨着的 Windows。</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222135430010.png" alt="image-20201222135430010"> </p></li></ul><ul><li><p>我想匹配Windows前面不是数字的Windows。我想匹配 Windows 前面不是数字的Windows ，通常叫做==负向预查定义左边界==</p><p>用<code>(?&lt;![0-9.]+) Windows</code>匹配前面不是数字和<code>.</code>的<code> Windows</code>（注意前面带一个空格）</p><p><img src="/2020/12/23/JavaScript/js-regexp/image-20201222141416785.png" alt="image-20201222141416785"> </p><p>而使用<code>(?&lt;![0-9.]+\b\s\b)Windows</code>还会匹配字符串开头的Windows。</p></li></ul><blockquote><p>正向预查可以理解成 自定义右边界，这个边界位于匹配内容正向（右侧）。</p><p>负向预查可以理解成 自定义左边界，这个边界位于匹配内容的负向（左侧）。</p><p>正向、负向预查又可以分别可以定义满足条件的边界条件以及需要排除的边界情况。</p></blockquote><p><font color="red">更需要注意的是： 正向预查和反向预查不消耗字符，也不会捕获，尤其是正向预查。</font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例说明：</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/windows(?=\b\s[0-9.]+)/g</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;windows 8.1 windows&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(reg.test(str));<br><span class="hljs-built_in">console</span>.log(reg.lastIndex);<br><span class="hljs-comment">//输出👉 true</span><br><span class="hljs-comment">//输出👉 7</span><br></code></pre></td></tr></table></figure><h2 id="懒惰性"><a href="#懒惰性" class="headerlink" title="懒惰性"></a>懒惰性</h2><p>非全局匹配的正则表达式在匹配字符串时具有懒惰性，即只会匹配从左到右第一个匹配项。</p><p>解决方法：创建正则表达式时加上<code>g</code>修饰符。（此时global属性值为true）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出 👉 [&quot;123&quot;, index: 0, input: &quot;123abc321&quot;, groups: undefined]</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 加上g修饰</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出 👉 [&quot;123&quot;, ”321“]</span><br></code></pre></td></tr></table></figure><h2 id="贪婪性"><a href="#贪婪性" class="headerlink" title="贪婪性"></a>贪婪性</h2><p>存在量词元字符的正则表达式进行匹配时，会尽可能多地匹配量词前的普通/特殊元字符，此策略称为正则匹配的==贪婪性==。</p><p>取消贪婪性：在量词后面加<code>?</code>修饰量词，就会匹配最少量的普通/特殊元字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\d+?/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc321&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">//输出👉 [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span><br><br></code></pre></td></tr></table></figure><h2 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h2><ul><li><p><code>RegExp.prototype.test()</code></p><p>如果不匹配，则返回false；</p><p>如果传入的字符串匹配正则，则返回true；</p><blockquote><p>hack：test方法其实也可以用于捕获，上一条匹配的字符串保存在RegExp函数对象的lastInput属性中，上一条捕获到的匹配项保存在lastMatch属性中，捕获到的分组分别保存在$1~$9属性中，所以用test方法最多能捕获9个分组。</p></blockquote></li></ul><h2 id="正则捕获"><a href="#正则捕获" class="headerlink" title="正则捕获"></a>正则捕获</h2><ul><li><p><code>RegExp.prototype.exec()</code></p><p>如果无法匹配，则返回null；</p><p>如果匹配：</p><ul><li><p>如果this.global === false，即懒惰匹配，则返回一个数组，数组索引为0的元素是匹配到的第一个字符串，剩余索引元素为分组捕获的内容。此外该数组还具有index，input以及groups属性。</p></li><li><p>如果this.global === true，即全局匹配，则返回一个数组，该数组为基于this.lastIndex的==下一条==匹配内容，同样索引为0的是匹配到的字符串，剩余索引元素为分组捕获的内容。==当this.lastIndex大于等于字符串参数的长度时，返回null，并重置this.lastIndex =0。==</p><blockquote><p>注意：</p><p>在全局匹配下，在非必要情况下，避免直接操作RegExp对象的lastIndex属性。</p><p>非全局匹配时，修改RegExp对象的lastIndex属性不起作用，仍然懒惰地返回第一个匹配项。</p></blockquote></li></ul></li></ul><h2 id="字符串的match方法"><a href="#字符串的match方法" class="headerlink" title="字符串的match方法"></a>字符串的match方法</h2><p><strong><code>str.match(regexp)</code></strong></p><p><strong>参数</strong></p><p><strong>regexp：</strong></p><p>一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 。如果你没有给出任何参数并直接使用match() 方法 ，你会得到一 个包含空字符串的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> ：[“”] 。</p><p><strong>返回值</strong></p><ul><li><p>如果使用g标志，则将返回与完整正则表达式匹配的所有结果，但不会返回分组捕获的信息。</p></li><li><p>如果未使用g标志，则仅返回第一个完整匹配及其相关的捕获组（<code>Array</code>），即正则表达式对象exec方法返回的内容。 在这种情况下，返回的项目将具有如下所述的其他属性。</p><p>附加属性</p><ul><li><code>groups</code>: 一个捕获组数组 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>（如果没有定义命名捕获组）。</li><li><code>index</code>: 匹配的结果的开始位置</li><li><code>input</code>: 搜索的字符串.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/\&#123;([0-9]+)\&#125;/g</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#123;123&#125;abc&#123;456&#125;&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.match(reg));<br><span class="hljs-comment">// 输出👉 [ &#x27;&#123;123&#125;&#x27;, &#x27;&#123;456&#125;&#x27; ]   无法捕获分组中的数字</span><br></code></pre></td></tr></table></figure><h2 id="字符串的matchAll方法"><a href="#字符串的matchAll方法" class="headerlink" title="字符串的matchAll方法"></a>字符串的matchAll方法</h2><p><strong><code>str.matchAll(regexp)</code></strong></p><p><strong>参数</strong></p><p><strong>regexp：</strong></p><p>正则表达式对象。如果所传参数不是一个正则表达式对象，则会隐式地使用 <code>new RegExp(obj)</code> 将其转换为一个 <code>RegExp</code> 。</p><blockquote><p> RegExp必须是设置了全局模式<code>g</code>的形式，否则会抛出异常<code>TypeError</code>。</p></blockquote><p><strong>返回值</strong></p><p>一个迭代器（不可重用，结果耗尽需要再次调用方法，获取一个新的迭代器）。</p><p><strong>强大之处：</strong></p><p>使用 <code>matchAll</code> 可以通过如下方式获取分组捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> array = [...str.matchAll(regexp)];<br><br>array[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test2&#x27;, length: 4]</span><br>array[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, length: 4]</span><br></code></pre></td></tr></table></figure><p>在 <code>matchAll</code> 出现之前，通过在循环中调用 <code>regexp.exec()</code> 来获取所有匹配项信息（regexp 需使用 <code>/g</code> 标志）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<br><span class="hljs-keyword">let</span> match;<br><br><span class="hljs-keyword">while</span> ((match = regexp.exec(str)) !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Found <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span> start=<span class="hljs-subst">$&#123;match.index&#125;</span> end=<span class="hljs-subst">$&#123;regexp.lastIndex&#125;</span>.`</span>);<br>  <span class="hljs-comment">// expected output: &quot;Found football start=6 end=14.&quot;</span><br>  <span class="hljs-comment">// expected output: &quot;Found foosball start=16 end=24.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 <code>matchAll</code> ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用 <code>/g</code> 标志）。使用 <code>matchAll</code> 会得到一个迭代器的返回值，配合 <code>for...of</code>, <code>array spread</code>, 或者 <code>Array.from()</code> 可以更方便实现功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;foo[a-z]*&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;table football, foosball&#x27;</span>;<br><span class="hljs-keyword">const</span> matches = str.matchAll(regexp);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matches) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Found <span class="hljs-subst">$&#123;match[<span class="hljs-number">0</span>]&#125;</span> start=<span class="hljs-subst">$&#123;match.index&#125;</span> end=<span class="hljs-subst">$&#123;match.index + match[<span class="hljs-number">0</span>].length&#125;</span>.`</span>);<br>&#125;<br><span class="hljs-comment">// expected output: &quot;Found football start=6 end=14.&quot;</span><br><span class="hljs-comment">// expected output: &quot;Found foosball start=16 end=24.&quot;</span><br><br><span class="hljs-comment">// matches iterator is exhausted after the for..of iteration</span><br><span class="hljs-comment">// Call matchAll again to create a new iterator</span><br><span class="hljs-built_in">Array</span>.from(str.matchAll(regexp), <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// Array [ &quot;football&quot;, &quot;foosball&quot; ]</span><br></code></pre></td></tr></table></figure><p>⭐⭐<code>matchAll</code> 内部做了一个 regexp 的复制，所以不像 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec">regexp.exec</a>, <code>lastIndex</code> 在字符串扫描时不会改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> regexp = <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;[a-c]&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>);<br>regexp.lastIndex = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-built_in">Array</span>.from(str.matchAll(regexp), <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;regexp.lastIndex&#125;</span> <span class="hljs-subst">$&#123;m[<span class="hljs-number">0</span>]&#125;</span>`</span>);<span class="hljs-comment">//👈没有改变实参regexp的内容</span><br><span class="hljs-comment">// Array [ &quot;1 b&quot;, &quot;1 c&quot; ]</span><br></code></pre></td></tr></table></figure><h2 id="字符串的replace方法"><a href="#字符串的replace方法" class="headerlink" title="字符串的replace方法"></a>字符串的replace方法</h2><p><strong><code>str.replace(regexp, newSubStr | function)</code></strong></p><p><strong>参数</strong></p><ul><li><p>regexp</p><p>一个RegExp对象或者其字面量，该正则所匹配的内容会被第二个参数的返回值替换掉。</p></li><li><p>newSubStr</p><p>用于替换掉第一个参数在原字符串中的匹配部分的字符串。==该字符串中可以内插一些特殊的变量名==。</p></li><li><p>function</p><p>一个用来创建新字符串的函数，==正则匹配多少次，该函数就调用多少次==。==该函数的返回值将替换掉每次正则匹配的内容==。</p></li></ul><p><strong>返回值：</strong> 一个部分或全部匹配由替代模式所取代的新的字符串。</p><blockquote><p>如果regexp没有<code>g</code>修饰，则至多执行一次匹配替换。</p></blockquote><p><strong>特殊变量名</strong></p><table><thead><tr><th>变量名</th><th>代表的值</th></tr></thead><tbody><tr><td><code>$$</code></td><td>插入一个 “$”。</td></tr><tr><td><code>$&amp;</code></td><td>插入匹配的子串。</td></tr><tr><td>$`</td><td>插入当前匹配的子串左边的内容。</td></tr><tr><td><code>$&#39;</code></td><td>插入当前匹配的子串右边的内容。</td></tr><tr><td><code>$n</code></td><td>假如第一个参数是 <code>RegExp</code>对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串。提示：索引是从1开始。如果不存在第 n个分组，那么将会把匹配到到内容替换为字面量。比如不存在第3个分组，就会用“$3”替换匹配到的内容。</td></tr><tr><td><code>$&lt;Name&gt;</code></td><td>这里*<code>Name</code>* 是一个分组名称。如果在正则表达式中并不存在分组（或者没有匹配），这个变量将被处理为空字符串。只有在支持命名分组捕获的浏览器中才能使用。</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例1</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;2020-12-22&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/^([0-9]&#123;4&#125;)-([0-9]&#123;1,2&#125;)-([0-9]&#123;1,2&#125;)$/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&#x27;$1年$2月$3日&#x27;</span>));<br><span class="hljs-comment">//输出👉 2020年12月22日</span><br><br><span class="hljs-comment">// 还可以这样做,对分组命名再引用</span><br>reg = <span class="hljs-regexp">/^(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;1,2&#125;)-(?&lt;day&gt;[0-9]&#123;1,2&#125;)$/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&#x27;$&lt;year&gt;年$&lt;month&gt;月$&lt;day&gt;日&#x27;</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例2</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;aaa123bbb&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/[0-9]+/</span>;<br><span class="hljs-built_in">console</span>.log(str.replace(reg, <span class="hljs-string">&quot;-$`-$&#x27;-&quot;</span>));<br><span class="hljs-comment">// 输出👉 aaa-aaa-bbb-bbb</span><br></code></pre></td></tr></table></figure><blockquote><p>个人感觉：在newSubStr使用 $` 和 $’  ，一般不会配合全局匹配正则表达式使用。</p></blockquote><p><strong>在第二个参数中使用function</strong></p><p>使用<code>str.replace(regExp, function(...args) &#123;......&#125;)</code>时</p><p>function的形参分别对应regExp.exec(str)返回数组中的每一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123abc 321eee&#x27;</span>;<br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/([0-9]+)([a-z]+)/g</span>;<br>str = str.replace(reg, <span class="hljs-function">(<span class="hljs-params">matched, $<span class="hljs-number">1</span>, $<span class="hljs-number">2</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(matched);<br>    <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span>+$<span class="hljs-number">2.</span>toUpperCase()<br>&#125;);<br><span class="hljs-built_in">console</span>.log(str);<br><span class="hljs-comment">// 输出👇</span><br>123abc<br>321eee<br><span class="hljs-string">&quot;123ABC 321EEE&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="字符串的replaceAll方法"><a href="#字符串的replaceAll方法" class="headerlink" title="字符串的replaceAll方法"></a>字符串的replaceAll方法</h2><p>replaceAll方法在第一个参数为<code>RegExp对象</code>时的功能与replace方法基本一致。</p><p>但有不同点：</p><p><code>replace</code>方法的第一个参数可以没有<code>g</code>修饰，相应地最多执行一次替换操作。而<code>replaceAll</code>方法第一个参数没有<code>g</code>修饰，则会抛出异常<code>TypeError</code>。</p><h2 id="字符串的split方法"><a href="#字符串的split方法" class="headerlink" title="字符串的split方法"></a>字符串的split方法</h2><p><strong><code>str.split(regExp)</code></strong></p><p><strong>参数</strong></p><ul><li>regExp 一个正则表达式对象</li></ul><p><strong>返回值</strong></p><p>返回一个数组，数组各元素是由所有匹配到的子串分割后得到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/-+/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123-foo---bar&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.split(reg));<br><span class="hljs-comment">//输出👉 [ &#x27;123&#x27;, &#x27;fafas&#x27;, &#x27;413123&#x27; ]</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：输入到split方法中的正则表达式，在非必要情况下避免使用分组，否则可能出现意想不到的情况。</p><p>例如下面的情况：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 举例</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(-+)/</span>;<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;123-foo---bar&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(str.split(reg));<br><span class="hljs-comment">// 输出👉 [ &#x27;123&#x27;, &#x27;-&#x27;, &#x27;foo&#x27;, &#x27;---&#x27;, &#x27;bar&#x27; ] </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/23/hello-world/"/>
    <url>/2020/12/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Demo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
