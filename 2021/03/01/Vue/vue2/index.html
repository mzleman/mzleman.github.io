

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>Vue2.js进一步整理 - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Vue2.js进一步整理">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-01 15:54" pubdate>
        2021年3月1日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      33.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      460
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue2.js进一步整理</h1>
            
            <div class="markdown-body">
              <p>Vue简介</p>
<p>Vue是一个渐进式JavaScript框架。</p>
<p>高级功能和特点：</p>
<ul>
<li>解耦视图和数据</li>
<li>可复用的组件</li>
<li>前端路由技术</li>
<li>状态管理</li>
<li>虚拟DOM</li>
</ul>
<p><strong>Vue.js的Hello world</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>   <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello world&quot;</span></span><br>        &#125; <br>        &#125;);<br><span class="handlebars"><span class="xml">        <span class="hljs-comment">&lt;!-- 新建一个Vue对象，在构造函数中传入options对象--&gt;</span></span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><font size="4" color="red">Vue采用声明式编程，不同于jQuery以及原生JS操作DOM的命令式编程</font></p>
<p><img src="/./image-20200811204642611.png" srcset="/img/loading.gif" alt="image-20200811204642611"> </p>
<h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><img src="/./image-20200811163236900.png" srcset="/img/loading.gif" alt="image-20200811163236900"></p>
<h2 id="Options对象"><a href="#Options对象" class="headerlink" title="Options对象"></a>Options对象</h2><ul>
<li><p><strong>el：</strong></p>
<p>类型：string | HTMLElement</p>
<p>作用：决定Vue实例会管理哪一个DOM对象</p>
</li>
<li><p><strong>data：</strong></p>
<p>类型：Object | Function</p>
<p>作用：Vue实例对应的数据对象</p>
</li>
<li><p><strong>methods</strong>：</p>
<p>类型：｛key : Function｝</p>
<p>作用：定义属于Vue实例的一些方法，可以在其他地方调用，也可以在指令中使用。</p>
</li>
<li><p><strong>computed：</strong></p>
<p>计算属性</p>
<p>类型：{key : Function}</p>
<p>作用：定义一些计算属性值供使用。<font color="red">计算属性具有缓存机制，如果计算属性使用的数据没有被修改，则计算属性不会计算多次，当访问该计算属性时，直接从缓存中取值。</font></p>
<p>==由于缓存机制的存在，当页面中显示的内容只是需要对数据进行简单变换时，尽量使用计算属性，而不是使用函数计算==</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>书籍购物车的总价格:&#123;&#123;totalPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">	<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">		el:<span class="hljs-string">&quot;h2&quot;</span>,</span><br>		data:&#123;<br>			books:[<br><span class="javascript">				&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;代码大全&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">20</span>&#125;,</span><br><span class="javascript">				&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;现代操作系统&#x27;</span>,<span class="hljs-attr">price</span>:<span class="hljs-number">50</span>&#125;</span><br>			]<br>		&#125;,<br>		computed:&#123;<br><span class="javascript">			totalPrice:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>    		&#125;<br>            /*<br>            也可以使用ES6方法的简写<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">totalPrice</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            	<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;</span><br>                    pre+=cur.price;<br><span class="javascript">                    <span class="hljs-keyword">return</span> pre;</span><br>                &#125;,0);<br>            &#125;<br>            */<br>		&#125;<br>	&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><font color='red'>computed中的计算属性底层的原理 可能 是使用了Proxy</font></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">comuputed:&#123;<br>    <span class="hljs-comment">//totalPrice:handler</span><br>    totalPrice:&#123;<br>        get&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.books.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br>                    pre+=cur.price;<br>                    <span class="hljs-keyword">return</span> pre;<br>                   &#125;,<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//get:function()&#123;....&#125;</span><br>        <span class="hljs-comment">//还可以设置set方法</span><br>    &#125;<br>&#125;<span class="hljs-comment">//这种写法同样可以。</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>filters：</strong></p>
<p>类型：Function</p>
<p>作用：允许传入一个value，对该值进行过滤或附加处理，返回新的值。</p>
<p>使用： value | filterFunctionName </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;grade | assessment&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br>data:&#123;<br>	grade:&#x27;A&#x27;<br>&#125;<br>filters:&#123;<br>	assessment(value)&#123;<br>		if(value===&#x27;A&#x27;) return &#x27;优秀&#x27;;<br>		else   return &#x27;其他&#x27;;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="/./image-20200819182643832.png" srcset="/img/loading.gif" alt="image-20200819182643832"> </p>
</li>
<li><p><strong>components</strong>：</p>
<p>类型：Object</p>
<p>作用：定义局部组件</p>
</li>
<li><p><strong>watch：</strong></p>
<p>类型：Object</p>
<p>作用：监听data中的数据以及props中的通信属性的变化。</p>
</li>
<li><p><strong>生命周期函数</strong>：</p>
<p>如：beforeCreate、created、Mounted、Destroyed…..</p>
</li>
</ul>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><img src="/./lifecycle.png" srcset="/img/loading.gif"> </p>
<h2 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;,Mazheng<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--Mustache语法不仅仅可以写变量，还可以写表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27;&#x27; + lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--另一种写法,不会忽略语法变量之间的空格，会忽略语法变量两端的空格--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> <br>    <br>    <br>    <span class="hljs-comment">&lt;!--数值表达式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>总价：&#123;&#123;price * 2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="文本指令"><a href="#文本指令" class="headerlink" title="文本指令"></a>文本指令</h3><ol>
<li><p><strong>v-once</strong> </p>
<p>布尔属性，数据渲染一次后就不再保持绑定，内容不会再随数据改变。</p>
</li>
<li><p><strong>v-html</strong></p>
<p>v-html=”==data==”，会将字符串类型的字面量、变量或表达式当做html内容进行渲染。</p>
<p>（覆盖标签内原有的内容）。</p>
</li>
<li><p>**v-text **</p>
<p>v-text=”==data==”，会将字符串类型的字面量、变量或表达式作为使用该指令的dom元素的文本（覆盖标签内原有的内容）。</p>
</li>
<li><p><strong>v-pre</strong></p>
<p>v-pre布尔指令，会将标签中包裹的内容原原本本的展示。（忽略mustache语法）</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span>hahaha<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-comment">&lt;!--会覆盖hahaha v-text不如mustache语法灵活--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>引入vue<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">	<span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">       el:<span class="hljs-string">&quot;#app&quot;</span>,</span><br>       data:&#123;<br><span class="handlebars"><span class="xml">           message:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&quot;</span></span><br>       &#125; <br>    &#125;);<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h3><p>防止闪动</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span>&#123;<br>	<span class="hljs-attribute">display</span>:none;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">v-cloak</span>&gt;</span><br>	<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--  在vue解析后会将v-cloak属性去掉  --&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h3><pre><code>v-bind指令用于将DOM元素的属性值与数据绑定。

语法糖 ==使用冒号代替v-bind==</code></pre>
<h4 id="动态绑定a-href属性与img-src属性"><a href="#动态绑定a-href属性与img-src属性" class="headerlink" title="动态绑定a:href属性与img:src属性"></a>动态绑定a:href属性与img:src属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">div#app<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgURL&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">img</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-comment">&lt;!--语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;aHref&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>div#app<br><br>app=new Vue(&#123;<br>	el:&quot;#app&quot;,<br>	data:&#123;<br>		imgURL:https://XXXXX.img,<br>		aHref:https://www.baidu.com<br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="动态绑定HTML元素的class属性"><a href="#动态绑定HTML元素的class属性" class="headerlink" title="动态绑定HTML元素的class属性"></a>动态绑定HTML元素的class属性</h4><ul>
<li><p><strong>对象写法</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;属性名1:boolean,属性名2:boolean&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--与既有的class属性共存,v-bind使用语法糖写法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>👇<br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;red active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--isLine为false--&gt;</span><br><br><span class="hljs-comment">&lt;!--v-bind:class取函数返回值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-comment">&lt;!--总之,v-bind绑定class的对象写法，属性值的形式为 &quot;Obeject&quot;  --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            isActive:<span class="hljs-literal">true</span>,</span><br><span class="javascript">            isLine:<span class="hljs-literal">false</span></span><br>        &#125;<br>        <br>        methods:&#123;<br>        	getClasses ()&#123;<br><span class="javascript">        		<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">active</span>:<span class="hljs-built_in">this</span>.isActive,<span class="hljs-attr">line</span>:<span class="hljs-built_in">this</span>.isLine&#125;;<span class="hljs-comment">//返回一个对象</span></span><br>    		&#125;<br>    	&#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><strong>数组写法</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"> <span class="hljs-comment">&lt;!--语法--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>  <span class="hljs-comment">&lt;!--list为一个含有字符串类型元素的数组--&gt;</span><br> <br> <span class="hljs-comment">&lt;!--例子--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#x27;class1&#x27;,&#x27;class2&#x27;,...&#x27;classN&#x27;]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;getClasses()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[classObj, ...list]&quot;</span>&gt;</span>  <span class="hljs-comment">&lt;!--👈 数组写法中嵌套对象写法 --&gt;</span><br> data:&#123;<br> 	class1:&#x27;active&#x27;,<br> 	class2:&#x27;red&#x27;<br> 	list: [&#x27;className1&#x27;, &#x27;className2&#x27;],<br> 	classObj: &#123;<br> 	  active: true,<br> 	&#125;<br> &#125;<br> <br> methods:&#123;<br>getClasses()&#123;<br> 		return [this.class1,this.class2];<br> 	&#125;<br> &#125;<br></code></pre></td></tr></table></figure>




</li>
</ul>
<ul>
<li><p><strong>应用在子组件标签上</strong></p>
<p>在子组件标签上的class类名会合并到子组件的根标签上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;cpn class&#x3D;&quot;cpn&quot; :class&#x3D;&quot;[&#39;active&#39;]&quot;&#x2F;&gt;<br><br>&lt;!-- 如果cpn组件的根标签是一个div元素，则类名&#96;cpn&#96;和&#96;active&#96;都会添加到该div元素上 --&gt;<br></code></pre></td></tr></table></figure>




</li>
</ul>
<h4 id="动态绑定内联样式"><a href="#动态绑定内联样式" class="headerlink" title="动态绑定内联样式"></a>动态绑定内联样式</h4><ul>
<li><p>对象写法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;css属性名:属性值(string类型)...&#125;&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     css属性名只能使用驼峰命名法!!!!!!</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;color:&#x27;red&#x27;,fontSize:&#x27;16px&#x27;&#125;&quot;</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;backgroundColor:backColor&#125;&quot;</span>&gt;</span><br>    <br>    new Vue(&#123;<br>    	el:&#x27;#app&#x27;,<br>    	data:&#123;<br>    		backColor:&#x27;#fff&#x27;	<br>    	&#125;<br>    &#125;)<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>数组写法（是基于对象写法）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">基本语法        </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...Obejects]&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">例：     </span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[style1,style2]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;[...styles]&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <br><br>    new Vue(&#123;<br>    	el:&#x27;#app&#x27;,<br>    	data:&#123;<br>    		style1:&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,<br>    		style2:&#123;color:&#x27;red&#x27;&#125;<br>			styles:[&#123;backgroundColor:&#x27;#bfa&#x27;&#125;,&#123;color:&#x27;red&#x27;&#125;]<br>    	&#125;<br>    &#125;)<br></code></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h3 id="v-on-事件监听"><a href="#v-on-事件监听" class="headerlink" title="v-on 事件监听"></a>v-on 事件监听</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>   v-on:==事件名.修饰符== =”函数/单句表达式/Object”</p>
<p>  语法糖   ==用@代替v-on== </p>
   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;count--&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrease&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>	el:&quot;#app&quot;,<br>	data:&#123;<br>		count=0<br>	&#125;<br>	methods=&#123;<br>		add()&#123;<br>			this.count++;<br>		&#125;,<br>		decrease()&#123;<br>			this.count--;<br>		&#125;<br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="事件响应函数的传参"><a href="#事件响应函数的传参" class="headerlink" title="事件响应函数的传参"></a>事件响应函数的传参</h4>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <br>    <br>    <span class="hljs-comment">&lt;!--实参和形参匹配时的正常调用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf&quot;</span>&gt;</span>没有实参和形参,当函数不带参数时，可省略括号<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;printf()&quot;</span>&gt;</span>没有实参和形参<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;y-printf(&quot;</span><span class="hljs-attr">hello</span>&quot;,&quot; <span class="hljs-attr">world</span>!&quot;)&quot;&gt;</span>处理两个参数<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--实参和形参不匹配时的处理策略--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf(123)&quot;</span>&gt;</span>有形参，输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=123--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf&quot;</span>&gt;</span>有形参，但不输入实参，且不带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=$event,会把事件对象当做第一个参数传入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf()&quot;</span>&gt;</span>有形参，但不输入实参，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   <br>    <span class="hljs-comment">&lt;!--val=undefined--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x-printf($event)&quot;</span>&gt;</span>有形参，输入实参$event，带括号调用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!--val=$event 强制输入事件对象--&gt;</span><br>       <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><br>new Vue(&#123;<br>	el:&quot;#app&quot;,<br>	data:&#123;<br>		count=0<br>	&#125;<br>	methods=&#123;<br>		printf()&#123;<br>			console.log(&quot;hello world&quot;);<br>		&#125;,<br>		x-printf(val)&#123;<br>			console.log(val);<br>		&#125;<br>		y-printf(val,event)&#123;<br>			console.log(val,event);<br>		&#125;<br>	&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="多事件处理"><a href="#多事件处理" class="headerlink" title="多事件处理"></a>多事件处理</h4><p>当对某个原生事件设置多个事件监听器，则需要显示地调用这些监听器。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这两个 one() 和 two() 将执行按钮点击事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;one($event); two($event)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 👈 分号分割了两个JS语句，分别执行两个函数 --&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br>methods: &#123;<br>  <span class="hljs-function"><span class="hljs-title">one</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-comment">// first handler logic...</span><br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">two</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    <span class="hljs-comment">// second handler logic...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul>
<li><p><code>.stop</code>  </p>
<p>中断事件的传播，常用于取消事件冒泡。</p>
<p>@click.stop=”==fun==”</p>
<blockquote>
<p>❗ 某些事件的默认行为发生在冒泡后，但取消冒泡并不会阻止默认行为的发生。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>.capture</code></p>
<p>响应函数在捕获阶段执行。</p>
</li>
</ul>
<ul>
<li><p><code>.self</code></p>
<p>  只当在 event.target 是当前元素自身时触发处理函数。</p>
</li>
</ul>
<ul>
<li><p><code>.prevent</code> </p>
<p>取消默认行为（例如a标签的click跳转、summit的click提交表单、form表单submit事件的http请求）。</p>
</li>
</ul>
<ul>
<li><p><code>.native </code>    </p>
<p> 用在组件标签上，监听组件根元素的原生DOM事件</p>
</li>
</ul>
<ul>
<li><p><code>.once </code> 只触发一次该事件</p>
<p>@click.once=”==fun==”</p>
</li>
</ul>
<ul>
<li><p><code>.passive</code></p>
<p>  passive这个修饰符会执行默认方法。你们可能会问，明明默认执行为什么会设置这样一个修饰符。这就要说一下这个修饰符的本意了。</p>
<pre><code>【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】</code></pre>
</li>
</ul>
<pre><code>  通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上**passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。**

  这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度。</code></pre>
<blockquote>
<p><strong>注：passive和prevent冲突，不能同时绑定在一个监听器上。</strong></p>
</blockquote>
<h4 id="键盘按键修饰符"><a href="#键盘按键修饰符" class="headerlink" title="键盘按键修饰符"></a>键盘按键修饰符</h4><p><code>@keyup</code>和<code>@keydown</code>事件可以使用以下修饰符。</p>
<ul>
<li><p><code>.enter</code></p>
<p>例如<code>@keyup.enter=&quot;xxx&quot;</code>表示控制当回车键松开时的行为</p>
<p>例如<code>@keydown.enter=&quot;xxx&quot;</code>表示控制当回车键按下时的行为</p>
<blockquote>
<p>此外还支持键名数字代号的修饰符，同按键别名同效果，如<code>.13</code> 等价于<code>.enter</code>。</p>
</blockquote>
</li>
</ul>
<p>此外还有：</p>
<ul>
<li><code>.tab</code></li>
</ul>
<ul>
<li><code>.delete</code> “删除”和“退格”键</li>
<li><code>.esc</code></li>
<li><code>.space</code> 空格键</li>
<li><code>.up</code> 上箭头</li>
<li><code>.down</code> 下箭头</li>
<li><code>.left</code> 左箭头</li>
<li><code>.right</code> 右箭头</li>
</ul>
<p>系统按键：</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>提示</p>
<p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。</p>
<p>注意：在 Mac 系统键盘上，<code>meta</code> 对应 <code>command </code>键 (<code>⌘</code>)。在 Windows 系统键盘 <code>meta</code> 对应<code>Windows</code>徽标键 (<code>⊞</code>)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p>
</blockquote>
<ul>
<li><p><code>.exact</code></p>
<p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h4><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符用来修饰点击事件，如<code>click</code>、<code>dbclick</code>，会限制处理函数仅响应特定的鼠标按钮。</p>
<h3 id="指令的动态参数"><a href="#指令的动态参数" class="headerlink" title="指令的动态参数"></a>指令的动态参数</h3><p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。<br>--&gt;<br>&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>
<p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p>
<p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>
<p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<blockquote>
<p>除了<code>v-bind</code>和<code>v-on</code>以外，<code>v-slot</code>指令可以设置参数，因此也可以使用到动态参数。详情见插槽相关内容。</p>
</blockquote>
<h4 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h4><p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</p>
<h4 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h4><p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这会触发一个编译警告 --&gt;<br>&lt;a v-bind:[&#39;foo&#39; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>
<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!--<br>在 DOM 中使用模板时这段代码会被转换为 &#96;v-bind:[someattr]&#96;。<br>除非在实例中有一个名为“someattr”的 property，否则代码不会工作。<br>--&gt;<br>&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;<br></code></pre></td></tr></table></figure>
<h3 id="v-if-条件渲染"><a href="#v-if-条件渲染" class="headerlink" title="v-if 条件渲染"></a>v-if 条件渲染</h3><p><strong>具有条件判断指令的标签，如果逻辑条件不符合，不会存在于DOM树中</strong> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;score&gt;=90&quot;</span>&gt;</span><br>    成绩：优秀<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;score&gt;=60&quot;</span>&gt;</span><br>    成绩：及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    成绩：不及格<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>    成绩:&#123;&#123;grade&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>data:&#123;<br>	score:70<br>&#125;<br>computed:&#123;<br>	grade()&#123;<br>		if(this.score&gt;=90) return &quot;优秀&quot;;<br>		else if (this.score&gt;=60) return &quot;及格&quot;;<br>		else return &quot;不及格&quot;;<br>	&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>


<h4 id="在-lt-template-gt-元素上使用-v-if"><a href="#在-lt-template-gt-元素上使用-v-if" class="headerlink" title="在 &lt;template&gt; 元素上使用 v-if"></a>在 <code>&lt;template&gt;</code> 元素上使用 <code>v-if</code></h4><p>因为 <code>v-if</code> 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。<strong>最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>




<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>v-show=”false”时，标签存在于DOM树中，但会添加内联样式 display:none</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>当需要在显示与隐藏之间切换很频繁时，使用v-show指令</p>
</li>
<li><p>当只有一次切换，或元素互斥存在时，使用v-if</p>
</li>
</ul>
<hr>
<h3 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h3><h4 id="遍历数组元素和对象属性"><a href="#遍历数组元素和对象属性" class="headerlink" title="遍历数组元素和对象属性"></a>遍历数组元素和对象属性</h4><p>可以使用v-for指令遍历数组和JS普通对象。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--根据需要，在Vue里可以使用类似&quot;元祖&quot;的语法遍历数组的元素及索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>&gt;</span>&#123;&#123; `$&#123;index&#125;.$&#123;item&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- ❗ 这里的index从1开始，而非0开始。--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--遍历对象的属性值、属性名及属性名的索引--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val,key,index) in obj&quot;</span>&gt;</span>&#123;&#123; `$&#123;key&#125;:$&#123;val&#125;` &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><font color="red">在v-for绑定的数据可能存在动态修改的情况时（如动态增加删除一个元素），建议为标签添加一个key属性，key的属性值应能唯一标识数据中的各个元素。添加key属性可以提高dom动态渲染性能。</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item.text&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p>==Vue是响应式的，当数据变化时，Vue会检测到数据的变化，并反应到视图上。==</p>
<p>==我们常用v-for指令绑定数组数据，Vue中包含了一组观察数组变化的方法。==</p>
<p>==当调用数组某些方法改变元素时，会触发视图的更新==</p>
<pre><code>包括：所有改变数组自身的方法(Vue中拦截了pop,push,unshift,shift, sort,reverse, splice这七种)

注意：使用下标改变数组元素的方法不会被Vue监听到，&lt;font color=&quot;red&quot;&gt;数据会发生改变，但视图不会发生改变。&lt;/font&gt;

❌  lis[0]=xxx;

✔  Vue.set(lis,&#39;0&#39;,xxx)    **使用Vue的set方法改变对象的属性值会被检测到，并反应到视图上**</code></pre>
<hr>
<h4 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h4><p>某些特殊情况下，给Data中的响应式数组重新赋值，可能比修改数组的部分元素来的更高效。</p>
<p>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>map()</code>、<code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。当使用非变更方法时，可以用新数组替换旧数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>    &lt;li v-for&#x3D;&quot;item in ls&quot;&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br><br>&lt;script&gt;<br>    &#x2F;&#x2F;...<br>    methods: &#123;<br>        update() &#123;<br>            ls &#x3D; ls.map(() &#x3D;&gt; &#123;&#x2F;*....*&#x2F;&#125;);<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>


<h4 id="在-v-for-里使用值的范围"><a href="#在-v-for-里使用值的范围" class="headerlink" title="在 v-for 里使用值的范围"></a>在 v-for 里使用值的范围</h4><p><code>v-for</code> 也可以接受整数。在这种情况下，它会把模板重复对应次数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;range&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- ❗ 类似的，这n的索引值仍然从1开始，而非从0开始 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><img src="/./image-20210511201311023.png" srcset="/img/loading.gif" alt="image-20210511201311023"></p>
<h4 id="在-lt-template-gt-中使用-v-for"><a href="#在-lt-template-gt-中使用-v-for" class="headerlink" title="在 &lt;template&gt;中使用 v-for"></a>在 &lt;template&gt;中使用 v-for</h4><p>类似于 <code>v-if</code>，你也可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 来循环渲染一段包含多个元素的内容。比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;divider&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;presentation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h4 id="在组件标签上使用-v-for"><a href="#在组件标签上使用-v-for" class="headerlink" title="在组件标签上使用 v-for"></a>在组件标签上使用 v-for</h4><p>在自定义组件上，你可以像在任何普通元素上一样使用 <code>v-for</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 props：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;my-component<br>  v-for=&quot;(item, index) in items&quot;<br>  :item=&quot;item&quot;<br>  :index=&quot;index&quot;<br>  :key=&quot;item.id&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure>




<h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>==要求：当点击一个li时，该li的color为红色，其他为默认颜色==</p>
<p><img src="/./image-20200816153838359.png" srcset="/img/loading.gif" alt="image-20200816153838359"> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.active</span>&#123;</span><br>            color: red;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in lis&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;active:currentIndex===index&#125;&quot;</span></span><br><span class="hljs-tag">             @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;beActive(index)&quot;</span></span><br><span class="hljs-tag">         &gt;</span><br>         &#123;&#123;`$&#123;index&#125;.$&#123;item&#125;`&#125;&#125;<br>         <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                lis:[<span class="hljs-string">&#x27;mazheng&#x27;</span>,<span class="hljs-string">&#x27;ley&#x27;</span>],</span><br><span class="javascript">                currentIndex:<span class="hljs-number">0</span>         <span class="hljs-comment">//使用currentIndex记录上次点击的元素索引</span></span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">beActive</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.currentIndex=index;</span><br>                &#125;<br>            &#125;<br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><img src="/./image-20200816171940331.png" srcset="/img/loading.gif" alt="image-20200816171940331"> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        table&#123;<br>            width: 600px;<br>            border-collapse: collapse;<br>        &#125;<br>        th,td&#123;<br><span class="css">            <span class="hljs-selector-tag">padding</span><span class="hljs-selector-pseudo">:5px</span> 10<span class="hljs-selector-tag">px</span>;</span><br>            text-align: left;<br>            border: 1px black solid;<br>        &#125;<br>        th&#123;<br>            background-color: silver;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>书籍名称<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>出版日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>购买数量<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>操作<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in books&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>《&#123;&#123;item.title&#125;&#125;》<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;item.releaseDate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> &#123;&#123;item.price | showPrice&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-comment">&lt;!--当书籍数量小于等于1时，按钮不可用--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;item.num &lt;= 1&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decOne(index)&quot;</span>&gt;</span><br>                            -<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                        &#123;&#123;item.num&#125;&#125;<br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addOne(index)&quot;</span>&gt;</span><br>                            +<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;removeBook(index)&quot;</span>&gt;</span><br>                            移除<br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br>                books:[<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;算法导论&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-06&#x27;</span>,</span><br>                        price:85,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;UNIX编程艺术&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2006-02&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;,<br>                    &#123;<br><span class="javascript">                        title:<span class="hljs-string">&#x27;代码大全&#x27;</span>,</span><br><span class="javascript">                        releaseDate:<span class="hljs-string">&#x27;2008-10&#x27;</span>,</span><br>                        price:59,<br>                        num:1<br>                    &#125;<br>                ]<br>            &#125;,<br><span class="javascript">            filters:&#123;  <span class="hljs-comment">//过滤器。跟计算属性类似，但是调用的方法不太一样</span></span><br><span class="handlebars"><span class="xml">                //<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span> | showPrice&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>     使用&quot; | &quot;调用过滤器,左边为参数</span></span><br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">showPrice</span>(<span class="hljs-params">price</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">return</span> <span class="hljs-string">`￥<span class="hljs-subst">$&#123;price.toFixed(<span class="hljs-number">2</span>)&#125;</span>`</span>;</span><br>                &#125;<br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">addOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num+=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">decOne</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books[index].num-=<span class="hljs-number">1</span>;</span><br>                &#125;,<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">removeBook</span>(<span class="hljs-params">index</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.books.splice(index,<span class="hljs-number">1</span>);</span><br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>主要用于实现表单元素的<strong>双向数据绑定</strong>。绑定的数据主要用于自定义的ajax请求，也可以供其他功能使用。</p>
<p>v-model其实是一个语法糖，它的背后本质是包含两个操作：</p>
<ol>
<li>监听表单元素的特征事件，如input、change，根据情况更新绑定的数据。</li>
<li>监测数据的变化，更新表单元素的属性值，如value、checked。</li>
</ol>
<blockquote>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> property 和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> property 和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//使用两个命令的组合实现input标签的v-model的功能<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;message=$event.target.value&quot;</span>&gt;</span><br><br>data:&#123;<br>	message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="文本类表单项-text-textarea"><a href="#文本类表单项-text-textarea" class="headerlink" title="文本类表单项 (text/textarea)"></a>文本类表单项 (text/textarea)</h4><p>将input的value和message变量进行绑定。文本框改变value，message的值也随之改变。改变message的值，文本框中的内容也随之改变。（双向绑定）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">//只使用v-model绑定数据，但不使用name标识表单元素，这种表单元素不会被表单提交（因为没有name属性）<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><br>data:&#123;<br>	message:&#x27;&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>textarea标签与input标签类似可以使用v-model指令实现上述功能</p>
</blockquote>
<h4 id="单选按钮-radio"><a href="#单选按钮-radio" class="headerlink" title="单选按钮 (radio)"></a>单选按钮 (radio)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--应当为每个单选按钮设置value属性--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;radioVal&quot;</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--这类没有name属性的radio不会随表单提交--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">	radioVal:<span class="hljs-number">0</span>   <span class="hljs-comment">// 初始值为0，代表默认第一个按钮选中。数字、字符串都可以。</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>双向数据绑定思路:</strong></p>
<ol>
<li><p>初次渲染时，如果v-model绑定的数组与该radio的value相同，则该radio会被选中，否则不被选中（所以要求radio标签必须有value属性）。</p>
<p>radio元素通过代码选中的方式为设置该元素的checked为true，例如 <code>radioELem.checked = true;</code>，取消选中为<code>radioElem.checked = false</code>。</p>
</li>
<li><p>监听change事件<font color='red'>，需要注意的是在DOM中，radio的change事件只有在该radio从为选中变为选中状态时才会发出，而当radio从选中到非选中状态，是不会产生change事件的，这一点很关键。</font>所以当某个radio产生change事件时，只需要将v-model绑定的响应式数据赋值为该radio的value即可，而不需要关注另一个变为非选中状态的radio。</p>
<p>❓ 修改v-model绑定的数据是否会触发视图更新？</p>
</li>
</ol>
<h4 id="复选框-checkbox"><a href="#复选框-checkbox" class="headerlink" title="复选框 (checkbox)"></a>复选框 (checkbox)</h4><ul>
<li><p>单个复选框，宜使用v-model绑定一个bool类型的变量</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isChecked&quot;</span>&gt;</span><br>//当选中时，isChecked值会为true,不选中时为false<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>data:&#123;<br><span class="javascript">	isChecked: <span class="hljs-literal">false</span>   <span class="hljs-comment">//isChecked默认值设为false，代表默认不选中</span></span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>双向绑定思路：</p>
<ol>
<li><p>渲染时，如果checkbox标签使用v-model数据绑定的是<strong>非数组类型</strong>（假设为<code>isCheck</code>），则数据绑定到一个单个复选框，当作单选按钮使用。如果<code>isCheck</code>是<code>truthy</code>，则该checkbox会被选中。</p>
</li>
<li><p>设置change事件监听器，事件的回调函数直接执行语句：<code>isCheck = !!!isCheck</code>，直接取反布尔值。</p>
<p>change事件表示checkbox切换状态，由选中=&gt; 不选中 或 不选中 =&gt; 选中，change事件由click事件触发。</p>
</li>
</ol>
<p>注意：</p>
<p>所以强烈建议<code>isCheck</code>初始时就是一个<strong>Boolean类型</strong>的数据，否则当用户没有切换该单个复选框，isCheck会保持原类型并作为Ajax请求的一部分。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data:&#123;<br>	isChecked: &#123;&#125;   <span class="hljs-comment">/** isChecked默认值设为&#123;&#125;，表现为该复选框被选中。一旦用户没有切换该复选框的状态，则isChecked的值会一直保持为&#123;&#125;，如果存在Ajax请求，后端接口规定isChecked字段为一个布尔值，而此时isChecked的字段值却为一个对象发送到后端，这显然会出现错误。 */</span><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
</ul>
<ul>
<li><p>多个复选框（绑定同一个数据），宜使用v-model绑定一个<strong>空数组,**或</strong>具有初始值的数组**。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      data:&#123;<br><span class="javascript">          balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>] <span class="hljs-comment">//默认选中第一个复选框</span></span><br>      &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in origins&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span>&gt;</span> &#123;&#123;item&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      data:&#123;<br>          balls:[],<br><span class="javascript">          origins:[<span class="hljs-string">&#x27;basketball&#x27;</span>,<span class="hljs-string">&#x27;football&#x27;</span>,<span class="hljs-string">&#x27;badminton&#x27;</span>]<span class="hljs-comment">//从后台获取</span></span><br>      &#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>双向数据绑定思路：</strong></p>
<ol>
<li>初次渲染时，如果检测出checkbox中v-model绑定的数据是<strong>数组类型</strong>（假设为<code>checkboxVals</code>），则认为该数据绑定到多个checkbox，作为复选框使用。<strong>每个checkbox必须设置value属性</strong>，如果<code>checkboxVals</code>数组中含有该value，则该checkbox默认被选中，<code>checkBoxElem.checked = true</code>。</li>
<li>设置change事件监听器。响应函数主要逻辑为：如果<code>checkboxVals</code>含有该checkbox的value，则从数组中删除该value，如果数组中不含有该checkbox的value，则将value添加到数组中。</li>
</ol>
<p><strong>注意点：</strong></p>
<ol>
<li><p>checkbox标签中使用v-model属性，会使标签中的checked属性失效。复选框是否<strong>默认</strong>选中，只与v-model绑定的初始数据有关。</p>
</li>
<li><p>v-model绑定的数组指定初始元素，以表示默认选中的复选框，但初始元素的值应出自默认选中复选框的value。因为checkbox取消选中时只会删除数组中的响应value，而不会删除不存在于所有复选框value中的其他值。即初始化数组时，初始元素若不存在于所有value中，则会始终存在于绑定的数组里。</p>
</li>
</ol>
</li>
</ul>
<h4 id="选择框-select"><a href="#选择框-select" class="headerlink" title="选择框 (select)"></a>选择框 (select)</h4><p><strong>一、单选select</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 单选select标签没有multiple属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ball&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        ball:<span class="hljs-string">&quot;basketball&quot;</span></span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>双向数据绑定思路：</strong></p>
<p>前提：select标签没有multipe属性。</p>
<ol>
<li>渲染时，将v-model绑定的值赋值给select标签的value。</li>
<li>监听select的change事件，将select标签的value属性赋值给v-model绑定的数据。</li>
</ol>
<p><a href="">Vue官方文档案例</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-model-select&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>Please select one<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.createApp(&#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      selected: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;).mount(<span class="hljs-string">&#x27;#v-model-select&#x27;</span>)<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 <code>change</code> 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p>
</blockquote>
<p><strong>二、多选select</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--多选select,添加multiple布尔属性--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;balls&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;basketball&quot;</span>&gt;</span>篮球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;football&quot;</span>&gt;</span>足球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;badminton&quot;</span>&gt;</span>羽毛球<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    data:&#123;<br><span class="javascript">        balls:[<span class="hljs-string">&#x27;basketball&#x27;</span>]</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>双向数据绑定思路：</strong></p>
<p>前提：select标签有multiple属性。</p>
<ol>
<li><p>渲染时，如果option的value包含在v-model绑定的数组内，则该option的selected属性设置为true，如<code>optionElem.selected = true</code>。</p>
</li>
<li><p>设置select标签的change事件监听器，响应函数的主要逻辑是：遍历select标签的options，如果option的selected属性为true，如果数组中没有该value，则添加该value；</p>
<p>如果option的selected属性为false，如果数组中有该value，则删除该value。</p>
<blockquote>
<p>select标签的options属性可以访问到所有子option，，如<code>selecElm.options</code>，该属性值为一个伪数组<code>HTMLOptionsCollection</code>。</p>
</blockquote>
</li>
</ol>
<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p><a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/guide/forms.html#%E5%80%BC%E7%BB%91%E5%AE%9A">Vue3官方文档-值绑定</a></p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><ol>
<li><p>lazy修饰符，常与input text标签使用</p>
<p>作用：让标签在失去焦点或在input中敲回车时才更新数据</p>
<p>（默认情况下，v-model是在input事件发生时立刻更新数据，lazy可以减少更新次数）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>number修饰符，常与input text标签使用</p>
<p>作用：获取input text标签内的value，转为number类型后再更新数据，即v-model绑定的数据会是number类型</p>
<p>（input text的value永远是string类型）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;marks&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>trim修饰符，常与input Text标签使用</p>
<p>作用：获取input text的value，去除首尾的空格后再更新数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>





</li>
</ol>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p><img src="/./image-20200817190948735.png" srcset="/img/loading.gif" alt="image-20200817190948735"></p>
<p><img src="/./image-20200818104015488.png" srcset="/img/loading.gif" alt="image-20200818104015488">  </p>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><img src="/./image-20200818104048034.png" srcset="/img/loading.gif" alt="image-20200818104048034">  </p>
<p>全局组件可以在多个不同的Vue实例中使用。但<font color="red">Vue实例才是根组件</font>，因为全局组件必须在Vue实例中才能使用。</p>
<ol>
<li><p><strong>调用Vue.extend()方法<font color="red">创建组件构造器</font></strong></p>
<p>👇</p>
<ol start="2">
<li><strong>调用Vue.component()方法<font color="red">注册组件</font></strong></li>
</ol>
<p>👇</p>
<ol start="3">
<li><strong>在Vue实例或其他组件内<font color="red">使用组件</font></strong></li>
</ol>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--全局组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用全局组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>        <br><span class="javascript">        <span class="hljs-comment">//---------------------------------------------------------</span></span><br>        <br><span class="javascript"> 		<span class="hljs-comment">//创建组件构造器对象</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> cpnC=Vue.extend(option);  <span class="hljs-comment">//传入该对象，创建组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//注册全局组件，注册后cpn标签就可以在vue的实例以及各个组件内使用了</span></span><br>        <br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,cpnC);<span class="hljs-comment">//注册全局组件。第一个参数是组件标签名，第二个参数是组件构造器</span></span><br>        <br><span class="javascript">        <span class="hljs-comment">//----------------------------------------------------------</span></span><br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>        &#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-comment">&lt;!--注册全局组件的简写方式--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> P element <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">          &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">      <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>          template:template<br>      &#125;<br>      <br><span class="javascript">Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,option); <span class="hljs-comment">//将extendOptions对象直接传入，而不是组件构造器对象</span></span><br>      <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure>




<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ol>
<li><p>创建模板</p>
<p>👇</p>
</li>
<li><p>创建extendOptions对象</p>
<p>👇</p>
</li>
<li><p>在Vue实例或父组件中注册</p>
<p>👇</p>
</li>
<li><p>在Vue实例或父组件中使用</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--局部组件的demo--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>   <span class="hljs-comment">&lt;!--在Vue实例中使用局部组件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--再次使用--&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> template=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>P element<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="javascript">            &lt;<span class="hljs-regexp">/div&gt;   `;               /</span><span class="hljs-regexp">/创建组件模板</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> option=&#123;                 <span class="hljs-comment">//创建extendOptions对象</span></span><br>            template:template<br>        &#125;;<br>        <br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span></span><br>            components:&#123;<br><span class="javascript">            	cpn:option            <span class="hljs-comment">//在components属性中注册组件</span></span><br>        	&#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>




<h3 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h3><p><font color="red">子组件本质上就是局部组件</font></p>
<p><font color="red">祖先组件和后代组件之间不能越级使用，除非后代组件在祖先组件中注册过</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn1</span>&gt;</span> <span class="hljs-comment">&lt;!--父组件的使用--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>    <br><span class="javascript">	<span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript">	<span class="hljs-keyword">let</span> temp2=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`;</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn2=Vue.extend(&#123;</span><br>        template:temp2<br>    &#125;);<br>    <br><span class="javascript">	<span class="hljs-comment">//创建子组件的构造器对象</span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> temp1=<span class="hljs-string">`</span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span>  <span class="hljs-comment">&lt;!--子组件的使用--&gt;</span>  </span></span><br><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   `;        </span></span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=Vue.extend(&#123;</span><br>        template:temp1,<br>        components:&#123;<br>            cpn2<br>        &#125;<br>    &#125;);<br><br><br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br><span class="javascript">            cpn1     <span class="hljs-comment">//挂载cpn1父组件</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--使用传入extendOptions直接注册组件--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> cpn1=&#123;</span><br>        template:`<br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                <span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`,</span></span><br>        components:&#123;<br>            cpn2:&#123;<br>                template:`<br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>`</span></span><br>            &#125;<br>        &#125;<br>    &#125;;<br>    <br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        components:&#123;<br>            cpn1<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="模板的抽离"><a href="#模板的抽离" class="headerlink" title="模板的抽离"></a>模板的抽离</h3><ol>
<li><p>第一种写法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/x-template&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp1&quot;</span>&gt;</span><br><span class="handlebars"><span class="xml">	<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">		<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><br><span class="handlebars"><span class="xml">	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp1&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>第二种写法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是组件的模板<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>,&#123;</span><br><span class="javascript">        template:<span class="hljs-string">&#x27;#temp2&#x27;</span>    <span class="hljs-comment">//使用id选择器</span></span><br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h3><p>组件拥有自己的数据，组件中<strong>不能直接访问</strong>父级组件以及子组件的数据。</p>
<p>组件的extendOptions中的data属性的属性值必须是Function，这个Function是一个工厂函数，返回一个对象，对象中包含组件自己的数据。</p>
<p>（利用工厂函数的特点，即每次返回一个新的包含数据的对象，来防止相同组件数据相互干扰）</p>
<p><img src="/./image-20200818150856104.png" srcset="/img/loading.gif" alt="image-20200818150856104"> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">        Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">            template: <span class="hljs-string">&#x27;#temp2&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">            data: <span class="hljs-function">() =&gt;</span> (&#123;  <span class="hljs-comment">//用小括号把返回的对象扩起来，防止解析成代码块</span></span><br><span class="javascript">                message: <span class="hljs-string">&#x27;hello world&#x27;</span></span><br>            &#125;)<br>        &#125;)<br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                message:<span class="hljs-string">&#x27;hello Vue&#x27;</span></span><br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>




<h3 id="父子组件之间的通信-props-emit"><a href="#父子组件之间的通信-props-emit" class="headerlink" title="父子组件之间的通信 props/$emit"></a>父子组件之间的通信 props/$emit</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p><strong>一、基本使用</strong></p>
<p>子组件的props属性挂载通信属性，父组件使用子组件时，在子组件标签中使用v-bind为通信属性绑定父组件的数据，在子组件中通信属性的同名变量就获取到了父组件传来的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:message-c</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;time&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--   驼峰命名法→连字符   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;today&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;console.log(messageC)&quot;</span>&gt;</span>通信<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,   <span class="hljs-comment">//使用id选择器</span></span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            <br>        &#125;),<br><span class="javascript">        props:[<span class="hljs-string">&#x27;messageC&#x27;</span>,<span class="hljs-string">&#x27;today&#x27;</span>]</span><br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;<br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><font color="red">由于dom标签中不区分大小写，当props挂载的通信属性名有大写字母时，应注意：</font></p>
<ol>
<li><p>使用驼峰命名法时（第一个字符小写，后面单词首字母大写），v-bind绑定的组件标签属性的属性名使用<strong>连字符写法</strong>。例如，上面的demo中 messageC   ,在绑定该属性时使用了  v-bind:message-c 。若子组件属性标签中绑定”messageC”，则默认传的通信属性实际为 “messagec”。</p>
</li>
<li><p>若通信属性第一个字母大写，则v-bind绑定的子元素标签属性名第一个字母大小写都可以。</p>
</li>
</ol>
<p><u>归纳：通信属性名第一个字母不要大写，尽量使用一个单词命名通信属性。若使用驼峰命名法，v-bind绑定时在大写字母前使用连字符。</u></p>
<p><strong>二、子组件定义props的写法</strong></p>
<ol>
<li><p>数组写法</p>
<p>由于数组写法功能没有对象写法强大，所以较少使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">props:[&#x27;messageC&#x27;,&#x27;today&#x27;]<br></code></pre></td></tr></table></figure></li>
<li><p>对象写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//指定通信属性的类型  type</span><br>props:&#123;<br>    messageC: <span class="hljs-built_in">String</span>,<br>    today: <span class="hljs-built_in">String</span>,<br>    age: <span class="hljs-built_in">Number</span>,<br>    books: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>], <span class="hljs-comment">//指定Array或String类型</span><br>    owner: <span class="hljs-built_in">Object</span><br>&#125;<br><br><span class="hljs-comment">//指定默认值  default 当指定Object以及Array类型的默认值时，default应是一个工厂函数返回默认值</span><br><span class="hljs-comment">//要想子组件在一开始时使用default中的默认值，则父组件传来的数据初始值应为undefinded</span><br>props:&#123;<br>    messageC:&#123;<br>        type: <span class="hljs-built_in">String</span>,<br>        <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;hello wolrd&#x27;</span><br>    &#125;<br>    books:&#123;<br>        type: [<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">String</span>]<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>    &#125;<br>    owner:&#123;<br>        type: <span class="hljs-built_in">Object</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指定必须传入 required</span><br>props:&#123;<br>    books:&#123;<br>        type: <span class="hljs-built_in">Array</span>,<br>        <span class="hljs-function"><span class="hljs-title">default</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> [];<br>        &#125;<br>        required: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//自定义验证函数 validator</span><br><br></code></pre></td></tr></table></figure>


</li>
</ol>
<p><strong>三、父级组件向子组件prop传入数据</strong></p>
<p>假设父组件App向子组件 BlogPost的传入数据。</p>
<p>▲ <strong>传入静态数据</strong>：</p>
<ol>
<li>```vue<br><blog-post :likes="42"></blog-post> 👈 传入一个数字<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>2. ```html<br>   <span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Hello world&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> 👈 传入一个字符串<br>   <span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;&#x27;Hello world&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> 👈 传入一个字符串<br></code></pre></td></tr></table></figure></li>
<li>```html<br><blog-post :is-published="false"></blog-post> 👈 传入一个布尔值<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br><span class="hljs-number">4</span>. ```html<br>   &lt;blog-post <span class="hljs-symbol">:comment-ids=<span class="hljs-string">&quot;[234, 266, 273]&quot;</span>&gt;&lt;/blog-post&gt;</span> 👈 传入一个数组<br></code></pre></td></tr></table></figure></li>
<li><pre><code class="html">&lt;blog-post
  :author=&quot;&#123;
    name: &#39;Veronica&#39;,
    company: &#39;Veridian Dynamics&#39;
  &#125;&quot;
&gt;&lt;/blog-post&gt; 👈 传入一个对象
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><br>&gt; 即便传入的是一个静态数据，当这个数据为一个<span class="hljs-type">JS</span>值或表达式时，仍然需要使用v-bind绑定该prop后再赋值。<br><br><br><br>▲ **传入动态数据**：<br><br>所谓传入动态数据，就是向子组件prop传入一个父组件的响应式数据（<span class="hljs-class"><span class="hljs-keyword">data</span>、prop、computed中的内容都可以）。写法上和传入静态的<span class="hljs-type">JS</span>表达式并没有太多区别，**但有一种简便的写法，可以传入一个响应式对象数据的所有属性：**</span><br><br>```js<br><span class="hljs-class"><span class="hljs-keyword">data</span>() &#123;</span><br><span class="hljs-class">	<span class="hljs-title">return</span> &#123;</span><br><span class="hljs-class">        <span class="hljs-title">post</span>: &#123;</span><br><span class="hljs-class">            <span class="hljs-title">id</span>: 1,</span><br><span class="hljs-class">            <span class="hljs-title">title</span>: &#x27;<span class="hljs-type">My</span> <span class="hljs-type">Journey</span> <span class="hljs-title">with</span> <span class="hljs-type">Vue</span>&#x27;</span><br><span class="hljs-class">      &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
下面的模板：
</code></pre>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span> ⭐⭐<br></code></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blog-post</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;post.id&quot;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;post.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">blog-post</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p><strong>四、单向数据流</strong></p>
<p>props属性挂载的通信属性（变量），从设计的初衷来看，应该是只读属性。所以在组件里避免有代码可以修改通信属性的值。</p>
<ul>
<li><p>如果子组件内需要修改父组件传入的prop的值，则最好定义一个本地的 data property并将这个prop作为其初始值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">props: [<span class="hljs-string">&#x27;initialCounter&#x27;</span>],<br><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    counter: <span class="hljs-built_in">this</span>.initialCounter<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">props: [<span class="hljs-string">&#x27;size&#x27;</span>],<br>computed: &#123;<br>  normalizedSize: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size.trim().toLowerCase()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>需要注意：在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身<strong>将会</strong>影响到父组件的状态。</p>
</blockquote>
</li>
</ul>
<p><strong>五、类型检查</strong></p>
<p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<blockquote>
<p>父组件向子组件任何类型的prop传入<code>undefined</code>或<code>null</code>都能通过类型检查。</p>
</blockquote>
<p>额外的，<code>type</code> 还可以是一个<strong>自定义的构造函数</strong>，并且通过 <code>instanceof</code> 来进行检查确认，验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。例如，给定下列现成的构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName<br>  <span class="hljs-built_in">this</span>.lastName = lastName<br>&#125;<br></code></pre></td></tr></table></figure>
<p>你可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;blog-post&#x27;</span>, &#123;<br>  props: &#123;<br>    author: Person<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<p><strong>六、prop验证函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义验证函数</span><br>propF: &#123;<br>    validator: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].indexOf(value) !== -<span class="hljs-number">1</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>
<p>当 prop 验证失败的时候（validator返回false），(开发环境构建版本的) Vue 将会产生一个**<font color="orange">控制台的警告</font>**。👈 不是报错。</p>
<h4 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h4><p><strong>一、基本使用</strong></p>
<ol>
<li><p>子组件监听DOM事件（如click），在事件响应函数中处理逻辑，然后通过<code>vm.$emit</code>发射自定义事件并传入通信数据。</p>
</li>
<li><p>父组件在子组件的标签内监听自定义事件并接收通信数据。自定义事件的响应函数不需要传参。</p>
</li>
</ol>
<p>**二、关于自定义事件命名 ❗ **</p>
<p>不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 <code>v-on</code> 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)。</p>
<p><font color='red'>所以Vue推荐始终使用 kebab-case (下划线格式)的事件名。</font></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">click-li</span>=<span class="hljs-string">&quot;getClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span>  <span class="hljs-comment">&lt;!--  父组件监听子组件的自定义事件clickli   --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in categories&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;myClick(item.id,item.name)&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--事件响应函数--&gt;</span><br>            &#123;&#123;item.name&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">//注册组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;cpn&#x27;</span>, &#123;</span><br><span class="javascript">        template: <span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">        data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>            categories:[<br>                &#123;<br>                    id:1,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;mz&#x27;</span></span><br>                &#125;,<br>                &#123;<br>                    id:2,<br><span class="javascript">                    name:<span class="hljs-string">&#x27;ley&#x27;</span></span><br>                &#125;<br>            ]<br>        &#125;),<br><span class="javascript">        <span class="hljs-comment">// 👇 可以显式地定义这个组件会向外发射的事件，这是可选的。</span></span><br><span class="javascript">        emits: [<span class="hljs-string">&#x27;clickli&#x27;</span>],</span><br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">myClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;click-li&#x27;</span>,id,name);  <span class="hljs-comment">//发生自定义事件，这里传入了两个通信数据id和name。</span></span><br>            &#125;<br>        &#125;<br>    &#125;)<br><span class="javascript">    <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&#x27;hello Vue&#x27;</span>,</span><br><span class="javascript">            time:<span class="hljs-string">&#x27;2020-08-18&#x27;</span></span><br>        &#125;,<br>        methods:&#123;<br><span class="javascript">            <span class="hljs-function"><span class="hljs-title">getClick</span>(<span class="hljs-params">id,name</span>)</span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(id,name);</span><br>            &#125;<br>        &#125;<br>        <br>    &#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p><strong>三、$event</strong></p>
<p>子组件自定义事件不存在事件对象，但父组件监听子组件的事件时，也可以访问$event，该参数的值是子组件发射事件时的第一个参数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> @<span class="hljs-attr">clickli</span>=<span class="hljs-string">&quot;getClick, printEvent($event)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>所以强烈建议在使用<code>vm.$emit(&#39;event-name&#39;)</code>时，如果需要传递信息给父组件，尽量使用一个参数。如果有多个参数要传递，则宜使用<code>payload</code>对象的形式，将所有参数由一个对象返回：<code>vm.$emit(&#39;event-name&#39;, &#123;...&#125;)</code>。</p>
<h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p>实现父子组件之间的双向通信。</p>
<p>在父组件的输入框输入要传递的数据，在子组件的文本框显示。</p>
<p>在子组件的输入框输入要传递的数据，在父组件的文本框显示。</p>
<p>在子组件的watch属性中定义要监听的数据的同名函数，以监听子组件数据的变化，并发送给父组件。</p>
<p><img src="/./image-20200819181030339.png" srcset="/img/loading.gif" alt="image-20200819181030339"> </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            向子传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>            子组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;ctoday&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:today</span>=<span class="hljs-string">&quot;today&quot;</span> @<span class="hljs-attr">cinput</span>=<span class="hljs-string">&quot;getCtoday&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;temp&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>                向父传递输入框：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;inputDate&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--懒监听--&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                父组件传来的数据：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">readonly</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;today&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> app=<span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">            el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>            data:&#123;<br><span class="javascript">                today:<span class="hljs-string">&#x27;2020-08-19&#x27;</span>,</span><br><span class="javascript">                ctoday:<span class="hljs-string">&#x27;&#x27;</span>,</span><br>            &#125;,<br>            methods:&#123;<br><span class="javascript">                <span class="hljs-function"><span class="hljs-title">getCtoday</span>(<span class="hljs-params">value</span>)</span>&#123;</span><br><span class="javascript">                    <span class="hljs-built_in">this</span>.ctoday=value;</span><br>                &#125;<br>            &#125;,<br>            components:&#123;<br>                cpn:&#123;<br><span class="javascript">                    template:<span class="hljs-string">&#x27;#temp&#x27;</span>,</span><br><span class="javascript">                    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                        <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">                            inputDate:<span class="hljs-string">&#x27;&#x27;</span></span><br>                        &#125;<br>                    &#125;,<br>                    props:&#123;<br>                        today:&#123;<br><span class="javascript">                            type:<span class="hljs-built_in">String</span></span><br>                        &#125;<br>                    &#125;,<br>                    watch:&#123;<br><span class="javascript">                        <span class="hljs-comment">//在watch中定义inputDate的同名函数，监听该数据的变化，处理逻辑</span></span><br><span class="javascript">                        <span class="hljs-function"><span class="hljs-title">inputDate</span>(<span class="hljs-params">newValue,oldValue</span>)</span>&#123; </span><br><span class="javascript">                            <span class="hljs-built_in">console</span>.log(oldValue,<span class="hljs-string">&#x27;=&gt;&#x27;</span>,newValue);</span><br><span class="javascript">                            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;cinput&#x27;</span>,newValue);</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="父子组件间的双向数据绑定"><a href="#父子组件间的双向数据绑定" class="headerlink" title="父子组件间的双向数据绑定"></a>父子组件间的双向数据绑定</h3><h4 id="组件的v-model"><a href="#组件的v-model" class="headerlink" title="组件的v-model"></a>组件的v-model</h4><p>组件的响应式数据可以和原生的DOM标签（如input:text, checkbox等）发送双向数据绑定。</p>
<p>而Vue提供了一种更加强大的功能，能够让父级组件的响应式数据和子组件的prop发生双向数据绑定，但这需要父级组件和子级组件之间的配合来实现。</p>
<blockquote>
<p>其实这没有什么神奇的地方，其实我们也可以通过已知的内容来实现：</p>
<ol>
<li>父组件向子组件的prop传入数据。</li>
<li>当子组件需要改变prop的值从而与父级组件产生联系时，不直接修改prop，而通过发出一个特殊名字的自定义事件，提醒父级组件更新数据。</li>
<li>父组件收到子组件的更新提醒，更新那个绑定到子组件prop的数据。</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">Vue2 自定义组件的v-model</a></p>
<p><strong>例子：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 定义子组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;button @click&#x3D;&quot;buttonClick&quot; &gt;触发自定义事件&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#39;HelloWorld&#39;,<br>  &#x2F;* ⭐ model option *&#x2F;  <br>  model: &#123;  <br>    prop: &#39;childDate&#39;, &#x2F;&#x2F; 👈 显示地定义v-model绑定到的prop名<br>    event: &#39;change&#39;, &#x2F;&#x2F; 👈 更新该prop的自定义事件名<br>  &#125;,<br>  &#x2F;* ⭐ props option 配合model option中的prop *&#x2F;  <br>  props: &#123;<br>    childDate: Date, &#x2F;&#x2F; 👈 必须在props中定义在model中规定的propName<br>  &#125;,<br>  methods: &#123;<br>    buttonClick() &#123;<br>      this.$emit(&#39;change&#39;, new Date()); &#x2F;&#x2F; 👈 触发自定义事件change，告知父组件更新v-model绑定到的值<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;!-- 定义父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;&quot; id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;p&gt;日期 &#123;&#123; date &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;HelloWorld v-model&#x3D;&quot;date&quot;&#x2F;&gt; 👈 &lt;!-- 一旦子组件触发了change event，则父级组件更新date的值 --&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    HelloWorld,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      date: new Date(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗ <strong>如果子组件不定义model option：</strong><br>         1. model.prop默认为 ‘value’<br>         2. model.event默认为 ‘input’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 不设置model的子组件，同样可以具备更新父级组件v-model数据的功能 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;hello&quot;&gt;<br>    &lt;button @click&#x3D;&quot;buttonClick&quot; &gt;触发自定义事件&lt;&#x2F;button&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#39;HelloWorld&#39;,<br>  props: &#123;<br>    value: Date,<br>  &#125;,<br>  methods: &#123;<br>    buttonClick() &#123;<br>      this.$emit(&#39;input&#39;, new Date()); &#x2F;&#x2F; 👈 发出input事件，并且传回一个payload( new Date )<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;!-- 定义父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class&#x3D;&quot;&quot; id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;p&gt;日期 &#123;&#123; date &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;HelloWorld v-model&#x3D;&quot;date&quot;&#x2F;&gt; 👈 &lt;!--一旦子组件触发了input event，则父级组件更新date的值为payload --&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloWorld from &#39;.&#x2F;components&#x2F;HelloWorld.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    HelloWorld,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      date: new Date(),<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>




<h4 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h4><p>👆<font color='red'> 在Vue2中强烈 推荐使用，而不是使用v-model，可以用于开发基础组件</font>。</p>
<p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件都没有明显的变更来源。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:title&#x27;</span>, newTitle)<br></code></pre></td></tr></table></figure>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document<br>  v-bind:title&#x3D;&quot;doc.title&quot;<br>  v-on:update:title&#x3D;&quot;doc.title &#x3D; $event&quot;<br>&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure>


<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document v-bind:title.sync&#x3D;&quot;doc.title&quot;&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 <code>v-model</code>。</p>
</blockquote>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;text-document v-bind.sync&#x3D;&quot;doc&quot;&gt;&lt;&#x2F;text-document&gt;<br></code></pre></td></tr></table></figure>
<p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<blockquote>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”&#123; title: doc.title &#125;”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h4 id="Vue3的改变"><a href="#Vue3的改变" class="headerlink" title="Vue3的改变"></a>Vue3的改变</h4><p><strong>1.</strong> <strong>支持对自定义事件的payload进行验证</strong></p>
<p>与 prop 类型验证类似，如果使用对象语法而不是数组语法定义发出的事件，则可以验证它。</p>
<p>要添加验证，将为事件分配一个函数，该函数接收传递给 <code>$emit</code> 调用的参数，并返回一个布尔值以指示事件是否有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">app.component(<span class="hljs-string">&#x27;custom-form&#x27;</span>, &#123;<br>  emits: &#123;<br>    <span class="hljs-comment">// 没有验证</span><br>    click: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-comment">// 验证submit 事件</span><br>    submit: <span class="hljs-function">(<span class="hljs-params">&#123; email, password &#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (email &amp;&amp; password) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;Invalid submit event payload!&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">submitForm</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;submit&#x27;</span>, &#123; email, password &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<p><strong>2. 默认的v-model prop 和 event发生改变</strong></p>
<p>在Vue2中可以定义子组件的<code>model option</code>，规定当父级组件使用在子组件标签上使用v-model指令时的行为。</p>
<p>Vue2中默认的<code>model option</code>设置是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">model: &#123;<br>    prop: <span class="hljs-string">&#x27;value&#x27;</span>,<br>    event: <span class="hljs-string">&#x27;input&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而Vue3中”规定“了<code>model option</code>的设置是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">model: &#123;<br>    prop: <span class="hljs-string">&#x27;modelValue&#x27;</span>,<br>    event: <span class="hljs-string">&#x27;update:modelValue&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时：</p>
<ol>
<li>Vue3中定义<code>model option</code>不再起效果。</li>
<li>子组件发出<code>$emit(&#39;update:modelValue&#39;, payload)</code>成为父子组件之间的双向数据绑定的默认方式。</li>
<li><code>modelValue</code>成为子组件的功能型prop，不是隐含的，如果需要v-model功能时，也必须在props中定义。</li>
</ol>
<p><strong>3.</strong> <strong>组件标签上的v-model语法的增强，替代 .sync 修饰符</strong></p>
<p><font color='red'>Vue3中已经不再使用.sync修饰符。</font></p>
<p>现在可以使用<code>v-model:prop=&quot;fatherData&quot;</code>语法代替<code>:propName.sync=&quot;fatherData&quot;</code>语法。</p>
<p>我们现在可以在单个组件实例上创建一个或多个 v-model 绑定。</p>
<p>每个 v-model 将同步到不同的 prop，而不需要在组件中添加额外的选项：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;user-name<br>  v-model:first-name=&quot;firstName&quot;<br>  v-model:last-name=&quot;lastName&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">user-name</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = Vue.createApp(&#123;&#125;)<br><br>app.component(<span class="hljs-string">&#x27;user-name&#x27;</span>, &#123;<br>  props: &#123;<br>    firstName: <span class="hljs-built_in">String</span>,<br>    lastName: <span class="hljs-built_in">String</span><br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input </span><br><span class="hljs-string">      type=&quot;text&quot;</span><br><span class="hljs-string">      :value=&quot;firstName&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      type=&quot;text&quot;</span><br><span class="hljs-string">      :value=&quot;lastName&quot;</span><br><span class="hljs-string">      @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>



<h3 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个非 prop 的 attribute 是指传向一个子组件，但是该子组件<strong>并没有相应 prop 定义的 attribute</strong>。</p>
<p>因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，<strong>而这些 attribute 会被添加到这个组件的根元素上。</strong></p>
<p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>&lt;bootstrap-date-input&gt;</code> 组件，这个插件需要在其 <code>&lt;input&gt;</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">&lt;bootstrap-<span class="hljs-built_in">date</span>-<span class="hljs-built_in">input</span> data-<span class="hljs-built_in">date</span>-picker=<span class="hljs-string">&quot;activated&quot;</span>&gt;&lt;/bootstrap-<span class="hljs-built_in">date</span>-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure>
<p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
<h4 id="替换-合并根标签已有的Attribute"><a href="#替换-合并根标签已有的Attribute" class="headerlink" title="替换 / 合并根标签已有的Attribute"></a>替换 / 合并根标签已有的Attribute</h4><p>想象一下 <code>&lt;bootstrap-date-input&gt;</code> 的模板是这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span></span>=<span class="hljs-string">&quot;date&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;form-control&quot;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;bootstrap-<span class="hljs-type">date</span>-<span class="hljs-keyword">input</span><br>  data-<span class="hljs-type">date</span>-picker=&quot;activated&quot;<br>  <span class="hljs-keyword">class</span>=&quot;date-picker-theme-dark&quot;<br>&gt;&lt;/bootstrap-<span class="hljs-type">date</span>-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure>
<p>在这种情况下，我们定义了两个不同的 <code>class</code> 的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p><strong>对于绝大多数 attribute 来说</strong>，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！</p>
<p><strong>庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，</strong>即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
<h4 id="禁用attribute继承"><a href="#禁用attribute继承" class="headerlink" title="禁用attribute继承"></a>禁用attribute继承</h4><p>如果你<strong>不</strong>希望组件的根元素继承 attribute，你可以在组件的选项中设置 <code>inheritAttrs: false</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  inheritAttrs: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这尤其适合配合实例的 <code>$attrs</code> property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  required: <span class="hljs-literal">true</span>,<br>  placeholder: <span class="hljs-string">&#x27;Enter your username&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D-%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">基础组件</a>的时候是常会用到的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;base-input&#x27;</span>, &#123;<br>  inheritAttrs: <span class="hljs-literal">false</span>,<br>  props: [<span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>],<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;label&gt;</span><br><span class="hljs-string">      &#123;&#123; label &#125;&#125;</span><br><span class="hljs-string">      &lt;input</span><br><span class="hljs-string">        v-bind=&quot;$attrs&quot;              👈 $attrs中所有的属性都会被绑定到该标签上</span><br><span class="hljs-string">        v-bind:value=&quot;value&quot;</span><br><span class="hljs-string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span><br><span class="hljs-string">      &gt;</span><br><span class="hljs-string">    &lt;/label&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗ <strong>注意：</strong><code>inheritAttrs: false</code> 选项<strong>不会</strong>影响 <code>style</code> 和 <code>class</code> 的绑定。在子组件根标签上的<code>class</code>和<code>style</code>属性仍然会合并到子组件的根标签上。</p>
</blockquote>
<h4 id="和Vue3中的区别"><a href="#和Vue3中的区别" class="headerlink" title="和Vue3中的区别"></a>和Vue3中的区别</h4><p><strong>1</strong>. <strong>定义上的区别</strong></p>
<p>Vue3对非prop的attribute的定义：一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 <a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/guide/component-props">props</a> 或 <a target="_blank" rel="noopener" href="https://vue3js.cn/docs/zh/guide/component-custom-events.html#defining-custom-events">emits</a> 定义的 attribute。常见的示例包括 <code>class</code>、<code>style</code> 和 <code>id</code> 属性。</p>
<blockquote>
<p>Vue3中允许在组件选项中定义emits这个option，显示地表明该组件会发出哪些自定义事件。</p>
</blockquote>
<p><strong>2</strong>. <strong>Vue3允许组件模板有多个根节点</strong></p>
<p>与单个根节点组件不同，具有多个根节点的组件不具有自动 attribute 回退行为。<strong>如果组件模板有多个根节点，同时模板中未显式绑定 <code>$attrs</code>，将发出运行时警告。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-layout</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;custom-layout&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeValue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这将发出警告</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br><br><span class="hljs-comment">// 没有警告，$attrs被传递到&lt;main&gt;元素</span><br>app.component(<span class="hljs-string">&#x27;custom-layout&#x27;</span>, &#123;<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="hljs-string">    &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="hljs-string">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="hljs-string">  `</span><br>&#125;)<br></code></pre></td></tr></table></figure>






<h3 id="父子组件间的直接访问-children-parent"><a href="#父子组件间的直接访问-children-parent" class="headerlink" title="父子组件间的直接访问 $children/$parent"></a>父子组件间的直接访问 $children/$parent</h3><p>==一、父组件直接访问子组件==</p>
<p>在父组件中，可以通过this.$children或this.$refs拿到所有子组件。</p>
<ul>
<li><p>$children属性是一个数组，可以像this.$children[index]的型式通过下标拿到子组件对象。（不常用）</p>
</li>
<li><p>$refs属性是一个对象，子组件标签中设置ref属性标识自己，父组件可以通过this.$refs[ref]的形式获取特定的子组件对象。（更常用）</p>
</li>
</ul>
<p>可访问到的子组件内容：几乎所有内容（数据、方法）。</p>
<p>==二、子组件直接访问父组件==</p>
<p>在子组件中，可以通过this.$parent拿到父组件对象。</p>
<p>同时可以使用this.$root直接拿到Vue实例对象。（Vue实例是根组件）</p>
<p>由于组件之间耦合度不应该太高，所以很少在子组件中访问父组件。</p>
<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h3><p><strong>一、provide</strong></p>
<p>父级组件向自己以及后代组件提供（provide）共享的数据。</p>
<p>语法：</p>
<ol>
<li>```js<br>provide: {<pre><code>provideData1: &#39;hello world&#39;</code></pre>
}<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">2</span>. ```<span class="hljs-selector-tag">js</span><br>   <span class="hljs-selector-tag">provide</span>() &#123;<br>       <span class="hljs-selector-tag">return</span> &#123;<br>           <span class="hljs-attribute">provideData1</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>,<br>           <span class="hljs-attribute">provideData2</span>: &#123; <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attribute">age</span>: <span class="hljs-number">24</span> &#125;,<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>```js<br>data() {<br>  return {<pre><code>  shared: &#123;
      state1: &#39;xxx&#39;,
      state2: &#39;foo&#39;
  &#125;,
  info: &#39;bar&#39;,</code></pre>
  }<br>},<br>provide() {<pre><code>return &#123;
    provideData1: &#39;hello world&#39;,
    provideData2: &#123; name: &#39;mz&#39;, age: 24 &#125;,
    shared: this.shared, // 👈 提供一个响应式的引用类型数据
    info: this.info, // 👈 提供一个响应式的基本类型数据，后代组件对其应该是只读的。
&#125;</code></pre>
}<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs"><br>   <br><br>**二、inject**<br><br>后代组件定义inject，从而获取到祖先组件实例上提供的内容。<br><br>语法：<br><br>1. ```js<br>   inject: [&#x27;provideData1&#x27;, &#x27;provideData2&#x27;]<br></code></pre></td></tr></table></figure></li>
<li><pre><code class="js">inject: &#123;
    data1: &#39;provideData1&#39;,
    data2: &#39;provideData2&#39;
&#125;
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-number">3</span>. ```js<br>   <span class="hljs-keyword">inject</span>: &#123;<br>       data1: &#123;<br>           <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;provideData1&#x27;</span>,<br>           <span class="hljs-keyword">default</span>: <span class="hljs-number">123</span>,<br>       &#125;<br>       data2: &#123;<br>           <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;provideData2&#x27;</span>,<br>           <span class="hljs-keyword">default</span>() &#123;<br>               <span class="hljs-keyword">return</span> &#123;&#125;;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<blockquote>
<p>注意点：</p>
<ol>
<li>非顶级组件（Vue实例）定义provide时，必须是函数形式，函数返回一个对象，对象内是提供的数据。</li>
<li>provide的内容可以是基本类型的数据，也可以是引用类型的数据。</li>
<li>provide的内容可以是响应式的，也可以是非响应式的（推荐使用响应式的）。</li>
<li>当provide的数据是非响应式的，或者是基本类型的数据时，后代组件在inject中获取该数据后，避免对其进行修改（这种provide的数据应该是只读的）。</li>
</ol>
</blockquote>
<p><strong>三、案例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 定义provide的父级组件 --&gt;<br>&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;.&#x2F;assets&#x2F;logo.png&quot;&gt;<br>    &lt;hr&gt;<br>    &lt;child-1 &#x2F;&gt;<br>    &lt;hr&gt;<br>    &lt;child-2 &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import Child1 from &#39;.&#x2F;components&#x2F;Child1.vue&#39;;<br>import Child2 from &#39;.&#x2F;components&#x2F;Child2.vue&#39;;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  components: &#123;<br>    Child1,<br>    Child2,<br>  &#125;,<br>  data() &#123;<br>    return &#123;<br>      colorReactive: &#39;red&#39;,<br>      styleReactive: &#123;<br>        color: &#39;red&#39;,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>  &#x2F;&#x2F; 👇 向后代组件提供四种类型的数据<br>  provide() &#123;<br>    return &#123;<br>      styleReactive: this.styleReactive, &#x2F;&#x2F; 响应式的引用类型数据<br>      colorReactive: this.colorReactive, &#x2F;&#x2F; 响应式的基本类型数据<br>      color: &#39;red&#39;, &#x2F;&#x2F; 非响应式的基本类型数据<br>      style: &#123; &#x2F;&#x2F; 非响应式的引用类型数据<br>        color: &#39;red&#39;,<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* MethodsMixin */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  methods: &#123;<br>    <span class="hljs-function"><span class="hljs-title">updateColor</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateStyle</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.style.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.style.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>      <span class="hljs-comment">// this.$forceUpdate();</span><br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateColorReactive</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.colorReactive === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.colorReactive = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.colorReactive = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">updateStyleReactive</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.styleReactive.color === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>        <span class="hljs-built_in">this</span>.styleReactive.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.styleReactive.color = <span class="hljs-string">&#x27;red&#x27;</span>;<br>      &#125;<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 后代组件Child1 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;Child1&lt;&#x2F;h2&gt;<br>    &lt;ul&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;父组件provide的基本类型数据: &#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;style&quot;&gt;父组件provide的引用类型数据: &#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColorReactive&quot;&gt;updateColorReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color: colorReactive &#125;&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; colorReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>    &lt;&#x2F;ul&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import sharedMethods from &#39;.&#x2F;sharedMethods&#39;;<br><br>export default &#123;<br>  name: &#39;Child1&#39;,<br>  inject: [&#39;color&#39;, &#39;style&#39;, &#39;colorReactive&#39;, &#39;styleReactive&#39;],<br>  mixins: [sharedMethods],<br>  data() &#123;<br>    return &#123;<br>      &#x2F;&#x2F; styleData: this.style, &#x2F;&#x2F; 👈 在data中引用inject的数据会对该数据进行响应式化，变为第四种情况<br>    &#125;;<br>  &#125;,<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br></code></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 后代组件Child2 --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h2&gt;Child2&lt;&#x2F;h2&gt;<br>    &lt;ul&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColor&quot;&gt;updateColor&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color &#125;&quot;&gt;父组件provide的基本类型数据: &#123;&#123; color &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyle&quot;&gt;updateStyle&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;style&quot;&gt;父组件provide的引用类型数据: &#123;&#123; style &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateColorReactive&quot;&gt;updateColorReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;&#123; color: colorReactive &#125;&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; colorReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>      &lt;li&gt;<br>        &lt;button @click&#x3D;&quot;updateStyleReactive&quot;&gt;updateStyleReactive&lt;&#x2F;button&gt;<br>        &lt;span :style&#x3D;&quot;styleReactive&quot;&gt;父组件provide的基本类型响应式数据: &#123;&#123; styleReactive &#125;&#125;&lt;&#x2F;span&gt;<br>      &lt;&#x2F;li&gt;<br>    &lt;&#x2F;ul&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import sharedMethods from &#39;.&#x2F;sharedMethods&#39;;<br><br>export default &#123;<br>  name: &#39;Child2&#39;,<br>  inject: [&#39;color&#39;, &#39;style&#39;, &#39;colorReactive&#39;, &#39;styleReactive&#39;],<br>  mixins: [sharedMethods],<br>&#125;;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br><br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>简单分析：</p>
<ol>
<li><p>父组件提供非响应式的基本类型数据，当在子组件中使用inject获取该数据（例如foo），在子组件中修改该数据的值时（如this.foo = …），这个操作会触发子组件更新，但不会影响其他使用foo的组件。</p>
</li>
<li><p>父组件提供非响应式的引用类型数据，子组件使用inject获取该数据（例如obj），并且修改该引用类型数据的内容时（如this.obj.foo = …），既不会触发子组件的视图更新，也不会影响其他使用obj的组件。但是如果进行this.obj = …的操作，会触发子组件更新。</p>
<p>值得注意的是：如果某个后代组件在data中引用了inject中的该非响应式的引用类型数据，会对该数据进行initData，从而使该数据从此变成响应式的。</p>
</li>
<li><p>父组件提供响应式的基本类型数据，在子组件中获取该数据并进行修改操作时，与父组件提供的是非响应式基本类型数据的情况是相同的。</p>
</li>
<li><p>父组件提供响应式的引用类型数据，在子组件中获取该数据（例如obj），在子组件中修改该数据的值时（例如this.obj.foo = …），既会触发子组件视图更新（前提是视图中依赖了该对象内容），也会影响到其他使用obj的组件，会引起这些其他组件的更新（主要是父级、兄弟、侄子组件）。</p>
</li>
</ol>
</blockquote>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 插槽它允许你像这样合成组件： --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>然后你在 <span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span>&gt;</span> 的模板中可能会写为：<br><br>&lt;a<br>  v-bind:href=&quot;url&quot;<br>  class=&quot;nav-link&quot;<br>&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>当组件渲染的时候，<span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span> 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：<br><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>甚至其它的组件：<br><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/profile&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 添加一个图标的组件 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">font-awesome-icon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font-awesome-icon</span>&gt;</span><br>  Your Profile<br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation-link</span>&gt;</span><br>如果 <span class="hljs-tag">&lt;<span class="hljs-name">navigation-link</span>&gt;</span> 的 template 中没有包含一个 <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span> 元素，则该组件起始标签和结束标签之间的任何内容都会被抛弃。<br></code></pre></td></tr></table></figure>
<ul>
<li><p>在子组件的模板中留下slot标签标识插槽。</p>
</li>
<li><p>使用时，父组件模板中在子组件标签内为插槽填充内容。</p>
</li>
<li><p>关于渲染作用域，请记住：</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
</li>
</ul>
<h4 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h4><p>有时为一个插槽设置具体的后备 (也就是默认的) 内容是很有用的，它只会在没有提供内容的时候被渲染。例如在一个 <code>&lt;submit-button&gt;</code> 组件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>我们可能希望这个 <code>&lt;button&gt;</code> 内绝大多数情况下都渲染文本“Submit”。为了将“Submit”作为后备内容，我们可以将它放在 <code>&lt;slot&gt;</code> 标签内：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>现在当我在一个父级组件中使用 <code>&lt;submit-button</code> &gt; 并且不提供任何插槽内容时：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>后备内容“Submit”将会被渲染：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Submit<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>但是如果我们提供内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">submit-button</span>&gt;</span><br>  Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">submit-button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>则这个提供的内容将会被渲染从而取代后备内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>  Save<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把页头放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>具名插槽的name一般不会作为property或者变量名，所以应该使用<strong>中划线格式的命名方式</strong>。</p>
</blockquote>
<p><strong>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字<code>“default”</code>。</strong></p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。</p>
<p>渲染的 HTML 将会是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Here might be a page title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>A paragraph for the main content.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>And another one.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Here&#x27;s some contact info<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> 。</p>
<p>(只有<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>：只向子组件的默认插槽中插入内容，<code>v-slot</code>指令可以用在子组件的标签上)，这一点和已经废弃的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95"><code>slot</code> attribute</a> 不同。</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p><strong>应用情景：</strong>在父组件中为子组件的插槽中添加内容，但内容中需要访问子组件的内容。</p>
<p>有时让插槽内容能够访问子组件中才有的数据是很有用的。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span&gt;<br>  &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;&#x2F;slot&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure>
<p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code> 而我们提供的内容是在父级渲染的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;span&gt;<br>  &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt;<br>    &#123;&#123; user.lastName &#125;&#125;<br>  &lt;&#x2F;slot&gt;<br>&lt;&#x2F;span&gt;<br></code></pre></td></tr></table></figure>
<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>    &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<h4 id="v-slot用于组件标签上"><a href="#v-slot用于组件标签上" class="headerlink" title="v-slot用于组件标签上"></a>v-slot用于组件标签上</h4><p>在上述情况下，当被提供的内容<strong>只有默认插槽时</strong>，组件的标签才可以被当作插槽的模板来使用。<strong>这样我们就可以把 <code>v-slot</code> 直接用在组件标签上：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<p>这种写法还可以更简单。就像假定未指明的内容对应默认插槽一样，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>


<p><strong>注意：默认插槽的缩写语法不能和具名插槽混用，因为它会导致作用域不明确：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 无效，会导致警告 --&gt;<br>&lt;current-user v-slot&#x3D;&quot;slotProps&quot;&gt;<br>  &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;template v-slot:other&#x3D;&quot;otherSlotProps&quot;&gt;<br>    slotProps is NOT available here<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<p>只要出现多个插槽，请始终为<em>所有的</em>插槽使用完整的基于 <code>&lt;template&gt;</code> 的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user&gt;<br>  &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;<br>    &#123;&#123; slotProps.user.firstName &#125;&#125;<br>  &lt;&#x2F;template&gt;<br><br>  &lt;template v-slot:other&#x3D;&quot;otherSlotProps&quot;&gt;<br>    ...<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>


<h4 id="插槽作用域解构"><a href="#插槽作用域解构" class="headerlink" title="插槽作用域解构"></a>插槽作用域解构</h4><p>作用域插槽的内部工作原理是将你的插槽内容包裹在一个拥有单个参数的函数里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">slotProps</span>) </span>&#123;<br>  <span class="hljs-comment">// 插槽内容</span><br>&#125;<br></code></pre></td></tr></table></figure>


<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。<strong>在支持ES2015的环境下，你也可以使用 <code>ES2015 解构语法</code>来传入具体的插槽 prop</strong>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>


<p>这样可以使模板更简洁，尤其是在该插槽提供了多个 prop 的时候。它同样开启了 prop 重命名等其它可能，例如将 <code>user</code> 重命名为 <code>person</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user: person &#125;&quot;&gt;<br>  &#123;&#123; person.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>


<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user v-slot&#x3D;&quot;&#123; user &#x3D; &#123; firstName: &#39;Guest&#39; &#125; &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里的“prop重命名”、“定义后背内容” 都是利用的<code>ES2015 解构语法</code>的高级特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;24&#x27;</span>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; name, age &#125; = obj; <span class="hljs-comment">// 解构</span><br><span class="hljs-built_in">console</span>.log(name, age);<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: n, <span class="hljs-attr">age</span>: a &#125; = obj; <span class="hljs-comment">// 改名为 n 和 a;</span><br><span class="hljs-built_in">console</span>.log(n, a);<br><br><span class="hljs-comment">// 回滚值，只有当obj.gender为undefined或obj不存在不存在该属性是，gender才为默认的回滚值。</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: name2, <span class="hljs-attr">age</span>: age2, gender = <span class="hljs-string">&#x27;男&#x27;</span> &#125; = obj; <span class="hljs-comment">// 需要注意 0, null, false均不回滚</span><br><br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;base-layout&gt;<br>  &lt;template v-slot:[dynamicSlotName]&gt;<br>    ...<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;base-layout&gt;<br></code></pre></td></tr></table></figure>


<h4 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h4><p>跟 <code>v-on</code> 和 <code>v-bind</code> 一样，<code>v-slot</code> 也有缩写，即把参数之前的所有内容 (<code>v-slot:</code>) 替换为字符 <code>#</code>。例如 <code>v-slot:header</code> 可以被重写为 <code>#header</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;base-layout&gt;<br>  &lt;template #header&gt;<br>    &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt;<br>  &lt;&#x2F;template&gt;<br><br>  &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt;<br>  &lt;p&gt;And another one.&lt;&#x2F;p&gt;<br><br>  &lt;template #footer&gt;<br>    &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;base-layout&gt;<br></code></pre></td></tr></table></figure>
<p>然而，和其它指令一样，该缩写只在其有参数的时候才可用。这意味着以下语法是无效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这样会触发一个警告 --&gt;<br>&lt;current-user #&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>
<p>如果你希望使用缩写的话，你必须始终以明确插槽名取而代之：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;current-user #default&#x3D;&quot;&#123; user &#125;&quot;&gt;<br>  &#123;&#123; user.firstName &#125;&#125;<br>&lt;&#x2F;current-user&gt;<br></code></pre></td></tr></table></figure>


<h4 id="具名插槽与v-for配合使用"><a href="#具名插槽与v-for配合使用" class="headerlink" title="具名插槽与v-for配合使用"></a>具名插槽与v-for配合使用</h4><p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>  &lt;li<br>    v-for&#x3D;&quot;todo in filteredTodos&quot;<br>    v-bind:key&#x3D;&quot;todo.id&quot;<br>  &gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;ul&gt;<br>  &lt;!-- 👇 只允许这一种情况，逻辑上子组件模板中允许出现多个同名的具名插槽 --&gt;  <br>  &lt;li<br>    v-for&#x3D;&quot;todo in filteredTodos&quot;<br>    v-bind:key&#x3D;&quot;todo.id&quot;<br>  &gt;<br>    &lt;!--<br>    我们为每个 todo 准备了一个插槽，<br>    将 &#96;todo&#96; 对象作为一个插槽的 prop 传入。<br>    --&gt;<br>    &lt;slot name&#x3D;&quot;todo-item&quot; v-bind:todo&#x3D;&quot;todo&quot;&gt;<br>      &lt;!-- 后备内容 --&gt;<br>      &#123;&#123; todo.text &#125;&#125;<br>    &lt;&#x2F;slot&gt;<br>  &lt;&#x2F;li&gt;<br>&lt;&#x2F;ul&gt;<br></code></pre></td></tr></table></figure>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;todo-list v-bind:todos&#x3D;&quot;todos&quot;&gt;<br>  &lt;template v-slot:todo-item&#x3D;&quot;&#123; todo &#125;&quot;&gt;  &lt;!-- 每个名为todo-item的插槽都按照以下格式渲染 --&gt;<br>    &lt;span v-if&#x3D;&quot;todo.isComplete&quot;&gt;✓&lt;&#x2F;span&gt;<br>    &#123;&#123; todo.text &#125;&#125;<br>  &lt;&#x2F;template&gt;<br>&lt;&#x2F;todo-list&gt;<br></code></pre></td></tr></table></figure>


<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里：</p>
<p><img src="/./image-20210516211310527.png" srcset="/img/loading.gif" alt="image-20210516211310527"></p>
<p>上述内容可以通过 Vue 的 <code>&lt;component&gt;</code> 元素加一个特殊的 <code>is</code> attribute 来实现：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure>


<p>在上述示例中，<code>currentTabComponent</code> 可以是：</p>
<ol>
<li><p>已注册组件的名字（字符串）</p>
</li>
<li><p>一个组件的选项对象</p>
</li>
</ol>
<h4 id="在动态组件上使用-keep-alive"><a href="#在动态组件上使用-keep-alive" class="headerlink" title="在动态组件上使用 keep-alive"></a>在动态组件上使用 keep-alive</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 失活的组件将会被缓存！--&gt;<br>&lt;keep-alive&gt;<br>  &lt;component v-bind:is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure>


<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;async-example&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 向 `resolve` 回调传递组件定义</span><br>    resolve(&#123;<br>      template: <span class="hljs-string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span><br>    &#125;)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a target="_blank" rel="noopener" href="https://webpack.js.org/guides/code-splitting/">webpack 的 code-splitting 功能</a>一起配合使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;async-webpack-example&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-comment">// 这个特殊的 `require` 语法将会告诉 webpack</span><br>  <span class="hljs-comment">// 自动将你的构建代码切割成多个包，这些包</span><br>  <span class="hljs-comment">// 会通过 Ajax 请求加载</span><br>  <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;./my-async-component&#x27;</span>], resolve)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以这样使用动态导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.component(<br>  <span class="hljs-string">&#x27;async-webpack-example&#x27;</span>,<br>  <span class="hljs-comment">// 这个动态导入会返回一个 `Promise` 对象。</span><br>  () =&gt; <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure>
<p>当使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-registration.html#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C">局部注册</a>的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-comment">// ...</span><br>  components: &#123;<br>    <span class="hljs-string">&#x27;my-component&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="处理加载的状态"><a href="#处理加载的状态" class="headerlink" title="处理加载的状态"></a>处理加载的状态</h4><p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AsyncComponent = <span class="hljs-function">() =&gt;</span> (&#123;<br>  <span class="hljs-comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span><br>  component: <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span>),<br>  <span class="hljs-comment">// 异步组件加载时使用的组件</span><br>  loading: LoadingComponent,<br>  <span class="hljs-comment">// 加载失败时使用的组件</span><br>  error: ErrorComponent,<br>  <span class="hljs-comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span><br>  delay: <span class="hljs-number">200</span>,<br>  <span class="hljs-comment">// 如果提供了超时时间且组件加载也超时了，</span><br>  <span class="hljs-comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span><br>  timeout: <span class="hljs-number">3000</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Vue3中提供了<code>Suspense</code>组件来处理异步子组件的加载状态。</p>
</blockquote>
<p>##自定义指令</p>
<p>自定义指令的源码在 vdom/modules/directives中</p>
<h3 id="局部与全局注册自定义指令"><a href="#局部与全局注册自定义指令" class="headerlink" title="局部与全局注册自定义指令"></a>局部与全局注册自定义指令</h3><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>举个聚焦输入框的例子，当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注册一个全局自定义指令 `v-focus`</span><br>Vue.directive(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>  inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>    <span class="hljs-comment">// 聚焦元素</span><br>    el.focus()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directives: &#123;<br>  focus: &#123;<br>    <span class="hljs-comment">// 指令的定义</span><br>    inserted: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) </span>&#123;<br>      el.focus()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> property，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><p><code>bind</code>：⭐只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。指令的bind钩子在调用Vnode的create钩子时会触发，即使用了createElm或createComponent为Vnode创建DOM元素后立刻触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">invokeCreateHooks(vnode, insertedVnodeQueue) <span class="hljs-comment">/* 该函数中会执行各个module对create声明周期的监听函数，同时将具有insert钩子的Vnode加入insertedVnodeQueue插入队列。而具有inserted钩子的自定义指令绑定的元素所对应的Vnode会将指令的inserted钩子合并到Vnode.data.hooks.insert上。*/</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)<br><span class="hljs-comment">/* __patch__在返回vnode.elm之前，才会调用插入队列中所有vnode的insert钩子。</span><br><span class="hljs-comment">也就是在一轮组件patch结束之前才会按从子到父的顺序执行insert钩子，这个时机可能远远晚于某个vnode的elm被插入到自己的父亲中的时间点。*/</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>update</code>：⭐所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 真正的update执行时机是在patchVnode主要逻辑之前。</span><br><span class="hljs-comment">此时还没有真正的对Vnode的text和children进行patch。</span><br><span class="hljs-comment">但是在执行自定义指令的update钩子之前，此Vnode的elm的attrs、class、style等等已经更新了。这是由于其他平台相关模块的钩子在指令钩子之前执行，所以说钩子的顺序也很重要。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) <br>  <span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) <br>&#125;<br><span class="hljs-keyword">if</span> (isUndef(vnode.text)) &#123; <br>    <span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br><br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 👇 patchVnode函数部分定义</span><br><span class="hljs-keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) <br>  <span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) <br>&#125;<br><span class="hljs-keyword">if</span> (isUndef(vnode.text)) &#123; <br>    <span class="hljs-comment">//...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<br><span class="hljs-keyword">if</span> (isDef(data)) &#123;<br>	<span class="hljs-keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) <br>        i(oldVnode, vnode) <span class="hljs-comment">// 👈 执行vnode的postpatch钩子。此时vnode及其子vnode已经patch完成了。</span><br>&#125;<br><br><span class="hljs-comment">/*自定义指令的componentUpdated钩子会安装到绑定该指令的vnode的postpatch钩子上，</span><br><span class="hljs-comment">* 即componentUpdated钩子真正执行的时机是patchVnode(old, new)的最后时刻。</span><br><span class="hljs-comment">* 此时vnode及其子vnode都已经patch完成了，此时vnode.elm为更新过后的最新正确状态。</span><br><span class="hljs-comment">* 所以当自定义指令绑定在父容器上，并且会对其子元素产生影响时，最好使用componentUpdated钩子，而不是update钩子。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>
</ul>
<p>接下来我们来看一下钩子函数的参数 (即 <code>el</code>、<code>binding</code>、<code>vnode</code> 和 <code>oldVnode</code>)。</p>
<h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</li>
<li><code>binding</code>：一个对象，包含以下 property：<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>
</ul>
<blockquote>
<p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset"><code>dataset</code></a> 来进行。</p>
</blockquote>
<p>这是一个使用了这些 property 的自定义钩子样例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hook-arguments-example&quot;</span> <span class="hljs-attr">v-demo:foo.a.b</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;demo&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">JSON</span>.stringify<br>    el.innerHTML =<br>      <span class="hljs-string">&#x27;name: &#x27;</span>       + s(binding.name) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;value: &#x27;</span>      + s(binding.value) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;expression: &#x27;</span> + s(binding.expression) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;argument: &#x27;</span>   + s(binding.arg) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;modifiers: &#x27;</span>  + s(binding.modifiers) + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>      <span class="hljs-string">&#x27;vnode keys: &#x27;</span> + <span class="hljs-built_in">Object</span>.keys(vnode).join(<span class="hljs-string">&#x27;, &#x27;</span>)<br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#hook-arguments-example&#x27;</span>,<br>  data: &#123;<br>    message: <span class="hljs-string">&#x27;hello!&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="/./image-20210322221045773.png" srcset="/img/loading.gif" alt="image-20210322221045773"></p>
<h3 id="动态指令参数"><a href="#动态指令参数" class="headerlink" title="动态指令参数"></a>动态指令参数</h3><p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p>
<p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;baseexample&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Scroll down the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;pin&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    el.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span><br>    el.style.top = binding.value + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#baseexample&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dynamicexample&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-pin:</span>[<span class="hljs-attr">direction</span>]=<span class="hljs-string">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;pin&#x27;</span>, &#123;<br>  bind: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding, vnode</span>) </span>&#123;<br>    el.style.position = <span class="hljs-string">&#x27;fixed&#x27;</span><br>    <span class="hljs-keyword">var</span> s = (binding.arg == <span class="hljs-string">&#x27;left&#x27;</span> ? <span class="hljs-string">&#x27;left&#x27;</span> : <span class="hljs-string">&#x27;top&#x27;</span>)<br>    el.style[s] = binding.value + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#dynamicexample&#x27;</span>,<br>  data: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      direction: <span class="hljs-string">&#x27;left&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h3><p>在很多时候，你可能想在 <code>bind</code> 和 <code>update</code> 时触发相同行为，而不关心其它的钩子。比如这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;color-swatch&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) </span>&#123;<br>  el.style.backgroundColor = binding.value<br>&#125;)<br></code></pre></td></tr></table></figure>


<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法的 JavaScript 表达式。<strong>同时，对象字面量中可以引用组件实例的状态。</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-demo</span>=<span class="hljs-string">&quot;&#123; color: &#x27;white&#x27;, text &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Vue.directive(<span class="hljs-string">&#x27;demo&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(binding.value.color) <span class="hljs-comment">// =&gt; &quot;white&quot;</span><br>  <span class="hljs-built_in">console</span>.log(binding.value.text)  <span class="hljs-comment">// =&gt; &quot;hello!&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-comment">//...</span><br>    data: &#123;<br>        text: <span class="hljs-string">&#x27;hello world&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li>依赖于Node环境，并全局安装webpack</li>
<li>npm intsall -g @vue/cli</li>
</ol>
<p>以上是安装脚手架3的步骤，如果需要兼容脚手架2的语法，需要额外执行第三条：</p>
<ol start="3">
<li>npm install -g @vue/cli-init</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#测试</span><br>vue --version<br></code></pre></td></tr></table></figure>


<h3 id="使用cli2初始化一个项目"><a href="#使用cli2初始化一个项目" class="headerlink" title="使用cli2初始化一个项目"></a>使用cli2初始化一个项目</h3><ol>
<li><pre><code class="dos">vue init webpack $项目名称   👉会在当前目录创建同名文件夹
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>![image<span class="hljs-number">-20200828201856002</span>](./image<span class="hljs-number">-20200828201856002.</span>png)<br><br><br><br>### 使用cli3初始化一个项目<br><br><span class="hljs-number">1.</span> ```dos<br>   vue create $项目名称<br></code></pre></td></tr></table></figure>
![image-20200922221753466](./image-20200922221753466.png)




</code></pre>
</li>
</ol>
<hr>
<h2 id="Vue-router-前端路由"><a href="#Vue-router-前端路由" class="headerlink" title="Vue-router 前端路由"></a>Vue-router 前端路由</h2><h3 id="前端路由原理"><a href="#前端路由原理" class="headerlink" title="前端路由原理"></a>前端路由原理</h3><p>路由的概念来源于服务端，在服务端中路由描述的是 URL 与处理函数之间的映射关系。</p>
<p>在 Web 前端单页应用 SPA(Single Page Application)中，路由描述的是 URL 与 UI 之间的映射关系，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p>
<p>后端渲染阶段</p>
<p>👇   +ajax</p>
<p>前后端分离阶段</p>
<p>👇   +前端路由</p>
<p>SPA 单页面富应用阶段</p>
<p><strong>如何实现前端路由？</strong></p>
<p>要实现前端路由，需要解决两个核心：</p>
<ul>
<li>如何改变 URL 却不引起页面刷新？</li>
<li>如何检测 URL 变化了？</li>
</ul>
<p>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p>
<ol>
<li><h5 id="hash实现"><a href="#hash实现" class="headerlink" title="hash实现"></a>hash实现</h5><ul>
<li>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新。</li>
<li>通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过<code>&lt;a&gt;</code>标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件。⭐</li>
</ul>
</li>
<li><h5 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a>history 实现</h5><ul>
<li>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。</li>
<li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。⭐</li>
</ul>
</li>
</ol>
<p>==参考资料：==[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lguow/p/10921564.html]">https://www.cnblogs.com/lguow/p/10921564.html]</a></p>
<hr>
<h3 id="vue-router-安装与基本使用"><a href="#vue-router-安装与基本使用" class="headerlink" title="vue-router 安装与基本使用"></a>vue-router 安装与基本使用</h3><p><img src="/./image-20200829225840412.png" srcset="/img/loading.gif" alt="image-20200829225840412"></p>
<p>目录结构：</p>
<p>project</p>
<p>—components目录</p>
<p>——Home.vue    //组件</p>
<p>——About.vue   //组件</p>
<p>—router目录</p>
<p>——index.js    //路由配置文件</p>
<p>—main.js</p>
<p>—App.vue</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># main.js<br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>   <span class="hljs-comment">//根组件</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router/index.js&#x27;</span>  <span class="hljs-comment">//可省略index.js</span><br><br>Vue.config.productionTip=<span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el:<span class="hljs-string">&#x27;#app&#x27;</span>,<br>    router:router,  <span class="hljs-comment">//挂载路由</span><br>    render:<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>h(App)<br>&#125;)<br><br></code></pre></td></tr></table></figure>


<p><img src="/./image-20200829231314899.png" srcset="/img/loading.gif" alt="image-20200829231314899"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># index.js<br><br><span class="hljs-comment">//事先准备好Home和About两个组件</span><br><br><span class="hljs-comment">/*路由组件与路由的映射 </span><br><span class="hljs-comment">	/home  👉  Home.vue</span><br><span class="hljs-comment">	/about 👉  About.vue</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span> <br><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home.vue&#x27;</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About.vue&#x27;</span><br><br><br><span class="hljs-comment">// 1.通过Vue.use(插件)，安装插件</span><br>Vue.use(VueRouter);<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>]<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>	&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &#x2F;&#x2F;router-link是由vue-router注册的全局组件，控制前端路由。默认会渲染为一个a标签<br>        &lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;    <br>        &lt;router-link to&#x3D;&quot;&#x2F;about&quot;&gt;&lt;&#x2F;router-link&gt;<br>        <br>        &#x2F;&#x2F;router-view是占位组件，可显示前端路由绑定的组件<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;<br>    <br>&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>
<p><img src="/./image-20200830144015434.png" srcset="/img/loading.gif" alt="image-20200830144015434"></p>
<h3 id="默认路由（路由重定向）"><a href="#默认路由（路由重定向）" class="headerlink" title="默认路由（路由重定向）"></a>默认路由（路由重定向）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <span class="hljs-comment">//   根目录重定向到&#x27;/home&#x27;</span><br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>
<p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p>
<p>上面对应的路由配置为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/a&#x27;</span>, <span class="hljs-attr">component</span>: A, <span class="hljs-attr">alias</span>: <span class="hljs-string">&#x27;/b&#x27;</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>
<h3 id="hash与HTMl5的history模式"><a href="#hash与HTMl5的history模式" class="headerlink" title="hash与HTMl5的history模式"></a>hash与HTMl5的history模式</h3><p>在不刷新页面的前提下，改变URL有两种方式：</p>
<p>1.改变url的hash（锚点），本质上是改变location对象的hash属性。（location.hash=xxx）</p>
<p>2.使用HTML5的history模式中的API。</p>
<pre><code>BOM中使用栈结构保存访问资源的历史记录，并使用一个指针指向当前的URL。</code></pre>
<ul>
<li>history.pushState( { } , ‘’ ,’home’)    ==’/home’ 压栈==</li>
<li>history.back( )              ==指针下移==</li>
<li>history.forward( )         ==指针上移==</li>
<li>history.go(n)                 ==指针跳转==</li>
<li>history.replaceState({ },’’, ‘home’)      ==’/home’ 替换栈顶==</li>
</ul>
<h3 id="在vue-router中使用history模式"><a href="#在vue-router中使用history模式" class="headerlink" title="在vue-router中使用history模式"></a>在vue-router中使用history模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># router目录下的index.js<br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        redirect:<span class="hljs-string">&#x27;/home&#x27;</span>    <br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;,<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/about&#x27;</span>,<br>        component:About<br>    &#125;<br>];<br><br><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes:routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>                    <span class="hljs-comment">//在创建路由对象时，配置history模式。默认值为&#x27;hash&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure>




<h3 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h3><ol>
<li><p><strong>to属性</strong></p>
<p>用于声明式前端路由跳转，to属性指定跳转的绝对path、query以及hash。</p>
<p>&lt;router-link ==to===”/home”&gt;     &lt;/ router-link&gt;</p>
</li>
</ol>
<ol start="2">
<li><p><strong>tag属性</strong></p>
<p>用于指定router-link标签最终被渲染成的dom标签类型，默认情况下会被渲染成a标签。</p>
<p>&lt;router-link to=”/home” ==tag===”button”&gt;   &lt;/ router-link&gt;</p>
</li>
<li><p><strong>replace布尔属性</strong></p>
<p>在url跳转时使用history.replace方法，替换BOM历史记录栈结构的栈顶记录。</p>
<p>&lt;router-link to=”/home” tag=”button” ==replace==&gt;   &lt;/ router-link&gt;</p>
</li>
<li><p><strong>active-class属性</strong></p>
<p>用于指定router-link渲染出的标签在活跃（被点击）时的class属性值。默认为router-link-active。</p>
<p><img src="/./image-20200830165640888.png" srcset="/img/loading.gif" alt="image-20200830165640888"></p>
<p>👇</p>
<p>&lt;router-link to=”/home” tag=”button” ==active-class=”active”==&gt;   &lt;/ router-link&gt;</p>
<p><img src="/./image-20200830165558560.png" srcset="/img/loading.gif" alt="image-20200830165558560"></p>
</li>
</ol>
<p>   <em>在路由对象中全局修改所有router-link的active-class：</em></p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span>,<br>    linkActiveClass:<span class="hljs-string">&#x27;active&#x27;</span>  <span class="hljs-comment">//修改linkActiveClass属性</span><br>&#125;)<br></code></pre></td></tr></table></figure>


<h3 id="router和-route"><a href="#router和-route" class="headerlink" title="$router和$route"></a>$router和$route</h3><p><strong>一、区别</strong></p>
<p><code>this.$router</code>是VueRouter的实例。</p>
<p>当导航到不同url，可以使用<code>this.$router.push</code>方法，这个方法则会向history栈里面添加一条记录，当点击浏览器回退按钮或者<code>this.$router.back()</code>就会回退之前的url。</p>
<p><code>this.$route</code>相当于当前激活的路由对象，包含当前url解析得到的数据，可以从对象里获取一些数据，如name,path,query,params等。</p>
<p><strong>二、联系</strong></p>
<p><code>$router</code>和<code>$route</code>是Vue原型对象上的属性，而所有组件都是Vue及其子类的实例，所以我们能通过组件的隐式原型链访问到这两个属性。</p>
<p><strong>三、常见使用</strong></p>
<p><code>this.$router</code></p>
<ol>
<li><p>push方法</p>
<p>push方法其实和<code>&lt;router-link :to=&quot;...&quot;&gt;</code>是等同的，会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.push(path)<br></code></pre></td></tr></table></figure></li>
<li><p>go方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//页面路由跳转 前进或者后退</span><br><span class="hljs-built_in">this</span>.$router.go(n)<br></code></pre></td></tr></table></figure></li>
<li><p>replace方法</p>
<p>push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的记录，并置为history栈顶。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$router.replace(path)<br></code></pre></td></tr></table></figure>


</li>
</ol>
<p><code>this.$route</code></p>
<p>$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。</p>
<ol>
<li><strong>$route.path</strong></li>
</ol>
<p>类型: <code>string</code></p>
<p>   字符串，对应当前路由的路径，总是解析为绝对路径，如 “/foo/bar”。</p>
<ol start="2">
<li><p><strong>$route.params</strong></p>
<p>类型: <code>Object</code></p>
<p>一个 key/value 对象，包含了 动态片段 和 全匹配片段，<br>如果没有路由参数，就是一个空对象。</p>
</li>
<li><p><strong>$route.query</strong></p>
<p>类型: <code>Object</code></p>
<p>一个 key/value 对象，表示 URL 查询参数。<br>例如，对于路径 /foo?user=1，则有 $route.query.user == 1，<br>如果没有查询参数，则是个空对象。</p>
</li>
<li><p><strong>$route.hash</strong></p>
<p>类型: <code>string</code></p>
<p>当前路由的 hash 值 (不带 #) ，如果没有 hash 值，则为空字符串。锚点</p>
</li>
<li><p><strong>$route.fullPath</strong></p>
<p>类型: <code>string</code></p>
<p>完成解析后的路径，包含path、查询参数和 hash 的完整路径。</p>
</li>
<li><p><strong>$route.matched</strong></p>
<p>类型: <code>Array&lt;RouteRecord&gt;</code></p>
<p>一个数组，包含当前路由的所有嵌套路径片段的<strong>路由记录</strong> 。路由记录就是 <code>routes</code> 配置数组中的对象副本 (还有在 <code>children</code> 数组)。</p>
</li>
<li><p><strong>$route.name</strong>  </p>
<p>当前路由的名称，如果有的话。</p>
</li>
<li><p><strong>$route.meta</strong></p>
<p>类型：<code>Object</code></p>
<p>一个键值对，内容$route匹配的那条路由纪录的元数据，如果有的话。</p>
<p>如果$route匹配的那条路由没有元数据，则本属性值为一个空对象。</p>
</li>
</ol>
<h3 id="编程式前端路由跳转"><a href="#编程式前端路由跳转" class="headerlink" title="编程式前端路由跳转"></a>编程式前端路由跳转</h3><p>即通过代码调用api跳转路由。</p>
<p>而在router-link标签中通过to属性跳转路由称作声明式前端路由跳转，其本质还是调用了$router.push方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs vue"># App.vue<br><br>&lt;template&gt;<br>	&lt;div id&#x3D;&quot;app&quot;&gt;<br>        <br>        &lt;button @click&#x3D;&quot;clickhome&quot;&gt;去主页&lt;&#x2F;button&gt;  &#x2F;&#x2F;使用按钮而不是router-link<br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    import router from &#39;.&#x2F;router&#x2F;index.js&#39;   &#x2F;&#x2F; 导入路由，index.js可以省略<br>    <br>    export default &#123;<br>        name:&#39;App&#39;,<br>        router:router,<br>        methods:&#123;<br>            clickHome()&#123;<br>                &#x2F;&#x2F;调用组件的$router的push方法跳转路由<br>                &#x2F;&#x2F;相当于执行了history.pushState(&#39;&#x2F;home&#39;)<br>                &#x2F;&#x2F;相应的还有$router.replace(path)方法<br>                this.$router.push(&#39;&#x2F;home&#39;);    <br>                &#x2F;&#x2F;this.$router.replace(&#39;&#x2F;home&#39;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>


<p><strong>Vue官方解析</strong></p>
<p><code>router.push(location, onComplete?, onAbort?)</code></p>
<p><strong>注意</strong>：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>
<p>想要导航到不同的 URL，则使用 <code>router.push</code> 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody></table>
<p>push/replace方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 字符串</span><br>router.push(<span class="hljs-string">&#x27;home&#x27;</span>)<br><br><span class="hljs-comment">// 对象</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;home&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;123&#x27;</span> &#125;&#125;)<br><br><span class="hljs-comment">// 带查询参数，变成 /register?plan=private</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125;&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> userId = <span class="hljs-string">&#x27;123&#x27;</span><br>router.push(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user/123</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">`/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="hljs-comment">// -&gt; /user/123</span><br><span class="hljs-comment">// 这里的 params 不生效</span><br>router.push(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; userId &#125;&#125;) <span class="hljs-comment">// -&gt; /user</span><br></code></pre></td></tr></table></figure>


<p><strong>注意：</strong>push方法中的<code>path</code>可以是相对路径。例如：</p>
<ol>
<li><p>若当前<code>path</code>为<code>/user</code>,则使用<code>$router.push(&#39;./user/mz&#39;)</code>可以跳转到<code>/user/mz</code>。</p>
<p>原因是<code>/user</code>的当前目录仍然为==根目录 /== 。</p>
</li>
<li><p>若当前path为<code>/user/</code>,则使用<code>$router.push(&#39;./mz&#39;)</code>就能跳转到<code>/user/mz</code></p>
</li>
</ol>
<p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p>
<p><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 <code>/users/1</code> -&gt; <code>/users/2</code>)，组件的生命周期钩子不会触发，你需要使用组件的 <a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><code>beforeRouteUpdate</code></a> 钩子来响应这个变化 (比如发出请求抓取用户信息并更新组件视图)。</p>
<p><strong>坑</strong>🕳：</p>
<p><font color='red'>在vue-router中，使用$router.push/replace时会检查是否重复跳转至当前所在路由，如果是，则会抛出异常，但不影响功能使用</font></p>
<p>解决方法：</p>
<p>方法1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"># 在router目录下的index.js (路由文件最后加载以下代码片段)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    let router = new VueRouter(&#123;...&#125;)</span><br><span class="hljs-comment">    ....</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">const</span> originalPush = VueRouter.prototype.push; <span class="hljs-comment">//解决push方法的bug</span><br>VueRouter.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalPush.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-keyword">const</span> originalReplace = VueRouter.prototype.replace;  <span class="hljs-comment">//解决replace方法的bug</span><br>VueRouter.prototype.replace = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span> (<span class="hljs-params">location</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> originalReplace.call(<span class="hljs-built_in">this</span>, location).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err)<br>&#125;;<br><br><span class="hljs-comment">// export default router</span><br></code></pre></td></tr></table></figure>
<p>方法2.</p>
<pre><code>下载指定版本的vue-router  </code></pre>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i vue-router@<span class="hljs-number">3</span>.<span class="hljs-number">0</span> --save<br></code></pre></td></tr></table></figure>




<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1%5D">https://blog.csdn.net/weixin_43202608/article/details/98884620?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1]</a></p>
<h3 id="动态路由与路由参数"><a href="#动态路由与路由参数" class="headerlink" title="动态路由与路由参数"></a>动态路由与路由参数</h3><p>==（以动态二级路由为例）==</p>
<p>动态路由的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span>  <span class="hljs-comment">//导入User组件</span><br><span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>    	path:<span class="hljs-string">&#x27;/user&#x27;</span>,<br>        component:Login,<br>        children:[<br>            &#123;<br>                name:<span class="hljs-string">&#x27;userInfo1&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;:userId&#x27;</span>,<br>                component:User<br>            &#125;<br>        ]<br>    &#125;,<br>    <br>    &#123;<br>        name:<span class="hljs-string">&#x27;userInfo2&#x27;</span><br>        path:<span class="hljs-string">&#x27;/user/:userId&#x27;</span>, <span class="hljs-comment">//UserInfo2永远不会起作用，因为优先级比userInfo1低。哪一条路由先设置，哪一条路由的优先级较高。</span><br>        component:User<br>    &#125;<br>]<br></code></pre></td></tr></table></figure>
<p>一级路由组件向二级路由传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Login.vue<br><br>&lt;template&gt;<br>	&lt;div class&#x3D;&quot;login&quot;&gt;<br>        <br>        &lt;!-- 指定跳转的完整绝对路径 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        &lt;!--相当于👇--&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;path:&#96;&#x2F;user&#x2F;$&#123;userId&#125;&#96;&#125;&quot;&gt;登录1&lt;&#x2F;router-link&gt;<br>        <br>        <br>        &lt;!-- 指定跳转到名为userInfo1的路由，并设置参数 --&gt;<br>        &lt;router-link :to&#x3D;&quot;&#123;name:&#39;userInfo1&#39;,params:&#123;userId&#125;&#125;&quot;&gt;登录2&lt;&#x2F;router-link&gt;<br>        <br>        &lt;router-view&gt;&lt;&#x2F;router-view&gt;<br>        <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>
<p>二级路由组件获取路由参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue"># User.vue<br><br>&lt;template&gt;<br>	&lt;div class&#x3D;&quot;user&quot;&gt;<br>        &lt;div&gt;头像&lt;&#x2F;div&gt;<br>        &lt;!-- 获取当前路由中的参数  $route.params  --&gt;<br>        &lt;h2&gt;id:&lt;span&gt;&#123;&#123;$route.params.userId&#125;&#125;&lt;&#x2F;span&gt;  <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;login&#39;,<br>        data()&#123;<br>            return &#123;<br>                userId:&#39;mzleman&#39;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure>




<h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><span class="hljs-keyword">import</span> User <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;xxx.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        name:<span class="hljs-string">&#x27;root&#x27;</span>,<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:App,<br>        <span class="hljs-comment">//开始嵌套</span><br>        children:[                 <span class="hljs-comment">//在路由配置对象中的children属性，可以设置子路由</span><br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /home</span><br>                name:<span class="hljs-string">&#x27;homepage&#x27;</span>,<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,       <span class="hljs-comment">//子路由配置中，路径使用相对路径 </span><br>                component:Home<br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">//   -&gt; /user/...</span><br>                name:<span class="hljs-string">&#x27;userinfo&#x27;</span>,      <span class="hljs-comment">//为路由设置name属性 唯一标识该条路由</span><br>                path:<span class="hljs-string">&#x27;user/:userId&#x27;</span>,  <span class="hljs-comment">// 子路由配置中，使用动态路由</span><br>                component:User<br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure>
<p><code>路由的嵌套只是用一种结构化的方式配置前端路由信息，将逻辑上有层次关系的路由放在一起，但相应的路由组件不存在绝对的层次化渲染关系。</code></p>
<p><code>子路由对应的component如何显示，只与该路由是在哪一个组件中跳转有关，子路由组件在该组件中的router-view中显示。</code></p>
<p><font color='red'>为了避免组件渲染后的层次关系混乱，父级路由对应的组件与子路由对应的组件也应该具有相应的父子关系。</font></p>
<blockquote>
<p>当route中有两条路由配置可以匹配同一个URL时，谁先在routes中定义，就匹配拿一条。</p>
<p>如 {path: ‘/user’, component: Login, children: [ {path: ‘:userId’, component: User} ]},</p>
<p>{path: ‘/user/:userId’, component: User} 这两条路由都可以匹配 /user/1，但前一条先定义，则匹配前一条，Login组件将嵌套User组件显示。</p>
<p>如果将第二条路由先定义，则直接显示User组件。</p>
</blockquote>
<h3 id="路由组件懒加载"><a href="#路由组件懒加载" class="headerlink" title="路由组件懒加载"></a>路由组件懒加载</h3><p><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html">https://router.vuejs.org/zh/guide/advanced/lazy-loading.html</a></p>
<p>在Vue Cli的默认配置情况下，所有的开发组件vue文件 (包括main.js)会被打包到一个app.js中，这就使得该js文件十分庞大。</p>
<p>(除了app.js会被第一时间请求外，还有第三方包的打包文件vendor.js以及模块化底层支撑的文件manifest.js会被第一时间请求至前端)</p>
<p>在使用组件懒加载后，每个懒加载的组件会被单独打包到一个js文件中（而不是app.js），浏览器会根据前端路由，按需向服务器请求组件的js打包文件。</p>
<p><img src="/./image-20200901110233735.png" srcset="/img/loading.gif" alt="image-20200901110233735"></p>
<p><img src="/./image-20200901110610641.png" srcset="/img/loading.gif" alt="image-20200901110610641"></p>
<p><strong>基本语法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># router👉index.js<br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> Home=<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../components/Home.vue&#x27;</span>)<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/home&#x27;</span>,<br>        component:Home<br>    &#125;<br>]<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<h4 id="把组件按组分块"><a href="#把组件按组分块" class="headerlink" title="把组件按组分块"></a>把组件按组分块</h4><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用 <a target="_blank" rel="noopener" href="https://webpack.js.org/guides/code-splitting-require/#chunkname">命名 chunk</a>，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> Bar = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Bar.vue&#x27;</span>)<br><span class="hljs-keyword">const</span> Baz = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Baz.vue&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>Webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html</a></p>
<h4 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"># router 👉 index.js<br><br><span class="hljs-keyword">const</span> routes=[<br>    &#123;<br>        path:<span class="hljs-string">&#x27;/&#x27;</span>,<br>        component:Index,<br>        meta:&#123;    <span class="hljs-comment">//在元数据meta中保存一些路由信息</span><br>            title:<span class="hljs-string">&#x27;首页&#x27;</span><br>        &#125;<br>        children:[<br>            &#123;<br>                path:<span class="hljs-string">&#x27;home&#x27;</span>,<br>                component:Home,<br>                meta:&#123;<br>                    title:<span class="hljs-string">&#x27;主页&#x27;</span><br>                &#125;<br>            &#125;<br>        ]<br>        <br>    &#125;<br>];<br><br><span class="hljs-keyword">let</span> router=<span class="hljs-keyword">new</span> VueRouter(&#123;<br>    routes,<br>    mode:<span class="hljs-string">&#x27;history&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">/* beforeEach方法加载前置守卫 */</span><br>router.beforeEach( guard:<span class="hljs-built_in">Function</span> );  <span class="hljs-comment">//钩子（守卫）的用法类似于中间件，可挂载多个钩子</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure>


<p><strong>前置钩子</strong>（守卫）要传入三个参数，分别为：</p>
<pre><code>  1. **to：Route对象** ，将要跳转到的下一个活跃路由
  2. from： Route对象，当前的活跃路由，即$route对象
  3. **next ：Function  下一个钩子函数**，必须使在钩子内调用一下 next( )。执行效果依赖 next 方法的调用参数。
  - **`next()`**: 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 **confirmed** (确认的)。
  - **`next(false)`**: 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 `from` 路由对应的地址。
  - **`next(&#39;/&#39;)` 或者 `next(&#123; path: &#39;/&#39; &#125;)`**: 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 `next` 传递任意位置对象，且允许设置诸如 `replace: true`、`name: &#39;home&#39;` 之类的选项以及任何用在 [`router-link` 的 `to` prop](https://router.vuejs.org/zh/api/#to) 或 [`router.push`](https://router.vuejs.org/zh/api/#router-push) 中的选项。
  - **`next(error)`**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。</code></pre>
<p><strong>案例：在跳转到各条路由时更新标签页的标题</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;<br>    <br>    <span class="hljs-built_in">console</span>.log(to);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">from</span>);<br>    <br>    <span class="hljs-built_in">document</span>.title=to.meta.title;<br>   <br>    <span class="hljs-comment">//document.title=to.matched[0].meta.title </span><br>   <span class="hljs-comment">//matched是一个数组，保存了所有匹配的路由</span><br>    <br>    next();<br>&#125;);<br></code></pre></td></tr></table></figure>


<h4 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h4><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next</code> 函数也不会改变导航本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h4><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这些守卫与全局前置守卫的方法参数是一样的。</p>
<h4 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h4><p><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB</a></p>
<p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>
<ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code> (2.2 新增)</li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = &#123;<br>  template: <span class="hljs-string">`...`</span>,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span><br>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>  &#125;,<br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;,<br>  beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-comment">// just use `this`</span><br>  <span class="hljs-built_in">this</span>.name = to.params.name<br>  next()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-keyword">const</span> answer = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (answer) &#123;<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next(<span class="hljs-literal">false</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><p><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B</a></p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ol>
<h3 id="keep-alive包裹router-view"><a href="#keep-alive包裹router-view" class="headerlink" title="keep-alive包裹router-view"></a>keep-alive包裹router-view</h3><p><code>keep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染（维持生命周期）。</code></p>
<p>使用keep-alive包裹一个需要反复使用的一个组件，可以避免组件在不活跃时被销毁，在活跃时被新建。同时该组件会具有新的生命周期函数actived和deactived。</p>
<p><strong>案例：组件在失活时记录组件状态，组件重新活跃时返回至上一状态</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue"># Home.vue<br># &lt;keep-alive&gt;标签包裹了Home.vue的父级组件中的&lt;router-view&#x2F;&gt;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>    &#123;&#123;path&#125;&#125;  <br>&lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>    export default &#123;<br>        name:&#39;Home&#39;,<br>        data()&#123;<br>            return &#123;<br>                path:&#39;&#x2F;home&#39;<br>            &#125;<br>        &#125;,<br>        actived()&#123;<br>            this.$router.replace(this.path);   &#x2F;&#x2F;返回至失活前的状态<br>        &#125;,<br>        beforeRouteLeave(to, from, next)&#123;         &#x2F;&#x2F;组件内的后置勾子<br>            this.path&#x3D;this.$route.path;<br>            next();<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;    <br></code></pre></td></tr></table></figure>


<p><strong>keep-alive标签的exclude和include属性</strong></p>
<p>keep-alive标签可以利用exclude与include属性指定排除或包含哪些组件的生命周期会被维持，属性值为逗号分隔的字符串，对应组件定义时的name属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link to&#x3D;&quot;&#x2F;home&quot;&gt;&lt;&#x2F;router-link&gt;<br>&lt;keep-alive exclude&#x3D;&quot;Profile,User&quot;&gt;<br>    &lt;router-view&#x2F;&gt;<br>&lt;&#x2F;keep-alive&gt;<br></code></pre></td></tr></table></figure>


<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>有时候，进入某个路由后，需要从服务器获取数据。例如，在渲染用户信息时，你需要从服务器获取用户的数据。我们可以通过两种方式来实现：</p>
<ul>
<li><strong>导航完成之后获取</strong>：先完成导航，然后在接下来的组件生命周期钩子中获取数据。在数据获取期间显示“加载中”之类的指示。</li>
<li><strong>导航完成之前获取</strong>：导航完成前，在路由进入的守卫中获取数据，在数据获取成功后执行导航。</li>
</ul>
<p>从技术角度讲，两种方式都不错 —— 就看你想要的用户体验是哪种。</p>
<h4 id="导航完成后获取数据"><a href="#导航完成后获取数据" class="headerlink" title="导航完成后获取数据"></a>导航完成后获取数据</h4><p>当你使用这种方式时，我们会马上导航和渲染组件，然后在组件的 <code>created</code> 钩子中获取数据。这让我们有机会在数据获取期间展示一个 loading 状态，还可以在不同视图间展示不同的 loading 状态。</p>
<p>假设我们有一个 <code>Post</code> 组件，需要基于 <code>$route.params.id</code> 获取文章数据：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loading&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span><br>      Loading...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><br>      &#123;&#123; error &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; post.body &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      loading: false,<br>      post: null,<br>      error: null<br>    &#125;<br>  &#125;,<br>  created () &#123;<br>    // 组件创建完后获取数据，<br>    // 此时 data 已经被 observed 了<br>    this.fetchData()<br>  &#125;,<br>  watch: &#123;<br>    // 如果路由有变化，会再次执行该方法<br>    &#x27;$route&#x27;: &#x27;fetchData&#x27;<br>  &#125;,<br>  methods: &#123;<br>    fetchData () &#123;<br>      this.error = this.post = null<br>      this.loading = true<br>      // replace getPost with your data fetching util / API wrapper<br>      getPost(this.$route.params.id, (err, post) =&gt; &#123;<br>        this.loading = false<br>        if (err) &#123;<br>          this.error = err.toString()<br>        &#125; else &#123;<br>          this.post = post<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="在导航完成前获取数据"><a href="#在导航完成前获取数据" class="headerlink" title="在导航完成前获取数据"></a>在导航完成前获取数据</h4><p>通过这种方式，我们在导航转入新的路由前获取数据。我们可以在接下来的组件的 <code>beforeRouteEnter</code> 守卫中获取数据，当数据获取成功后只调用 <code>next</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      post: <span class="hljs-literal">null</span>,<br>      error: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    getPost(to.params.id, <span class="hljs-function">(<span class="hljs-params">err, post</span>) =&gt;</span> &#123;<br>      next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> vm.setData(err, post))<br>    &#125;)<br>  &#125;,<br>  <span class="hljs-comment">// 路由改变前，组件就已经渲染完了</span><br>  <span class="hljs-comment">// 逻辑稍稍不同</span><br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-built_in">this</span>.post = <span class="hljs-literal">null</span><br>    getPost(to.params.id, <span class="hljs-function">(<span class="hljs-params">err, post</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.setData(err, post)<br>      next()<br>    &#125;)<br>  &#125;,<br>  methods: &#123;<br>    setData (err, post) &#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">this</span>.error = err.toString()<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.post = post<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在为后面的视图获取数据时，用户会停留在当前的界面，因此建议在数据获取期间，显示一些进度条或者别的指示。如果数据获取失败，同样有必要展示一些全局的错误提醒。</p>
<h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p>定义路由的时候可以配置 <code>meta</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      component: Foo,<br>      children: [<br>        &#123;<br>          path: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>          component: Bar,<br>          <span class="hljs-comment">// a meta field</span><br>          meta: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span> &#125;<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>那么如何访问这个 <code>meta</code> 字段呢？</p>
<p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 <strong>路由记录</strong>。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>
<p>例如，根据上面的路由配置，<code>/foo/bar</code> 这个 URL 将会匹配父路由记录以及子路由记录。</p>
<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p>
<p>下面例子展示在全局导航守卫中检查元字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.matched.some(<span class="hljs-function"><span class="hljs-params">record</span> =&gt;</span> record.meta.requiresAuth)) &#123;<br>    <span class="hljs-comment">// this route requires auth, check if logged in</span><br>    <span class="hljs-comment">// if not, redirect to login page.</span><br>    <span class="hljs-keyword">if</span> (!auth.loggedIn()) &#123;<br>      next(&#123;<br>        path: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>        query: &#123; <span class="hljs-attr">redirect</span>: to.fullPath &#125;<br>      &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      next()<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next() <span class="hljs-comment">// 确保一定要调用 next()</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>不宜修改meta。</p>
</blockquote>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p> <img src="/./image-20200926103349466.png" srcset="/img/loading.gif" alt="image-20200926103349466"></p>
<p><img src="/./image-20200926103508601.png" srcset="/img/loading.gif" alt="image-20200926103508601"></p>
<blockquote>
<p>在Vuex中保存的状态（数据）是响应式的。</p>
</blockquote>
<p><strong>应用场景👇</strong></p>
<p><img src="/./image-20200926103551896.png" srcset="/img/loading.gif" alt="image-20200926103551896"></p>
<p><strong>单个组件的状态管理:</strong></p>
<p><img src="/./image-20200926104012022.png" srcset="/img/loading.gif" alt="image-20200926104012022"></p>
<blockquote>
<p>Vue已经帮我们做好了单个页面的状态管理，即组件的数据是比较独立的，可以通过各种Action的回调函数去修改State（数据），并通过响应式去更新View。</p>
<p>但如果是多个界面（组件）的状态管理就可能需要Vuex。</p>
</blockquote>
<p><strong>Vuex的基本思想：</strong></p>
<p><img src="/./image-20200926104500158.png" srcset="/img/loading.gif" alt="image-20200926104500158"></p>
<p><img src="/./image-20200926104627320.png" srcset="/img/loading.gif" alt="image-20200926104627320"></p>
<h3 id="什么情况下应该使用Vuex？"><a href="#什么情况下应该使用Vuex？" class="headerlink" title="什么情况下应该使用Vuex？"></a>什么情况下应该使用Vuex？</h3><p>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p>
<p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8">store 模式</a>就足够了。但是，如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p>
<h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vuex --save<br></code></pre></td></tr></table></figure>
<p>在 Vue 的单页面应用中使用，需要使用<code>Vue.use(Vuex)</code>调用插件。</p>
<p>之后新建一个Vuex.Store实例，将其注入到Vue根实例中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br>Vue.use(Vuex)<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  getter: &#123;<br>    doneTodos: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;,<br>  mutations: &#123;<br>    increment (state, payload) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">addCount</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-comment">// 可以包含异步操作</span><br>      <span class="hljs-comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span><br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 注入到根实例</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br>  store,<br>  template: <span class="hljs-string">&#x27;&lt;App/&gt;&#x27;</span>,<br>  components: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>然后通过mutations改变状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure>


<blockquote>
<p>在项目中使用Vuex，常常在src目录下创建store文件夹统一管理Vuex的单一状态树的内容。</p>
</blockquote>
<hr>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p><code>State，Getter，Mutation，Action，Module，</code></p>
<p><strong>Vuex 有五部分核心内容：</strong></p>
<ol>
<li>state：包含了<code>store</code>中存储的各个状态。</li>
<li>getters: 类似于 Vue 中的计算属性，根据其他 getter 或 state 计算返回值。</li>
<li>mutations: 一组方法，是改变<code>store</code>中状态的执行者，<strong>只能是同步操作</strong>。</li>
<li>actions: 一组方法，其中可以<strong>包含异步操作</strong>,但只允许通过提交mutations修改状态。</li>
<li>modules：多个模块，每个模块拥有自己的state、getter、mutations、actions。</li>
</ol>
<hr>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>Vuex 使用 <code>state</code> 来存储应用中需要共享的状态。</p>
<p>在根组件（Vue实例）以及子组件中使用<code>this.$store.state</code>访问共享状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#x2F;&#x2F; Cpn.vue<br>&#x2F;*<br>	const store &#x3D; new Vuex.Store(&#123;<br>  		state: &#123;<br>    		count: 0,<br>			obj: &#123;name: &#39;mz&#39;, age: 23&#125;<br>		&#125;<br>	&#125;)<br>	<br>*&#x2F;<br><br>&lt;template&gt;<br>	&lt;div&gt;<br>        &lt;h2&gt; &#123;&#123;count&#125;&#125; &lt;&#x2F;h2&gt; <br>    &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>	export default &#123;<br>        name: &#39;Cpn&#39;,<br>        computed: &#123;<br>            count()&#123;<br>                return this.$store.state.count  &#x2F;&#x2F; 访问state中的count<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;&#x2F;script&gt;<br><br>&lt;style&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在state初始化时就已经定义的数据以及数据的属性才会被添加到响应式系统。</p>
<p>( 在Vue中所有需要响应式的数据都是这样 )</p>
<p>所以通过this.$store.state.obj[‘xxx’]的方式为数据添加额外的属性值时，虽然数据确实变化了，但不会更新View。</p>
<p>此时，需要通过Vue.set方法来修改状态的属性，可以确保数据是响应式的。</p>
<p>Vue.set(obj, propName, value)</p>
<p>删除状态的属性需要通过Vue.delete方法实现响应式。</p>
<p>Vue.delete(obj, propName)</p>
</blockquote>
<hr>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>类似于 Vue 中的 计算属性（可以认为是 store 的计算属性），getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>getter 方法接受<code>state</code>作为其第一个参数，<code>state</code>参数即Store对象中的state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<p>getter 方法接受<code>getters</code>作为其第二个参数，<code>getters</code>参数即Store对象中的getters，该参数允许我们在某个getter中访问其他getter：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    todos: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;<br>    ]<br>  &#125;,<br>  getters: &#123;<br>    doneTodos: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.todos.filter(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.done);<br>    &#125;,<br>    doneTodosCount: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> getters.doneTodos.length;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<p><strong>在组件中访问getters：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>    <span class="hljs-function"><span class="hljs-title">cpnDoneTodos</span>(<span class="hljs-params"></span>)</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodos;<br>	&#125;,<br>	<span class="hljs-function"><span class="hljs-title">cpnDoneTodosCount</span>(<span class="hljs-params"></span>)</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.getters.doneTodosCount;	<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>getter方法返回一个函数，实现给getter传参：</strong></p>
<p>这种做法在对 store 里的数组进行查询时非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getters: &#123;<br>  <span class="hljs-comment">// ...</span><br>  getTodoById: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> state.todos.find(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.id === id)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在组件中为getter返回的函数传参：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$store.getters.getTodoById(<span class="hljs-number">2</span>) <span class="hljs-comment">// -&gt; &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><h4 id="基本使用-3"><a href="#基本使用-3" class="headerlink" title="基本使用"></a>基本使用</h4><p>在Vuex中约定必须通过mutation修改状态，不允许通过<code>$store.state.xxx = xxx</code>的形式直接修改。（虽然这样没什么可怕的后果，只是通过mutation修改能保存修改日志与状态快照）</p>
<blockquote>
<p><code>state</code>和<code>getter</code>都是状态值本身，<code>mutations</code>才是改变状态的执行者。</p>
<p><strong>注意：<code>mutations</code>只能是同步地更改状态。</strong></p>
</blockquote>
<p>Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">1</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 变更状态</span><br>      state.count++<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<p>在组件中提交mutation，并执行回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><code>commit</code>方法中第一个参数可以是<code>事件类型名(String)</code>；</p>
<p>第二个参数是传递的<code>载荷</code>，可以作为实参传递给mutation的回调函数，第二个参数<code>是可选的</code>。</p>
<blockquote>
<p>提交mutation时，不可以像发送action一样能够获取mutation回调函数的返回值。</p>
<p>即在mutation的回调函数中返回值是无意义的。</p>
</blockquote>
<p><strong>规范地提交mutation并传参：</strong></p>
<p>在规范中，mutation的回调函数支持传入第二个参数payload，作为载荷。载荷中可以保存向mutation回调函数传递的实参。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br>        state.count += payload.n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>


<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的形式1：提交mutation的事件类型，传递载荷，触发回调函数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;); 👉 传递的实参的值： &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-comment">// 推荐的形式2：使用对象风格的提交方式，传递参数名与值   </span><br><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>    type: <span class="hljs-string">&#x27;increment&#x27;</span>, 👉 传递的实参的值： &#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;<br>    n: <span class="hljs-number">1</span><br>&#125;);<br></code></pre></td></tr></table></figure>


<p><strong>向提交简单参数：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>mutations: &#123;<br>    <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, n</span>)</span> &#123;<br>        state.count += n <span class="hljs-comment">//要求payload是一个对象，其中n为传递的加数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 不能再通过对象风格来传递参数</span><br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>


<blockquote>
<p>总结： 在向mutation传递参数时，需要回调函数与提交方式的配合。</p>
</blockquote>
<h4 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h4><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// mutation-types.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_MUTATION = <span class="hljs-string">&#x27;SOME_MUTATION&#x27;</span><br><span class="hljs-comment">// store.js</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> &#123; SOME_MUTATION &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./mutation-types&#x27;</span><br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123; ... &#125;,<br>  mutations: &#123;<br>    <span class="hljs-comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span><br>    [SOME_MUTATION] (state) &#123;<br>      <span class="hljs-comment">// mutate state</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
<h4 id="在组件中提交-Mutation"><a href="#在组件中提交-Mutation" class="headerlink" title="在组件中提交 Mutation"></a>在组件中提交 Mutation</h4><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  methods: &#123;<br>    ...mapMutations([<br>      <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span><br><br>      <span class="hljs-comment">// `mapMutations` 也支持载荷：</span><br>      <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span><br>    ]),<br>    ...mapMutations(&#123;<br>      add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>想要<strong>异步地更改状态</strong>，就需要使用<code>action</code>。<code>action</code>并不直接改变<code>state</code>，而是发起<code>mutation</code>。</p>
<blockquote>
<p>action既可以异步地提交mutation，也可以同步提交，但更主要的是利用它来异步修改状态</p>
</blockquote>
<p><strong>注册一个简单的 action：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (state) &#123;<br>      state.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context</span>)</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>          context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>


<h4 id="发起简单的action"><a href="#发起简单的action" class="headerlink" title="发起简单的action"></a>发起简单的action</h4><p>发起<code>action</code>的方法形式和发起<code>mutation</code>一样，只是换了个名字<code>dispatch</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>)<br></code></pre></td></tr></table></figure>


<p><strong>Actions 支持同样的载荷方式和对象方式<code>进行分发</code>并<code>传递参数</code>：</strong></p>
<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。当我们在之后介绍到 <code>Modules</code> 时，你就知道 context 对象为什么不是 store 实例本身了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ...</span><br>	mutations:&#123;<br>      <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params">state, payload</span>)</span>&#123;<br>          state.count += payload.n<br>      &#125;  <br>    &#125;,<br>	actions: &#123;<br>      <span class="hljs-function"><span class="hljs-title">asyncIncrement</span>(<span class="hljs-params">context, payload</span>)</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>            context.commit(<span class="hljs-string">&#x27;increment&#x27;</span>, payload)  <span class="hljs-comment">// 实参的类型要与mutation中的形参一致</span><br>         &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐使用载荷的方式向action传参</span><br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;asyncIncrement&#x27;</span>, &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">1</span>&#125;)<br><br><span class="hljs-comment">// 不建议使用下面这种对象风格的方式，因为payload形参的type不再是mutation的type，需要进行调整</span><br><span class="hljs-built_in">this</span>.$store.dispatch(&#123;<br>    type: <span class="hljs-string">&#x27;asyncIncrement&#x27;</span>,<br>    n: <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>可见，向action或mutation传参，以载荷的方式更直观，同时能避免差错。</p>
</blockquote>
<p><strong>对context进行解构：</strong></p>
<p>实践中，我们会经常用到 ES2015 的 <a target="_blank" rel="noopener" href="https://github.com/lukehoban/es6features#destructuring">参数解构</a> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  increment (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>context具有store 实例的相同方法和属性，包括commit, dispatch, getters, state。</p>
<p>此外还具有rootGetters以及rootState；</p>
<p>这些属性和方法都可以进行解构获取。</p>
<p><img src="/./image-20200926153828952.png" srcset="/img/loading.gif" alt="image-20200926153828952"> </p>
</blockquote>
<h4 id="分发多重-mutation"><a href="#分发多重-mutation" class="headerlink" title="分发多重 mutation"></a>分发多重 mutation</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">actions: &#123;<br>  checkout (&#123; commit, state &#125;, products) &#123;<br>    <span class="hljs-comment">// 把当前购物车的物品备份起来</span><br>    <span class="hljs-keyword">const</span> savedCartItems = [...state.cart.added]<br>    <span class="hljs-comment">// 发出结账请求，然后乐观地清空购物车</span><br>    commit(types.CHECKOUT_REQUEST)<br>    <span class="hljs-comment">// 购物 API 接受一个成功回调和一个失败回调</span><br>    shop.buyProducts(<br>      products,<br>      <span class="hljs-comment">// 成功操作</span><br>      () =&gt; commit(types.CHECKOUT_SUCCESS),<br>      <span class="hljs-comment">// 失败操作</span><br>      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="Action处理异步的正确使用方式"><a href="#Action处理异步的正确使用方式" class="headerlink" title="Action处理异步的正确使用方式"></a>Action处理异步的正确使用方式</h4><p>想要使用<code>action</code>处理异步工作很简单，只需要将异步操作放到<code>action</code>中执行（如上面代码中的<code>setTimeout</code>）。</p>
<p><strong>要想在异步操作完成后继续进行相应的流程操作</strong>，有两种方式:</p>
<ol>
<li><p>在action中返回一个Promise</p>
<p><code>store.dispatch</code>返回相应<code>action</code>的执行结果，而当action的处理函数返回的是一个Promise实例时，就可以写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>    <span class="hljs-function"><span class="hljs-title">actionA</span>(<span class="hljs-params">&#123;commit&#125;, payload</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> data = <span class="hljs-built_in">setTimeout</span>( <span class="hljs-function">()=&gt;</span> &#123;<br>             commit(<span class="hljs-string">&#x27;mutation1&#x27;</span>, payload);<br>                resolve();<br>         &#125;, <span class="hljs-number">1000</span>)<br>        &#125;)<br> &#125;<br>&#125;<br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>, payload).then(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure>



</li>
</ol>
<p>   在另外一个 action 中也可以：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">actions: &#123;<br>  <span class="hljs-comment">// ...</span><br>  actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>      commit(<span class="hljs-string">&#x27;someOtherMutation&#x27;</span>)<br>    &#125;) <span class="hljs-comment">// dispatch(&#x27;ActionB&#x27;) 仍然会返回一个Promise</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="2">
<li><p>利用<code>async/await</code> 进行组合action。代码更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><br>actions: &#123;<br>  <span class="hljs-keyword">async</span> actionA (&#123; commit &#125;) &#123;<br>    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())<br>  &#125;,<br>  <span class="hljs-keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;<br>    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span><br>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>一个 <code>$store.dispatch</code> 可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>
</blockquote>
</li>
</ol>
<h4 id="在组件中分发-Action"><a href="#在组件中分发-Action" class="headerlink" title="在组件中分发 Action"></a>在组件中分发 Action</h4><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 <code>store</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  methods: &#123;<br>    ...mapActions([<br>      <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span><br><br>      <span class="hljs-comment">// `mapActions` 也支持载荷：</span><br>      <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span><br>    ]),<br>    ...mapActions(&#123;<br>      add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>由于使用<strong>单一状态树</strong>，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;,<br>  getters: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> moduleB = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    a: moduleA,<br>    b: moduleB<br>  &#125;<br>&#125;)<br><br>store.state.a <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.state.b <span class="hljs-comment">// -&gt; moduleB 的状态</span><br></code></pre></td></tr></table></figure>
<h4 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;),<br>  mutations: &#123;<br>    increment (state) &#123;<br>      <span class="hljs-comment">// 这里的 `state` 对象是模块的局部状态</span><br>      state.count++<br>    &#125;<br>  &#125;,<br><br>  getters: &#123;<br>    doubleCount (state) &#123;<br>      <span class="hljs-keyword">return</span> state.count * <span class="hljs-number">2</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-comment">// ...</span><br>  actions: &#123;<br>    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;<br>      <span class="hljs-keyword">if</span> ((state.count + rootState.count) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>        commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  <span class="hljs-comment">// ...</span><br>  getters: &#123;<br>    sumWithRootCount (state, getters, rootState) &#123;<br>      <span class="hljs-keyword">return</span> state.count + rootState.count<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>
<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 <code>namespaced: true</code> 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    account: &#123;<br>      namespaced: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// account是一个独立模块</span><br><br>      <span class="hljs-comment">// 模块内容（module assets）</span><br>      state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;), <span class="hljs-comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span><br>      getters: &#123;<br>        isAdmin () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/isAdmin&#x27;]</span><br>      &#125;,<br>      actions: &#123;<br>        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; dispatch(&#x27;account/login&#x27;)</span><br>      &#125;,<br>      mutations: &#123;<br>        login () &#123; ... &#125; <span class="hljs-comment">// -&gt; commit(&#x27;account/login&#x27;)</span><br>      &#125;,<br><br>      <span class="hljs-comment">// 嵌套模块</span><br>      modules: &#123;<br>        <span class="hljs-comment">// 继承父模块的命名空间 ⭐ 这是是一个独立命名模块下的非独立命名模块</span><br>        myPage: &#123;<br>          state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>          getters: &#123;<br>            profile () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/profile&#x27;]</span><br>          &#125;<br>        &#125;,<br><br>        <span class="hljs-comment">// 进一步嵌套命名空间</span><br>        posts: &#123;           <span class="hljs-comment">// ⭐ 这是是一个独立命名模块下的独立命名模块</span><br>          namespaced: <span class="hljs-literal">true</span>,<br><br>          state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>          getters: &#123;<br>            popular () &#123; ... &#125; <span class="hljs-comment">// -&gt; getters[&#x27;account/posts/popular&#x27;]</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>
<h4 id="在带命名空间的模块内访问全局内容"><a href="#在带命名空间的模块内访问全局内容" class="headerlink" title="在带命名空间的模块内访问全局内容"></a>在带命名空间的模块内访问全局内容</h4><p>如果你希望使用全局 state 和 getter，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p>
<p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>&#123; root: true &#125;</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">modules: &#123;<br>  foo: &#123;<br>    namespaced: <span class="hljs-literal">true</span>,<br><br>    getters: &#123;<br>      <span class="hljs-comment">// 在这个模块的 getter 中，`getters` 被局部化了</span><br>      <span class="hljs-comment">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span><br>      someGetter (state, getters, rootState, rootGetters) &#123;<br>        getters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;foo/someOtherGetter&#x27;</span><br>        rootGetters.someOtherGetter <span class="hljs-comment">// -&gt; &#x27;someOtherGetter&#x27;</span><br>      &#125;,<br>      someOtherGetter: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123; ... &#125;<br>    &#125;,<br><br>    actions: &#123;<br>      <span class="hljs-comment">// 在这个模块中， dispatch 和 commit 也被局部化了</span><br>      <span class="hljs-comment">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span><br>      someAction (&#123; dispatch, commit, getters, rootGetters &#125;) &#123;<br>        getters.someGetter <span class="hljs-comment">// -&gt; &#x27;foo/someGetter&#x27;</span><br>        rootGetters.someGetter <span class="hljs-comment">// -&gt; &#x27;someGetter&#x27;</span><br><br>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someOtherAction&#x27;</span><br>        dispatch(<span class="hljs-string">&#x27;someOtherAction&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someOtherAction&#x27;</span><br><br>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>) <span class="hljs-comment">// -&gt; &#x27;foo/someMutation&#x27;</span><br>        commit(<span class="hljs-string">&#x27;someMutation&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// -&gt; &#x27;someMutation&#x27;</span><br>      &#125;,<br>      someOtherAction (ctx, payload) &#123; ... &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Vue/">Vue</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/03/25/Vue/Vue%E7%BB%84%E4%BB%B6%E5%8C%96/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue2.x组件化分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/19/python3/python3/">
                        <span class="hidden-mobile">python3笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
