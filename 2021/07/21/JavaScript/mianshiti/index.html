

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>js面试题相关内容 - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="js面试题相关内容">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-21 23:32" pubdate>
        2021年7月21日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      244
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">js面试题相关内容</h1>
            
            <div class="markdown-body">
              <h2 id="JavaScript操作符"><a href="#JavaScript操作符" class="headerlink" title="JavaScript操作符"></a>JavaScript操作符</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><h3 id="指数操作符-ES7"><a href="#指数操作符-ES7" class="headerlink" title="指数操作符 ES7"></a>指数操作符 ES7</h3><h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><h3 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h3><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>理解： 正常运行模式（混杂模式） → <code>&quot;use strict;&quot;</code>严格模式</p>
<p>目的 / 作用：</p>
<ol>
<li>消除JavaScript语法的不严谨、不合理的地方，减少一些怪异行为。</li>
<li>消除JavaScript语法的不安全隐患，为代码的运行保驾护航。</li>
</ol>
<p>语法和行为的改变：</p>
<ol>
<li>变量在使用之前必须声明，且在一个作用域（词法环境）内只能声明一次。</li>
<li>禁止开发人员定义的函数在运行时，其<code>this</code>指向全局对象。在<code>this</code>丢失时，值为<code>undefined</code>。</li>
<li>为<code>eval</code>函数的运行代码创建局部作用域，<code>eval</code>函数内声明的变量不可以在外界访问。</li>
<li>对象不能有重名属性。</li>
<li>….</li>
</ol>
<h2 id="作用域、执行上下文、执行栈、闭包"><a href="#作用域、执行上下文、执行栈、闭包" class="headerlink" title="作用域、执行上下文、执行栈、闭包"></a>作用域、执行上下文、执行栈、闭包</h2><h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3><p><font color='red'>词法环境类似于作用域的概念，JavaScript采用的是词法作用域。</font></p>
<blockquote>
<p><strong><code>ECMAScript2015</code>规范中对词法环境的描述如下</strong>：</p>
<p><strong>原文：</strong></p>
<p>A <em>Lexical Environment</em> is a specification type used to define the association of <em>Identifiers</em> to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an <a target="_blank" rel="noopener" href="https://262.ecma-international.org/6.0/#sec-environment-records">Environment Record</a> and a possibly null reference to an <em>outer</em> Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a <em>FunctionDeclaration</em>, a <em>BlockStatement</em>, or a <em>Catch</em> clause of a <em>TryStatement</em> and a new Lexical Environment is created each time such code is evaluated.</p>
<p><strong>分句翻译：</strong></p>
<ul>
<li>词法环境是用来定义 基于词法嵌套结构的<code>ECMAScript</code>代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。</li>
<li>一个词法环境由环境记录（<code>Environment Record</code>）和一个可能为<code>null</code>的对外部词法环境的引用（<code>outer</code>）组成。</li>
<li>一般来说，词法环境都与特定的<code>ECMAScript</code>代码语法结构相关联，例如<strong>函数声明</strong>、代码块（for+let/with语句…）、<code>TryCatch</code>中的<code>Catch</code>从句，并且每次解释执行这类代码结构时都会创建新的词法环境。</li>
</ul>
<p><strong>注意：</strong></p>
<p>函数声明（定义）时就发生了词法环境的创建，区别于函数执行上下文中的词法环境组件和变量环境组件。</p>
</blockquote>
<h4 id="词法环境的分类"><a href="#词法环境的分类" class="headerlink" title="词法环境的分类"></a>词法环境的分类</h4><p>👇 <font color='cornflowerblue'>这是自己归纳的，不是官方说法</font></p>
<p><strong>词法环境</strong>是一个抽象类型，根据<font color='red'>创建时机</font>的不同，可分为多种具体类型：</p>
<ul>
<li><p><strong>全局词法环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。在一个JavaScript程序中只会有一个全局词法环境实例，在全局的<code>ECMAScript</code>代码执行之前就被创建。。</p>
<blockquote>
<p>全局环境中的环境记录器(Environment Record)由一个声明环境记录器和一个对象环境记录器构成。</p>
<p>它的声明环境记录器部分保存着对全局的变量与自定义的函数绑定。</p>
<p>它的对象环境记录器部分被<font color='red'>绑定到全局对象</font>（在浏览器环境中window对象），因此它拥有对内建的 Object/Array/Math等标识的绑定。</p>
<p>全局环境的外部环境引用是 <strong>null</strong>。</p>
</blockquote>
</li>
<li><p><strong>函数词法环境</strong>是在函数声明（定义）时实例化的词法环境类型。</p>
<blockquote>
<p>函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局词法环境，或者任何包含此内部函数的外部函数的外部词法环境。</p>
</blockquote>
</li>
<li><p><strong>模块词法环境</strong>是在一个<code>ES6</code>模块中创建的词法环境，包含对一些<code>import</code>的变量的绑定，其外层词法环境是全局词法环境。</p>
</li>
<li><p><strong>Block词法环境</strong>，例如执行<code>for + let</code>循环的代码块时，或是执行<code>with</code>代码块时，就会实例化一个Block类型的词法环境。</p>
<blockquote>
<p>注意，<code>for + var</code>循环的代码块执行时不会创建一个新的词法环境，<code>for + var</code>结构会为这段代码所属的词法环境添加一个新的绑定。</p>
</blockquote>
</li>
<li><p><strong>Catch词法环境</strong>，执行<code>try catch</code>结构中的<code>catch</code>从句时，会实例化一个此类型的词法环境。</p>
<blockquote>
<p><code>catch(e)&#123;...&#125;</code>会创建一个新的词法环境，词法环境中有标识符为<code>e</code>的绑定，同时也会有对catch结构代码块内声明的变量的绑定。</p>
</blockquote>
</li>
</ul>
<h4 id="词法环境的构成"><a href="#词法环境的构成" class="headerlink" title="词法环境的构成"></a>词法环境的构成</h4><p>在词法环境的内部有两个组件：</p>
<p>(1) 环境记录器 ：<code>Environment Record</code>。</p>
<blockquote>
<p>可以理解为相应代码块内的所有变量声明、函数声明（代码块若为函数还包括其形参）都储存于此<br>对应网上博客中疯传的变量对象VO和活动对象AO。</p>
</blockquote>
<p> (2) 对外部环境的引用 ：<code>outer</code>指针。</p>
<h4 id="环境记录器（environment-records）"><a href="#环境记录器（environment-records）" class="headerlink" title="环境记录器（environment records）"></a>环境记录器（environment records）</h4><p>简单来说<strong>环境记录器</strong>是一种持有<strong>标识符—变量映射</strong>的结构。这里的标识符指的是变量/函数的名字，而变量是对基本类型数据、一般对象、函数类型对象的原始数据的引用。</p>
<p><code>ES 2015规范</code>中提到：环境记录器是一个抽象类，它有两个基本的子类（声明式环境记录器和对象式环境记录器）和一个特殊的子类（全局环境记录器）</p>
<p><strong>环境记录器的子类：</strong></p>
<ol>
<li><p>声明式环境记录器 <code>declarative environment records</code>。</p>
<blockquote>
<p>声明式环境记录是用来定义那些直接将标识符与语言值绑定的ES语法元素，例如var，const，let，class，module，import以及函数声明等。</p>
<p>声明式环境记录有函数环境记录（Function Environment Record）和模块环境记录（Module Environment Record）两种特殊类型。</p>
</blockquote>
</li>
<li><p>对象式环境记录器 <code>object environment records</code>。</p>
<blockquote>
<p>每个对象式环境记录都与一个对象相关联，这个对象叫做对象式环境记录的<code>binding object</code>。可以理解为对象式环境记录就是基于这个<code>binding object</code>，以对象属性的形式进行标识符绑定，标识符与<code>binding object</code>的属性名一一对应。</p>
<p>是对象就可以动态添加或者删除属性，所以对象环境记录不存在不可变绑定。</p>
<p>对象式环境记录用来定义那些将标识符与某些对象属性相绑定的ES语法元素，例如with语句、全局var声明和全局函数声明。</p>
</blockquote>
</li>
<li><p>全局环境记录器 <code>global environment records</code>。</p>
<blockquote>
<ul>
<li><p>全局环境记录逻辑上来说是单个记录，但是实际上可以看作是对一个<code>对象式环境记录</code>组件和一个<code>声明式环境记录</code>组件的封装。</p>
</li>
<li><p>之前说过每个<code>对象式环境记录</code>都有一个<code>binding object</code>，全局环境记录的<code>对象式环境记录</code>的<code>binding object</code>就是全局对象，在浏览器内，全局的<code>this</code>及<code>window</code>绑定都指向全局对象。全局环境记录的<code>对象式环境记录</code>组件，绑定了所有内置全局属性、全局的函数声明以及全局的<code>var</code>声明。所以这些绑定我们可以通过<code>window.xx</code>或<code>this.xx</code>获取到。</p>
</li>
<li><p>全局代码的其他声明（如<strong>let、const、class</strong>等）则绑定在<code>声明式环境记录</code>组件内，由于<code>声明式环境记录</code>组件并不是基于简单的对象形式来实现绑定，所以这些声明我们并<strong>不能通过全局对象的属性来访问</strong>。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>抽象地讲，词法环境在伪代码中看起来像这样：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts">GlobalExectionContext = &#123;<br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;null&gt;</span><br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br><span class="hljs-symbol">  LexicalEnvironment:</span> &#123;<br><span class="hljs-symbol">    EnvironmentRecord:</span> &#123;<br><span class="hljs-symbol">      Type:</span> <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br><span class="hljs-symbol">    outer:</span> <span class="hljs-params">&lt;Global or outer function environment reference&gt;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="外部词法环境的引用（outer）"><a href="#外部词法环境的引用（outer）" class="headerlink" title="外部词法环境的引用（outer）"></a>外部词法环境的引用（outer）</h4><p>首先要说明两点：</p>
<ol>
<li>全局环境的外部词法环境引用为<code>null</code>。</li>
<li>一个词法环境可以作为多个词法环境的外部环境。例如全局声明了多个函数，则这些函数词法环境的外部词法环境引用都指向全局环境。</li>
</ol>
<p>外部词法环境的引用将一个词法环境和其外部词法环境链接起来，外部词法环境又拥有对其自身的外部词法环境的引用。这样就形成一个链式结构，这里我们称其为<strong>环境链</strong>（即ES6之前的作用域链），全局环境是这条链的顶端。</p>
<p>环境链的存在是为了标识符的解析，通俗的说就是查找变量。首先在当前环境查找变量，找不到就去外部环境找，还找不到就去外部环境的外部环境找，以此类推，直到找到，或者到环境链顶端（全局环境）还未找到则抛出<code>ReferenceError</code>。</p>
<p><strong>标识符解析</strong>：在环境链中解析变量（绑定）的过程，</p>
<p>我们使用伪代码来模拟一下标识符解析的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">ResolveBinding(name[, LexicalEnvironment]) &#123;<br>    &#x2F;&#x2F; 如果传入词法环境为null(即一直解析到全局环境还未找到变量)，则抛出ReferenceError<br>    if (LexicalEnvironment &#x3D;&#x3D;&#x3D; null) &#123;<br>        throw ReferenceError(&#96;$&#123;name&#125; is not defined&#96;)<br>    &#125;<br><br>    &#x2F;&#x2F; 首次查找，将当前词法环境设置为解析环境<br>    if (typeof LexicalEnvironment &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;<br>        LexicalEnvironment &#x3D; currentLexicalEnvironment<br>    &#125;<br><br>    &#x2F;&#x2F; 检查环境的环境记录中是否有此绑定<br><br>    let isExist &#x3D; LexicalEnvironment.EnviromentRecord.HasBinding(name)<br><br>    &#x2F;&#x2F; 如果有则返回绑定值，没有则去外层环境查找<br><br>    if （isExist） &#123;<br>        return LexicalEnvironment.EnviromentRecord[name]<br>    &#125; else &#123;<br>        return ResolveBinding(name, LexicalEnvironment.outer)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>执行上下文是一个抽象概念，可以理解为评估和执行JavaScript代码的环境，每段JavaScript代码都运行在某一个执行上下文环境中。执行全局代码、函数调用最开始都会创建一个执行上下文。</p>
<p>执行上下文有以下组件：</p>
<ol>
<li><code>Code Evaluation State</code></li>
<li><code>Function</code></li>
<li><code>Realm</code></li>
<li><code>LexicalEnvironment</code></li>
<li><code>VariableEnvironment</code></li>
</ol>
<h4 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h4><ol>
<li><p><strong>全局执行上下文。</strong>这是默认或者说是基础的上下文，任何不在函数内部的代码都在全局上下文中。全局执行上下文创建时会执行一些操作，其中包括：</p>
<ul>
<li>创建一个全局对象（浏览器环境下为window，node环境下为global）。</li>
<li>并且设置<code>this</code>指向这个全局对象。</li>
</ul>
<blockquote>
<p>（不论何种JavaScript运行环境）一个程序中，只会有一个全局执行上下文。</p>
</blockquote>
</li>
<li><p><strong>函数执行上下文。</strong>每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，在函数被调用时创建的。</p>
</li>
<li><p><strong>Eval函数执行上下文。</strong>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</p>
</li>
</ol>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p><strong>执行栈，</strong>也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来<strong>存储和管理</strong>代码运行时创建的<strong>所有执行上下文</strong>。</p>
<ul>
<li>当一个JavaScript程序运行时，JavaScript引擎第一时间创建一个<font color='red'>全局执行上下文</font>并将其<font color='red'>压入栈底</font>。</li>
<li>每当一个<font color='red'>函数被调用</font>时，该函数的执行上下文<font color='red'>压栈</font>，函数<font color='red'>执行完毕时</font>执行上下文<font color='red'>出栈</font>。</li>
<li>一旦<font color='red'>所有代码执行完毕</font>，JavaScript 引擎从当前栈中移除全局执行上下文（浏览器环境下，页面如果不关闭，全局执行上下文会永远保存）。</li>
</ul>
<h4 id="执行上下文的创建阶段"><a href="#执行上下文的创建阶段" class="headerlink" title="执行上下文的创建阶段"></a>执行上下文的创建阶段</h4><p>全局代码或函数执行时，JavaScript引擎会创建相应的执行上下文，在执行上下文的创建阶段会发生三件事：</p>
<ol>
<li><strong>this绑定</strong></li>
<li>创建**词法环境组件 **<code>LexicalEnvironment</code></li>
<li> 创建<strong>变量环境组件</strong><code>VaribleEnviroment</code></li>
</ol>
<p>所以执行上下文在概念上表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">ExecutionContext &#x3D; &#123;<br>  ThisBinding &#x3D; &lt;this value&gt;,<br>  LexicalEnvironment &#x3D; &#123; ... &#125;,<br>  VariableEnvironment &#x3D; &#123; ... &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="This-绑定"><a href="#This-绑定" class="headerlink" title="This 绑定"></a>This 绑定</h4><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p>
<p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123;<br>  baz: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>foo.baz();   <span class="hljs-comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span><br>             <span class="hljs-comment">// 对象 &#x27;foo&#x27; 调用</span><br><span class="hljs-keyword">let</span> bar = foo.baz;<br><br>bar();       <span class="hljs-comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span><br>             <span class="hljs-comment">// 没有指定引用对象</span><br></code></pre></td></tr></table></figure>


<h4 id="词法环境组件和变量环境组件"><a href="#词法环境组件和变量环境组件" class="headerlink" title="词法环境组件和变量环境组件"></a>词法环境组件和变量环境组件</h4><p><strong>词法环境组件和变量环境组件的区别：</strong></p>
<ol>
<li><p><strong>作用上的区别：</strong></p>
<p>前者被用来存储函数声明和变量（<code>function</code>、<code>let</code> 、 <code>const</code>、<code>class</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p>
</li>
<li><p><strong>结构上的区别：</strong></p>
<ul>
<li>前者是一个类似于<strong>小型栈</strong>的结构（相比于执行栈，是小型的），在执行上下文的创建阶段，里面只有一个词法环境对象，而在执行上下文的执行阶段，这个栈中可能存储多个词法环境对象（如遇到代码块、catch从句、with代码块时会添加新的词法环境对象进去）。</li>
<li>而在一个执行上下文中，后者只保存一个词法环境对象，即保存<code>var</code>声明的变量绑定（在函数的可执行代码中，在任何地方用<code>var</code>声明的变量都会在执行上下文预处理阶段保存到变量词法组件中）。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/feral_coder/article/details/106447013">参考文章链接 https://blog.csdn.net/feral_coder/article/details/106447013</a></p>
<h4 id="执行上下文的执行阶段"><a href="#执行上下文的执行阶段" class="headerlink" title="执行上下文的执行阶段"></a>执行上下文的执行阶段</h4><p>在此阶段，伴随着代码的执行，JavaScript引擎不断更新执行上下文中的内容，直到代码执行完毕。</p>
<p>执行过程中，如果遇到局部代码块（包括with、for、if）时，JS引擎会创建新的词法环境，并将其添加到当前执行上下文的词法环境组件的栈顶，当代码块执行完毕，词法环境出栈。</p>
<p>当前执行上下文中调用某个函数，则当前执行上下文会被挂起，JS引擎会为函数调用创建新的执行上下文，这个新的执行上下文压入执行栈并成为新的当前执行上下文。</p>
<p>当前执行上下文中的所有代码执行完毕，JS引擎会将当前执行上下文出栈，并继续执行栈顶的执行上下文代码。</p>
<h3 id="代码预处理"><a href="#代码预处理" class="headerlink" title="代码预处理"></a>代码预处理</h3><p><font color='red'>代码预处理的表现为变量声明提升。但需要注意的是，代码预处理是以词法环境为单位的，而不是以执行上下文为单位的。一个函数拥有一个函数级别的词法环境，一个代码块同样拥有一个块级别的词法环境。</font></p>
<p>可能你已经注意到函数执行上下文创建时，<code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，因此处于未初始化状态。而 <code>var</code> 定义的变量被设成了 <code>undefined</code>，且声明的函数得到初始化，函数变量指向具体的内存地址。这就是所谓的<strong>变量声明提升</strong>。</p>
<blockquote>
<p>虽然通过函数声明定义的函数会一开就完全存储在环境中，但是通过函数表达式定义的函数变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。尽管由<code>let</code>和<code>const</code>声明的变量没有初始化值，且存在暂时性死区，但是JavaScript引擎确实对这些变量声明做了预处理。</p>
</blockquote>
<p><strong>函数中代码执行的步骤：</strong></p>
<ul>
<li><p>在函数执行之前，先扫描出<font color='red'>函数层级</font>的<code>let、const</code>声明的变量以及所有级别的<code>var</code>声明的变量（包括函数局部代码块中的<code>var</code>声明），对他们进行预处理。</p>
</li>
<li><p>然后再扫描当前函数代码中全局的函数声明（非严格模式下也会扫描函数局部代码块中的函数声明），对函数声明进行预处理。</p>
</li>
<li><p>当函数声明和变量声明发生命名冲突时，对函数声明的预处理会覆盖对变量声明的预处理。</p>
</li>
<li><p>执行函数代码，遇到新的<font color='red'>局部代码块</font>时，进行新一轮预处理操作。</p>
</li>
<li><p>函数所有代码执行完毕。</p>
</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包这个概念挖的越深就越难理解，涉及到函数、执行上下文、词法环境（作用域）、垃圾回收等一系列概念。</p>
<p>而且当前人们对闭包的定义各不相同。</p>
<h4 id="MDN对闭包的解释"><a href="#MDN对闭包的解释" class="headerlink" title="MDN对闭包的解释"></a><code>MDN</code>对闭包的解释</h4><blockquote>
<p>Consider the following code example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeFunc</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Mozilla&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayName</span>(<span class="hljs-params"></span>) </span>&#123;<br> alert(name);<br>&#125;<br><span class="hljs-keyword">return</span> displayName;<br>&#125;<br><br><span class="hljs-keyword">var</span> myFunc = makeFunc();<br>myFunc();<br></code></pre></td></tr></table></figure>

<p>Running this code has exactly the same effect as the previous example of the <code>init()</code> function above. What’s different (and interesting) is that the <code>displayName()</code> inner function is returned from the outer function <em>before being executed</em>.</p>
<p>At first glance, it might seem unintuitive that this code still works. In some programming languages, the local variables within a function exist for just the duration of that function’s execution. Once <code>makeFunc()</code> finishes executing, you might expect that the name variable would no longer be accessible. However, because the code still works as expected, this is obviously not the case in JavaScript.</p>
<p>The reason is that functions in JavaScript form closures. <strong>A <em>closure</em> is the combination of a function and the lexical environment within which that function was declared.</strong> This environment consists of any local variables that were in-scope at the time the closure was created. In this case, <code>myFunc</code> is a reference to the instance of the function <code>displayName</code> that is created when <code>makeFunc</code> is run. <strong>The instance of <code>displayName</code> maintains a reference to its lexical environment, within which the variable <code>name</code> exists.</strong> For this reason, when <code>myFunc</code> is invoked, the variable <code>name</code> remains available for use, and “Mozilla” is passed to <code>alert</code>.</p>
</blockquote>
<p><strong><em>闭包</em>是一个函数和声明该函数的词法环境的组合。</strong></p>
<p><font color='cornflowerblue'>我觉得这个词法环境👆更像是一个删减版的词法环境，但能够确定的是一个函数保存着对声明该函数时的词法环境的引用。</font></p>
<h4 id="Chrome对闭包的定义"><a href="#Chrome对闭包的定义" class="headerlink" title="Chrome对闭包的定义"></a>Chrome对闭包的定义</h4><p>Chrome浏览器似乎已经成为了前端的标准，那么在Chrome浏览器中，是如何判定闭包的呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">function test() &#123;<br>  var a = 1;<br>  function increase() &#123;<br>    debugger;<br>    var b = 2;<br>    a++;<br>    return a;<br>  &#125;;<br>  increase();<br>&#125;<br>test();<br></code></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-f1d0c322e4d505d20d18129ef4f91207_720w.jpg" srcset="/img/loading.gif" alt="img"></p>
<p>我把debugger置于内部函数<code>increase</code>中，调试时我们直接看右侧的高亮部分，可以发现，Scope中存在一个Closure（闭包），Closure的名称是外部函数<code>test</code>的函数名，闭包中的变量<code>a</code>是在函数<code>test</code>中定义的，而变量<code>b</code>是作为本地变量处于<code>Local</code>中。</p>
<p>PS: 关于本地变量，可以参见**<a href="https://link.zhihu.com/?target=http://es5.github.io/%23x10.4.3">localEnv</a>**。</p>
<p>假设我在外部函数<code>test</code>中再定义一个变量<code>c</code>，但是在内部函数<code>increase</code>中不引用它，会怎么样呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span>; <span class="hljs-comment">// c不在闭包中</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increase</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">debugger</span>;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    a++;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;;<br>  increase();<br>&#125;<br>test();<br></code></pre></td></tr></table></figure>
<p>经验证，内部函数<code>increase</code>执行时，变量<code>c</code>没有在闭包中。</p>
<p>我们还可以验证，如果内部函数<code>increase</code>不引用任何外部函数<code>test</code>中的变量，就不会产生闭包。</p>
<p>所以到这里，我们可以下这样一个结论，<strong>闭包产生的必要条件</strong>是：</p>
<ol>
<li>存在函数嵌套；</li>
<li>嵌套的内部函数必须引用在外部函数中定义的变量；</li>
<li>嵌套的内部函数必须被执行。</li>
</ol>
<p><strong>似乎Chrome认为<code>外部函数名+外部函数执行后残留下的词法环境</code>构成闭包。</strong></p>
<h4 id="我对闭包形成机制的理解"><a href="#我对闭包形成机制的理解" class="headerlink" title="我对闭包形成机制的理解"></a>我对闭包形成机制的理解</h4><p>一个函数执行上下文在执行完后（退出执行栈），在它执行过程中声明的某些变量可以以闭包的形式被保留，而不会被垃圾回收器回收。原因是外层执行上下文中仍然间接地（通过内层函数）保持对该变量的引用。闭包像是使得内层函数的词法环境链上多了一个特殊节点。</p>
<p>👆 <font color='cornflowerblue'>这个跟Chrome的观点类似</font></p>
<p>由于ES5中没有块级作用域，所以只有函数闭包❓</p>
<p>ES6中有了块级作用域，会使得闭包有了新的类型？块级闭包❓</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> ret;<br>    <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>        ret = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>            <span class="hljs-built_in">console</span>.log(foo);<span class="hljs-comment">// 在此打断点会发现，ret()执行过程中，多了一层Block类型的词法环境</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">let</span> fn = foo();<br>fn(); <span class="hljs-comment">// 输出 bar</span><br><br></code></pre></td></tr></table></figure>


<h4 id="1-说说对闭包的理解？"><a href="#1-说说对闭包的理解？" class="headerlink" title="1. 说说对闭包的理解？"></a>1. 说说对闭包的理解？</h4><p>MDN的解释是闭包是函数与声明该函数的词法环境的组合（函数保存着对声明该函数词法环境的引用）。</p>
<p>Chrome中查看闭包，发现闭包像是一层残留的词法环境。</p>
<blockquote>
<p>但之所以其中的变量值保留了下来而没有被垃圾回收期回收，是因为内层函数有对声明该函数词法环境的引用，同时该内层函数对象被外部执行上下文的词法环境记录器保存。</p>
</blockquote>
<h4 id="2-为什么说所有函数都是闭包？"><a href="#2-为什么说所有函数都是闭包？" class="headerlink" title="2.为什么说所有函数都是闭包？"></a>2.为什么说所有函数都是闭包？</h4><p>从定义上来说，闭包不是一种函数，而是函数与声明该函数的词法环境的组合。</p>
<p>如果非要解释，那就是任何函数创建时，都会在该函数对象上保存对声明该函数词法环境的引用，但这种引用不是引用词法环境的全部内容，而是部分内容，这其中就涉及到垃圾回收策略。</p>
<h2 id="this、apply、call、bind"><a href="#this、apply、call、bind" class="headerlink" title="this、apply、call、bind"></a>this、apply、call、bind</h2><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><ol>
<li><p>函数没有显式的宿主时，this指向全局对象（在严格模式下this的值为undefined）。</p>
</li>
<li><p>当函数存在宿主（以方法的形式调用），this指向该宿主对象。</p>
</li>
<li><p>当函数是构造函数（以new的方式调用），this指向新实例化的对象。</p>
</li>
<li><p>当函数不是箭头函数，且用apply、call、bind方法绑定了宿主对象，则函数调用时this指向该宿主对象。</p>
</li>
<li><p>函数是箭头函数，根据函数声明时的词法环境判断this。</p>
</li>
</ol>
<h3 id="ES6写法模拟apply、call、bind"><a href="#ES6写法模拟apply、call、bind" class="headerlink" title="ES6写法模拟apply、call、bind"></a>ES6写法模拟apply、call、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义apply</span><br><span class="hljs-built_in">Function</span>.prototype.myapply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(args)) &#123;<br>    <span class="hljs-keyword">if</span> (args === <span class="hljs-literal">null</span> || args === <span class="hljs-literal">undefined</span>) &#123;<br>      args = [];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;The second argument must be an Array&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (ctx === <span class="hljs-literal">undefined</span> || ctx === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>(...args);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctx !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123; <span class="hljs-comment">// 只可能是引用类型，null已经被前一个if判断语句剔除</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not an Object&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> fnSymbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;__fn__&#x27;</span>);<br>  <span class="hljs-built_in">Object</span>.defineProperty(ctx, fnSymbol, &#123;<br>    value: <span class="hljs-built_in">this</span>,<br>    configurable: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 让该属性能够被删除,configurable默认为false</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> result = ctx[fnSymbol](...args);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性前&#x27;</span>, <span class="hljs-built_in">Reflect</span>.ownKeys(ctx));<br>  <span class="hljs-comment">// Reflect.deleteProperty(ctx, fnSymbol);</span><br>  <span class="hljs-keyword">delete</span> ctx[fnSymbol];<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性后&#x27;</span>, <span class="hljs-built_in">Reflect</span>.ownKeys(ctx));<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 自定义call</span><br><span class="hljs-built_in">Function</span>.prototype.mycall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.myapply(ctx, args);<br>&#125;<br><br><span class="hljs-comment">// 自定义bind</span><br><span class="hljs-built_in">Function</span>.prototype.mybind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx, ...partialArgs</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not callable&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> args = partialArgs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>    <span class="hljs-keyword">return</span> self.myapply(ctx, args);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>));<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;myapply测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.myapply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mycall测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.mycall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mybind测试：&#x27;</span>);<br><span class="hljs-keyword">const</span> fn = add.mybind(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure>


<h3 id="ES5写法模拟apply、call、bind"><a href="#ES5写法模拟apply、call、bind" class="headerlink" title="ES5写法模拟apply、call、bind"></a>ES5写法模拟apply、call、bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 自定义apply</span><br><span class="hljs-built_in">Function</span>.prototype.myapply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> fn = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || [], <br>      argsString = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (!(args <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;The second argument must be an Array&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>    argsString += <span class="hljs-string">&#x27;args[&#x27;</span> + i + <span class="hljs-string">&#x27;],&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (ctx === <span class="hljs-literal">undefined</span> || ctx === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 方法1 new Funciton ⭐ 更加安全</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;fn&#x27;</span>, <span class="hljs-string">&#x27;args&#x27;</span>, <span class="hljs-string">&#x27;return fn(&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>)(fn, args);<br>      <br>    <span class="hljs-comment">// 方法2 eval函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;fn(&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctx !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(ctx + <span class="hljs-string">&#x27;is not an Object&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> mountProp = <span class="hljs-string">&#x27;__fn__&#x27;</span>, temp;<br>  <span class="hljs-keyword">if</span> (ctx[mountProp]) &#123;<br>    temp = ctx[mountProp];<br>  &#125;<br>  <span class="hljs-built_in">Object</span>.defineProperty(ctx, mountProp, &#123;<br>    value: fn,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    enumerable: <span class="hljs-literal">false</span>,<br>  &#125;);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性前的this对象&#x27;</span>, ctx);<br>    <br>  <span class="hljs-comment">/*========== 执行ctx[mountProp]，并得到返回的数据==========*/</span><br>  <span class="hljs-comment">// 方法1. new Function ⭐ 更加安全</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>      <span class="hljs-string">&#x27;ctx&#x27;</span>, <span class="hljs-comment">// 参数1</span><br>      <span class="hljs-string">&#x27;args&#x27;</span>, <span class="hljs-comment">// 参数2</span><br>      <span class="hljs-string">&#x27;mountProp&#x27;</span>, <span class="hljs-comment">// 参数3</span><br>      <span class="hljs-string">&#x27;return ctx[mountProp](&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span> <span class="hljs-comment">// 函数体代码</span><br>  )(ctx, args, mountProp);<br>  <br>    <br>  <span class="hljs-comment">// 方法2. eval</span><br>  <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;ctx[mountProp](&#x27;</span> + argsString + <span class="hljs-string">&#x27;)&#x27;</span>);<br>  <br>  <br>  <span class="hljs-keyword">delete</span> ctx[mountProp];<br>  <span class="hljs-keyword">if</span> (temp) &#123;<br>    ctx[mountProp] = temp;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;删除属性后的this对象&#x27;</span>, ctx);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 自定义call</span><br><span class="hljs-built_in">Function</span>.prototype.mycall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">var</span> args = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.myapply(ctx, args);<br>&#125;<br><br><span class="hljs-comment">// 自定义bind</span><br><span class="hljs-built_in">Function</span>.prototype.mybind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-built_in">this</span> + <span class="hljs-string">&#x27;is not a Function&#x27;</span>);<br>  &#125; <br>  <span class="hljs-keyword">var</span> partialArgs = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) partialArgs.push(<span class="hljs-built_in">arguments</span>[i]);<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> args = partialArgs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) args.push(<span class="hljs-built_in">arguments</span>[i]);<br>    <span class="hljs-keyword">return</span> self.myapply(ctx, args);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;myapply测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.myapply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mycall测试：&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(add.mycall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;mybind测试：&#x27;</span>);<br><span class="hljs-keyword">const</span> fn = add.mybind(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>&#125;, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">4</span>));<br></code></pre></td></tr></table></figure>


<h2 id="原型链、类、继承"><a href="#原型链、类、继承" class="headerlink" title="原型链、类、继承"></a>原型链、类、继承</h2><h3 id="原型链示意图"><a href="#原型链示意图" class="headerlink" title="原型链示意图"></a>原型链示意图</h3><p><img src="/2021/07/21/JavaScript/mianshiti/image-20210622171532346.png" srcset="/img/loading.gif" alt="image-20210622171532346"></p>
<p>其中还缺三条紫色线：Object分别实例化 Function.prototype、Object.prototype、Person.prototype。</p>
<p>最主要的核心逻辑：<code>Function = new Function()</code>导致<code>Function.constructor === Function</code>。</p>
<p><strong>要点</strong></p>
<ol>
<li><p>JavaScript语言内部，当创建一个函数时，会相应地生成该函数的原型对象，并且函数的<code>prototype</code>属性指向该原型对象，而该原型对象<code>constructor</code>属性指向函数。</p>
<blockquote>
<p>函数的<code>prototype</code>以及原型对象的<code>constructor</code>属性是不可枚举的、不可修改、不可删除的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br> writable: <span class="hljs-literal">false</span>,<br> enumerable: <span class="hljs-literal">false</span>,<br> configurable: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>当使用<code>new</code>关键字加构造函数的形式创建对象时，JavaScript会实例化一个对象，实例化步骤：</p>
<ul>
<li>创建一个空对象，该空对象的<code>__proto__</code>属性指向构造函数的原型对象。</li>
<li>借用构造函数，为该空对象赋属性值。</li>
<li>返回这个新创建并经过处理的对象。</li>
</ul>
</li>
<li><p>万物皆对象，所有原型对象、函数、普通JavaScript对象都是<code>Object</code>类型的实例。</p>
</li>
<li><p><code>Object</code>构造函数是<code>Function</code>类型的实例，<code>Function</code>也是<code>Function</code>类型的实例。</p>
<p>即存在这样的逻辑：<code>Object = new Function(...); Function = new Function()</code>;</p>
</li>
<li><p>所有函数对象（包括<code>Function、Object</code>）都有一个显式原型和一个隐式原型。它们的显式原型<code>prototype</code>指向各自的原型对象，而函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>。</p>
</li>
</ol>
<h3 id="ES5的类与继承写法"><a href="#ES5的类与继承写法" class="headerlink" title="ES5的类与继承写法"></a>ES5的类与继承写法</h3><p>在<code>ES5</code>中，JavaScript不提供<strong>类</strong>的标准语法，需要通过“构造函数”的方式来模仿类型机制。</p>
<p>在<code>ES5</code>中，JavaScript不提供<strong>继承</strong>的标准语法，需要通过“组合继承”的方式来模仿继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">组合继承 &#x3D; 借用父类构造函数 + 原型继承<br>          👆 继承父类属性    👆 继承父类的方法<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Father.prototype.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  Father.call(<span class="hljs-built_in">this</span>, name);<br>&#125;<br><br>Son.prototype = <span class="hljs-keyword">new</span> Father();<br><span class="hljs-built_in">Object</span>.defineProperty(Son.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;<br>  value: Father,<br>&#125;)<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;mz&#x27;</span>);<br>s.sayHi();<br></code></pre></td></tr></table></figure>


<h3 id="ES6的类与继承语法"><a href="#ES6的类与继承语法" class="headerlink" title="ES6的类与继承语法"></a>ES6的类与继承语法</h3><p><code>class</code>是<code>ES6</code>引入的一个关键字，<strong>其用法基本上等同于<code>ES5</code>中的组合继承</strong>，所以class关键字的引入并没有为JavaScript添加新的继承模型，而是仅仅作为一个<strong>语法糖</strong>被使用，因此JavaScript中的class和其他面向对象语言中的class是两码事。</p>
<p><strong>类的成员定义：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>        <span class="hljs-comment">// 在构造函数中定义实例属性</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is an static method&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 静态属性</span><br>Human.staticProp = <span class="hljs-string">&#x27;...&#x27;</span>; <span class="hljs-comment">//❗ 在ES2015规范中，类的静态属性定义在类外（类内不存在定义静态属性的语法）</span><br></code></pre></td></tr></table></figure>
<p><strong>继承：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chinese</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age, hometown</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name, age);<br>    <span class="hljs-built_in">this</span>.hometown = hometown;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">greeting</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.sayHi();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I am from <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.hometown&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.describle();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>要点：</p>
<ol>
<li><p><code>ES2015</code>规范中，允许使用<code>extends</code>关键字实现<font color='red'>单继承</font>。此时会实例化一个父类对象，作为子类的原型对象（修改子类的<code>prototype</code>）。同时<font color='red'>删除</font>父类对象本来拥有的所有属性，然后再将该对象的<code>constructor</code>属性（不可枚举、不可修改、不可删除的属性）指向子类。</p>
</li>
<li><p>在子类的构造函数中，可以使用<code>super</code>方法显式调用父类的构造函数并传入父类构造函数所需要的参数。子类构造函数中调用<code>super</code>方法，会借用父类的构造函数为子类实例属性赋值。</p>
<blockquote>
<p>从要点1和要点2看出，<code>ES2015</code>规范提供的类的标准语法，实际上是组合继承的语法糖。</p>
</blockquote>
</li>
<li><p>子类会继承父类的实例方法、静态方法、静态属性。</p>
</li>
<li><p>子类的实例方法中可以通过<code>super</code>调用父类的实例方法，同时父类实例方法调用时<code>this</code>指向子类实例。</p>
</li>
<li><p>子类的静态方法中可以通过<code>super</code>调用父类的静态方法，同时父类静态方法调用时<code>this</code>指向子类。</p>
<blockquote>
<p>注意，子类静态方法中不能通过<code>super</code>访问父类实例方法；</p>
<p>同理，子类实例方法中不能通过<code>super</code>访问父类静态方法</p>
</blockquote>
</li>
<li><p>子类中可以重写父类的方法，对其进行覆盖。</p>
<blockquote>
<p>区别于方法重载，JS中没有重载。</p>
</blockquote>
</li>
</ol>
<h3 id="最新的类的语法"><a href="#最新的类的语法" class="headerlink" title="最新的类的语法"></a>最新的类的语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;<br>    <span class="hljs-comment">// ⭐ 可以显式地定义实例属性，也可以进行默认值赋值。</span><br>    name = <span class="hljs-string">&#x27;John Doe&#x27;</span>; <br>    age;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>        <span class="hljs-comment">// 在构造函数中定义实例属性</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 静态方法</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">describle</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is an static method&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// ⭐ 静态属性 </span><br>	<span class="hljs-keyword">static</span> staticProp = <span class="hljs-string">&#x27;...&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>




<h2 id="JavaScript数据类型"><a href="#JavaScript数据类型" class="headerlink" title="JavaScript数据类型"></a>JavaScript数据类型</h2><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p><code>typeof</code>运算符总会返回一个字符串。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// typeof 数字 👉 &#x27;number&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">0</span>); <br><br><span class="hljs-comment">// typeof 字符串 👉 &#x27;string&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// typeof 布尔值 👉 &#x27;boolean&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// typeof undefined 👉 &#x27;undefined&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);<br><br><span class="hljs-comment">// typeof null 👉 &#x27;object&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// typeof 引用类型数据（包括数组） 👉 &#x27;object&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> &#123;&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []);<br><br><span class="hljs-comment">// typeof Symbol值 👉 &#x27;symbol&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>));<br></code></pre></td></tr></table></figure>


<h4 id="判断-undefined和null"><a href="#判断-undefined和null" class="headerlink" title="=== 判断 undefined和null"></a>=== 判断 undefined和null</h4><p>可以用 <code>===</code>来判断一个数据是否为<code>undefined</code>和<code>null</code>，原因是<code>===</code>判断相等的前提是类型相等，而和<code>undefined</code>和<code>null</code>同类型的只有他们本身。</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p><code>A instanceof B</code>返回<code>true</code>的条件是：B的显示原型对象等于A或在A的隐式原型链上。</p>
<p>通常用于判断某个对象是不是某个类的实例。</p>
<blockquote>
<p>要求：</p>
<ol>
<li><p>A 必须是一个引用类型对象，不可以是 Number、String、Boolean、undefined、null、Symbol类型的数据，否则返回false</p>
</li>
<li><p>B 必须是一个构造函数/类（也可以是一个对象，但不实 用），否则报错。</p>
</li>
</ol>
</blockquote>
<h4 id="使用Object-prototype-toString"><a href="#使用Object-prototype-toString" class="headerlink" title="使用Object.prototype.toString"></a>使用Object.prototype.toString</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数字</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">123</span>)) <span class="hljs-comment">// &#x27;[object Number]&#x27;</span><br><br><span class="hljs-comment">// 字符串</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&#x27;&#x27;</span>)) <span class="hljs-comment">// &#x27;[object String]&#x27;</span><br><br><span class="hljs-comment">// 布尔型</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// &#x27;[object Boolean]&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// &#x27;[object Boolean]&#x27;</span><br><br><span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// &#x27;[object Undefined]&#x27;</span><br><br><span class="hljs-comment">// null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// &#x27;[object Null]&#x27;</span><br><br><span class="hljs-comment">// 普通JS对象</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;)); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br><br><span class="hljs-comment">// 数组</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call([])); <span class="hljs-comment">// &#x27;[object Array]&#x27;</span><br><br><span class="hljs-comment">// Symbol</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>))); <span class="hljs-comment">// &#x27;[object Symbol]&#x27;</span><br><br><span class="hljs-comment">// 函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(Person)); <span class="hljs-comment">// &#x27;[object Function]&#x27;</span><br><br><span class="hljs-comment">// 类的实例</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(p)); <span class="hljs-comment">// &#x27;[object Object]&#x27;</span><br><br>p[<span class="hljs-built_in">Symbol</span>.toStringTag] = <span class="hljs-string">&#x27;Person&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(p)); <span class="hljs-comment">// &#x27;[object Person]&#x27;</span><br></code></pre></td></tr></table></figure>




<h3 id="显式的类型转换"><a href="#显式的类型转换" class="headerlink" title="显式的类型转换"></a>显式的类型转换</h3><h4 id="各类型数据强制转换为Number⭐"><a href="#各类型数据强制转换为Number⭐" class="headerlink" title="各类型数据强制转换为Number⭐"></a>各类型数据强制转换为Number⭐</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1.布尔型 转 Number </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)) <span class="hljs-comment">// 👉 1</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;false:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// 👉 0</span><br><br><span class="hljs-comment">// 2.undefined 转 Number </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;undefined:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>)) <span class="hljs-comment">// 👉 NaN</span><br><br><span class="hljs-comment">// 3.null 转 Number </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;null:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// 👉 0</span><br><br><span class="hljs-comment">// 4.Symbol 转 Number ❌不允许转</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Symbol:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>))); <span class="hljs-comment">// ❌ 报错，Symbol类型不允许转换为Number</span><br><br><br><span class="hljs-comment">// 5.字符串 转 Number  </span><br><span class="hljs-comment">// 5.1 空串</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;空字符串:&#x27;</span>, <span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>)) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 5.2 只包含数字（包括前面带正负号和多个0）</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;+123&#x27;</span>)) <span class="hljs-comment">//  👉 123</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;000123&#x27;</span>)) <span class="hljs-comment">// 👉 123</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>)) <span class="hljs-comment">// 👉 123</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;-123&#x27;</span>)) <span class="hljs-comment">// 👉 -123</span><br><span class="hljs-comment">// 5.3 字符串可以解析为有效地浮点数格式（包含前面带有正负号以及多个0）</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>))  <span class="hljs-comment">// 👉 1.23</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;.23&#x27;</span>)) <span class="hljs-comment">// 👉 0.23</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;-00.23&#x27;</span>)) <span class="hljs-comment">// 👉 -0.23</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;+0000.23&#x27;</span>)) <span class="hljs-comment">// 👉 0.23</span><br><span class="hljs-comment">// 5.4 字符串可以解析未有效的二进制、八进制、十六进制数（忽略字母大小写）</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0b101&#x27;</span>)) <span class="hljs-comment">// 👉 5</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0B101&#x27;</span>)) <span class="hljs-comment">// 👉 5</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0o71&#x27;</span>)) <span class="hljs-comment">// 👉 57 </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0x1A&#x27;</span>)) <span class="hljs-comment">// 👉 26</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;0x1a&#x27;</span>)) <span class="hljs-comment">// 👉 26</span><br><span class="hljs-comment">// 5.5 除5.1~5.4之外，其他格式的字符串转为Number型会输出NaN</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123s&#x27;</span>)) <span class="hljs-comment">// 👉 NaN</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;.23.4&#x27;</span>)) <span class="hljs-comment">// 👉 NaN</span><br><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">⭐⭐ 以下为引用类型数据转换为Number的规则：⭐⭐</span><br><span class="hljs-comment">+ 如果引用类型数据target有valueOf()方法，且该方法返回一个“非引用类型”的数据data（包括NaN），</span><br><span class="hljs-comment">  则Number(target) = Number(data)。❗ 注：默认情况下，对象和数组的valueOf方法返回自身。</span><br><span class="hljs-comment">+ 如果引用类型数据target没有valueOf()方法，或者该方法仍然返回一个引用类型数据，</span><br><span class="hljs-comment">  则调用target的toString()方法得到s，Number(target) = Number(s)。</span><br><span class="hljs-comment">+ 如果target既不包含valueOf()方法，又不包含toString()方法（一般不会）,</span><br><span class="hljs-comment">  则试图将target转为Number时会报错。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">❗ 注：以下6~7均符合上述规则的描述。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 6.普通JS对象 转 Number </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;空对象:&#x27;</span>, <span class="hljs-built_in">Number</span>(&#123;&#125;));  <span class="hljs-comment">// 👉 NaN</span><br><br><span class="hljs-comment">// 7. 数组 转 Number</span><br><span class="hljs-comment">// 7.1 空数组</span><br>	consolle.log(<span class="hljs-built_in">Number</span>([])) <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 7.2 数组中只有一个元素，其值为undefined或null，则此数组转换为Number，返回值为0</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">undefined</span>])) <span class="hljs-comment">// 👉 0</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">null</span>])); <span class="hljs-comment">// 👉 0</span><br><span class="hljs-comment">// 7.3 数组中只有一个元素，其值为布尔型，则此数组转换为Number，返回值为NaN</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">false</span>])) <span class="hljs-comment">// 👉 NaN</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-literal">true</span>])) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-comment">// 7.4 数组中只有一个元素，其值为一个数字、字符串、JS对象，则对此数组转换为Number等价于对第一个元素转换</span><br><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>])) <span class="hljs-comment">// 👉 1</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([-<span class="hljs-number">100</span>])) <span class="hljs-comment">// 👉 -100</span><br><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;&#x27;</span>])) <span class="hljs-comment">// 👉 0</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;+0123&#x27;</span>])) <span class="hljs-comment">// 👉 123</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;12.3&#x27;</span>])) <span class="hljs-comment">// 👉 12.3</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;0b101&#x27;</span>])) <span class="hljs-comment">// 👉 5</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;12.3xxxx&#x27;</span>])) <span class="hljs-comment">// 👉 NaN</span><br><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([&#123;&#125;])) <span class="hljs-comment">// 👉 NaN</span><br><span class="hljs-comment">// 7.5 数组中有多个元素，即数组长度大于1时，此数组转换为Number，返回NaN</span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>([<span class="hljs-number">123</span>, <span class="hljs-number">3213</span>])) <span class="hljs-comment">// 👉 NaN</span><br><br></code></pre></td></tr></table></figure>


<h4 id="各类型数据强制转为Boolean⭐"><a href="#各类型数据强制转为Boolean⭐" class="headerlink" title="各类型数据强制转为Boolean⭐"></a>各类型数据强制转为Boolean⭐</h4><p><strong>虚值</strong></p>
<p>在JavaScript中，有6个虚值。如果将其中任何一个字符串转换为Boolean，它将变为<code>false</code> 。</p>
<ol>
<li>false本身</li>
<li>0</li>
<li>undefined</li>
<li>null</li>
<li>NaN</li>
<li>“”（空字符串）</li>
</ol>
<blockquote>
<p><strong>任何不为虚值</strong>的都会被<code>Boolean</code>转换为<code>true</code>。</p>
</blockquote>
<h4 id="各类型数据的toString方法⭐"><a href="#各类型数据的toString方法⭐" class="headerlink" title="各类型数据的toString方法⭐"></a>各类型数据的toString方法⭐</h4><p>JavaScript中有七种数据类型，除<code>undefined</code>和<code>null</code>外，其他五种数据类型都具有<code>toString</code>方法（数字、字符串、布尔值数据会装箱后再调用该方法）。</p>
<p>因此，除<code>undefined</code>和<code>null</code>以外的<strong>任何数据</strong>调用<code>toString</code>方法都是在<strong>原型链上查找该方法</strong>并调用。</p>
<ol>
<li><p><code>Number.prototype.toString()</code></p>
<p><code>toString</code>方法很简单地将数字转为字符串形式返回，但数字类型的<code>toString</code>方法可以<strong>传递一个参数</strong>，用于指定用进制数（默认为10，还可以指定2、8、16等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;<br>num.toString();                   <span class="hljs-comment">//&quot;10&quot;</span><br>num.toString(<span class="hljs-number">2</span>);                  <span class="hljs-comment">//&quot;1010&quot;</span><br>num.toString(<span class="hljs-number">8</span>);                  <span class="hljs-comment">//&quot;12&quot;</span><br>num.toString(<span class="hljs-number">10</span>);                 <span class="hljs-comment">//&quot;10&quot;</span><br>num.toString(<span class="hljs-number">16</span>);                 <span class="hljs-comment">//&quot;a&quot;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p><code>String.prototype.toString()</code></p>
<p>返回字符串本身。</p>
</li>
</ol>
<ol start="3">
<li><p><code>Boolean.prototype.toString()</code></p>
<p>返回<code>&#39;true&#39;</code>或<code>&#39;false&#39;</code>。</p>
</li>
</ol>
<ol start="4">
<li><p><code>Array.prototype.toString()</code></p>
<p>返回一个字符串，该字符串为数组中所有元素调用<code>toString</code>方法后用逗号<code>,</code>相连的结果。</p>
<blockquote>
<p>⭐<strong>注意</strong>：</p>
<p>如果数组中有元素的值为<code>undefined</code>或<code>null</code>，则该元素位置上为空字符串<code>&#39;&#39;</code>代替。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-literal">undefined</span>].toString() <span class="hljs-comment">// 结果为 &#x27;&#x27;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>].toString() <span class="hljs-comment">// 结果为 &#x27;1,&#x27;</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].toString() <span class="hljs-comment">// 结果为 &#x27;1,,2&#x27;</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<ol start="5">
<li><p><code>Object.prototype.toString()</code> ⭐⭐</p>
<blockquote>
<p>对于 <code>Object.prototype.toString()</code> 方法，会返回一个形如 <code>&quot;[object XXX]&quot;</code> 的字符串。如果在对象的原型链上， <code>toString()</code> 方法未被重写，就会返回如上面形式的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">(&#123;&#125;).toString();     <span class="hljs-comment">// =&gt; &quot;[object Object]&quot;</span><br><span class="hljs-built_in">Math</span>.toString();     <span class="hljs-comment">// =&gt; &quot;[object Math]&quot;</span><br></code></pre></td></tr></table></figure>

<p>但是，大多数对象，<code>toString()</code> 方法都是重写了的，这时，需要用 <code>call()</code> 或 <code>Reflect.apply()</code> 等方法来调用。</p>
</blockquote>
<p><strong>所以我们更关注的是<code>Object.prototype.toString.call(target)</code>的返回值情况。</strong></p>
<p>(1) 若target参数为 <code>null</code> 或 <code>undefined</code>，直接返回<code>&#39;[object Null]&#39;</code>或<code>&#39;[object Undefined]&#39;</code></p>
<p>(2) 若target参数不为 <code>null</code> 或 <code>undefined</code>，则将参数转为对象，再作判断。对于原始类型，转为对象的方法即装箱。</p>
<p>(3) 转为对象后，取得该对象的 <code>[Symbol.toStringTag]</code> 属性值（可能会遍历原型链）作为 <code>tag</code>，如无该属性，或该属性值不为字符串类型，则依下表取得 <code>tag</code>, 然后返回 <code>&#39;[object &#39; + tag + &#39;]&#39;</code> 形式的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Boolean 类型，tag 为 &quot;Boolean&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>);     <span class="hljs-comment">// =&gt; &quot;[object Boolean]&quot;</span><br><br><span class="hljs-comment">// Number 类型，tag 为 &quot;Number&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>);        <span class="hljs-comment">// =&gt; &quot;[object Boolean]&quot;</span><br><br><span class="hljs-comment">// String 类型，tag 为 &quot;String&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&quot;&quot;</span>);       <span class="hljs-comment">// =&gt; &quot;[object String]&quot;</span><br><br><span class="hljs-comment">// Array 类型，tag 为 &quot;Array&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call([]);       <span class="hljs-comment">// =&gt; &quot;[object Array]&quot;</span><br><br><span class="hljs-comment">// Arguments 类型，tag 为 &quot;Arguments&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>;<br>&#125;)());                                    <span class="hljs-comment">// =&gt; &quot;[object Arguments]&quot;</span><br><br><span class="hljs-comment">// Function 类型， tag 为 &quot;Function&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);    <span class="hljs-comment">// =&gt; &quot;[object Function]&quot;</span><br><br><span class="hljs-comment">// Error 类型（包含子类型），tag 为 &quot;Error&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());     <span class="hljs-comment">// =&gt; &quot;[object Error]&quot;</span><br><br><span class="hljs-comment">// RegExp 类型，tag 为 &quot;RegExp&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-regexp">/\d+/</span>);           <span class="hljs-comment">// =&gt; &quot;[object RegExp]&quot;</span><br><br><span class="hljs-comment">// Date 类型，tag 为 &quot;Date&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());      <span class="hljs-comment">// =&gt; &quot;[object Date]&quot;</span><br><br><span class="hljs-comment">// 其他类型，tag 为 &quot;Object&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;&#125;);    <span class="hljs-comment">// =&gt; &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>已经部署了Symbol.toStringTag的类型有：Map、Set、WeakMap、WeakSet、JSON、Math、Symbol等。</p>
</blockquote>
</li>
</ol>
<ol start="6">
<li><p><code>Symbol.prototype.toString</code></p>
<p>Symbol类型的<code>toString</code>方法会返回一个型如<code>&#39;Symbol(&#39; + tag + &#39;)&#39;</code>的字符串。</p>
<p>而<code>tag</code>是对Symbol数据构建时第一个参数调用<code>toString</code>方法后的字符串。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;mz&#x27;</span>).toString()) <span class="hljs-comment">// 👉 &#x27;Symbol(mz)&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(&#123;&#125;).toString()) <span class="hljs-comment">// 👉 &#x27;Symbol([object Object])&#x27;</span><br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li><p><code>Function.prototype.toString</code></p>
<p>返回函数代码。</p>
</li>
</ol>
<ol start="8">
<li><p><code>RegExp.prototype.toString</code></p>
<p>返回正则表达式对象的pattern字符串。 </p>
</li>
</ol>
<h4 id="各数据类型强制转换为String"><a href="#各数据类型强制转换为String" class="headerlink" title="各数据类型强制转换为String"></a>各数据类型强制转换为String</h4><p>String函数可以将参数转换为字符串类型后返回。</p>
<p>如果有参数对象具有<code>toString()</code>方法，调用该方法；⭐</p>
<p>而只有<code>undefined</code>和<code>null</code>没有<code>toString()</code>方法，所以如果是undefined，返回<code>&#39;undefined&#39;</code>；如果是null，返回<code>&#39;null&#39;</code>。</p>
<h3 id="隐式的类型转换"><a href="#隐式的类型转换" class="headerlink" title="隐式的类型转换"></a>隐式的类型转换</h3><p>在JavaScript中，明确地将某种类型数据转换成另一种类型的数据称为显式转换，相反则称为隐式类型转换。</p>
<p>显式类型转换地方法有很多，包括<code>Number()、Boolean()、String()、toString()、parseInt()、parseFloat()</code>等等。</p>
<p>隐式类型转换包括<code>运算符</code>、<code>JS逻辑语句</code>。</p>
<h4 id="运算符导致的隐式类型转换"><a href="#运算符导致的隐式类型转换" class="headerlink" title="运算符导致的隐式类型转换"></a>运算符导致的隐式类型转换</h4><h5 id="1-一元递增递减操作符"><a href="#1-一元递增递减操作符" class="headerlink" title="1. 一元递增递减操作符"></a>1. 一元递增递减操作符</h5><p>递增<code>++</code> 、 递减<code>--</code> 运算符不仅适用于整数，还可以用于字符串、布尔值、浮点数值、普通对象、数组、函数等等，其隐式转换规则如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;任意的数据类型&#x27;</span><br># 对于value的递增操作，有以下三种情况 <br>++value;value++;<br>f(++value);<br>f(value++)<br><br><span class="hljs-comment">// 情况1：value++和++value等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>value += <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 要点2：f(value++)的最新结果等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>f(value);<br>value += <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 要点3：f(++value)的最新结果等价于以下操作过程</span><br>value = <span class="hljs-built_in">Number</span>(value);<br>value += <span class="hljs-number">1</span>;<br>f(value);<br></code></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = [<span class="hljs-number">123</span>]<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出 123，而不是[123] ⭐⭐</span><br><span class="hljs-built_in">console</span>.log(value) <span class="hljs-comment">// 输出 124</span><br><br><span class="hljs-keyword">let</span> value = [<span class="hljs-number">123</span>]<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出124</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 2</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出 0</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 1</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-literal">undefined</span>;<br><span class="hljs-built_in">console</span>.log(++value); <span class="hljs-comment">// 输出 NaN</span><br><br><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;3.14&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(value++); <span class="hljs-comment">// 输出3.14</span><br><span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 输出4.14</span><br><br><span class="hljs-keyword">let</span> value = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(value++) <span class="hljs-comment">// 输出NaN，因为NaN + 1 = NaN</span><br></code></pre></td></tr></table></figure>
<p>递减操作符与递增操作符同理，不再赘述。</p>
<h5 id="2-一元加减操作符"><a href="#2-一元加减操作符" class="headerlink" title="2. 一元加减操作符"></a>2. 一元加减操作符</h5><p>一元加号（<code>+</code>）放在数字前面，作为一个表达式，其值为数字本身。</p>
<p>一元加号（<code>+</code>）放在非数字类型的数据前面，作为一个<strong>表达式</strong>，其值为强制转换为Number的结果。</p>
<p>一元减号（<code>-</code>）放在数字前面，作为一个表达式，其值为数字的相反数。</p>
<blockquote>
<p>注意 <code>-0 === +0</code>为<code>true</code>，<code>-NaN === NaN</code>为<code>false</code>。</p>
</blockquote>
<p>一元加号（<code>-</code>）放在非数字类型的数据前面，作为一个<strong>表达式</strong>，其值为强制转换为Number的结果再取相反数。</p>
<h5 id="3-加法-⭐"><a href="#3-加法-⭐" class="headerlink" title="3. 加法 ⭐"></a>3. 加法 ⭐</h5><p>(1) 两个操作数中<font color='red'>只要有其中之一为字符串</font>，则认为这个<code>+</code>二元运算符是一个<font color='red'>拼串</font>操作。两个操作数会被<code>String()</code>函数强制转换为字符串类型，再执行拼串，作为表达式的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-number">123</span>);                <span class="hljs-comment">// 👉 输出 &#x27;123&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> + <span class="hljs-string">&#x27;abc&#x27;</span>);            <span class="hljs-comment">// 👉 输出 &#x27;nullabc&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-string">&#x27;333&#x27;</span>)             <span class="hljs-comment">// 👉 输出 &#x27;true333&#x27;</span><br></code></pre></td></tr></table></figure>
<p>(2) 两个操作数中存在引用类型，则会尝试先调用该引用类型的<code>valueOf</code>方法得到返回值，如果<code>valueOf</code>方法不存在或该方法仍然返回一个引用类型数据，则调用该对象的<code>toString</code>方法得到返回值，作为引用类型数据原位置上的操作数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(&#123;&#125; + <span class="hljs-string">&#x27;xxx&#x27;</span>);             <span class="hljs-comment">// 👉 输出 &#x27;[object Object]xxx&#x27;</span><br><span class="hljs-built_in">console</span>.log([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] + <span class="hljs-literal">undefined</span>);  <span class="hljs-comment">// 👉 输出 &#x27;1,2,3undefined&#x27;</span><br><br><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125;,<br>&#125;<br><span class="hljs-built_in">console</span>.log(obj1 + obj2);  <span class="hljs-comment">// 👉 输出3</span><br><br><br><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + obj); <span class="hljs-comment">// 👉 输出 &#x27;1[objet Object]&#x27;</span><br><br></code></pre></td></tr></table></figure>
<p>(3) <font color='red'>其他情况下</font>，<code>+</code>二元运算符是一个<font color='red'>加法</font>操作。两个操作数会被<code>Number()</code>函数强制转换为两个数字，再执行加法运算，作为表达式的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> + <span class="hljs-number">123</span>);        <span class="hljs-comment">// 👉 输出 NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">3</span>);               <span class="hljs-comment">// 👉 输出 4</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>);              <span class="hljs-comment">// 👉 输出 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> + <span class="hljs-number">100</span>);             <span class="hljs-comment">// 👉 输出 100</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>特殊的加法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// JS中有两个无穷大，+Infinity和-Infinity，+Infinity和Infinity等价的。</span><br><span class="hljs-comment">// Infinity === Infinity 为true， -Infinity === -Infinity 为true</span><br><span class="hljs-literal">Infinity</span> + <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">Infinity</span><br>-<span class="hljs-literal">Infinity</span> + (-<span class="hljs-literal">Infinity</span>) = -<span class="hljs-literal">Infinity</span><br><span class="hljs-literal">Infinity</span> + (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">NaN</span> ⭐<br><br><span class="hljs-comment">// 任何数 与 NaN 计算的结果都为NaN</span><br><span class="hljs-literal">NaN</span> + <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">NaN</span>  <br><br><span class="hljs-comment">// JS中有-0和+0，+0和0是等价的，-0 === +0为true</span><br><span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> + (-<span class="hljs-number">0</span>) = <span class="hljs-number">0</span><br>(-<span class="hljs-number">0</span>) + (-<span class="hljs-number">0</span>) = -<span class="hljs-number">0</span> ⭐<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-减法"><a href="#4-减法" class="headerlink" title="4. 减法"></a>4. 减法</h5><p>二元减法操作符比较简单，如果操作符两侧的操作数不为数字类型，则使用<code>Number()</code>将其强制转换为数字类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> - <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出 -3</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>特殊的减法：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">Infinity</span> - <span class="hljs-literal">Infinity</span> = <span class="hljs-literal">NaN</span><br>(-<span class="hljs-literal">Infinity</span>) - (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">NaN</span><br><span class="hljs-literal">Infinity</span> - (-<span class="hljs-literal">Infinity</span>) = <span class="hljs-literal">Infinity</span><br>(-<span class="hljs-literal">Infinity</span>) - <span class="hljs-literal">Infinity</span> = -<span class="hljs-literal">Infinity</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span> - <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br>-<span class="hljs-number">0</span> - -<span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-number">0</span> - (-<span class="hljs-number">0</span>) = <span class="hljs-number">0</span><br>(-<span class="hljs-number">0</span>) - <span class="hljs-number">0</span> = -<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="5-乘性运算"><a href="#5-乘性运算" class="headerlink" title="5.  乘性运算"></a>5.  乘性运算</h5><p>乘性运算包括二元乘法操作符<code>*</code>、二元除法操作符<code>/</code>、二元取模操作符<code>%</code>，这三个操作符也很简单，只要两侧操作数不是数字类型，则强制将其转为数字类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span> * [<span class="hljs-number">3</span>]);  <span class="hljs-comment">// 👉 输出 24</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">999</span> / <span class="hljs-string">&#x27;333&#x27;</span>); <span class="hljs-comment">// 👉 输出 3</span><br></code></pre></td></tr></table></figure>


<h5 id="6-关系操作符⭐"><a href="#6-关系操作符⭐" class="headerlink" title="6. 关系操作符⭐"></a>6. 关系操作符⭐</h5><p>在JavaScript高级程序设计中，关系操作符有四个，分别是<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>，由关系操作符和两个操作数组成的表达式的值是一个布尔值。</p>
<p>(1) 如果操作符两侧的操作数都是数字，则执行数值比较。</p>
<p>(2) 如果操作符两侧的操作数都是字符串，则逐个比较字符串中对应位置字符的编码（应该是Unicode）。</p>
<p>(3) 如果只有一个操作数为数字，另一个不是，则使用<code>Number()</code>将另一个操作数转换为数字后执行比较。</p>
<p>(4) 如果操作数中有<code>true</code>、<code>false</code>、<code>undefined</code>、<code>null</code>，则先使用<code>Number()</code>将其转换成数字后再与另一个操作数比较。</p>
<p>(5) 如果两个操作数中有一个引用类型数据<code>refVal</code>，而另一个操作数不是数字，则调用<code>refVal</code>的<code>valueOf()</code>方法得到返回值<code>data</code>后再与另一个操作数比较。如果<code>refVal</code>不存在<code>valueOf()</code>方法或<code>valueOf()</code>方法仍然返回一个引用类型数据，则调用<code>refVal</code>的<code>toString()</code>方法得到字符串<code>s</code>，将<code>s</code>与另一个操作数进行比较。</p>
<p>(6) 关系操作符的操作数不允许出现Symbol类型数据，如出现，会报错。</p>
<blockquote>
<p>其实可以简单理解为：</p>
<ol>
<li>如果两个操作数都是数字，则直接执行比较。</li>
<li>如果两个操作数都是字符串，则进行字符串比较。</li>
<li>其他情况两个操作数都要转换为数字。</li>
</ol>
<p>注意，任何关系操作符在涉及比较<code>NaN</code>时都返回<code>false</code>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举例</span><br><span class="hljs-string">&#x27;123&#x27;</span> &lt; <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// true (2)</span><br><span class="hljs-string">&#x27;ab &#x27;</span> &gt; <span class="hljs-string">&#x27;ab&#x27;</span> <span class="hljs-comment">// true (2)</span><br><br><span class="hljs-string">&#x27;&#x27;</span> &lt; <span class="hljs-number">1</span>  <span class="hljs-comment">// true (3)</span><br><br><span class="hljs-literal">true</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-comment">// true (4)</span><br><span class="hljs-literal">false</span> &gt;= <span class="hljs-number">1</span> <span class="hljs-comment">// false (4)</span><br><span class="hljs-literal">false</span> &gt;= <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// true (4)</span><br><span class="hljs-literal">null</span> &lt; <span class="hljs-number">1</span> <span class="hljs-comment">// true (4)</span><br><br><span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">100</span> <span class="hljs-comment">// false (4)因为undefined转为数字为NaN</span><br>undefind &lt;= <span class="hljs-number">100</span> <span class="hljs-comment">// false (4)因为undefined转为数字为NaN</span><br><br><span class="hljs-keyword">let</span> obj = &#123;<br>    valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>    toString: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;obj&#x27;</span><br>    &#125;<br>&#125;<br>obj &gt; <span class="hljs-number">123</span>  <span class="hljs-comment">// false (3):123是数字，则将obj转为Number会返回NaN</span><br>obj &gt; <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// true (5):obj为引用类型，而&#x27;123&#x27;不是数字，obj调用toString方法会返回&#x27;obj&#x27;,&#x27;obj&#x27; &gt; &#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>


<h5 id="7-等于和不等于"><a href="#7-等于和不等于" class="headerlink" title="7. 等于和不等于"></a>7. 等于和不等于</h5><p><strong><code>==</code>和<code>!=</code>在比较两个操作数的过程中，可能会对操作数进行隐式的强制类型转换后再比较。</strong></p>
<p>(1) 如果两个操作数中存在<code>null</code>或<code>undefined</code>，则只有<code>undefined == undefined</code>、<code>null == null</code>、<code>undefined == null</code>会返回<code>true</code>。❗ 在执行等号或不等号时，<code>undefined</code>和<code>null</code>都不会进行类型转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">null</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><span class="hljs-comment">// ⭐ 因此，根据这条规则，只要判断一个数是否等于 undefined，就能判断该值是否为undefined或null。</span><br></code></pre></td></tr></table></figure>


<p>(2.1) 如果<font color='red'>两个操作数都是数字</font>，则执行正常的数值比较。</p>
<blockquote>
<p>如果操作数中存在<code>NaN</code>，则任何涉及<code>NaN</code>的等于操作符都返回<code>false</code>，不等于操作符都返回<code>true</code>。</p>
</blockquote>
<p>(2.2) 如果<font color='red'>两个操作数都是字符串</font>，则比较两个字符串各个位置上的字符是否相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;abc&#x27;</span> != <span class="hljs-string">&#x27;abc &#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;123&#x27;</span> == <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>(2.3) 如果<font color='red'>两个操作数都是布尔值</font>，则正常执行布尔值的比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">true</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>(2.4) 如果<font color='red'>两个操作数都是引用类型</font>，则只有当两个操作数指向同一个引用类型数据时，才返回<code>true</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;&#125;, obj2 = &#123;&#125;;<br>obj1 == obj2 <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>


<p>(3.1) 如果<font color='red'>一个操作数是数字，另一个操作数不是数字</font>，则使用<code>Number()</code>将其转换为数字后再执行比较。⭐</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0</span> == <span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">123</span> == <span class="hljs-string">&#x27;+123&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">8</span> == <span class="hljs-string">&#x27;0b1000&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> == <span class="hljs-literal">null</span> <span class="hljs-comment">// false 遵守第一条</span><br></code></pre></td></tr></table></figure>
<p>(3.2) 如果<font color='red'>一个操作数是布尔值，另一个不是布尔值</font>，则使用<code>Number()</code>将二者都转为数字后再比较。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> != <span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p>(3.3) 如果<font color='red'>一个操作数是引用类型，另一个不是引用类型</font>， 则会先尝试调用该对象的<code>valueOf()</code>方法得到返回值<code>value</code>，如果该对象不存在<code>valueOf()</code>方法或<code>data</code>仍然是引用类型数据，则再尝试调用该对象的<code>toString()</code>方法得到返回值<code>s</code>。得到<code>value</code>或<code>s</code>后，按照其他规则再与另外一个操作数进行比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>    <span class="hljs-function"><span class="hljs-title">valueOf</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;123&#x27;</span>;<br>    &#125;<br>&#125;<br>obj1 == <span class="hljs-string">&#x27;[object Object]&#x27;</span> <span class="hljs-comment">// true</span><br>obj2 == <span class="hljs-number">123</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>




<p>(4) 如果两个操作数中<font color='red'>存在Symbol类型的数据</font>，<font color='red'>Symbol类型数据只与自己相等</font>，其他情况都返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>), s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>s1 == s2 <span class="hljs-comment">// false</span><br>s1 == s1 <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>




<h5 id="8-全等和不全等"><a href="#8-全等和不全等" class="headerlink" title="8. 全等和不全等"></a>8. 全等和不全等</h5><p>全等操作符<code>===</code>要求两个操作数“类型相同，值也相同”的情况下才返回<code>true</code>。</p>
<h4 id="JavaScript语句中的隐式类型转换"><a href="#JavaScript语句中的隐式类型转换" class="headerlink" title="JavaScript语句中的隐式类型转换"></a>JavaScript语句中的隐式类型转换</h4><h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p><code>if（condition）statement1 else statement2</code></p>
<p>其中的<code>condition</code>（条件）可以是任意表达式，而且对这个表达式求值的结果不一定是布尔值。</p>
<p><code>ECMAScript</code>会自动调用<code>Boolean()</code>转换函数将这个表达式结果转换为一个布尔值。</p>
<p>如果对condition求值的结果是<code>true</code>，则执行<code>satement1</code>，如果对condition求值的结果是<code>false</code>，则执行<code>statement2</code>。</p>
<h5 id="while-和-do-while-语句"><a href="#while-和-do-while-语句" class="headerlink" title="while 和 do while 语句"></a>while 和 do while 语句</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">while</span>（expression）statement<br><br><span class="hljs-keyword">do</span>&#123;<br><br>　　statement<br><br>&#125;<span class="hljs-keyword">while</span>（expression）<br></code></pre></td></tr></table></figure>
<p>⭐ 同if语句，会对<code>expression</code>强制转换为<code>Boolean</code>。</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript的数据类型分为基本数据类型和引用数据类型。</p>
<p>对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的<font color='red'>深浅拷贝都是对于引用数据类型而言的</font>。</p>
<p><strong>浅拷贝：</strong>浅拷贝的意思就是只复制引用（指针），而未复制真正的值（指针指向的内存空间）。</p>
<p><strong>深拷贝：</strong>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p>
<p><strong>实现深拷贝的思路：</strong></p>
<p>目前实现深拷贝的方法不多，主要是两种 👇</p>
<ol>
<li>组合使用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
</ol>
<h3 id="JSON-stringify-JSON-parse"><a href="#JSON-stringify-JSON-parse" class="headerlink" title="JSON.stringify + JSON.parse"></a>JSON.stringify + JSON.parse</h3><p>在简单情况下，<code>JSON.parse(JSON.stringify(target))</code>能够实现对一个引用类型数据的深拷贝。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> originArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> cloneArray = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(originArray));<br><span class="hljs-built_in">console</span>.log(cloneArray === originArray); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> originObj = &#123;<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-attr">c</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-attr">d</span>:&#123;<span class="hljs-attr">dd</span>:<span class="hljs-string">&#x27;dd&#x27;</span>&#125;&#125;;<br><span class="hljs-keyword">const</span> cloneObj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(originObj));<br><span class="hljs-built_in">console</span>.log(cloneObj === originObj); <span class="hljs-comment">// false</span><br><br>cloneObj.a = <span class="hljs-string">&#x27;aa&#x27;</span>;<br>cloneObj.c = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];<br>cloneObj.d.dd = <span class="hljs-string">&#x27;doubled&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(cloneObj); <span class="hljs-comment">// &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;</span><br><span class="hljs-built_in">console</span>.log(originObj); <span class="hljs-comment">// &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span><br></code></pre></td></tr></table></figure>
<p>但是在以下情况中，该方法不能完全实现引用类型数据的深拷贝：</p>
<ol>
<li>源对象是普通JavaScript对象，其中有<code>Symbol</code>类型的属性名时，用上述方法复制出的对象不具有这些属性。</li>
<li>源对象是普通JavaScript对象，其中有<code>Symbol</code>类型的、<code>Function</code>类型的、<code>undefined</code>类型的属性值时，用上述方法复制出的对象不具有这些属性。</li>
<li>源对象是数组，数组中有<code>Symbol</code>类型、<code>Function</code>类型、<code>undefined</code>类型的元素时，复制出的数组在相应位置上的元素为<code>null</code>。</li>
<li>源对象是数组，数组中的引用类型数据有上述1~3情况的，上述方法不能够完整复制出源数组对象。</li>
</ol>
<blockquote>
<p>⭐ 原因：</p>
<p><code>json</code>格式数据的属性名必须是字符串，属性值只允许①字符串 ②数字 ③布尔值 ④null ⑤数组 ⑥json。</p>
<p><code>json</code>格式数据还可以是包含上述①~⑥类型数据的数组。</p>
</blockquote>
<h3 id="递归深拷贝"><a href="#递归深拷贝" class="headerlink" title="递归深拷贝"></a>递归深拷贝</h3><blockquote>
<p>深拷贝的功能代码要考虑需求：</p>
<ol>
<li>是否考虑Symbol属性</li>
<li>是否拷贝不可枚举属性</li>
<li>是否考虑循环引用</li>
<li>是否考虑派生对象的复制（要求保持原型链）</li>
<li>是否考虑函数的深拷贝</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"># 最简单的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-built_in">Array</span>.isArray(target)? [] : &#123;&#125;;<br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，不考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Object</span>.keys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloned[key] = deepClone(target[key]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br><br># 考虑函数深拷贝、派生对象的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">`return <span class="hljs-subst">$&#123;target.toString()&#125;</span>`</span>);<br>        fn.name = target.name;<br>        <span class="hljs-keyword">return</span> fn;<br>    &#125;<br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，不考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Object</span>.keys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>        cloned[key] = deepClone(target[key]);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br></code></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js"># 考虑函数深拷贝、派生对象、Symbol属性以及不可枚举属性的版本<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制。</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 注意对象的方法简写方式会导致该方法的toString()结果不包含&#x27;function&#x27;这个关键字</span><br>        <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^(?&lt;FunctionName&gt;[_a-zA-Z]\w*)\s*\(\s*\)/</span>;<br>        <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + target.toString().replace(reg, <span class="hljs-string">`function $&lt;FunctionName&gt;()`</span>));<br>        seen.set(target, fn);<br>        <span class="hljs-keyword">return</span> fn;<br>      &#125;  <br>    <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>    <br>    <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>    <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>    <br>    <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>    <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>    <br>    <span class="hljs-comment">// 以下开始遍历属性，考虑Symbol属性以及不可枚举属性的深拷贝</span><br>    <span class="hljs-built_in">Reflect</span>.ownKeys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>       <span class="hljs-comment">// Reflect.getOwnPropertyDescriptor每次返回一个新的描述对象</span><br>       <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(target, key); <br>       descriptor.value = deepClone(descriptor.value);<br>       <span class="hljs-built_in">Reflect</span>.defineProperty(cloned, key, descriptor);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cloned;<br>&#125;<br><br># 考虑循环引用的版本，利用hash表<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果是函数（方法），则进行函数的复制</span><br>    <span class="hljs-keyword">const</span> seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<br>    <span class="hljs-keyword">return</span> __deepClone__(target);<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__deepClone__</span>(<span class="hljs-params">target</span>) </span>&#123;<br>        <span class="hljs-comment">// 在考虑typeof target !== &#x27;object&#x27;之前考虑 null</span><br>        <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 考虑函数复制</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (seen.has(target)) <span class="hljs-keyword">return</span> seen.get(target);<br>            <span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/^(?&lt;FunctionName&gt;[_a-zA-Z]\w*)\s*\(\s*\)/</span>;<br>            <span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;return &#x27;</span> + target.toString().replace(reg, <span class="hljs-string">&#x27;function $&lt;FunctionName&gt;()&#x27;</span>));<br>            seen.set(target, fn);<br>            <span class="hljs-keyword">return</span> fn;<br>        &#125;        <br>        <span class="hljs-comment">// 如果target是Number、String、Boolean、Symbol、undefined，直接返回</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> target;<br>        <br>        <span class="hljs-comment">// 开始考虑数组和对象</span><br>        <span class="hljs-keyword">if</span> (seen.has(target)) <span class="hljs-keyword">return</span> seen.get(target);<br>        <span class="hljs-comment">// 如果是特殊的Date类型数据，则构造方式不太一样。</span><br>        <span class="hljs-keyword">if</span> (target.constructor === <span class="hljs-built_in">Date</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(target);<br>        <span class="hljs-comment">// 进行普通JS对象以及数组的拷贝</span><br>        <span class="hljs-keyword">const</span> cloned = <span class="hljs-keyword">new</span> target.constructor(); <span class="hljs-comment">// 保持原型链</span><br>		seen.set(target, cloned);<br>        <span class="hljs-comment">// 以下开始遍历属性，考虑Symbol属性以及不可枚举属性的深拷贝</span><br>        <span class="hljs-built_in">Reflect</span>.ownKeys(target).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>           <span class="hljs-comment">// Reflect.getOwnPropertyDescriptor每次返回一个新的描述对象</span><br>           <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Reflect</span>.getOwnPropertyDescriptor(target, key); <br>           descriptor.value = __deepClone__(descriptor.value);<br>           <span class="hljs-built_in">Reflect</span>.defineProperty(cloned, key, descriptor);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>作用：处理JavaScript中的异步代码，避免回调地狱。</p>
<h3 id="创建一个Promise对象"><a href="#创建一个Promise对象" class="headerlink" title="创建一个Promise对象"></a>创建一个Promise对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	执行异步操作,</span><br><span class="hljs-comment">    	异步操作成功时，使用resolve(result)将结果挂载到p上</span><br><span class="hljs-comment">    	异步操作失败时，使用reject(reason)将失败信息挂载到p上</span><br><span class="hljs-comment">    */</span><br>&#125;) <br></code></pre></td></tr></table></figure>
<blockquote>
<p>根据业务逻辑，创建一个Promise对象时有一个同步执行过程以及一个至多个异步任务的启动和执行。</p>
<p>当其中任何一个执行过程调用了<code>resolve</code>或<code>reject</code>时，该Promise的内容（状态和值）就不再发生变化。</p>
</blockquote>
<h3 id="Promise的三种状态"><a href="#Promise的三种状态" class="headerlink" title="Promise的三种状态"></a>Promise的三种状态</h3><p><code>Promise</code>对象的<code>[[PromiseStatus]]</code>属性能够表示该promise对象的状态，有三个可能值分别代表三种不同的状态。</p>
<p><code>pending</code> 👉 未决（同步或异步操作仍然在执行）</p>
<p><code>fulfilled</code> 👉 接受（同步、异步操作执行成功时调用<code>resolve</code>的结果）</p>
<p><code>rejected</code> 👉 拒绝 （同步、异步操作执行失败时调用<code>reject</code>的结果）</p>
<h3 id="Promise的链式调用（then与catch）"><a href="#Promise的链式调用（then与catch）" class="headerlink" title="Promise的链式调用（then与catch）"></a>Promise的链式调用（then与catch）</h3><p><code>promiseInstance.then(onResolved[, onRejected])</code></p>
<h4 id="then方法参数"><a href="#then方法参数" class="headerlink" title="then方法参数"></a>then方法参数</h4><p>该方法可以接收一个参数（<code>onResolved</code>）或两个参数（<code>onResolved、onRejected</code>）。</p>
<ul>
<li><p><code>onResolved</code>是调用<code>then</code>方法的Promise对象的状态改变为<code>fulfilled</code>状态时会执行的回调。JavaScript会将该Promise对象的<code>[[PromiseValue]]</code>属性值传递给<code>onResolved</code>回调函数并同步执行（相对于当前任务）。</p>
</li>
<li><p><code>onRejected</code>是调用<code>then</code>方法的Promise对象的状态改变为<code>rejected</code>状态时会执行的回调。JavaScript会将该对象的<code>[[PromiseValue]]</code>属性值传递给<code>onRejected</code>回调函数并同步执行（相对于当前任务）。</p>
</li>
</ul>
<h4 id="then方法返回值"><a href="#then方法返回值" class="headerlink" title="then方法返回值"></a>then方法返回值</h4><p>Promise对象的then方法会<font color='red'>返回一个Promise对象</font>，以实现Promise的链式效果。</p>
<p>以下开始分析<code>let r = p.then(onResolved, onRejected)</code>的返回值情况：</p>
<ol>
<li><p>如果执行到<code>p.then</code>时，<code>p</code>为<code>pending</code>状态，则<code>r</code>的值为<code>pending</code>状态的新Promise对象。<strong>但是<code>r</code>此时与<code>p</code>产生了关联</strong>，如果将来<code>p</code>的状态发生改变时（<code>[[PromiseStatus]]</code>和<code>[[PromiseValue]]</code>），<code>r</code>的状态也会相应发生改变。</p>
<ul>
<li><p>如果将来的某个时间点，p的状态由<code>pending</code>转为了<code>fulfilled</code>，则JavaScript会将<code>p.then</code>方法调用时传入的<code>onResolved</code>函数加入微任务队列，并且将<code>p</code>的<code>[[PromiseValue]]</code>作为实参传给该函数。</p>
</li>
<li><p>如果将来的某个时间点，p的状态由<code>pending</code>转为了<code>rejected</code>，则JavaScript会将<code>p.then</code>方法调用时传入的<code>onRejected</code>函数加入微任务队列，并且将<code>p</code>的<code>[[PromiseValue]]</code>作为实参传给该函数。</p>
</li>
<li><p>当<code>p</code>的状态确定时，<code>p</code>如果为<code>fulfilled</code>，<code>r</code>的状态由<code>onResolved</code>决定；如果<code>p</code>为<code>rejected</code>，<code>r</code>的状态由<code>onRejected</code>决定。因此我们设<code>handler = onResolved/onRejected</code>，再进行分析：</p>
<p>(1) 如果<code>handler</code>为空（<code>undefined</code>或<code>null</code>），则<code>r</code>的状态是对<code>p</code>的状态的深拷贝。⭐</p>
<p>(2) 如果<code>handler</code>返回一个值，则<code>r</code>转为<code>fulfilled</code>，且<code>r</code>的“value”为<code>handler</code>的返回值。</p>
<p>(3) 如果<code>handler</code>不返回任何值，则<code>r</code>转为<code>fulfilled</code>，且<code>r</code>的“reason”为<code>undefined</code>。</p>
<p>(4) 如果<code>handler</code>返回一个<code>fulfilled</code>的Promise对象，则<code>r</code>的状态是对该Promise对象状态的深拷贝。</p>
<p>(5) 如果<code>handler</code>返回一个<code>rejected</code>的Promise对象，则<code>r</code>的状态是对该Promise对象状态的深拷贝。</p>
<p>(6) 如果<code>handler</code>返回一个<code>pending</code>的Promise对象，则<code>r</code>的状态与该Promise对象产生关联。</p>
<p>(7) 如果<code>handler</code>在执行过程中发生异常，则<code>r</code>转为<code>rejected</code>，且<code>r</code>的“reason”为抛出的异常对象。</p>
<blockquote>
<p><strong>MDN原文：</strong></p>
<h3 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#return_value">Return value</a></h3><p>Once a <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> is fulfilled or rejected, the respective handler function (<code>onFulfilled</code> or <code>onRejected</code>) will be called <strong>asynchronously</strong> (scheduled in the current thread loop). The behavior of the handler function follows a specific set of rules. If a handler function:</p>
<ul>
<li>returns a value, the promise returned by <code>then</code> gets resolved with the returned value as its value.</li>
<li>doesn’t return anything, the promise returned by <code>then</code> gets resolved with an <code>undefined</code> value.</li>
<li>throws an error, the promise returned by <code>then</code> gets rejected with the thrown error as its value.</li>
<li>returns an already fulfilled promise, the promise returned by <code>then</code> gets fulfilled with that promise’s value as its value.</li>
<li>returns an already rejected promise, the promise returned by <code>then</code> gets rejected with that promise’s value as its value.</li>
<li>returns another <strong>pending</strong> promise object, the resolution/rejection of the promise returned by <code>then</code> will be subsequent to the resolution/rejection of the promise returned by the handler. Also, the resolved value of the promise returned by <code>then</code> will be the same as the resolved value of the promise returned by the handler.</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>如果执行到<code>p.then</code>时，<code>p</code>已经为<code>fulfilled</code>状态，则<code>r</code>的状态是对<code>p</code>的深拷贝。</p>
</li>
<li><p>如果执行到<code>p.then</code>时，<code>p</code>已经为<code>rejected</code>状态，则<code>r</code>的状态是对<code>p</code>的深拷贝。</p>
</li>
</ol>
<h4 id="then方法的多次调用"><a href="#then方法的多次调用" class="headerlink" title="then方法的多次调用"></a>then方法的多次调用</h4><p> <code>then</code> 方法可以被同一个 <code>promise</code> 对象调用多次</p>
<ul>
<li><p>当 <code>promise</code> 成功状态时，所有 <code>onFulfilled</code> 需按照其注册顺序依次回调</p>
</li>
<li><p>当 <code>promise</code> 失败状态时，所有 <code>onRejected</code> 需按照其注册顺序依次回调</p>
</li>
</ul>
<h4 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h4><p><code>catch</code>方法只传入一个参数<code>onRejected</code>。该方法其实是<code>then</code>方法的语法糖🍬。</p>
<p><code>p.catch(onRejected)</code>等同于<code>p.then(null, onRejected)</code>。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>综合上述讲解与分析，可以发现通常为了更好地利用<code>Promise.prototype.then</code>的链式效果，我们在中间过程的<code>onResolved</code>和<code>onRejected</code>回调函数中都会返回一个Promise对象，然后在该Promise对象中定义中间过程逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br> &#125;); <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) = &gt; &#123;<br>    <span class="hljs-comment">/* 同步或异步任务 */</span><br> &#125;);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <br>&#125;);  <span class="hljs-comment">// 所以 p 一般情况是 catch方法返回的pending状态的Promise对象。</span><br></code></pre></td></tr></table></figure>








<hr>
<h3 id="处理多个Promise"><a href="#处理多个Promise" class="headerlink" title="处理多个Promise"></a>处理多个Promise</h3><p><strong>1.</strong><code>Promise.all(promiseInstances)</code></p>
<p><strong>参数</strong></p>
<p>Promise.all 函数允许传入一个包含多个Promise对象的数组。</p>
<p><strong>返回值</strong></p>
<p>Promise.all 函数会返回一个新的Promise对象<code>r</code>，<code>r</code>与传入的实参数组中所有的Promise对象产生关联。只有当实参数组中<font color='red'>所有的Promise对象状态确定</font>时，<code>r</code>的状态才会由<code>pending</code>变为<code>fulfilled</code>或者<code>rejected</code>。</p>
<p>(1) 当实参数组中所有的Promise对象变为<code>fulfilled</code>时，<code>r</code>才会转为<code>fulfilled</code>，其<code>value</code>为一个数组，数组中按顺序保存了实参数组中每一个Promise对象的<code>value</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p1 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p2 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p3 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br>		.then(<span class="hljs-function">(<span class="hljs-params">[value1, value2, value3]</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(value1, value2, value3);<br>        &#125;)<br></code></pre></td></tr></table></figure>


<p>(2) 当实参数组中所有的Promise对象的其中之一变为<code>rejected</code>时，<code>r</code>立即转为<code>rejected</code>，其<code>reason</code>为实参数组中第一个被<code>rejected</code>的Promise对象的<code>reason</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p1 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> resolve(<span class="hljs-string">&#x27;p2 value&#x27;</span>), <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> reject(<span class="hljs-string">&#x27;p3 reason&#x27;</span>), <span class="hljs-number">2000</span>); <span class="hljs-comment">// 👈 rejected</span><br>&#125;)<br><br><span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])<br>		.then(<span class="hljs-function">(<span class="hljs-params">[value1, value2, value3]</span>) =&gt;</span> &#123;    <span class="hljs-comment">// ⭐ 当有一个Promise失败时，不会执行onResolved </span><br>            <span class="hljs-built_in">console</span>.log(value1, value2, value3);<br>        &#125;)<br>		.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(reason);<br>        &#125;)<br></code></pre></td></tr></table></figure>


<p><strong>2.</strong><code>Promise.race()</code></p>
<p><strong>参数</strong></p>
<p>Promise.race 函数允许传入一个包含多个Promise对象的数组。</p>
<p><strong>返回值</strong></p>
<p>Promise.race 函数会返回一个新的Promise对象<code>r</code>，<code>r</code>与传入的实参数组中所有的Promise对象产生关联。只要当实参数组中的<font color='red'>其中一个Promise对象状态确定</font>时，<code>r</code>的状态就会由<code>pending</code>变为<code>fulfilled</code>或者<code>rejected</code>。</p>
<p>(1) 当实参数组中<font color='red'>第一个确定状态的</font>Promise对象变为<code>fulfilled</code>时，<code>r</code>的状态就会转为<code>fulfilled</code>。</p>
<p>(2) 当实参数组中<font color='red'>第一个确定状态的</font>Promise对象的其中之一变为<code>rejected</code>时，<code>r</code>的状态立即转为<code>rejected</code>。</p>
<h3 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> isFunction = <span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> <span class="hljs-keyword">typeof</span> target === <span class="hljs-string">&#x27;function&#x27;</span>;<br><br><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      FUlFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>,<br>      REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<br><br><span class="hljs-keyword">let</span> pushIntoMicroQueue;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> queueMicrotask !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;              <span class="hljs-comment">// 好像最新的浏览器和Node都支持该函数</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use queueMicrotask to create Microtask&#x27;</span>)        <br>  pushIntoMicroQueue = queueMicrotask;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;     <span class="hljs-comment">// 最新的浏览器支持</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use MutationObserver to create Microtask&#x27;</span>);<br>  pushIntoMicroQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">task</span>) </span>&#123; <br>    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>),<br>          config = &#123; <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span> &#125;;<br>    <span class="hljs-keyword">let</span> observer = <span class="hljs-keyword">new</span> MutationObserver(<span class="hljs-function">() =&gt;</span> &#123;<br>      task();<br>      observer.disconnect();<br>      observer = <span class="hljs-literal">null</span>;<br>      dummyNode = <span class="hljs-literal">null</span>;<br>    &#125;);<br>    observer.observe(dummyNode, config);<br>    dummyNode.style = <span class="hljs-string">&#x27;display: none;&#x27;</span>; <span class="hljs-comment">// 触发MutationObserser的回调</span><br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;                                <span class="hljs-comment">// Node环境下使用process.nextTick创建微任务</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Use process.nextTick to create Microtask&#x27;</span>);          <br>  pushIntoMicroQueue = process.nextTick;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">handler</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isFunction(handler)) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;MyPromise must accept a function as a parameter&#x27;</span>)<br>    &#125;<br>    <span class="hljs-built_in">this</span>._value = <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-built_in">this</span>._status = PENDING;<br>    <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">this</span>._onResolvedQueue = [];<br>    <span class="hljs-built_in">this</span>._onRejectedQueue = [];<br>    <span class="hljs-keyword">try</span> &#123;<br>      handler(<span class="hljs-built_in">this</span>._resolve.bind(<span class="hljs-built_in">this</span>), <span class="hljs-built_in">this</span>._reject.bind(<span class="hljs-built_in">this</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (e)&#123;<br>      <span class="hljs-built_in">this</span>._reject(e);<br>      <span class="hljs-comment">// ========= 打印一些错误信息，便于调试 ========</span><br>      <span class="hljs-comment">// console.warn(e); </span><br>      <span class="hljs-comment">// ===========================================  </span><br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">_flushOnResolvedQueue</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> task;<br>    <span class="hljs-keyword">while</span> (task = <span class="hljs-built_in">this</span>._onResolvedQueue.shift()) &#123;<br>      task(value);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._onRejectedQueue.length = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">_flushOnRejectedQueue</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> task;<br>    <span class="hljs-keyword">while</span> (task = <span class="hljs-built_in">this</span>._onRejectedQueue.shift()) &#123;<br>      task(reason);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._onResolvedQueue.length = <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-title">_resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// promise的状态只更改一次</span><br>    <span class="hljs-built_in">this</span>._status = FUlFILLED;<br>    <span class="hljs-built_in">this</span>._value = value;<br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) &#123;  <span class="hljs-comment">// 支持resolve一个promise的情况</span><br>      value.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">this</span>._resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> <span class="hljs-built_in">this</span>._reject(r));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      pushIntoMicroQueue(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 👈 核心是将清空promise任务队列的函数加入到JS引擎的微任务队列</span><br>        <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>._flushOnResolvedQueue(value);<br>      &#125;);<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">_reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>._status !== PENDING) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// promise的状态只更改一次</span><br>    <span class="hljs-built_in">this</span>._status = REJECTED;<br>    <span class="hljs-built_in">this</span>._value = reason;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>._chained) &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Uncaught (in MyPromise)&#x27;</span>, <span class="hljs-built_in">this</span>._value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      pushIntoMicroQueue(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 👈 核心是将清空promise任务队列的函数加入到JS引擎的微任务队列</span><br>        <span class="hljs-built_in">this</span>._flushed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>._flushOnRejectedQueue(reason);<br>      &#125;);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ⭐ 最核心的then方法，其实还是发布订阅模式。</span><br>  <span class="hljs-comment">// 新的promise是订阅者，调用then的promise是发布者。</span><br>  <span class="hljs-comment">// resolve或reject相当于trigger，只会发布这两种通知</span><br>  <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onResolved, onRejected</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; _status, _value, _flushed&#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <br>      <span class="hljs-keyword">const</span> onResolvedWrapper = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onResolved)) &#123;<br>          resolve(value);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onResolved(value);<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(res);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> onRejectedWrapper = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isFunction(onRejected)) &#123;<br>          reject(reason);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onRejected(reason);<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> resolve(v), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(res);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// ⭐⭐</span><br>      <span class="hljs-keyword">switch</span> (_status) &#123;  <br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FUlFILLED:<br>          <span class="hljs-keyword">if</span> (_flushed) onResolvedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// catch方法是then方法的语法糖</span><br>  <span class="hljs-keyword">catch</span>(onRejected) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);<br>  &#125;<br>    <br>  <span class="hljs-comment">// ⭐ finally方法，其特性与then(onFinally, onFinally)有区别，所以单独实现</span><br>  <span class="hljs-function"><span class="hljs-title">finally</span>(<span class="hljs-params">onFinally</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; _status, _value, _flushed &#125; = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>._chained = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> onResolvedWrapper = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onFinally();<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">ignoredValue</span> =&gt;</span> resolve(value), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            resolve(value);<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>  <br>      <span class="hljs-keyword">const</span> onRejectedWrapper = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">const</span> res = onFinally();<br>          <span class="hljs-keyword">if</span> (res <span class="hljs-keyword">instanceof</span> MyPromise) &#123;<br>            res.then(<span class="hljs-function"><span class="hljs-params">ignoredValue</span> =&gt;</span> reject(reason), <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> reject(r));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            reject(reason);<br>          &#125;          <br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          reject(e);<br>        &#125;<br>      &#125;<br>      <br>      <span class="hljs-keyword">switch</span> (_status) &#123;<br>        <span class="hljs-keyword">case</span> PENDING:<br>          <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FUlFILLED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onResolvedQueue.push(onResolvedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECTED:<br>          <span class="hljs-keyword">if</span> (_flushed) onRejectedWrapper(_value);<br>          <span class="hljs-keyword">else</span> <span class="hljs-built_in">this</span>._onRejectedQueue.push(onRejectedWrapper);<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果参数是MyPromise实例，直接返回这个实例，避免额外增加一个中间promise。</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> MyPromise) <span class="hljs-keyword">return</span> value;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(reason))<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">all</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> n = promises.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> _counter = <span class="hljs-number">0</span>, _values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 如果数组中有元素不是Promise，则将其包装为Fulfilled的Promise</span><br>        <span class="hljs-keyword">if</span> (!(promises[i] <span class="hljs-keyword">instanceof</span> MyPromise)) &#123;<br>          promises[i] = MyPromise.resolve(promises[i]);<br>        &#125;<br>        promises[i].then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>          _values[_counter++] = v;<br>          <span class="hljs-keyword">if</span> (_counter === n) &#123;<br>            resolve(_values);<br>          &#125;<br>        &#125;, <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>          reject(r);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">race</span>(<span class="hljs-params">promises</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> n = promises.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// 如果数组中有元素不是Promise，则将其包装为Fulfilled的Promise</span><br>        <span class="hljs-keyword">if</span> (!(promises[i] <span class="hljs-keyword">instanceof</span> MyPromise)) &#123;<br>          promises[i] = MyPromise.resolve(promises[i]);<br>        &#125;<br>        promises[i].then(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;<br>          resolve(v);<br>        &#125;, <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;<br>          reject(r);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="event-loop-事件循环"><a href="#event-loop-事件循环" class="headerlink" title="event loop  事件循环"></a>event loop  事件循环</h2><p>本质：调度任务（函数）的模型、策略。</p>
<h3 id="JS为什么被设计为单线程执行？"><a href="#JS为什么被设计为单线程执行？" class="headerlink" title="JS为什么被设计为单线程执行？"></a>JS为什么被设计为单线程执行？</h3><p>JS设计之初，主要用于操作DOM，这决定了它只能是单线程执行的，否则会带来很复杂的问题。</p>
<p>例如，如果有两个线程，一个线程在某个DOM节点上添加内容，另一个节点删除了这个节点，就会带来同步问题。</p>
<h3 id="Web-Worker没有改变JS单线程本质"><a href="#Web-Worker没有改变JS单线程本质" class="headerlink" title="Web Worker没有改变JS单线程本质"></a>Web Worker没有改变JS单线程本质</h3><p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，<font color='red'>但是子线程完全受主线程控制，且不得操作DOM</font>。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<h3 id="单线程的问题与任务队列"><a href="#单线程的问题与任务队列" class="headerlink" title="单线程的问题与任务队列"></a>单线程的问题与任务队列</h3><p>但是单线程也意味着所有任务都需要依次排队执行，这也会带来问题，例如网络请求会阻塞后续任务的执行，例如I/O操作也会造成阻塞。</p>
<p>所以JS就将代码分成了同步操作和异步操作，异步操作不阻塞同步代码，主线程会将其委托给底层的线程池，如果该操作在后台完成了，其回调会添加到任务队列，主线程空闲时将轮询任务队列并执行其中的回调。</p>
<blockquote>
<p>在JavaScript中，不论是浏览器环境还是Node环境，主线程既是任务的消费者（执行全局代码、同步函数与异步回调），也扮演轮询的角色（在空闲时轮询任务队列）。</p>
</blockquote>
<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><p>“任务”可以理解为需要被同步执行的一段代码。</p>
<p>任务可以分为宏任务与微任务，在宏任务和微任务代码执行过程中可能又执行新的异步操作。</p>
<p><strong>宏任务包括：</strong></p>
<ol>
<li>浏览器环境下HTML文档中依赖的全部script脚本。</li>
<li>setTimeout、setInterval、setImmediate（Node环境）。</li>
<li>DOM事件的回调</li>
<li>页面UI渲染</li>
</ol>
<blockquote>
<p>⭐ 注意：</p>
<p>在浏览器环境下，<code>setTimeout(cb, 0)</code>等价于<code>setTimeout(cb, 4)</code>。</p>
<p>在Node.js环境下，<code>setTimeout(cb, 0)</code>等价于<code>setTimeout(cb, 1)</code>。</p>
<p>解释：原因在于如果设置延迟是0，含义相当于是同步执行，所以设置一个定时器到期的最小值（过一小会后执行）。</p>
</blockquote>
<p><strong>微任务包括：</strong></p>
<ol>
<li>Promise.prototype.resolve以及Promise.prototype.reject触发的“清空Promise任务队列”的任务。</li>
<li>创建MutationObeserver时传入的回调，会在DOM元素触发监听内容时执行。</li>
<li>Object.observe（已经废弃）</li>
<li>process.nextTick（Node环境）</li>
<li>H5中的web worker回调</li>
</ol>
<h3 id="浏览器环境下的事件循环模型"><a href="#浏览器环境下的事件循环模型" class="headerlink" title="浏览器环境下的事件循环模型"></a>浏览器环境下的事件循环模型</h3><p>浏览器环境下，为了协调网页事件（event）、用户交互（user interaction）、脚本执行（script）、页面渲染（rendering）、网络请求（newworking）等，必须使用<code>event loop</code>技术（类似于GUI编程中的消息循环）。</p>
<p>网页事件：<code>PostMessage❓</code>、<code>MutationObserver</code>等</p>
<p>用户交互：<code>click</code>、<code>scroll</code>等DOM事件的响应函数</p>
<p>页面渲染：创建、更新渲染树后进行绘图渲染</p>
<p>脚本执行：HTML文件中依赖的JS脚本</p>
<p>网络请求：<code>AJAX</code>、外链下载与处理</p>
<h3 id="Node-js-中的事件循环模型"><a href="#Node-js-中的事件循环模型" class="headerlink" title="Node.js 中的事件循环模型"></a>Node.js 中的事件循环模型</h3><h4 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h4><blockquote>
<p>Node.js官方文档中对Event Loop的介绍：</p>
<p><em>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.</em></p>
<p><em>Since most modern kernels are multi-threaded, they can handle multiple operations executing in the background. When one of these operations completes, the kernel tells Node.js so that the appropriate callback may be added to the <strong>poll</strong> queue to eventually be executed. We’ll explain this in further detail later in this topic.</em></p>
</blockquote>
<p>事件循环是Node.js实现异步IO的关键。尽管JavaScript是单线程执行的，但通过尽可能将一些（费时费力的）操作卸载到操作系统内核。</p>
<p>由于现代操作系统内核大多数是多线程的，它们可以在后台执行这些操作，并在合适的时机通知Node.js，<font color='red'>从而将相应的回调添加到Node.js的轮询队列中等待被主线程执行。</font></p>
<p><img src="/2021/07/21/JavaScript/mianshiti/image-20210708153456296.png" srcset="/img/loading.gif" alt="主线程、后台线程池、任务队列"> </p>
<h4 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">   ┌───────────────────────────┐<br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │     pending callbacks     │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤  connections, │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │           check           │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br></code></pre></td></tr></table></figure>
<p><strong>Phases Overview</strong></p>
<ul>
<li><strong>timers</strong>: this phase executes callbacks scheduled by <code>setTimeout()</code> and <code>setInterval()</code>.</li>
<li><strong>pending callbacks</strong>: executes I/O callbacks deferred to the next loop iteration.</li>
<li><strong>idle, prepare</strong>: only used internally.</li>
<li><strong>poll</strong>: retrieve new I/O events; execute I/O related callbacks (almost all with the exception of close callbacks, the ones scheduled by timers, and <code>setImmediate()</code>); node will block here when appropriate.</li>
<li><strong>check</strong>: <code>setImmediate()</code> callbacks are invoked here.</li>
<li><strong>close callbacks</strong>: some close callbacks, e.g. <code>socket.on(&#39;close&#39;, ...)</code>.</li>
</ul>
<p>Between each run of the event loop, Node.js checks if it is waiting for any asynchronous I/O or timers and shuts down cleanly if there are not any.</p>
<h4 id="自己归纳的运行机制模型"><a href="#自己归纳的运行机制模型" class="headerlink" title="自己归纳的运行机制模型"></a>自己归纳的运行机制模型</h4><p><img src="/2021/07/21/JavaScript/mianshiti/image-20210708200904878.png" srcset="/img/loading.gif" alt="image-20210708200904878"></p>
<p>⭐<strong>要点：</strong></p>
<ul>
<li><p>上述所有回调函数都是宏任务，最新版的Node.js中所有微任务的执行表现与浏览器环境下一致，即会在每个宏任务执行完之后轮询微任务队列，直到没有微任务为止，才执行下一个宏任务。</p>
</li>
<li><p>进入Timer阶段和Check阶段，如果队列为空，则直接进入下一阶段。</p>
</li>
<li><p>在进入Poll阶段前要进行两个检查，是否Timers队列中有新的回调？Check队列中是否已经有回调？</p>
</li>
<li><p>假如进入Poll阶段后，Poll队列中没有任务，且Timer Queue队列没有新的任务，且确实有异步操作在后台线程池执行，则主线程会在Poll阶段阻塞一段时间（同样有个最大时间阈值）。</p>
</li>
<li><p>其中最重要的就是进入Poll阶段后，假设此时Poll队列中有k个回调函数，执行1~k个回调都有可能（根据Node.js计算的阻塞在此阶段的时长阈值），然后在队列清空前，提前进入Check阶段，所以容易表现出怪异的测试用例，例如下面这个案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pause</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Date</span>.now() - start &gt;= ms) <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第1次读取完文件&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>  setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2&#x27;</span>)); <span class="hljs-comment">// immediate2和readFile2、3相对执行顺序不定</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2&#x27;</span>), <span class="hljs-number">0</span>);<br>&#125;)<br><br>pause(<span class="hljs-number">3</span>);<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第2次读取完文件:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>&#125;)<br><br>pause(<span class="hljs-number">3</span>);<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第3次读取完文件:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1&#x27;</span>), <span class="hljs-number">0</span>);<br>setImmediate(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1&#x27;</span>));<br><br><br>pause(<span class="hljs-number">50</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;全局代码执行完毕:&#x27;</span>, <span class="hljs-built_in">Date</span>.now());<br><br></code></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="和浏览器环境最大的区别"><a href="#和浏览器环境最大的区别" class="headerlink" title="和浏览器环境最大的区别"></a>和浏览器环境最大的区别</h4><ol>
<li><p>对于浏览器的宏任务队列，该宏任务队列唯一，哪个异步操作先完成，其回调（宏任务）就先加入到宏任务队列，优先被主线程执行。</p>
</li>
<li><p>对于Node环境，其宏任务队列不唯一，包括Timer Queue、Poll Queue、Check Queue等，每个宏任务队列进行<code>flush</code>时有自己的特性，同时，不同的宏任务之间有优先级关系。</p>
<ul>
<li>Timer Queue是在原队列上进行flush。</li>
<li>Poll Queue有最长flush时间的限制。</li>
<li>Check Queue是对原队列进行浅拷贝后进行flush。</li>
</ul>
</li>
<li><p>对于不同版本的Node环境，微任务的执行时机不太一致，但最新版的Node的微任务执行实际好像表现得和浏览器环境一致。❓</p>
</li>
</ol>
<h2 id="JavaScript字符串操作"><a href="#JavaScript字符串操作" class="headerlink" title="JavaScript字符串操作"></a>JavaScript字符串操作</h2><h3 id="encodeURI和encodeURIComponent区别"><a href="#encodeURI和encodeURIComponent区别" class="headerlink" title="encodeURI和encodeURIComponent区别"></a>encodeURI和encodeURIComponent区别</h3><p><strong>编码范围</strong></p>
<ul>
<li><p><code>encodeURI</code>方法**<em>不会**</em>对下列字符编码： ASCII字母、数字、<code>~!@#$&amp;*()=:/,;?+&#39;</code>。</p>
</li>
<li><p><code>encodeURIComponent</code>方法**<em>不会**</em>对下列字符编码：ASCII字母、数字、<code>~!*()&#39;</code>。</p>
</li>
</ul>
<blockquote>
<p>所以<code>encodeURIComponent</code>比<code>encodeURI</code>编码的范围更大。</p>
<p>主要区别是<code>encodeURIComponent</code>会将<code>/?#=&amp;</code>等URL中常用的特殊字符进行编码。</p>
<p>实际例子来说，<code>encodeURIComponent</code>会把 <code>http://  </code>编码成 <code>http%3A%2F%2F</code>而<code>encodeURI</code>却不会。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li><p>如果需要编码整个URL，而且URL中不存在URL语义范围外的特殊字符使用时，那么用<code>encodeURL</code>，相应地解码时使用<code>decodeURI</code>。</p>
<blockquote>
<p>例如 <code>encodeURI(&quot;http://www.cnblogs.com/season-huang/some other thing&quot;);</code></p>
<p>编码后会变为 <code>&quot;http://www.cnblogs.com/season-huang/some%20other%20thing&quot;</code>。</p>
<p>其中空格被编码成了<code>%20</code>，除此之外，当URL的path部分存在中文时，也可以使用此方法。</p>
</blockquote>
</li>
<li><p>如果需要编码URL中的参数的时候，那么<code>encodeURIComponent</code>是最好的方法。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> param = <span class="hljs-string">&quot;http://www.cnblogs.com/season-huang/&quot;</span>; <span class="hljs-comment">//param为参数</span><br>param = <span class="hljs-built_in">encodeURIComponent</span>(param);<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">&quot;http://www.cnblogs.com?next=&quot;</span> + param;<br><span class="hljs-built_in">console</span>.log(url) <span class="hljs-comment">//&quot;http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F&quot;</span><br></code></pre></td></tr></table></figure>

<p>可以看到查询字符串中的参数值内的<code>/</code>需要被编码，因为这个参数值虽然是一个URL，但只是作为参数传递给后端服务器。<code>encodeURIComponent</code>对查询字符串的key和value进行编码时可以保证其中不存在可能破坏URL结构的特殊字符。</p>
</blockquote>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JavaScript/">JavaScript</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/23/CSS/css-note/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">css面试题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/19/Node/node%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/">
                        <span class="hidden-mobile">Node.js模块与包</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
