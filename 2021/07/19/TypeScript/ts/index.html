

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>TypeScript笔记 - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="TypeScript笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-19 17:30" pubdate>
        2021年7月19日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      157
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">TypeScript笔记</h1>
            
            <div class="markdown-body">
              <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="安装和基本使用"><a href="#安装和基本使用" class="headerlink" title="安装和基本使用"></a>安装和基本使用</h2><h3 id="全局安装TypeScript"><a href="#全局安装TypeScript" class="headerlink" title="全局安装TypeScript"></a>全局安装TypeScript</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> typescript<br></code></pre></td></tr></table></figure>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc <span class="hljs-literal">-V</span> <br></code></pre></td></tr></table></figure>


<h3 id="编写TS程序"><a href="#编写TS程序" class="headerlink" title="编写TS程序"></a>编写TS程序</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* src/helloworld.ts */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;Yee&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure>


<h3 id="手动编译代码"><a href="#手动编译代码" class="headerlink" title="手动编译代码"></a>手动编译代码</h3><p>我们使用了 <code>.ts</code> 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>
<p>在命令行上，运行 TypeScript 编译器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc helloworld.ts<br></code></pre></td></tr></table></figure>
<p>输出结果为一个 <code>helloworld.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>
<p>在命令行上，通过 Node.js 运行这段代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node helloworld.js<br></code></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Hello, Yee<br></code></pre></td></tr></table></figure>


<h3 id="终端监视模式编译"><a href="#终端监视模式编译" class="headerlink" title="终端监视模式编译"></a>终端监视模式编译</h3><ol>
<li><p>生成配置文件tsconfig.json。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc -<span class="hljs-literal">-init</span><br></code></pre></td></tr></table></figure></li>
<li><p>修改tsconfig.json配置。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./js&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>启动监视模式编译</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">tsc <span class="hljs-literal">-w</span>  👈 -<span class="hljs-literal">-watch</span>也可以<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="Webpack打包TS"><a href="#Webpack打包TS" class="headerlink" title="Webpack打包TS"></a>Webpack打包TS</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"># webpack.config.js<br><br>&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/.tsx?$/</span>,<br>                use: <span class="hljs-string">&#x27;ts-loader&#x27;</span>,<br>                include: [path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;ts&#x27;</span>)],<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>接下来让我们看看 TypeScript 工具带来的高级功能。 给 <code>person</code> 函数的参数添加 <code>: string</code> 类型注解，如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = <span class="hljs-string">&#x27;Yee&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure>
<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 <code>greeter</code> 函数接收一个字符串参数。 然后尝试把 <code>greeter</code> 的调用改成传入一个数组：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greeter</span> (<span class="hljs-params">person: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + person<br>&#125;<br><br><span class="hljs-keyword">let</span> user = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-built_in">console</span>.log(greeter(user))<br></code></pre></td></tr></table></figure>
<p>重新编译，你会看到产生了一个错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">error TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;.<br></code></pre></td></tr></table></figure>
<p>类似地，尝试删除 <code>greeter</code> 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>
<p>要注意的是尽管有错误，<code>greeter.js</code> 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型 boolean"></a>布尔型 boolean</h3><p>最基本的数据类型就是简单的 true/false 值，在JavaScript 和 TypeScript 里叫做 <code>boolean</code>（其它语言中也一样）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>isDone = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// isDone = 2 // error</span><br></code></pre></td></tr></table></figure>


<h3 id="数字-number"><a href="#数字-number" class="headerlink" title="数字 number"></a>数字 number</h3><p><strong>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。</strong> 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a1: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 十进制</span><br><span class="hljs-keyword">let</span> a2: <span class="hljs-built_in">number</span> = <span class="hljs-number">0b1010</span>  <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> a3: <span class="hljs-built_in">number</span> = <span class="hljs-number">0o12</span> <span class="hljs-comment">// 八进制</span><br><span class="hljs-keyword">let</span> a4: <span class="hljs-built_in">number</span> = <span class="hljs-number">0xa</span> <span class="hljs-comment">// 十六进制</span><br></code></pre></td></tr></table></figure>


<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 <code>string</code> 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）表示字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> name:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;tom&#x27;</span><br>name = <span class="hljs-string">&#x27;jack&#x27;</span><br><span class="hljs-comment">// name = 12 // error</span><br><span class="hljs-keyword">let</span> age:<span class="hljs-built_in">number</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">const</span> info = <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;name&#125;</span>, I am <span class="hljs-subst">$&#123;age&#125;</span> years old!`</span><br></code></pre></td></tr></table></figure>


<h3 id="undefined和null"><a href="#undefined和null" class="headerlink" title="undefined和null"></a>undefined和null</h3><p>TypeScript 里，<code>undefined</code> 和 <code>null</code> 两者各自有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。 它们的本身的类型用处不是很大：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> u: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> n: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>
<p>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。 就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</p>
<blockquote>
<p>注意，当处于TS类型检查的严格模式下，将其他类型的变量赋值为undefined或null，编译会报错，当设置<code>&quot;strict&quot;: false</code>或<code>&quot;strictNullChecks&quot;: true,</code>，则编译可以通过。</p>
</blockquote>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><ul>
<li><code>never</code>类型不是任何类型的子类型，任何其他类型的值不可以赋值给never类型变量。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">let a: never = 123; # 编译不通过<br></code></pre></td></tr></table></figure>


<p>它的应用场景主要用在定义函数的返回类型，当函数的返回值类型为never时，表示这个函数一定不会返回值。</p>
<ol>
<li><p>函数会抛出异常。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertNever</span>(<span class="hljs-params">val: <span class="hljs-built_in">never</span></span>):<span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unexpected object&#x27;</span> + val);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>函数中包含死循环或者是死递归函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>):<span class="hljs-title">never</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>never类型在联合类型的类型收窄中具有一定应用。</p>
</blockquote>
</li>
</ol>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>当TS编译的target为<code>ES2015</code>及以上版本或<code>Lib</code>中导入了ES2015时，TS支持Symbol类型。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES2015&quot;</span>, <br>&#125;<br></code></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 👈 s 会被推断为symbol类型</span><br><br><span class="hljs-keyword">let</span> s: symbol = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); <span class="hljs-comment">// 👈 完整的写法</span><br></code></pre></td></tr></table></figure>




<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有三种方式可以定义数组。</p>
<p> <strong>第一种，可以在<code>元素类型后面接上[]</code>，表示由此类型元素组成的一个数组：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list1: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>
<p><strong>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list2: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>
<p><strong>第三种方式是使用接口定义数组：</strong></p>
<p>接口也可以用来描述数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> NumberArray &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">let</span> fibonacci: NumberArray = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
<p><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p>
<p>虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。</p>
<p>不过有一种情况例外，那就是它常用来表示类数组。</p>
<blockquote>
<p>⭐ 其实这是使用了接口的跳转，JS中的数组实现了NumberArray接口的所有成员，所以数组类型的值可以赋给该接口类型的变量。</p>
</blockquote>
<h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><p>类数组（Array-like Object）不是数组类型，比如 <code>arguments</code>（在TS函数中也可以使用该隐式变量）：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: <span class="hljs-built_in">number</span>[] = <span class="hljs-built_in">arguments</span>;<br>&#125;<br><br><span class="hljs-comment">// Type &#x27;IArguments&#x27; is missing the following properties from type &#x27;number[]&#x27;: pop, push, concat, join, and 24 more.</span><br></code></pre></td></tr></table></figure>
<p>上例中，<code>arguments</code> 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: &#123;  <span class="hljs-comment">// ⭐ 临时定义一个匿名的接口</span><br>        [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;<br>        length: <span class="hljs-built_in">number</span>;<br>        callee: <span class="hljs-built_in">Function</span>;<br>    &#125; = <span class="hljs-built_in">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 <code>length</code> 和 <code>callee</code> 两个属性。</p>
<p>事实上常用的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> args: IArguments = <span class="hljs-built_in">arguments</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 <code>IArguments</code> 是 TypeScript 中定义好了的类型，它实际上就是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IArguments &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>;<br>    length: <span class="hljs-built_in">number</span>;<br>    callee: <span class="hljs-built_in">Function</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="元组-type1-type2…"><a href="#元组-type1-type2…" class="headerlink" title="元组 [type1, type2…]"></a>元组 [type1, type2…]</h3><p>元组类型允许表示一个已知元素数量和类型的数组，<code>各元素的类型不必相同</code>。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> t1: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]<br>t1 = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-number">10</span>] <span class="hljs-comment">// OK</span><br>t1 = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;hello&#x27;</span>] <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">console</span>.log(t1[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>)) <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.log(t1[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>)) <span class="hljs-comment">// Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法</span><br></code></pre></td></tr></table></figure>


<h3 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h3><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以<code>为一组数值赋予友好的名字</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;<br>  Red,<br>  Green,<br>  Blue<br>&#125;<br><br><span class="hljs-comment">// 枚举数值默认从0开始依次递增</span><br><span class="hljs-comment">// 根据特定的名称得到对应的枚举数值</span><br><span class="hljs-keyword">let</span> myColor: Color = Color.Green  <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">console</span>.log(myColor, Color.Red, Color.Blue)<br></code></pre></td></tr></table></figure>
<p>默认情况下，从 <code>0</code> 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code> 开始编号：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green, Blue&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green<br></code></pre></td></tr></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">let</span> c: Color = Color.Green<br></code></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green, Blue&#125;<br><span class="hljs-keyword">let</span> colorName: <span class="hljs-built_in">string</span> = Color[<span class="hljs-number">2</span>]<br><br><span class="hljs-built_in">console</span>.log(colorName)  <span class="hljs-comment">// &#x27;Green&#x27;</span><br></code></pre></td></tr></table></figure>


<p><strong>字符串枚举</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">enum</span> Message &#123;<br>    <span class="hljs-built_in">Error</span> = <span class="hljs-string">&#x27;Sorry, error&#x27;</span>, <span class="hljs-comment">// 枚举值设置为字符串</span><br>    Success = <span class="hljs-string">&#x27;Hoho, success&#x27;</span>,<br>    Failed = <span class="hljs-built_in">Error</span>  <span class="hljs-comment">// 👈 可以使用本枚举类型的其他枚举值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>异构枚举</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 枚举值既有数字也有字符串</span><br><span class="hljs-built_in">enum</span> Result &#123;<br>    Failed = <span class="hljs-number">0</span>,<br>    Success = <span class="hljs-string">&#x27;success&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="常数项和计算所得项"><a href="#常数项和计算所得项" class="headerlink" title="常数项和计算所得项"></a>常数项和计算所得项</h4><p>枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。</p>
<p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue = <span class="hljs-string">&quot;blue&quot;</span>.length&#125;;<br></code></pre></td></tr></table></figure>
<p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p>
<p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> Color &#123;Red = <span class="hljs-string">&quot;red&quot;</span>.length, Green, Blue&#125;;<br><br><span class="hljs-comment">// index.ts(1,33): error TS1061: Enum member must have initializer.</span><br><span class="hljs-comment">// index.ts(1,40): error TS1061: Enum member must have initializer.</span><br><br><span class="hljs-built_in">enum</span> Status &#123;<br>  A = <span class="hljs-string">&#x27;a&#x27;</span>,<br>  B       # B不赋值时也会报错<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="常数枚举"><a href="#常数枚举" class="headerlink" title="常数枚举"></a>常数枚举</h4><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Directions &#123;<br>    Up,<br>    Down,<br>    Left,<br>    Right<br>&#125;<br><br><span class="hljs-keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];<br></code></pre></td></tr></table></figure>
<p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p>
<p>上例的编译结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> directions = [<span class="hljs-number">0</span> <span class="hljs-comment">/* Up */</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* Down */</span>, <span class="hljs-number">2</span> <span class="hljs-comment">/* Left */</span>, <span class="hljs-number">3</span> <span class="hljs-comment">/* Right */</span>];<br></code></pre></td></tr></table></figure>
<p>假如包含了计算成员，则会在编译阶段报错：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-built_in">enum</span> Color &#123;Red, Green, Blue = <span class="hljs-string">&quot;blue&quot;</span>.length&#125;;<br><br><span class="hljs-comment">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span><br></code></pre></td></tr></table></figure>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> notSure: <span class="hljs-built_in">any</span> = <span class="hljs-number">4</span><br>notSure = <span class="hljs-string">&#x27;maybe a string&#x27;</span><br>notSure = <span class="hljs-literal">false</span> <span class="hljs-comment">// 也可以是个 boolean</span><br></code></pre></td></tr></table></figure>
<p>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，<code>any</code> 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> list: <span class="hljs-built_in">any</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;free&#x27;</span>]<br><br>list[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure>


<p><strong>在TS语法中，如果一个变量在声明时，既没有进行类型注解，也没有初始化赋值，则该变量的类型为any。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> bar;<br>bar = <span class="hljs-number">1</span>;<br>bar = <span class="hljs-string">&#x27;&#x27;</span>; <br></code></pre></td></tr></table></figure>


<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它<code>表示没有任何类型</code>。 **当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>**：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>): <span class="hljs-title">void</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn()&#x27;</span>)<br>  <span class="hljs-comment">// return undefined</span><br>  <span class="hljs-comment">// return null</span><br>  <span class="hljs-comment">// return 1 // error</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code>（<strong>非严格模式下</strong>）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> unusable: <span class="hljs-built_in">void</span> = <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure>


<h3 id="引用类型-object"><a href="#引用类型-object" class="headerlink" title="引用类型 object"></a>引用类型 object</h3><p><code>object</code> 表示非原始类型（引用类型），也就是除 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>之外的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params">obj:<span class="hljs-built_in">object</span></span>):<span class="hljs-title">object</span> </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fn2()&#x27;</span>, obj)<br>  <span class="hljs-keyword">return</span> &#123;&#125;<br>  <span class="hljs-comment">// return undefined</span><br>  <span class="hljs-comment">// return null</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(fn2(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)))<br><span class="hljs-comment">// console.log(fn2(&#x27;abc&#x27;) // error</span><br><span class="hljs-built_in">console</span>.log(fn2(<span class="hljs-built_in">String</span>))<br></code></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>Symbol只有在target为ES2015时才可以使用，所以不作为TypeScript的基本类型。</p>
</li>
<li><p>⭐ TypeScript中，所有JavaScript中定义的引用类型值都可以赋值给object类型的变量。</p>
</li>
<li><p>TypeScript非严格模式下，undefined和null可以赋给object类型的变量。</p>
</li>
</ul>
</blockquote>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>联合类型（Union Types）表示取值可以为多种类型中的一种。<br>需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toString2</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) : <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> x.toString()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需求2: 定义一个一个函数得到一个数字或字符串值的长度</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br><br>  <span class="hljs-comment">// return x.length // error</span><br><br>  <span class="hljs-keyword">if</span> (x.length) &#123; <span class="hljs-comment">// error</span><br>    <span class="hljs-keyword">return</span> x.length<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> x.toString().length<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> something.length;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="hljs-comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">something: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> something.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> myFavoriteNumber: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br>myFavoriteNumber = <span class="hljs-string">&#x27;seven&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 5</span><br>myFavoriteNumber = <span class="hljs-number">7</span>;<br><span class="hljs-built_in">console</span>.log(myFavoriteNumber.length); <span class="hljs-comment">// 编译时报错</span><br><br><span class="hljs-comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h4 id="类型收窄"><a href="#类型收窄" class="headerlink" title="类型收窄"></a>类型收窄</h4><p>作者：尤雨溪<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/354601204/answer/888551021">https://www.zhihu.com/question/354601204/answer/888551021</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>举个具体点的例子，当你有一个 union type:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Foo &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> Bar &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> All = Foo | Bar<br></code></pre></td></tr></table></figure>
<p>在 switch 当中判断 type，TS 是可以收窄类型的 (discriminated union)：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleValue</span>(<span class="hljs-params">val: All</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (val.type) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;foo&#x27;</span>:<br>      <span class="hljs-comment">// 这里 val 被收窄为 Foo</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;bar&#x27;</span>:<br>      <span class="hljs-comment">// val 在这里是 Bar</span><br>      <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">// val 在这里是 never</span><br>      <span class="hljs-keyword">const</span> exhaustiveCheck: <span class="hljs-built_in">never</span> = val<br>      <span class="hljs-keyword">break</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意在 default 里面我们把被收窄为 never 的 val 赋值给一个显式声明为 never 的变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事改了 All 的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> All = Foo | Bar | Baz<br></code></pre></td></tr></table></figure>
<p>然而他忘记了在 handleValue 里面加上针对 Baz 的处理逻辑，这个时候在 default branch 里面 val 会被收窄为 Baz，导致无法赋值给 never，产生一个编译错误。所以通过这个办法，你可以确保 handleValue 总是穷尽 (exhaust) 了所有 All 的可能类型。</p>
<h4 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h4><p>在TypeScript中，如果一个变量为联合类型，一般情况下在代码中我们只能访问联合类型的共有成员。</p>
<p>但是类型保护机制可以让我们访问联合类型的非共有成员时，不会出现编译出错的情况。</p>
<ol>
<li><p>使用类型保护函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> NumberOrString = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span><br><span class="hljs-keyword">let</span> a: NumberOrString = <span class="hljs-string">&#x27;string&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>    console.log(val.split(&#x27;&#x27;)); # 报错，number上不存在split<br>&#125;<br><br><span class="hljs-comment">// 定义类型保护函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isString</span>(<span class="hljs-params">value: NumberOrString</span>): <span class="hljs-title">value</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123; <span class="hljs-comment">// xxx is ... xxx必须和参数名一直</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(isString(val)) &#123;<br>    <span class="hljs-built_in">console</span>.log(val.split(<span class="hljs-string">&#x27;&#x27;</span>));  <span class="hljs-comment">// 👈 不再会报错</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(val.split()); <span class="hljs-comment">// ❌ 这里没有用类型保护函数，仍然会报错</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>类型保护函数一般用于复杂的类型判断，或者用于需要复用代码的情况。</p>
</blockquote>
</li>
<li><p>使用<code>typeof</code>进行类型保护。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: NumberOrString</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>) &#123; <span class="hljs-comment">// 👈 使用typeof同样可以起到类型保护的作用</span><br>    <span class="hljs-built_in">console</span>.log(val.split(<span class="hljs-string">&#x27;&#x27;</span>));  <span class="hljs-comment">// 👈 不再会报错</span><br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(val.split()); <span class="hljs-comment">// ❌ 这里没有用类型保护函数，仍然会报错</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，typeof只能用于 number、string、boolean、symbol类型的类型保护。</p>
<p>因为使用typeof只能准确判断出这四种类型。</p>
</blockquote>
</li>
<li><p>使用<code>instanceof</code>进行类型保护。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> </span>&#123;<br>  sing(): <span class="hljs-built_in">void</span> &#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>  eat(): <span class="hljs-built_in">void</span> &#123;<br><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Animal = People | Dog<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">val: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>  val.sing();  # 报错，只有people有sing方法<br>&#125;<br><br><span class="hljs-comment">// 重新定义visit函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">visit</span>(<span class="hljs-params">val: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> People) &#123;<br>        val.sing()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>在TypeScript种，当我们使用联合类型，且不确定该联合类型的具体类型的时候，我们只能使用联合类型所共有的属性或方法，比如：</p>
<p>let num:number|string = ‘10’<br>let count = num.toString().length<br>1<br>2<br>但是有的的时候，我们需要在不确定具体类型的时候来访问该联合类型，但是又会报错，这时候就可以用上类型断言：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> num:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;10&#x27;</span><br>num = <span class="hljs-number">20</span><br><span class="hljs-comment">// console.log(num.length) //报错，这种情况可以使用类型断言</span><br></code></pre></td></tr></table></figure>
<p><strong>类型断言</strong>：可以用来手动指定一个值的类型。</p>
<p>类型断言的三种种语法：</p>
<ol>
<li>语法&lt;类型&gt;值</li>
<li>值 as 类型</li>
<li>特殊情况，变量使用时后面加<code>!</code>，可以断言该变量不为undefined或null</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> ((x <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length) &#123;    <span class="hljs-comment">// 👈 仅仅是编译时避免报错，真正执行时，类型断言不起任何作用。</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;string类型的逻辑&#x27;</span>);<br>    <span class="hljs-keyword">return</span> (x <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).length<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;非string类型的逻辑&#x27;</span>);<br>    <span class="hljs-keyword">return</span> x.toString().length<br>  &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-string">&#x27;abcd&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(getLength(<span class="hljs-number">123</span>));<br><span class="hljs-comment">// 👇 输出内容</span><br><span class="hljs-comment">// string类型的逻辑</span><br><span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 非string类型的逻辑</span><br><span class="hljs-comment">// 3</span><br><br><br><span class="hljs-comment">// 演示第三种情况</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> + val; <span class="hljs-comment">// ❌ 如果此处不断言val不为undefined，则会编译会飘红</span><br>  &#125;<br>  val = val || <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> fn();<br>&#125;<br><br><span class="hljs-comment">// 重新定义print函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">val: <span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> + val!; <span class="hljs-comment">// 使用`!` 断言val不为undefined</span><br>  &#125;<br>  val = val || <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> fn();<br>&#125;<br></code></pre></td></tr></table></figure>


<blockquote>
<p>注意：</p>
<ol>
<li>❗ 在tsx语法（React的jsx语法的ts版）必须采用后面一种，因为在jsx种，尖括号会用来包裹标签，与第一种语法有冲突。</li>
<li>❗ 类型断言不是类型转换，<strong>断言成一个联合类型中不存在的类型是不允许的</strong> 。</li>
</ol>
</blockquote>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型<br>有下面2种情况: </p>
<ol>
<li>声明变量时，同时进行了赋值, 推断为对应的类型。</li>
<li>声明变量时没有初始化赋值, 推断为any类型。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 定义变量时赋值了, 推断为对应的类型 */</span><br><span class="hljs-keyword">let</span> b9 = <span class="hljs-number">123</span> <span class="hljs-comment">// number</span><br><span class="hljs-comment">// b9 = &#x27;abc&#x27; // error</span><br><br><span class="hljs-comment">/* 定义变量时没有赋值, 推断为any类型 */</span><br><span class="hljs-keyword">let</span> b10  <span class="hljs-comment">// any类型</span><br>b10 = <span class="hljs-number">123</span><br>b10 = <span class="hljs-string">&#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure>


<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><h4 id="定义一个新类型"><a href="#定义一个新类型" class="headerlink" title="定义一个新类型"></a>定义一个新类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Person = &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> NameResolver = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 定义一个具体的函数类型的名字</span><br></code></pre></td></tr></table></figure>
<p>甚至用<code>type</code>定义的类型可以指定该变量具有的方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> Person = &#123;<br>  name: <span class="hljs-built_in">string</span>,<br>  age: <span class="hljs-built_in">number</span>,<br>  run: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">let</span> p: Person = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">23</span>,<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>👆 但不建议这样用。</p>
</blockquote>
<h4 id="定义类型别名"><a href="#定义类型别名" class="headerlink" title="定义类型别名"></a>定义类型别名</h4><p>类型别名用来给一个类型起个新名字。</p>
<p><strong>简单的例子</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Name = <span class="hljs-built_in">string</span>;<br><br><span class="hljs-keyword">type</span> NameOrResolver = Name | NameResolver;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params">n: NameOrResolver</span>): <span class="hljs-title">Name</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上例中，我们使用 <code>type</code> 创建类型别名。</p>
<p>类型别名常用于联合类型。</p>
<h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>字面量类型用来约束取值只能是某几个值中的一个。</p>
<h4 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> EventNames = <span class="hljs-string">&#x27;click&#x27;</span> | <span class="hljs-string">&#x27;scroll&#x27;</span> | <span class="hljs-string">&#x27;mousemove&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvent</span>(<span class="hljs-params">ele: Element, event: EventNames</span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><br>handleEvent(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;hello&#x27;</span>), <span class="hljs-string">&#x27;scroll&#x27;</span>);  <span class="hljs-comment">// 没问题</span><br>handleEvent(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;world&#x27;</span>), <span class="hljs-string">&#x27;dblclick&#x27;</span>); <span class="hljs-comment">// 报错，event 不能为 &#x27;dblclick&#x27;</span><br><br><span class="hljs-comment">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dblclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</p>
<p>注意，<strong>类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</strong></p>
<h4 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> StatusCode = <span class="hljs-number">200</span> | <span class="hljs-number">404</span> | <span class="hljs-number">301</span><br></code></pre></td></tr></table></figure>


<h4 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h4><p>TypeScript中，<code>keyof</code>关键字是一个操作符，它的作用类似于JS中的<code>Object.keys</code>。</p>
<p><code>keyof</code>可以枚举出对象、接口、type、类的所有属性名、方法名，并将它们组合为一个<strong>字符串字面量类型</strong>返回。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> People = &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>&#125;<br><br><span class="hljs-keyword">interface</span> ILeg &#123;<br>    run(): <span class="hljs-built_in">void</span>,<br>    walk(): <span class="hljs-built_in">void</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> StrangeInterface &#123;<br>    foo: <span class="hljs-built_in">never</span>,<br>    bar: <span class="hljs-literal">undefined</span>,<br>    xyz: <span class="hljs-literal">null</span>,<br>    usefulField: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;<br>    age: <span class="hljs-built_in">number</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> A = keyof People;  <span class="hljs-comment">// &#x27;name&#x27; | &#x27;age&#x27;</span><br><span class="hljs-keyword">type</span> B = keyof ILeg; <span class="hljs-comment">// &#x27;run&#x27; | walk</span><br><span class="hljs-keyword">type</span> C = keyof Dog; <span class="hljs-comment">// &#x27;age&#x27; | &#x27;name&#x27; | &#x27;eat&#x27; ⭐ constructor不会被枚举</span><br></code></pre></td></tr></table></figure>


<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="简单类的完整定义"><a href="#简单类的完整定义" class="headerlink" title="简单类的完整定义"></a>简单类的完整定义</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">/* 定义静态属性 */</span><br>    <span class="hljs-keyword">static</span> info: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;人类&#x27;</span><br>    <br>    <span class="hljs-comment">/* 定义静态方法，this指向类 */</span><br>    <span class="hljs-keyword">static</span> introduce(): <span class="hljs-built_in">void</span> &#123;  <span class="hljs-comment">// 👈 如果返回值值类型为void，可省略返回值类型注解</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.info);<br>    &#125;<br>    <br>    /* 定义实例属性 */  # 在TS中，实例属性要么在类中声明时初始化，要么在构造函数中初始化，否则编译不通过<br>    name: <span class="hljs-built_in">string</span><br>    age: <span class="hljs-built_in">number</span><br>    family: Person[] = []  <span class="hljs-comment">// 👈 如果在constructor中没有初始化语句，则必须在声明该属性时定义默认值</span><br>    <br>    <span class="hljs-comment">/* 定义实例方法, this指向实例 */</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    sayHi(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, 你好`</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>TypeScript中，类的成员的定义写法是根据ES7部分提案设计的。</p>
<p>在ES6中，可以在类内定义静态方法、实例方法，只允许在构造函数内初始化实例属性，只允许在类外定义静态属性。</p>
</blockquote>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  sayHi(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a: Animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.sayHi()); <span class="hljs-comment">// My name is Jack</span><br></code></pre></td></tr></table></figure>


<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>除了<code>static</code>修饰符可以修饰静态成员外，TypeScript中在定义类的成员时，还可以使用<code>public</code>、<code>protected</code>、<code>private</code>以及<code>readonly</code>修饰符。</p>
<h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<p>下面举一些例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure>
<p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name);<br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-comment">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br><span class="hljs-comment">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;</span><br></code></pre></td></tr></table></figure>
<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">protected</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="修饰构造函数"><a href="#修饰构造函数" class="headerlink" title="修饰构造函数"></a>修饰构造函数</h4><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.</span><br><span class="hljs-comment">// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.</span><br></code></pre></td></tr></table></figure>
<p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(name);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the</span><br></code></pre></td></tr></table></figure>


<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">readonly</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span><br></code></pre></td></tr></table></figure>
<p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-comment">// public readonly name;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> name</span>)</span> &#123;<br>    <span class="hljs-comment">// this.name = name;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">name</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Kitty&#x27;</span>); <span class="hljs-comment">// setter: Kitty</span><br>a.name = <span class="hljs-string">&#x27;Tom&#x27;</span>; <span class="hljs-comment">// setter: Tom</span><br><span class="hljs-built_in">console</span>.log(a.name); <span class="hljs-comment">// Jack</span><br></code></pre></td></tr></table></figure>


<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript中，和JS一样，使用<code>extends</code>关键字定义继承关系。</p>
<p>子类会继承父类所有的非private成员，包括构造函数、实例属性、实例方法、静态属性、静态方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    public name;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(a.sayHi()); <span class="hljs-comment">// My name is Jack</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>	<span class="hljs-comment">/* 隐式地含有父类的所有非private的成员，包括构造函数 */</span><br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>); <span class="hljs-comment">// Tom  👈 继承了父类的构造函数</span><br><span class="hljs-built_in">console</span>.log(c.sayHi()); <span class="hljs-comment">// Meow, My name is Tom</span><br></code></pre></td></tr></table></figure>


<p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123; <span class="hljs-comment">// ⭐ 定义子类的构造函数</span><br>    <span class="hljs-built_in">super</span>(name); <span class="hljs-comment">// 当父类定义中存在构造函数时，必须先调用父类的constructor</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Meow, &#x27;</span> + <span class="hljs-built_in">super</span>.sayHi(); <span class="hljs-comment">// 调用父类的 sayHi()</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>); <span class="hljs-comment">// Tom</span><br><span class="hljs-built_in">console</span>.log(c.sayHi()); <span class="hljs-comment">// Meow, My name is Tom</span><br></code></pre></td></tr></table></figure>


<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃东西&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃骨头&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;吃鱼&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a1: Animal = <span class="hljs-keyword">new</span> Cat();<br>a1.eat(); <span class="hljs-comment">// 吃鱼</span><br><br><span class="hljs-keyword">let</span> a2: Animal = <span class="hljs-keyword">new</span> Dog();<br>a2.eat(); <span class="hljs-comment">// 吃骨头</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a: Animal</span>): <span class="hljs-title">void</span> </span>&#123;<br>  a.eat();<br>&#125;<br><br>test(a1); <span class="hljs-comment">// 吃鱼</span><br>test(a2); <span class="hljs-comment">// 吃骨头</span><br><br></code></pre></td></tr></table></figure>




<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<p>什么是抽象类？</p>
<p>首先，抽象类是不允许被实例化的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
<p>其次，抽象类中的抽象方法必须被子类实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is eating.`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
<p>下面是一个正确使用抽象类的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> name;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sayHi();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Meow, My name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 TypeScript 中，我们使用接口（Interfaces）。</p>
<p>根据接口的不同作用，可以将TypeScript接口分为多种类型的接口。</p>
<h3 id="约束对象属性和方法的接口"><a href="#约束对象属性和方法的接口" class="headerlink" title="约束对象属性和方法的接口"></a>约束对象属性和方法的接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo1 &#123;<br>    name: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对属性的类型进行约束 ⭐</span><br>    age: <span class="hljs-built_in">number</span>,<br>    fn0(): <span class="hljs-built_in">void</span>, <span class="hljs-comment">// 对方法的类型进行约束的第一种写法 ⭐ 无参数</span><br>    fn1(arg1: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对方法的类型进行约束的第一种写法 ⭐ 有参数</span><br>        <br>    fn2: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>, <span class="hljs-comment">// 对方法进行约束的第二种写法 ⭐ 无参数</span><br>    fn3: <span class="hljs-function">(<span class="hljs-params">arg1: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 对方法进行约束的第二种写法 ⭐ 有参数</span><br>&#125;<br>    <br><span class="hljs-keyword">let</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">24</span>,<br>  <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> i: IDemo = obj;<br>i.fn();<br></code></pre></td></tr></table></figure>


<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo1 &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    age: <span class="hljs-built_in">number</span>,<br>    fn(): <span class="hljs-built_in">void</span><br>&#125;<br>    <br><span class="hljs-keyword">let</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;mz&#x27;</span>,<br>  age: <span class="hljs-number">24</span>,<br>  <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> i: IDemo = obj;<br>i.fn();<br></code></pre></td></tr></table></figure>
<p><strong>接口成员的嵌套约束</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IDemo &#123;<br>    name: <span class="hljs-built_in">string</span>,<br>    info: &#123;<br>        age: <span class="hljs-built_in">number</span>,<br>        gender: <span class="hljs-built_in">string</span>,<br>    &#125;,<br>    run(): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure>






<h3 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h3><p><strong>约束对象的全部属性（不常用）</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 要求某个对象或某个类的实例可以通过下标访问内容</span><br><span class="hljs-keyword">interface</span> IIndex &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>,<br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或某个类的实例可以通过下标访问内容，同时具有length属性</span><br><span class="hljs-keyword">interface</span> IArrayLike &#123;<br>    [index: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">any</span>,<br>    length: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或者某个类的实例的所有属性值都为string类型</span><br><span class="hljs-keyword">interface</span> IStringContent &#123;<br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// 要求某个对象或者某个类的实例的所有的方法都是没有参数且没有返回值的函数</span><br><span class="hljs-keyword">interface</span> IStringContent &#123;<br>    [propName: <span class="hljs-built_in">string</span>]: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="约束类的成员的接口"><a href="#约束类的成员的接口" class="headerlink" title="约束类的成员的接口"></a>约束类的成员的接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 定义一个接口</span><br><span class="hljs-keyword">interface</span> IPerson &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  speak(): <span class="hljs-built_in">void</span><br>  growUp(years: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 定义一个学生类，该类要实现IPerson</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-title">implements</span> <span class="hljs-title">IPerson</span></span>&#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br><br>  growUp(year: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-built_in">this</span>.age += year<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">goToSchool</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;上学&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>在类实现接口时，接口中定义了的成员必须是<code>public</code>的，即在类内不可以用<code>private</code>、<code>protected</code>进行修饰接口要求的成员。</p>
</blockquote>
<p><strong>实现（implements）是面向对象中的一个重要概念。</strong>一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    alert(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Door</span> </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityDoor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Door</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;SecurityDoor alert&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car alert&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>一个类可以实现多个接口：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    alert(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Light &#123;<br>    lightOn(): <span class="hljs-built_in">void</span>;<br>    lightOff(): <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-title">implements</span> <span class="hljs-title">Alarm</span>, <span class="hljs-title">Light</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car alert&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">lightOn</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car light on&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">lightOff</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Car light off&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯。</p>
<h3 id="定义函数形状的接口"><a href="#定义函数形状的接口" class="headerlink" title="定义函数形状的接口"></a>定义函数形状的接口</h3><p>见函数相关章节。</p>
<h3 id="可选成员以及readonly修饰符"><a href="#可选成员以及readonly修饰符" class="headerlink" title="可选成员以及readonly修饰符"></a>可选成员以及readonly修饰符</h3><p>可选的成员使用<code>?</code></p>
<p>只读属性使用 <code>readonly</code>在成员前面进行修饰</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> ILeg &#123;<br>    walk(): <span class="hljs-built_in">void</span><br>    run?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>,  <span class="hljs-comment">// 也可以写成 run?(): void</span><br>    <span class="hljs-keyword">readonly</span> count: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明（Function Declaration）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 函数表达式（Function Expression）</span><br><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意，<strong>输入多余的（或者少于要求的）参数，是不被允许的</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br> <span class="hljs-keyword">return</span> x + y;<br>&#125;<br>sum(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 在TS中通过函数表达式定义函数的一般写法：</span><br><span class="hljs-keyword">let</span> mySum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TS中完整的函数表达式：</span><br><span class="hljs-keyword">let</span> mySum: <span class="hljs-function">(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意不要混淆了 TypeScript 中的 <code>=&gt;</code> 和 ES6 中的 <code>=&gt;</code>。</p>
<p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
</blockquote>
<h3 id="用接口定义函数的形状"><a href="#用接口定义函数的形状" class="headerlink" title="用接口定义函数的形状"></a>用接口定义函数的形状</h3><p><strong>我们也可以使用接口的方式来定义一个函数需要符合的形状：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>    (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123; <span class="hljs-comment">// 👈 这里可以省略函数返回值</span><br>    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p>
<p><strong>定义函数形状的同时，还可以指定函数可能具有的属性：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> IFn &#123;<br>    (s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>,<br>    info?: <span class="hljs-built_in">string</span>,  <span class="hljs-comment">// 👈 必须用`?`修饰，否则使用函数表达式语法定义函数时，编译不通过</span><br>	<span class="hljs-comment">// ⭐ 每个函数接口，都具有隐式的属性name: string</span><br>&#125;<br><br><span class="hljs-keyword">let</span> fn: IFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br><br>fn.info = <span class="hljs-string">&#x27;...&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(fn.info); <span class="hljs-comment">// ...</span><br><br><span class="hljs-built_in">console</span>.log(fn.name); <span class="hljs-comment">// fn 👈 TS中所有函数默认具有name属性</span><br><br></code></pre></td></tr></table></figure>








<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (lastName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> firstName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName?: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (firstName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> lastName;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;Tom&#x27;</span>);<br><br><span class="hljs-comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span><br></code></pre></td></tr></table></figure>


<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Cat&#x27;</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> tom = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>此时就不受「可选参数必须接在必需参数后面」的限制了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>, lastName: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;<br>&#125;<br><span class="hljs-keyword">let</span> tomcat = buildName(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br><span class="hljs-keyword">let</span> cat = buildName(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;Cat&#x27;</span>);<br></code></pre></td></tr></table></figure>


<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array, ...items</span>) </span>&#123;<br>    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>        array.push(item);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> a: any[] = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">push</span>(<span class="hljs-params">array: <span class="hljs-built_in">any</span>[], ...items: <span class="hljs-built_in">any</span>[]</span>) </span>&#123;<br>    items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>        array.push(item);<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">let</span> a = [];<br>push(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<ol>
<li>剩余参数只能是最后一个参数。</li>
<li>剩余参数前可以出现可选参数和有默认值的参数。</li>
</ol>
</blockquote>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><blockquote>
<p>TypeScript的函数重载语法很僵硬的表现：</p>
<p>允许多次声明，每次声明的同名函数的形状不同，但是函数的实现只允许发生一次。</p>
<p>原因在于：</p>
<p>TypeScript会被编译为JavaScript，而JavaScript是不具有函数重载语法的，任何函数只有一次实现。</p>
</blockquote>
<p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>
<p>利用联合类型，我们可以这么实现：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// ❗  如果写  else if (typeof x === &#x27;string&#x27;) 编译报错</span><br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p>
<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// ❗  如果写  else if (typeof x === &#x27;string&#x27;) 编译报错</span><br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>): <span class="hljs-title">number</span> | <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">typeof</span> x) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x!.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:<br>      <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 或者 ⭐ 更推荐的写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">any</span> </span>&#123;  <span class="hljs-comment">// 这里的any并不代表可以输入任何类型，而是表示实参与返回值类型不确定</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(x.toString().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> x.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>    &#125;<br>&#125;<br><br>reverse(true) # 报错，不可以传入boolean类型的值<br>reverse(<span class="hljs-number">12</span>) <span class="hljs-comment">// 21</span><br>reverse(<span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-comment">// &#x27;ba&#x27;</span><br></code></pre></td></tr></table></figure>
<p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p>
<blockquote>
<p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<blockquote>
<p>使用泛型的目的是为了提高代码的可复用性。</p>
</blockquote>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: <span class="hljs-built_in">any</span></span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">any</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</p>
<p>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：</p>
<p><code>Array&lt;any&gt;</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 <code>value</code> 的类型。</p>
<p>这时候，泛型就派上用场了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>上例中，我们在函数名后添加了 <code>&lt;T&gt;</code>，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code> 和输出 <code>Array&lt;T&gt;</code> 中即可使用了。</p>
<p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 注意，第二个参数传入&#x27;x&#x27;，TS编译器会推测出此时T为string</span><br></code></pre></td></tr></table></figure>


<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>上述的例子中，使用的就是泛型函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// ⭐ 需要注意的是这里其实是省略了具体类型的传入。</span><br><br>createArray&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 本次函数调用的泛型T的具体类型为string类型</span><br></code></pre></td></tr></table></figure>


<blockquote>
<p>可以在函数的参数中使用泛型，使得函数可以传入多种类型的参数。</p>
<p>也可以在函数代码块中使用泛型，使得函数代码块中可以定义多种类型的变量。</p>
<p>还可以在函数的返回值中使用泛型，使得函数可以返回多种类型的值。</p>
</blockquote>
<h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><p>定义泛型的时候，可以一次定义多个类型参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">tuple: [T, U]</span>): [<span class="hljs-title">U</span>, <span class="hljs-title">T</span>] </span>&#123;<br>    <span class="hljs-keyword">return</span> [tuple[<span class="hljs-number">1</span>], tuple[<span class="hljs-number">0</span>]];<br>&#125;<br><br>swap&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>&gt;([<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;seven&#x27;</span>]); <span class="hljs-comment">// [&#x27;seven&#x27;, 7]</span><br></code></pre></td></tr></table></figure>
<p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组。</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p>
<blockquote>
<p>在泛型形参后面使用 <code>extends</code>关键字，不是继承的含义，而是在对泛型进行约束，要求类型实参必须<strong>兼容</strong>某个接口、某个class、某种Type，甚至是其他的泛型。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br><span class="hljs-comment">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p>
<p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 <code>length</code> 属性的变量。这就是泛型约束：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthwise &#123;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上例中，我们使用了 <code>extends</code> 约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p>
<p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code> 不包含 <code>length</code>，那么在编译阶段就会报错了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthwise &#123;<br>    length: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loggingIdentity</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthwise</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg.length);<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br><br>loggingIdentity(<span class="hljs-number">7</span>);<br><br><span class="hljs-comment">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span><br></code></pre></td></tr></table></figure>


<p><strong>多个类型参数之间也可以互相约束：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyFields</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">U</span>, <span class="hljs-title">U</span>&gt;(<span class="hljs-params">target: T, source: U</span>): <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id <span class="hljs-keyword">in</span> source) &#123;<br>        target[id] = (&lt;T&gt;source)[id];<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-keyword">let</span> x = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> &#125;;<br><br>copyFields(x, &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">20</span> &#125;);<br></code></pre></td></tr></table></figure>
<p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了 <code>U</code> 上不会出现 <code>T</code> 中不存在的字段。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><a target="_blank" rel="noopener" href="https://ts.xcatliu.com/basics/type-of-function.html#%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">之前学习过</a>，可以使用接口的方式来定义一个函数需要符合的形状：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SearchFunc &#123;<br>  (source: <span class="hljs-built_in">string</span>, <span class="hljs-attr">subString</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">source: <span class="hljs-built_in">string</span>, subString: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> source.search(subString) !== -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然也可以使用含有泛型的接口来定义函数的形状：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> CreateArrayFunc &#123;<br>    &lt;T&gt;(length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">let</span> createArray: CreateArrayFunc;<br>createArray = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure>
<p>进一步，我们可以把泛型参数提前到接口名上：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> CreateArrayFunc&lt;T&gt; &#123;<br>    (length: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): <span class="hljs-built_in">Array</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">let</span> createArray: CreateArrayFunc&lt;<span class="hljs-built_in">number</span>&gt;;<br>createArray = <span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(3, &#x27;x&#x27;); # 编译报错，泛型接口的T为number，creatArray是该接口类型，第二个参数不能传入string类型<br><br><span class="hljs-keyword">let</span> result = createArray(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 编译通过，将返回 [0, 0, 0]</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意，此时在使用泛型接口的时候，需要定义泛型的类型。</p>
</blockquote>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>与泛型接口类似，泛型也可以用于类的类型定义中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    zeroValue: T;<br>    add: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T;<br>&#125;<br><br><span class="hljs-keyword">let</span> myGenericNumber = <span class="hljs-keyword">new</span> GenericNumber&lt;<span class="hljs-built_in">number</span>&gt;();<br>myGenericNumber.zeroValue = <span class="hljs-number">0</span>;<br>myGenericNumber.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>&#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br></code></pre></td></tr></table></figure>


<h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，<strong>从实际值参数中也无法推测出时，这个默认类型才会起作用</strong>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createArray</span>&lt;<span class="hljs-title">T</span> = <span class="hljs-title">string</span>&gt;(<span class="hljs-params">length: <span class="hljs-built_in">number</span>, value: T</span>): <span class="hljs-title">Array</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">let</span> result: T[] = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        result[i] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br>createArray(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// ⭐这里能够从实参推断出T为number，所以默认的T = string在这里不起作用</span><br></code></pre></td></tr></table></figure>


<h2 id="模块化系统"><a href="#模块化系统" class="headerlink" title="模块化系统"></a>模块化系统</h2><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><h2 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h2><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><p>接口中的属性在合并时会简单的合并到一个接口中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，<strong>合并的属性的类型必须是唯一的</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;  <span class="hljs-comment">// 虽然重复了，但是类型都是 `number`，所以不会报错</span><br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">string</span>;  <span class="hljs-comment">// 类型不一致，会报错</span><br>    weight: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span><br></code></pre></td></tr></table></figure>
<p>接口中方法的合并，与函数的合并一样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> Alarm &#123;<br>    weight: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Alarm &#123;<br>    price: <span class="hljs-built_in">number</span>;<br>    weight: <span class="hljs-built_in">number</span>;<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span>;<br>    alert(s: <span class="hljs-built_in">string</span>, <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意，当接口中定义了同名不同形的方法，实现该接口的对象或者类，只需要实现其中一种形状的该方法。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> a: Alarm = &#123;<br>    price: <span class="hljs-number">12</span>,<br>    weight: <span class="hljs-number">15</span>,<br>    alert(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="类的合并"><a href="#类的合并" class="headerlink" title="类的合并"></a>类的合并</h3><p>类的合并与接口的合并规则一致。</p>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/07/19/Node/node%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Node.js模块与包</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/">
                        <span class="hidden-mobile">Git笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
