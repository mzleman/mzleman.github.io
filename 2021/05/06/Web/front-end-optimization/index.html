

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>前端性能优化 - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="前端性能优化">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-05-06 14:55" pubdate>
        2021年5月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      121
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端性能优化</h1>
            
            <div class="markdown-body">
              <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下性能优化的手段是主流的、面向Chrome的，但适用于大部分浏览器。</p>
<h2 id="渲染引擎组成"><a href="#渲染引擎组成" class="headerlink" title="渲染引擎组成"></a>渲染引擎组成</h2><p>一个渲染引擎主要包括：</p>
<ol>
<li>HTML解析器：用于解析HTML文本，将文本解析为DOM树。</li>
<li>CSS解析器：用于解析CSS文本，构建CSS树。</li>
<li>JS引擎：用于执行HTML中script标签内的代码，可以通过浏览器的API操作DOM元素。</li>
<li>布局模块：在将DOM树和CSS树合并为Render树后，布局模块计算每个元素的位置和大小。</li>
<li>绘图模块：绘制页面。</li>
</ol>
<h2 id="大致的渲染流程"><a href="#大致的渲染流程" class="headerlink" title="大致的渲染流程"></a>大致的渲染流程</h2><ol>
<li>调用HTML解析器解析HTML文本，目标是构建一棵DOM树。</li>
<li>遇到<code>style</code>标签，异步地解析<code>style</code>标签内的CSS代码，并更新CSS树（不阻塞合成Render Tree）。</li>
<li>遇到<code>link stylesheet</code>，异步地请求资源，在CSS文件被返回时，异步地调用CSS解析器解析文件中的CSS代码，并更新CSS树（不同于style标签，这里会阻塞Render Tree的合成）。</li>
<li>遇到<code>普通 script</code>标签，同步地请求资源，在JS文件被返回时，同步地执行文件中的JS代码。</li>
<li>HTML解析完成后生成一棵DOM树，CSS树构建完成后，将CSS树和DOM树合并为<code>Render Tree</code>。</li>
<li>布局渲染树，计算每个节点的几何信息（位置和形状）👈 再次触发这个过程就称为回流。</li>
<li>根据外观样式+布局的结果，将节点绘制到图层位图上 👈 再次触发这个过程就称为重绘。</li>
<li>将像素图层发送给GPU，显卡发送信号展示页面。</li>
</ol>
<h3 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h3><p><img src="/2021/05/06/Web/front-end-optimization/image-20210525230335464.png" srcset="/img/loading.gif" alt="image-20210525230335464"></p>
<p>为了构建渲染树，浏览器主要完成了以下工作：</p>
<ol>
<li>从DOM树的根节点开始遍历每个可见节点。</li>
<li>对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。</li>
<li>根据每个可见节点以及其对应的样式，组合生成渲染树。</li>
</ol>
<p>第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：</p>
<ul>
<li>一些不会渲染输出的节点，比如<code>script、meta、link</code>等。</li>
<li>一些通过css进行隐藏的节点。比如<code>display:none</code>。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。</li>
</ul>
<blockquote>
<p>渲染树中只包含可见的节点。</p>
</blockquote>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><h3 id="CSS阻塞"><a href="#CSS阻塞" class="headerlink" title="CSS阻塞"></a>CSS阻塞</h3><ol>
<li><p><strong>关于style标签内的CSS</strong></p>
<p>例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>    * &#123;<br>        margin: 0;<br>        padding: 0;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>不阻塞DOM解析</strong><ul>
<li><strong>不阻塞DOM渲染</strong>（style标签内的CSS代码是异步解析更新CSS树的）</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>关于link标签引用的外部样式表</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;common.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>外部样式表的下载不阻塞DOM解析，</strong>HTML解析器在解析到外部引用CSS时，会发出异步请求，得到响应后使用CSS解析器异步解析该文件（相较于HTML解析）。</li>
<li><strong>外部样式表的下载和解析阻塞DOM渲染，</strong>即只要有link标签引用的外部资源没有加载或加载了但CSS解析器没完成解析，DOM不会完成渲染，页面不显示内容，尽管这时候DOM解析可能已经完成了。</li>
<li><strong>外部样式表的下载和解析阻塞后面的JS脚本执行，</strong>即只要script标签前面的有引用的外部样式表没有加载、解析完成，则script标签内的JS脚本不会执行。</li>
</ul>
</li>
</ol>
<blockquote>
<p>优化手段：</p>
<ul>
<li>CSS文件压缩合并。</li>
<li>尽可能早地让浏览器下载解析CSS文件（通过preload、CDN、HTML中link标签位置等）。</li>
<li>优化CSS代码。</li>
</ul>
</blockquote>
<h3 id="JS阻塞"><a href="#JS阻塞" class="headerlink" title="JS阻塞"></a>JS阻塞</h3><ol>
<li><p><strong>普通的内联JS代码</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><strong>内联的JS脚本的执行阻塞DOM解析</strong>，即HTML解析器会停下来等待脚本执行完毕。<ul>
<li><strong>由于阻塞DOM解析，所以一定阻塞DOM渲染</strong>（渲染的必要条件是DOM解析完成，构建DOM树）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>普通的外部JS资源</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>外部JS资源的下载会阻塞DOM解析</strong>。</li>
<li><strong>外部JS资源的执行也会阻塞DOM解析</strong>。</li>
</ul>
<blockquote>
<p>即HTML解析器遇到这样的一个外部JS引用标签，会等待该JS文件下载成功、执行完毕后，再继续解析下面的HTML代码。</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li><p><strong>defer / async script标签</strong></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;foo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bar.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>async script 的下载是异步的，不阻塞DOM解析，也不阻塞渲染</strong>。注意，是JS脚本的下载任务是不阻塞DOM解析和渲染的。</li>
<li><strong>async script 的执行可能会阻塞DOM解析，因此可能阻塞渲染</strong>。如果下载完成的时间点在DOM解析完成之前，则该脚本的执行会阻塞，如果下载完成的时间点在DOM解析完成之后，则不阻塞DOM渲染。</li>
<li><strong>async script 是乱序执行的</strong>，只要下载完成且不被CSS解析阻塞就执行，不考虑与其他async script的顺序关系。</li>
</ul>
<blockquote>
<p>async script是乱序的，所以可以用于链接那些不依赖于其他脚本、且不被其他脚本依赖的JS代码文件。</p>
<p>async script的执行会中断DOM解析，所以async script中最好不要操作非该脚本创建的DOM元素，因为此时HTML解析到了哪个元素是不确定的。</p>
<p>❓ 有一个问题：如果async script下载完成的时机是在DOM解析完成之后，DOM渲染之前，那这个JS脚本阻不阻塞DOM渲染？</p>
</blockquote>
</li>
</ol>
<ul>
<li><p><strong>defer script 的下载是异步的，不阻塞DOM解析，也不阻塞渲染。</strong></p>
</li>
<li><p><strong>defer script 的执行不阻塞DOM解析</strong>。最早的执行时间点是DOM解析完成之后，DOMContentLoaded事件之前。</p>
</li>
<li><p><strong>defer script 的执行可能阻塞DOM渲染</strong>。如果defer script在DOM解析完成之前下载完成，则将在DOM解析完成之后进行执行，则可能阻塞DOM渲染。</p>
</li>
<li><p><strong>defer script 是顺序执行的。</strong>H5规范规定defer scripts 之间的执行顺序要严格按照在HTML文件中的位置，从上到下执行。</p>
<blockquote>
<p>一般情况下，defer script更能满足应用脚本的使用场景。</p>
<p>❓ 这里同样有这样一个问题：如果defer script下载完成的时机是在DOM解析完成之后，DOM渲染之前，那这个JS脚本阻不阻塞DOM渲染？</p>
</blockquote>
</li>
</ul>
<p>   <img src="/2021/05/06/Web/front-end-optimization/image-20210523144121965.png" srcset="/img/loading.gif" alt="image-20210523144121965"></p>
<blockquote>
<p>优化手段：</p>
<ul>
<li>通过defer属性的JS引用避免阻塞DOM解析。</li>
<li>利用prefetch属性加载非必要但可能会用到的JS文件。</li>
</ul>
</blockquote>
<h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><h3 id="基于图层渲染"><a href="#基于图层渲染" class="headerlink" title="基于图层渲染"></a>基于图层渲染</h3><p>更具体来说，浏览器在渲染一个页面时会将页面分成一到多个图层：</p>
<ol>
<li><p>基于HTML解析+CSS解析的结果，这个过程中会根据DOM元素的特性将所有元素分为一到多个图层，而DOM树和CSS树合成为渲染树。</p>
<blockquote>
<p>我理解为：渲染树的节点信息中包含这个元素属于哪个图层，即图层信息包含在渲染树内。</p>
</blockquote>
</li>
<li><p>为每个节点计算位置、形状（回流）。</p>
</li>
<li><p>将每个DOM节点绘制填充到图层位图中（重绘）。</p>
</li>
<li><p>图层作为纹理上传到GPU。</p>
</li>
<li><p>GPU组合多个图层，进行叠加等操作，最后将结果展示到屏幕上。</p>
</li>
</ol>
<h3 id="创建图层"><a href="#创建图层" class="headerlink" title="创建图层"></a>创建图层</h3><p>基于Chrome进行测试，以下情况会创建图层：</p>
<ol>
<li><p>所有页面有一个document图层，一般的DOM元素绘制于该图层上。</p>
</li>
<li><p>拥有3D变换CSS属性<code>transform</code>的DOM节点会单独开辟一个图层。</p>
</li>
<li><p>应用CSS3动画的节点<code>animation: keyfameName</code>。</p>
</li>
<li><p>使用加速视频解码的<code>&lt;video&gt;</code>节点会开辟一个图层。</p>
</li>
<li><p><code>&lt;canvas&gt;</code>节点会开辟一个图层。</p>
</li>
<li><p>拥有CSS加速属性的元素（<code>will-change</code>）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#animate</span> &#123;<br>    <span class="hljs-attribute">will-change</span>: transform;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>❓ 不确定。固定定位fixed和粘滞定位stick的元素好像也会单独设置为一个图层。</p>
</li>
</ol>
<h2 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h2><h3 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流 reflow"></a>回流 reflow</h3><p>基于构造出的渲染树或更新后的渲染树，将可见DOM节点与其布局样式、尺寸结合起来，计算出它们在布局视口中的确切位置和形状大小，这个计算的阶段就是回流。</p>
<h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘 repaint"></a>重绘 repaint</h3><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，和他们的具体几何信息(位置、大小)，那么我们就可以再根据外观样式，将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。</p>
<blockquote>
<p><strong>重绘是以图层为单位的</strong>，如果图层中某个元素需要重绘，则整个图层都需要重绘。</p>
<p>所以为了提高性能，我们应该让这些经常会重绘的元素拥有一个自己的图层。</p>
</blockquote>
<h3 id="触发回流的情况"><a href="#触发回流的情况" class="headerlink" title="触发回流的情况"></a>触发回流的情况</h3><ul>
<li>添加或删除可见的DOM元素（包括修改<code>display：none</code>） 。</li>
<li>元素的位置发生变化。</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>
<li>页面一开始渲染的时候（这肯定避免不了）</li>
<li>页面的布局视口变化（特别是PC端窗口resize，因为回流是根据视口的大小来计算元素的位置和大小的）。</li>
<li>字体发生变化。</li>
<li>…..</li>
</ul>
<blockquote>
<p><strong>大部分情况下，重排是以Render Tree为单位的</strong>，因为如果某个独立图层上的元素触发了重排，而该图层的元素没有脱离文档流，则单独重排该图层是达不到效果的。</p>
</blockquote>
<p><strong>具体而言，以下CSS属性发生改变会触发回流：</strong></p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210525232641079.png" srcset="/img/loading.gif" alt="image-20210525232641079"></p>
<p><strong>同时，通过Web API访问CSS样式会触发回流：</strong></p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210525233110226.png" srcset="/img/loading.gif" alt="image-20210525233110226"></p>
<blockquote>
<p><strong>只要是获取元素位置相关的操作，都会触发回流，原因在于：</strong></p>
<p>现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>。</p>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。</strong></p>
</blockquote>
<h3 id="触发重绘的情况"><a href="#触发重绘的情况" class="headerlink" title="触发重绘的情况"></a>触发重绘的情况</h3><p><img src="/2021/05/06/Web/front-end-optimization/image-20210530192602044.png" srcset="/img/loading.gif" alt="image-20210530192602044"></p>
<blockquote>
<p>总结为： </p>
<ul>
<li>color</li>
<li>background 简写属性及其相关具体样式。</li>
<li>一些装饰性的样式，如border-radius、border-style、text-decoration、box-shadow、outline相关。</li>
<li>visibility</li>
</ul>
</blockquote>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ol>
<li><p>在兼容性良好的情况下，移动元素位置时，使用<code>transform</code>，替代操作<code>left/top</code>。</p>
<blockquote>
<p><code>transform</code>的改变仅仅是改变图层的组合方式，而不触发重排和重绘。</p>
</blockquote>
</li>
<li><p>使用<code>opacity: 0;/ opacity: 1;</code>代替<code>visibility: hidden;/ visibility: visible;</code>。</p>
<ul>
<li><p>使用<code>visibility</code>不触发重排，但是依然重绘。</p>
</li>
<li><p>直接使用<code>opacity</code>既触发重绘，又触发重排。</p>
</li>
<li><p>理论上，改变一个独享图层的元素的<code>opacity</code>属性，既不触发重排，也不触发重绘。</p>
<blockquote>
<p>这里有点小问题，最新版本的Chrome测试的结果是配合图层使用时，<code>opacity</code>也会触发重绘。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>利用元素的<code>class</code>，将多个样式的改变合并成一次操作（修改元素类名）。</p>
</li>
<li><p>将DOM元素脱离文档流后再修改。</p>
<blockquote>
<p>DOM元素不在文档流中意味着元素不在渲染树中，这有两种情况：</p>
<ul>
<li>元素不在DOM树中，就不可能存在于渲染树中。</li>
<li>元素在DOM树中，但<code>display: none;</code></li>
</ul>
<p>如果要对一个元素进行复杂的样式操作时，可以先不插入DOM树、或者先对该树中元素使用<code>display: none;</code>，操作完样式后再使之可见。这样至多触发2次重排重绘。</p>
</blockquote>
</li>
<li><p>利用文档碎片<code>documentFragment</code>。Vue中就利用了该方式提升渲染性能。</p>
</li>
<li><p>避免频繁地通过JS访问节点的位置、尺寸等样式属性，必要时进行缓存。</p>
</li>
</ol>
<p><strong>其他关于动画的优化手段：</strong></p>
<ol>
<li><p>当通过背景图片位置的变化实现动画效果时，记得为该元素开启一个图层，最简单的方式：<code>transform: translateZ(0)</code>。</p>
</li>
<li><p>不懂❓ 为动画元素新增图层，提高动画元素的<code>z-index</code>。</p>
</li>
<li><p>使用<code>requestAnimationFrame</code>实现动画效果。</p>
<p>MDN解释：<code>window.requestAnimationFrame(fn)</code>告诉浏览器——你希望执行动画，并且要求浏览器在下一次重绘之前调用指定的回调函数更新动画。</p>
<ul>
<li><p>该方法需要传入一个回调函数<code>fn</code>作为参数，该回调函数会被注册，并在浏览器下一次重绘之前执行，执行完毕后会从注册表中清除，如果想实现连续的动画效果，<code>fn</code>中需要重新调用<code>requestAnimationFrame</code>。</p>
</li>
<li><p>该方法返回一个ID，该ID可以用于解除回调函数的注册（使用<code>cancelAnimationFrame(ID)</code>）。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> distance = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move</span>(<span class="hljs-params"></span>) </span>&#123;<br>	<span class="hljs-keyword">let</span> elm = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>    elm.style.transform = <span class="hljs-string">`translateX(<span class="hljs-subst">$&#123;++distance&#125;</span>)`</span>;<br>    id = requestAnimationFrame(move);  <span class="hljs-comment">// 更新id，JS会阻塞DOM渲染。</span><br>&#125;<br><br><span class="hljs-keyword">let</span> id = requestAnimationFrame(move); <span class="hljs-comment">// 页面第一次渲染时会发生重绘，动画便开始了。</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> cancelAnimationFrame(id), <span class="hljs-number">2000</span>); <span class="hljs-comment">// 👈2s 后取消动画</span><br></code></pre></td></tr></table></figure>






</li>
</ol>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，<strong>将网站的内容发布到最接近用户的“边缘节点”，使用户可以就近取得所需的内容</strong>，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN=更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「xiangzhihong8」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangzhihong8/article/details/83147542">https://blog.csdn.net/xiangzhihong8/article/details/83147542</a></p>
<h3 id="CDN相关技术"><a href="#CDN相关技术" class="headerlink" title="CDN相关技术"></a>CDN相关技术</h3><p>CDN的实现需要依赖多种网络技术的支持，其中最主要的包括负载均衡技术、动态内容分发与复制技术、缓存技术等。</p>
<p><strong>负载均衡技术</strong><br>负载均衡技术不仅仅应用于CDN中，在网络的很多领域都得到了广泛的应用，如服务器的负载均衡、网络流量的负载均衡。顾名思义，网络中的负载均衡就是将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或网络节点上，由此来避免部分网络节点过载。这样既可以提高网络流量，又提高了网络的整体性能。在CDN中，负载均衡又分为服务器负载均衡和服务器整体负载均衡(也有的称为服务器全局负载均衡)。服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。而服务器整体负载均衡允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。</p>
<blockquote>
<p>智能DNS服务器的核心就是根据负载均衡策略导流不同来源的请求。</p>
</blockquote>
<p><strong>动态分发与复制技术</strong><br>众所周知，网站访问响应速度取决于许多因素，如网络的带宽是否有瓶颈、传输途中的路由是否有阻塞和延迟、网站服务器的处理能力及访问距离等。多数情况下，网站响应速度和访问者与网站服务器之间的距离有密切的关系。如果访问者和网站之间的距离过远的话，它们之间的通信一样需要经过重重的路由转发和处理，网络延误不可避免。一个有效的方法就是利用内容分发与复制技术，将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上。所以动态内容分发与复制技术也是CDN所需的一个主要技术。</p>
<blockquote>
<p>个人理解：CDN上要能够存储一些静态资源，这里也存在推拉模型❓</p>
</blockquote>
<p><strong>缓存技术</strong><br>缓存技术已经不是一种新鲜技术。Web缓存服务通过几种方式来改善用户的响应时间，如代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务等。通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低。对于公司内联网用户来说，这意味着将内容在本地缓存，而无须通过专用的广域网来检索网页。对于Internet用户来说，这意味着将内容存储在他们的ISP的缓存器中，而无须通过Internet来检索网页。这样无疑会提高用户的访问速度。CDN的核心作用正是提高网络的访问速度，所以，缓存技术将是CDN所采用的又一个主要技术。</p>
<h3 id="使用CDN的好处"><a href="#使用CDN的好处" class="headerlink" title="使用CDN的好处"></a>使用CDN的好处</h3><p>对于用户：</p>
<ol>
<li>解决跨运营商和跨地域访问的问题，最重要的是大大降低获取网络资源的延迟，用户体验更好。</li>
</ol>
<p>对于企业、网站：</p>
<ol>
<li>大部分请求再CDN边缘节点完成，起到了分流作用，减轻了源站负载。</li>
<li>提高网站的稳定性、可用性。</li>
<li>让大规模的用户请求架构变得简单了，避免企业自己去部署很多节点。</li>
</ol>
<h3 id="大致工作流程"><a href="#大致工作流程" class="headerlink" title="大致工作流程"></a>大致工作流程</h3><p>当用户通过浏览器访问已经加入CDN服务的网站时，首先通过<strong>智能DNS（有博客说叫做DNS重定向）</strong>确定最接近用户的最佳<strong>CDN节点</strong>，同时浏览器将请求发送到该节点。当用户的请求到达指定节点时，CDN的服务器（节点上的高速缓存）负责将用户请求的内容响应给用户。</p>
<blockquote>
<p>从以上内容可以分析出，CDN技术的主要组成部分之一是DNS接管。</p>
</blockquote>
<p><strong>首先，让我们看一下传统的未加缓存服务的访问过程：</strong></p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210531165645196.png" srcset="/img/loading.gif" alt="image-20210531165645196"></p>
<p>如图可以看出，传统的网络访问的流程如下：</p>
<ol>
<li><p>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址；</p>
</li>
<li><p>LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)；</p>
</li>
<li><p>ROOT DNS将域名授权dns记录回应给 LocalDns；</p>
<blockquote>
<p>这里是一个不断查找目标域名的NS纪录的过程，可能问询了不止一台授权服务器。</p>
</blockquote>
</li>
<li><p>LocalDns得到域名的授权dns记录后，继续向域名授权dns查询域名的ip地址；</p>
<blockquote>
<p>最终的授权DNS服务器上有目标域名的A纪录，即目标域名的ip地址。</p>
</blockquote>
</li>
<li><p>域名授权dns 查询域名记录后，回应给 LocalDns；</p>
</li>
<li><p>LocalDns 将得到的域名ip地址，回应给用户端；</p>
</li>
<li><p>用户得到域名ip地址后，访问站点服务器；</p>
</li>
<li><p>站点服务器应答请求，将内容返回给客户端。</p>
</li>
</ol>
<p><strong>下面让我们看一下使用CDN缓存后的网站的访问过程：</strong></p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210531170631233.png" srcset="/img/loading.gif" alt="image-20210531170631233"></p>
<p>如上图，是使用CDN缓存后的网络访问流程：</p>
<ol>
<li><p>用户通过浏览器访问网站，浏览器调用操作系统接口向 LocalDns 查询域名的ip地址。</p>
<blockquote>
<p>这里存在以下假设前提：</p>
<ul>
<li>浏览器域名缓存不存在该域名IP。</li>
<li>操作系统的DNS解析缓存不存在该域名IP。</li>
<li>本地host文件中没有该域名+ip的键值对。</li>
</ul>
</blockquote>
</li>
<li><p>LocalDns向 ROOT DNS 查询域名的授权服务器。</p>
<blockquote>
<p>这里假设LocalDns缓存过期。</p>
</blockquote>
</li>
<li><p>ROOT DNS将域名授权dns记录回应给 LocalDns；</p>
<blockquote>
<p>❓ 域名授权DNS会不会是一台智能DNS服务器？从而减少4~6步？</p>
</blockquote>
</li>
<li><p>LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址；</p>
</li>
<li><p>域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDNS；</p>
<blockquote>
<p>DNS服务器的表中有A记录、NS记录、CNAME记录。</p>
</blockquote>
</li>
<li><p>LocalDNS重新到ROOT DNS查询域名别名的授权DNS服务器IP（智能DNS服务器的IP）。</p>
</li>
<li><p>LocalDNS 得到智能调度DNS的IP后,向智能调度DNS查询域名的ip地址；</p>
</li>
<li><p>智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给LocalDNS。</p>
</li>
<li><p>LocalDNS将得到的域名ip地址，回应给用户端；</p>
</li>
<li><p>用户浏览器得到域名ip地址后，访问站点服务器。</p>
</li>
</ol>
<blockquote>
<p><strong>综上，</strong>CDN网络是在用户和服务器之间增加Cache层，主要是通过<strong>网站接管DNS解析</strong>实现，将用户的请求引导到Cache上获得源服务器的数据，从而降低网络的访问时间。</p>
</blockquote>
<h3 id="CDN通过“推拉”更新内容"><a href="#CDN通过“推拉”更新内容" class="headerlink" title="CDN通过“推拉”更新内容"></a>CDN通过“推拉”更新内容</h3><p>CDN分为推拉两种方式，推是源服务器将内容推到cdn节点上，拉是cdn在第一次接受请求的时候从服务器拉取资源进行响应并保存，当资源在cdn缓存之后，如果服务器上的资源发生变化，cdn节点是不会知道的，除非缓存时间到期重新拉取或者修改新资源的访问地址。</p>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p>概念：  延迟要执行的动作，若在延迟的这段时间内，再次出发了，则取消之前开启的动作，重新计时。</p>
<p>实现：  借助<code>setTimeout</code>和<code>clearTimeout</code>。</p>
<p>应用场景：  搜索时等待用户完整输入内容后再发送查询请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay = <span class="hljs-number">300</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timer;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>       timer &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timer);<br>       timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           fn.apply(<span class="hljs-built_in">this</span>, args);<br>           <span class="hljs-built_in">clearTimeout</span>(timer);<br>           timer = <span class="hljs-literal">undefined</span>;<br>       &#125;, delay);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><p>概念：  设定一个特定的时间间隔，让函数在此事件间隔内只执行一次，不会频繁执行。</p>
<p>实现： 借助一个标识和<code>setTimeout</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">cb, interval = <span class="hljs-number">300</span></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> allowed = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (allowed) &#123;<br>            allowed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123; allowed = <span class="hljs-literal">true</span>; &#125;, interval);<br>            cb.apply(<span class="hljs-built_in">this</span>, args);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="联系和区别"><a href="#联系和区别" class="headerlink" title="联系和区别"></a>联系和区别</h3><p>联系：防抖和节流的目的都是当短时间内同一事件多次触发时，避免多次执行同样的回调。</p>
<p>区别：</p>
<ul>
<li>防抖是一段时间内重复触发回调，下一次取消上一次的再执行。</li>
<li>节流是一段时间内重复触发回调，只要保证最先的一次执行即可。</li>
</ul>
<h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>Cookie、LocalStorage、SessionStorage这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。</p>
<p>Web Storage主要包括<code>localStorage</code>和<code>sessionStorage</code>，二者都有大约5M的空间。</p>
<h3 id="增删改API"><a href="#增删改API" class="headerlink" title="增删改API"></a>增删改API</h3><ol>
<li><p>保存数据。</p>
<p><code>localStoragge.setItem(&#39;key&#39;, &#39;value&#39;)</code></p>
<p><code>localStorage.setItem(&#39;obj&#39;, JSON.stringify(obj))</code></p>
<p><code>sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code></p>
<p><code>sessionStorage.setItem(&#39;obj&#39;, JSON.stringify(obj))</code></p>
<blockquote>
<p>本地存储中，存储的value一定是字符串类型。如果调用setItem方法，value为基本类型时，API会自动转换为字符串，而对于引用类型，必须显示调用<code>JSON.stringify</code>后再存入。</p>
</blockquote>
</li>
<li><p>读取数据，结果一定是字符串。</p>
<p><code>localStorage.getItem(&#39;key&#39;)</code></p>
<p><code>sessionStorage.getItem(&#39;key&#39;)</code></p>
<blockquote>
<p>如果不存在键名为key的记录，则返回null。</p>
</blockquote>
</li>
<li><p>删除一条记录。</p>
<p><code>localStorage.removeItem(&#39;key&#39;)</code></p>
<p><code>sessionStorage.removeItem(&#39;key&#39;)</code></p>
</li>
<li><p>清空所有键值对。</p>
<p><code>localStorage.clear()</code></p>
<p><code>sessionStorage.clear()</code></p>
</li>
</ol>
<h3 id="window的storage事件"><a href="#window的storage事件" class="headerlink" title="window的storage事件"></a>window的storage事件</h3><p>我们可以通过监听window对象的storage事件来实现跨页签通信（数据同步）。</p>
<p><code>window.addEventListener(&#39;storage&#39;, function(event)&#123;...&#125;)</code></p>
<p><strong>触发机制</strong></p>
<ol>
<li>该事件会在<code>web storage</code>（localStorage/sessionStorage）的内容发生变化时触发（例如创建、删除、修改、清空操作）。</li>
<li>在某个页面中修改了<code>web storage</code>的内容，<font color='red'>在本页面并不会触发window对象的storage事件，而是在其他共享的页面中触发</font>。</li>
</ol>
<p><strong>StorageEvent对象</strong></p>
<p>window对象的storage事件的回调函数中，event的实参是一个<code>StorageEvent</code>对象，该对象具有以下属性：</p>
<ul>
<li><p><code>key</code>： 新增、更新、删除的记录键名，调用的是clear()时，该属性值为null。</p>
</li>
<li><p><code>newValue</code>： 最新的值，如果调用clear()或removeItem()，该属性值为null。</p>
</li>
<li><p><code>oldValue</code>：  修改之前的值，如果调用clear()或新增了该键值对，该属性值为null。</p>
</li>
<li><p><code>url</code>： 触发该事件时的页面的url。</p>
</li>
<li><p><code>storageArea</code>：  当前的storage对象，即 localStorage或 sessionStorage。</p>
</li>
</ul>
<h3 id="有效期和作用域"><a href="#有效期和作用域" class="headerlink" title="有效期和作用域"></a>有效期和作用域</h3><p><strong>localStorage 作用域</strong></p>
<p>限定在文档源级别的，每个源只能访问属于自己的localStorage，不同的path之间共享。</p>
<blockquote>
<p>文档源通过协议、主机名、端口三者来确定（即每个源拥有一个localStorage）。</p>
</blockquote>
<p><strong>sessionStorage 作用域</strong></p>
<p>限定在文档源级别，一个标签页下的每个源只能访问属于自己的sessionStorage，不同的path之间共享，<font color='red'>但不同页签之间同一个源的sessionStorage不共享</font>。</p>
<blockquote>
<p>例如：第一个标签页打开<a target="_blank" rel="noopener" href="http://www.baidu.com,写入一些东西到sessionstorage,再新建一个标签页打开www.baidu.com,新页签下www.baidu.com的sessionstorage和第一个页签www.baidu.com的sessionstorage不相同./">www.baidu.com，写入一些东西到sessionStorage，再新建一个标签页打开www.baidu.com，新页签下www.baidu.com的sessionStorage和第一个页签www.baidu.com的sessionStorage不相同。</a></p>
</blockquote>
<p><strong>localStorage 有效期</strong></p>
<p>某个源下的localStorage永不失效，除非web应用删除一条或全部的记录，或者浏览器清空本地存储。</p>
<p><strong>sessionStorage 有效期</strong></p>
<p>标签页或整个浏览器程序关闭后失效，单个标签页内的跳转、前进、后退或刷新不会使得会话期间某个源下的sessionStorage失效。</p>
<blockquote>
<p>但需要注意的是，如果在本标签页上点击了a标签，并使用新的标签页打开链接，即使新的标签页和本标签页是同源的，在新的标签页上也访问不到原标签页的sessionStorage。</p>
</blockquote>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于HTTP协议是无状态的，而服务器端的业务必须是要有状态的<strong>。Cookie诞生的最初目的是为了在客户端存储Web中的状态信息</strong>，以方便服务器端使用，例如：用于判断用户是否是第一次访问网站。</p>
<blockquote>
<p>HTTP是无状态的：HTTP通信中，每个请求/响应都是完全独立于其他的请求/响应的。每个请求包含了处理这个请求所需的完整的数据，每个响应也只是针对请求做出的回答。请求/响应的过程不涉及到状态变更。</p>
</blockquote>
<h3 id="Cookie的处理"><a href="#Cookie的处理" class="headerlink" title="Cookie的处理"></a>Cookie的处理</h3><ol>
<li>通过HTTP响应头中的Set-Cookie首部，服务器向客户端发送cookie。</li>
<li>根据有效期属性，Cookie在浏览器上保存一段时间或删除某条Cookie。</li>
<li>之后每次Http请求，浏览器都会自动将对本次请求<font color='red'>可见的、未过期的、被允许的</font>Cookie发送给服务器。</li>
</ol>
<h3 id="Cookie的结构"><a href="#Cookie的结构" class="headerlink" title="Cookie的结构"></a>Cookie的结构</h3><ul>
<li><p><code>Name/Value</code></p>
<p><strong>Name</strong>和<strong>Value</strong>是一个键值对。<strong>Name</strong>是Cookie的名称，Cookie一旦创建，名称便不可更改，一般名称不区分大小写；<strong>Value</strong>是该名称对应的Cookie的值，如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。</p>
</li>
</ul>
<ul>
<li><p><code>Domain</code></p>
<p><font color='red'>Domain决定Cookie在哪些域名下的主机是有效的，也就是决定在向该主机发送请求时是否携带此Cookie，</font>Domain的设置在一些情况下是对子域生效的，如Domain设置为<code> .a.com</code>,则该域名下的主机<code>b.a.com</code>和主机<code>c.a.com</code>均可使用该Cookie，同时<code>.xxx.a.com</code>域名下</p>
<blockquote>
<p>需要强调：</p>
<ol>
<li><p>如果某个域下的Cookie如果希望能够被他的子域具有可见性、可用性，应该保证这个cookie在被Set的时候，<font color='red'>应该以”.”开头</font>。不同浏览器有不同样的实现，但这样做一定不会错。例如，有些浏览器认为Cookie的Domain不以点开头，只有请求的主机名和Domain相同时，才会发出该Cookie，而IE不是这样的。</p>
</li>
<li><p>如果服务端在Set Cookie时，如果省略Domain属性，那么大部分浏览器会将该条Cookie的domain设置HTTP请求中的host值（主机名）。</p>
</li>
<li><p>Cookie的Domain不支持端口（❓ 不确定支不支持IP），如果你想多个端口来区分cookie的域，可以为这些不同端口的访问来绑定不同的子域名。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>Path</code></p>
<p>Path是Cookie的有效路径，和Domain类似，也对子路径生效，如Cookie1和Cookie2的Domain均为a.com，但Path不同，Cookie1的Path为 /b/,而Cookie的Path为 /b/c/,则在a.com/b页面时只可以访问Cookie1，在a.com/b/c页面时，可访问Cookie1和Cookie2。</p>
<blockquote>
<p>需要强调：</p>
<ol>
<li><p>Cookie的Path属性值一定以<code>/</code>结尾。</p>
</li>
<li><p>如果服务端在Set Cookie时，如果省略Domain属性，则浏览器会将该条Cookie的path属性值设置为HTTP请求Path的目录。例如在请求<a target="_blank" rel="noopener" href="http://localhost/day07_03/AServlet%E6%97%B6%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E4%BA%86%E4%B8%80%E4%B8%AACookie%EF%BC%8C%E4%BD%86%E6%B2%A1%E6%9C%89path%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%82%A3%E4%B9%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86%E8%BF%99%E4%B8%AACookie%E7%9A%84path%E5%B0%B1%E9%BB%98%E8%AE%A4%E8%AE%BE%E7%BD%AE%E4%B8%BA%60/day07_03/%60%E3%80%82">http://localhost/day07_03/AServlet时，服务器响应了一个Cookie，但没有path属性，那么浏览器将这个Cookie的path就默认设置为`/day07_03/`。</a></p>
</li>
<li><p>大部分网站的做法是将Cookie的Domain设置为顶级域名<code>.xxx.com</code>，path设置为<code>/</code>。</p>
</li>
</ol>
<p>❓ 有一个疑惑：</p>
<p>对子域名下的主机发出请求时，父级域名下的Path不为<code>/</code>的Cookie是否对该请求可见？</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>Expires/Max-age</code></p>
<p>Expires和Max-age均为Cookie的有效期，Expires是该Cookie被删除时的时间戳，格式为GMT。</p>
<p>Max-age也是Cookie的有效期，但它的单位为秒，即多少秒之后失效，Max-age比Expires优先级更高。</p>
<p>设置了未过期的Expires值或Max-age&gt;=0的Cookie称为<font color='red'>持久化Cookie，会保存至硬盘文件，过期时删除</font>。</p>
<p>没有设置Max-age，但设置Expires时，以Expires为准。</p>
<p>既没有设置Max-age，也没有设置Expires的Cookie成为<font color='red'>会话Cookie，会保存在内存中，浏览器关闭时删除</font>。</p>
<blockquote>
<p>需要注意：</p>
<ol>
<li>Cookie的Expires值由服务端设置，该时间戳为服务器时间，而浏览器以本地时间做过期判定。</li>
<li>若Expires的值为本地过期的时间，则该Cookie立刻被删除。</li>
<li>若Max-age设置为0，则立刻失效，同Expires过期的情况。</li>
<li>若Max-age设置为-1，浏览器关闭时，该Cookie会删除，意味着该条Cookie成为会话Cookie。</li>
<li>如果希望将客户端已有的Cookie删除，则后端可以发送过期的Expires值或者Max-age=0；又或是希望通过Max-age=-1将客户端某条已有的Cookie变为会话Cookie；<font color='red'>必须同时指定Cookie的Name、Value、Expires/Max-age，以及Domain和Path，因为Domain+Path+Name才能定位到客户端的一条Cookie</font>。</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>HttpOnly</code></p>
<p>HttpOnly为布尔属性，默认时没有该属性，如果设置Cookie时存在该属性，则不允许通过脚本document.cookie去更改这个值，同样这条Cookie在document.cookie中也不可见，但在发送请求时依旧会携带此Cookie。</p>
</li>
</ul>
<ul>
<li><p><code>Secure</code></p>
<p>Secure为Cookie的安全属性，它是一个布尔属性，默认为false，若Cookie记录中存在该属性则为<em>true</em>，则浏览器只会在HTTPS和SSL等安全协议中传输此Cookie，不会在不安全的HTTP协议中传输此Cookie。</p>
</li>
</ul>
<ul>
<li><p><code>SameSite</code></p>
<p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止跨站点请求伪造（CSRF）攻击和用户追踪。这个属性也被IEIF提倡使用。当然防止CSRF攻击还有其他方法，如<code>CSRF token</code>校验以及<code>Referer</code>请求头校验。</p>
<p>SameSite属性可以设置三个值: <code>① Strict ② Lax ③ None</code>。</p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210602151717018.png" srcset="/img/loading.gif" alt="image-20210602151717018"></p>
<p><strong>1. Strict</strong><br>Strict最为严格，完全禁止第三方 Cookie，<font color='red'>跨站点时</font>，任何情况下都不会发送此类型Cookie。换言之，只有当前网页的URL的主机名部分与Cookie的Domain属性值是同站的关系（same-site），请求时才会发送此类型的Cookie。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span>: CookieName=CookieValue; SameSite=Strict;<br></code></pre></td></tr></table></figure>
<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<p><strong>2. Lax</strong><br>Lax规则稍稍放宽，<font color='red'>跨站点时，</font>大多数情况也是不发送第三方 Cookie，但是导航到与Cookie同站点的 Get 请求除外（如A标签、GET表单、link:prefetch/preload）。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span>: CookieName=CookieValue; SameSite=Lax;<br></code></pre></td></tr></table></figure>
<p><strong>3. None</strong></p>
<p>不对此条Cookie在第三方上下文中的发送作限制，只要是Cookie对第三方上下文的这次请求可见，就把Cookie发送过去。</p>
</li>
</ul>
<blockquote>
<p><strong>最新变化：</strong></p>
<p>但一些浏览器，例如Chrome，计划将<code>SameSite=Lax</code>作为每条Cookie的默认设置。而当网站希望不对某条Cookie的第三方上下文发送作限制，则需要显示地设置<code>SameSite=None</code>，但是必须配合<code>Secure</code>字段使用（即此条Cookie必须通过HTTPS发送，否则无效），例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">下面的设置无效，即浏览器不会记录该条Cookie：<br><span class="hljs-attribute">Set-Cookie</span>: widget_session=abc123;Max-age=100;SameSite=None<br>而下面的设置有效：<br><span class="hljs-attribute">Set-Cookie</span>: widget_session=abc123;Max-age=100;SameSite=None;Secure<br></code></pre></td></tr></table></figure>

<p>尽管有些浏览器将Cookie的<code>SameSite</code>属性默认为<code>Lax</code>，但考虑兼容情况，尽量在Set-Cookie时显示地为属性赋值<code>SameSite=Lax</code>；同时考虑到对一些浏览器单独使用<code>SameSize=None</code>无效，所以如果希望允许在第三方上下文中发送Cookie，则需要设置<code>SameSite=None;Secure</code>，无形中强制Cookie所属的网站使用HTTPS通信。</p>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44269886/article/details/102459425">Cookie的SameSite属性：https://blog.csdn.net/weixin_44269886/article/details/102459425</a></p>
<p>  <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html">SameSite阮一峰：http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
<p>  <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904095476613133">SameSite cookies 理解 https://juejin.cn/post/6844904095476613133</a></p>
<ul>
<li><p><code>Priority</code></p>
<p>优先级，chrome的提案，定义了三种优先级，Low/Medium/High，当cookie数量超出时，低优先级的cookie会被优先清除。在360极速浏览器和FireFox中，不存在<strong>Priority</strong>属性，不清楚在此类浏览器中设置该属性后是否生效。</p>
</li>
</ul>
<h3 id="Cookie的写入"><a href="#Cookie的写入" class="headerlink" title="Cookie的写入"></a>Cookie的写入</h3><p>① a标签跳转</p>
<p>② 表单GET/POST </p>
<p>③  外部资源引用src（图片） </p>
<p>④  iframe src </p>
<p>⑤ Ajax </p>
<p><strong>以上这五种方式，都有可能发出跨域/不跨域、跨站/不跨站的请求，返回的响应头中很可能会有Set-Cookie。</strong></p>
<p><strong>以下开始分析浏览器如果发现各种类型请求的响应头中有Set-Cookie，它会怎样处理。</strong></p>
<ol>
<li><p><font color='red'>如果请求不跨域</font><font color='red'>，就会像顶级导航一样</font>，响应头中任何Set的Cookie都有效，浏览器会对它执行有关逻辑。</p>
</li>
<li><p><font color='red'>如果这个请求跨域不跨站</font>，响应中Set的Cookie就可以写入，<font color='red'>不论</font>Cookie的<code>SameSite</code>属性为何值。</p>
<blockquote>
<p>❗ 如果是跨域不跨站的AJAX请求，请看第五条。</p>
</blockquote>
</li>
<li><p>⭐<font color='red'>即使这个请求不跨站，</font><font color='red'>但Scheme为HTTP</font>，浏览器只允许写入响应头中<code>SameSite=Lax</code>或<code>SameSite=Strict</code>的Cookie，不允许写入<code>SameSite=None;Secure</code>的Cookie。</p>
</li>
<li><p>❓ <font color='red'>如果是跨站请求</font>，浏览器只会写入响应头中<code>SameSite=None;Secure</code>的Cookie。</p>
<blockquote>
<p>不确定是否会存入<code>SameSite=Strict或SameSite=Lax</code>的Cookie。</p>
<p>❗ 如果是跨站的AJAX请求，请看第五条。</p>
</blockquote>
</li>
<li><p><font color='red'>如果是AJAX 跨域不跨站/ 跨站请求</font>：</p>
<ul>
<li><p>如果<code>XMLHttpRequest</code>对象的<code>withCredentials</code>属性值为false，则响应头中Set的任何Cookie都无效，浏览器不会写入它们。</p>
<blockquote>
<p>即<code>withCredentials</code>属性既控制AJAX跨域请求时是否携带Cookie，又控制是否允许该请求的响应在自己的域中设置Cookie，具体可以参考MDN对<code>XMLHttpRequest.withCredentials</code>的解释。</p>
</blockquote>
</li>
<li><p>如果<code>XMLHttpRequest</code>对象的<code>withCredentials</code>属性值为<code>true</code>，则跨域/跨站AJAX请求会发送与之相关的Cookie，而对响应头中的Set-Cookie的处理可以参考2~4条。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Cookie的Web-API"><a href="#Cookie的Web-API" class="headerlink" title="Cookie的Web API"></a>Cookie的Web API</h3><p>我们不仅可以通过HTTP响应让浏览器操作Cookie，还可以在页面运行JS脚本时，通过代码操作当前域下可见的Cookie。</p>
<blockquote>
<p>受同源政策的约束，在某个页面中以JS脚本的方式只允许访问页面的主机名下的Cookie及其上级域名的Cookie（受限于<code>Domain</code>）。同时只能访问页面所在目录及其上级目录的Cookie（受限于<code>Path</code>）。</p>
<p>例如：</p>
<p>当前访问的页面是<code>https://www.a.com/pathtohtml/index.html</code>，则该页面的脚本只可以访问<code>www.a.com</code>与<code>.a.com</code>域名下的Cookie，同时只能访问<code>/pathtohtml/</code>和<code>/</code>路径下的Cookie。</p>
</blockquote>
<p><strong>API：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 读取当前页面下的所有Cookie，其值为形如`key1=value1;key2=value...`的字符串</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.cookie);<br><br><span class="hljs-comment">// 添加一条Cookie</span><br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;key=value;Max-age=300;Path=/;SameSite=None;Secure&#x27;</span><br><br><span class="hljs-comment">// 删除一条Cookie</span><br><span class="hljs-built_in">document</span>.cookie = <span class="hljs-string">&#x27;key=value;Max-age=0;Path=/;&#x27;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol>
<li>Cookie默认不会保存任何数据，<code>document.cookie</code>默认值为空字符串。</li>
<li>Cookie不能一次性设置多条，只能一条一条添加。</li>
<li>同一个站点，Cookie有个数限制，一般为20~50条，大小限制在4KB。</li>
<li>HTTP响应中设置了<code>HttpOnly</code>的Cookie不能通过<code>document.cookie</code>访问，但确实存在。</li>
</ol>
</blockquote>
<h3 id="第一方Cookie注意事项"><a href="#第一方Cookie注意事项" class="headerlink" title="第一方Cookie注意事项"></a>第一方Cookie注意事项</h3><p><strong>第一方Cookie是指：</strong>当前网页主机名下可以访问到的Cookie（一般是同站的Cookie）。</p>
<ol>
<li>第一方Cookie可以由网站加载的第三方脚本写入，即第三方脚本中使用 document.cookie 接口。</li>
<li>第一方Cookie如果没有设置HttpOnly，则可以通过跨站外链、跨站AJAX请求将第一方Cookie以参数形式发送给第三方脚本。</li>
<li>第一方Cookie即使设置了HttpOnly，第三方仍然可以让第一方（网站服务器）托管脚本，从而读取第一方Cookie。</li>
</ol>
<h3 id="浏览器禁用第三方Cookie"><a href="#浏览器禁用第三方Cookie" class="headerlink" title="浏览器禁用第三方Cookie"></a>浏览器禁用第三方Cookie</h3><p><strong>第三方Cookie是指：</strong>相对于当前页面URL的主机名，某个请求是跨站请求，发送给该站点以及该请求的响应头中含有的Cookie属于第三方Cookie（即在一次跨站请求中，第三方Cookie含有发送和写入两个环节）。</p>
<p>很多浏览器都具有禁用第三方Cookie的功能，开启禁用后，如果发送跨站请求：</p>
<ol>
<li>发送请求环节，不论浏览器在该跨站域名下的Cookie的<code>SameSite</code>属性为何值，都不会发送Cookie。</li>
<li>得到响应环节，Set-Cookie首部中的任何Cookie都不会被浏览器记录。</li>
</ol>
<blockquote>
<p>区别于<code>SameSite=Strict</code>的Cookie，该属性只是不允许在跨站请求时发送Cookie，这是对用户的Cookie进行保护。❓ 其实不是确定跨站响应中<code>SameSite=Strict</code>的Cookie是否会被写入。</p>
<p>浏览器禁用第三方Cookie功能是为了保护用户的隐私，禁止第三方网站跟踪用户、分析用户行为。</p>
</blockquote>
<h2 id="Cookie和Web-Storage的区别与联系"><a href="#Cookie和Web-Storage的区别与联系" class="headerlink" title="Cookie和Web Storage的区别与联系"></a>Cookie和Web Storage的区别与联系</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>可以从Cookie、localStorage、sessionStorage的有效期、作用域、大小限制、发送时机来进行回答。</p>
<p><strong>有效期</strong></p>
<ul>
<li>Cookie的有效期分两种，会话Cookie在浏览器程序关闭时删除，持久化Cookie在到期时被删除。</li>
<li>localStorage除非Web应用代码删除、用户点击删除、用户清空本地存储，否则一直有效。</li>
<li>sessionStorage在页签关闭时删除，历史记录前进后退时也不删除，不同页签打开同一页面不共享。</li>
</ul>
<p><strong>作用域</strong></p>
<ul>
<li><p>Cookie的作用域：</p>
<p>子域名可以访问本级与上级域名的Cookie，反之不可；</p>
<p>子目录可以访问当前目录与上级目录的Cookie，反之不可。</p>
<blockquote>
<p>不同浏览器不共享Cookie！！！</p>
</blockquote>
</li>
<li><p>localStorage的作用域为文档源，即同一个域名下的多个页面共享一个localStorage。</p>
</li>
<li><p>sessionStorage的作用域为一个页签下的一个文档源，页签可以不断跳转从而显示不同的页面，但是一个页签跳转到不同的域名时，sessionStorage会切换为该域下的存储空间。 </p>
</li>
</ul>
<p><strong>大小限制</strong></p>
<ul>
<li>Cookie的大小限制为：一个站点可以存储20~50条Cookie，大小限制在4KB。</li>
<li>Web Storage的大小限制为5M~8M。</li>
</ul>
<p><strong>发送时机</strong></p>
<ul>
<li>Cookie的发送时机是向某个站点下的某台主机发送请求时，会携带对于该次请求可见的Cookie。</li>
<li>Web Storage中的内容不会自动发送给服务器，需要通过JS脚本发送。</li>
</ul>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ol>
<li>都是在浏览器端存储状态的手段。</li>
<li>在一定程度上，都受同源策略保护。</li>
</ol>
<h2 id="对域名和主机名的理解"><a href="#对域名和主机名的理解" class="headerlink" title="对域名和主机名的理解"></a>对域名和主机名的理解</h2><p><code>.</code>为根域。</p>
<p>有人称<code>.com</code>、<code>.net</code>为顶级域名/一级域名，而<code>baidu.com</code>、<code>jd.com</code>为二级域名。</p>
<p>又有人称<code>baidu.com</code>为顶级域名/一级域名。</p>
<p>主机 = <code>主机的英文名字.域名</code></p>
<p>例如<code>www.baidu.com</code>是<code>baidu.com</code>域下的一台叫做<code>www</code>的主机。</p>
<p>例如<code>live.bilibili.com</code>是<code>bilibili.com</code>域下的一台叫做<code>live</code>的主机。</p>
<p>一个企业开发的网站，使用多少级域名由企业自己决定。</p>
<h2 id="对跨域和跨站的理解"><a href="#对跨域和跨站的理解" class="headerlink" title="对跨域和跨站的理解"></a>对跨域和跨站的理解</h2><p><strong>同域名</strong>：<code>scheme+host+port</code>相同，其他视为跨域。</p>
<p>举例：</p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210602225335101.png" srcset="/img/loading.gif" alt="image-20210602225335101"></p>
<p><strong>同站点</strong>：<code>eTLD+1</code>相同，其他视为跨站。</p>
<p>举例：</p>
<p><img src="/2021/05/06/Web/front-end-optimization/image-20210602225354985.png" srcset="/img/loading.gif" alt="image-20210602225354985"></p>
<blockquote>
<p>注意：</p>
<ol>
<li>普通的跨站不考虑scheme，考虑scheme的跨站叫做<code>schemeful same-site</code>。</li>
<li><code>mzleman.github.io</code>和<code>ley.github.io</code>跨站，因为<code>.io</code>不是一个<code>eTLD</code>，<code>.github.io</code>才是。<code>a.mzleman.github.io</code>和<code>b.mzleman.github.io</code>才是同站的。</li>
</ol>
</blockquote>
<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>浏览器在本地磁盘/内存中将之前请求的响应存储起来，当页面再次需要发出这些请求时，无需真正地发送请求（可能是真的不发，也可能是发送简单的缓存校验），直接从浏览器本地获取响应结果。</p>
<h3 id="使用浏览器缓存的好处"><a href="#使用浏览器缓存的好处" class="headerlink" title="使用浏览器缓存的好处"></a>使用浏览器缓存的好处</h3><ol>
<li>减少请求次数，避免网络通信带来延迟，从而加快浏览器获取资源、数据的速度。</li>
<li>减轻网站服务器的压力。</li>
<li>节省带宽、流量。</li>
</ol>
<h3 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h3><p><strong>强缓存：</strong></p>
<p>浏览器发出一条请求，服务器在响应头中通过<code>Cache-control:max-age=.../Expires</code>指示浏览器将该请求的响应缓存一段时间，在缓存失效之前，这条缓存为强缓存。</p>
<p>在下一次请求时，如果缓存不不过期，则命中强缓存，返回<code>200 OK (from memory/disk cache)</code>。</p>
<p><strong>协商缓存：</strong></p>
<p>针对浏览器的请求，服务器在响应头中设置了<code>Cache-control:no-cache</code>的响应会被浏览器保存为协商缓存。</p>
<p>或者是当一条强缓存过期时，也可以认为该缓存成为协商缓存。</p>
<p>在下一次请求时，如果浏览器保存的是请求的协商缓存，浏览器会发送缓存校验请求（带有<code>If-modified-Since/If-None-Match</code>的条件请求），如果服务器认为客户端缓存仍然可用，则返回<code>304 Not Modified</code>，如果服务端更新了内容，则返回<code>200 ok</code>的完整响应并指示浏览器更新客户端缓存信息。</p>
<blockquote>
<p>针对协商缓存的两种情况进行讨论：</p>
<ol>
<li><code>Cache-control:no-cache</code>型的协商缓存：Chrome相应发出<code>Cache-Control:no-cache</code>的请求头。</li>
<li><code>过期的强缓存</code>：Chrome发出<code>Cache-control:max-age=0</code>的请求头。</li>
</ol>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/05/20/Git/Git%E7%AC%94%E8%AE%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Git笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/09/JavaScript/webapis/">
                        <span class="hidden-mobile">WebAPIs</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
