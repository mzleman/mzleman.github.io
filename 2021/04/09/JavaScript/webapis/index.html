

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>WebAPIs - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="WebAPIs">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-09 23:01" pubdate>
        2021年4月9日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">WebAPIs</h1>
            
            <div class="markdown-body">
              <h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><ul>
<li>API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结其内在实现。</li>
<li>Web API主要是浏览器提供接口，允许我们操作BOM和DOM元素。</li>
<li>API一般都是函数或方法，有输入和输出，Web API也不例外。</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>文档对象模型（Document Object Model），是W3C阻止推荐的处理可扩展标记语言（HTML或XML）的标准编程接口。</p>
<p>W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。</p>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p><img src="/2021/04/09/JavaScript/webapis/image-20210109150913764.png" srcset="/img/loading.gif" alt="image-20210109150913764"></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol>
<li>节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM使用node表示节点，节点也就是一个个节点对象。</li>
<li>元素：HTML标签就是元素，DOM中使用element表示。</li>
<li>文档：一个页面就是一个文档，DOM中用document表示</li>
</ol>
<h4 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h4><ul>
<li>文档节点，特指 <code>document</code></li>
<li>元素节点，即标签, html节点是<code>document.documentElement</code></li>
<li>属性节点 , 可以通过element.getAttributeNode(attrName) 获得</li>
<li>文本节点</li>
</ul>
<h4 id="节点的共有属性"><a href="#节点的共有属性" class="headerlink" title="节点的共有属性"></a>节点的共有属性</h4><table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名大写 ⭐❗</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名小写  ❗</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3 ⭐</td>
<td>文本内容 ⭐</td>
</tr>
</tbody></table>
<hr>
<h3 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h3><h4 id="兼容-IE8："><a href="#兼容-IE8：" class="headerlink" title="兼容 IE8："></a>兼容 IE8：</h4><ul>
<li><p><code>document.getElementById(id)</code></p>
</li>
<li><p><code>element.getElementsByTagName(tageName)</code></p>
</li>
<li><p><code>document.getElementsByName(name)</code></p>
</li>
</ul>
<h4 id="HTML5新增-IE9-："><a href="#HTML5新增-IE9-：" class="headerlink" title="HTML5新增 IE9+："></a>HTML5新增 IE9+：</h4><ul>
<li><code>element.getElementsByClassName(className)</code></li>
<li><code>element.querySelector(selector)</code></li>
<li><code>element.querySelectorAll(selector)</code></li>
</ul>
<h4 id="特殊元素的获取"><a href="#特殊元素的获取" class="headerlink" title="特殊元素的获取"></a>特殊元素的获取</h4><ul>
<li>html元素：<code>document.documentElement</code></li>
<li>body元素：<code>document.body</code></li>
<li>head元素：<code>document.head</code></li>
</ul>
<h4 id="查询方法分类"><a href="#查询方法分类" class="headerlink" title="查询方法分类"></a>查询方法分类</h4><ol>
<li><p>document的方法：</p>
<ul>
<li>getElementById</li>
<li>getElementsByName</li>
</ul>
</li>
<li><p>可以变化范围的属于一般element的方法：</p>
<ul>
<li>getElementsByTagName</li>
<li>getElementsByClassName</li>
<li>querySelector</li>
<li>querySelectorAll</li>
</ul>
</li>
<li><p>返回查询到的第一个元素的：</p>
<ul>
<li>getElementById</li>
<li>querySelector</li>
</ul>
</li>
<li><p>返回一个NodeList的：</p>
<ul>
<li>getElementsByName</li>
<li>getElementsByTagName</li>
<li>getElementsByClassName</li>
<li>querySelectorAll</li>
</ul>
<blockquote>
<p>NodeList是一个伪数组，在遍历功能上只实现了ForEach方法。</p>
</blockquote>
</li>
</ol>
<p>⭐ <strong>总结：</strong></p>
<ul>
<li><p><font color='red'>一共有6种DOM查询方法</font>。</p>
</li>
<li><p><font color='red'>两种方法只属于document</font>，分别为<code>document.getElementById</code>和<code>document.getElementsByName</code>；</p>
<p><font color='red'>其他四种方法都属于一般DOM元素</font>，且<font color='red'>搜寻范围为后代元素</font>。</p>
</li>
<li><p><font color='red'>两种方法只返回第一个查询到的DOM元素</font>，分别为<code>document.getElementById</code>和<code>node.querySelector</code>；</p>
<p><font color='red'>其他四种方法都返回一个NodeList。</font></p>
</li>
</ul>
<hr>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><h4 id="1-子节点"><a href="#1-子节点" class="headerlink" title="1. 子节点"></a>1. 子节点</h4><ul>
<li><p><code>childNodes</code>属性</p>
<p>属性值为当前节点的所有子节点所组成的伪数组<code>NodeList</code>，包含文本子节点。</p>
</li>
<li><p><code>firstChild</code>属性</p>
<p>属性值为第一个子节点，如果不存在子节点，则值为<code>null</code></p>
</li>
<li><p><code>lastChild</code>属性</p>
<p>属性值为最后一个子节点，如果不存在子节点，则值为<code>null</code></p>
</li>
</ul>
<ul>
<li><p><code>children</code>属性</p>
<p>属性值为当前节点的所有<code>子元素节点</code>所组成的伪数组<code>NodeList</code>，不包含文本字节点。</p>
<blockquote>
<p>children属性是非标准属性，但兼容所有浏览器，放心使用。</p>
</blockquote>
</li>
<li><p><code>firstElementChild</code>属性 </p>
<p>IE9+支持，属性值为第一个<code>子元素节点</code>，如果不存在子元素节点，则值为<code>null</code></p>
<blockquote>
<p>实际开发中尽量使用node.children[0]代替firstElementChild</p>
</blockquote>
</li>
<li><p><code>lastElementChild</code>属性</p>
<p>IE9+支持，属性值为最后一个<code>子元素节点</code>，如果不存在子元素节点 ，则值为<code>null</code></p>
<blockquote>
<p>实际开发中尽量使用node.children[node.children.length-1]代替lastElementChild</p>
</blockquote>
</li>
</ul>
<h4 id="2-父节点"><a href="#2-父节点" class="headerlink" title="2. 父节点"></a>2. 父节点</h4><ul>
<li><p><code>parentNode</code>属性</p>
<p>返回当前节点的父节点。</p>
<blockquote>
<p>html的父节点是document，document的父节点是null。</p>
</blockquote>
</li>
</ul>
<h4 id="3-兄弟节点"><a href="#3-兄弟节点" class="headerlink" title="3. 兄弟节点"></a>3. 兄弟节点</h4><ul>
<li><p><code>previousSibling</code>属性</p>
<p>属性值为当前节点的前一个兄弟节点 （可能为文本节点），若不存在则值为<code>null</code></p>
</li>
<li><p><code>nextSibling</code>属性</p>
<p>属性值为当前节点的后一个兄弟节点（可能为文本节点），若不存在则值为<code>null</code></p>
</li>
</ul>
<ul>
<li><p><code>previousElementSibling</code>属性</p>
<p>IE9+支持，属性值为当前节点的前一个兄弟<code>元素节点 </code>，若不存在则值为<code>null</code></p>
</li>
<li><p><code>nextElementSibling</code>属性</p>
<p>IE9+支持，属性值为当前节点的后一个兄弟<code>元素节点</code>，若不存在则值为<code>null</code></p>
</li>
</ul>
<hr>
<h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><h4 id="读写文本或HTML片段"><a href="#读写文本或HTML片段" class="headerlink" title="读写文本或HTML片段"></a>读写文本或HTML片段</h4><p>通过以下DOM元素的属性，可以操作元素的内容：</p>
<ol>
<li><code>innerText</code></li>
<li><code>innerHTML</code></li>
<li><code>textContent</code></li>
</ol>
<p>区别：</p>
<ul>
<li><strong>innerText</strong>：返回由css决定的<font color='red'>可显示的后代节点中所有的文本内容，display: none的元素的文本子节点会被忽略。</font>文本节点text两端的空白字符会被忽略（导致全是空白字符的文本节点会被忽略），文本节点text内的换行符当作一个空格来处理，块元素的文本与其他文本节点内容之间用”\n”连接，内联元素的文本与文本节点的文本之间用””连接。❓ 由于受css影响，会触发回流 ❓。</li>
<li><strong>textContent</strong>：不受css影响，<font color='red'>display: none的元素不会被忽略</font>，返回所有子结点中所有的文本内容，保留所有空白字符。文本内容间用””连接。</li>
<li><strong>innerHTML</strong>：返回元素的HTML代码，保留所有空白字符。</li>
</ul>
<blockquote>
<p>以上属性都可以读写。</p>
</blockquote>
<hr>
<h4 id="DOM-增删改"><a href="#DOM-增删改" class="headerlink" title="DOM 增删改"></a>DOM 增删改</h4><p><strong>1. 创建文本节点</strong></p>
<p><code>document.createTextNode(text)</code></p>
<p>返回nodeValue为text的文本节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> tNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br><span class="hljs-built_in">document</span>.body.appendChild(tNode)<br></code></pre></td></tr></table></figure>


<p><strong>2. 创建元素节点</strong></p>
<ul>
<li><p>使用<code>document.createElement(tagName)</code></p>
<p>返回标签名为tagName的空元素节点</p>
</li>
<li><p>使用<code>node.innerHTML</code>创建子树</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">box.innerHTML = <span class="hljs-string">`&lt;div&gt;</span><br><span class="hljs-string">	&lt;ul&gt;</span><br><span class="hljs-string">		&lt;li&gt;&lt;/li&gt;</span><br><span class="hljs-string">	&lt;/ul&gt;</span><br><span class="hljs-string">&lt;/div&gt;`</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>document.write(htmlText)</code></p>
<p>在body元素中写入新的HTML片段，但如果实在文档流已经解析完的情况下调用该方法，会触发文档的重绘。</p>
</li>
</ul>
<blockquote>
<p>在为元素新增子节点或子树的操作中，相比于createElement创建元素再插入的做法，将html片段字符串赋值给父元素的innerHTML属性的做法效率更高。</p>
</blockquote>
<p><strong>3. 向父节点添加一个子节点（尾插）</strong></p>
<p><code>parentNode.appendChild(childNode)</code></p>
<p><strong>4. 在指定子节点前插入一个子节点</strong></p>
<p><code>parentNode.insertBefore(newChild, targetChild)</code></p>
<p><strong>5. 替换一个子节点</strong></p>
<p><code>parentNode.replaceChild(newChild, oldChild)</code></p>
<blockquote>
<p>如果oldChild不是parentNode的子节点，则会抛出异常。</p>
</blockquote>
<p><strong>6. 删除一个子节点</strong></p>
<p><code>parentNode.removeChild(childNode)</code></p>
<blockquote>
<p>如果childNode不是parentNode的子节点，则抛出异常。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">node.parent.removeChild(node); <span class="hljs-comment">// 自杀行为</span><br></code></pre></td></tr></table></figure>


<p><strong>7. 节点克隆</strong></p>
<p><code>node.cloneNode(deep = false)</code></p>
<p>该方法属于DOMNode，返回调用该方法的节点的一个副本。</p>
<p>deep参数可选，是否采用深度克隆。</p>
<ul>
<li>默认值为<code>false</code>，只克隆该节点本身（<font color='red'>如果为元素节点，则也会复制元素属性</font>）。</li>
<li>如果为<code>true,</code>则该节点的所有<font color='red'>后代元素节点</font>也都会被克隆，即会返回一棵节点树。</li>
</ul>
<blockquote>
<p><strong>关于deep参数默认值的问题：</strong></p>
<p>在 DOM4 规范中(实现于Gecko 13.0(Firefox 13.0 / Thunderbird 13.0 / SeaMonkey 2.10))，<code>deep</code>是一个可选参数。如果省略的话，参数的默认值为 <code>true，</code>也就是说默认是深度克隆。如果想使用浅克隆, 你需要将该参数设置为 <code>false。</code></p>
<p>在最新的规范里，该方法的行为已经改变了，其默认值变成了 false。虽然该参数仍旧是可选的，但是你必须要为该方法设置 deep 参数，无论是为了向前还是向后兼容考虑。假如开发者没设置参数的话，Gecko 28.0 (Firefox 28 / Thunderbird 28 / SeaMonkey 2.25 / Firefox OS 1.3)) 版本的控制台会发出警告。从 Gecko 29.0 (Firefox 29 / Thunderbird 29 / SeaMonkey 2.26)) 开始该方法默认为浅复制而不是深度复制。</p>
<p><font color='red'>所以在使用cloneNode方法时，最好明确deep参数的值，以防兼容性问题。</font></p>
</blockquote>
<blockquote>
<p><strong>关于克隆模板节点的Id和Name属性唯一性的问题：</strong></p>
<p>如果原始节点设置了ID，并且克隆节点会被插入到相同的文档中，那么应该更新克隆节点的ID以保证唯一性。name属性可能也需要进行修改，取决于你是否希望有相同名称的节点存在于文档中。</p>
<p><font color='red'>对存在Id或Name属性的节点进行克隆后，在将克隆节点插入到文档之前，应更新Id和Name属性。</font></p>
</blockquote>
<hr>
<h4 id="读写内置属性与自定义属性"><a href="#读写内置属性与自定义属性" class="headerlink" title="读写内置属性与自定义属性"></a>读写内置属性与自定义属性</h4><p><strong>1.内置属性的读写</strong></p>
<p>内置属性是HTML各类的标签所拥有的原生属性，包括普通的id、class、title以及img的src等。</p>
<p>内置属性可以直接通过 <code>element.xxx </code>读写。</p>
<p>内置属性也可以通过<code>element.getAttribute</code>读取，通过<code>element.setAttribute</code>修改。</p>
<blockquote>
<p>❗ 需要注意的是获取class属性值时，需要使用element.className，而不是class</p>
</blockquote>
<p><strong>2.自定义属性的读写</strong></p>
<p>自定义属性是指内置属性以外的标签属性，开发人员可以自定义属性上保存数据。</p>
<p>自定义属性可以通过element.getAttribute读取，element.setAttribute修改。</p>
<blockquote>
<p>使用element.getAttribute(attrName)，若属性不存在则返回null</p>
</blockquote>
<p>⭐ H5标准 ⭐</p>
<p>H5规范中要求自定义属性必须以<code>data-</code>开头。</p>
<p>以<code>data-</code>开头的自定义属性，除了可以用上述的<code>getAttribute</code>和<code>setAttribute</code>读写外，还可以在<code>element.dataset</code>中访问。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">data-my-prop</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 自定义属性 data-my-prop --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.getAttribute(<span class="hljs-string">&#x27;data-my-prop&#x27;</span>)); </span><br><span class="javascript">    <span class="hljs-comment">// 输出 123</span></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(box.dataset.myProp); <span class="hljs-comment">// 👈 驼峰命名法，不带 &#x27;data&#x27;</span></span><br><span class="javascript">    <span class="hljs-comment">// 输入 123</span></span><br><span class="javascript">    box.dataset.myProp = <span class="hljs-string">&#x27;321&#x27;</span>;</span><br><span class="javascript">    <span class="hljs-comment">// 等价于data.dataset[&#x27;myProp&#x27;] = &#x27;321&#x27;;</span></span><br><span class="javascript">    <span class="hljs-comment">// 等价于 box.setAttribute(&#x27;data-my-prop&#x27;, &#x27;321&#x27;);</span></span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗ 兼容性问题：通过<code>element.dataset</code>访问自定义属性，只有<code>IE11+</code>兼容。</p>
</blockquote>
<p><strong>3. 删除属性</strong></p>
<p><code>element.removeAttribute(attrName)</code></p>
<p>如果指定的属性不存在也不会生成错误。</p>
<blockquote>
<p>若要彻底移除一个属性的效果，应当使用  <code>removeAttribute()</code>，而不是使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/setAttribute"><code>setAttribute()</code></a> 将属性值设置为 <code>null</code>。</p>
</blockquote>
<hr>
<h4 id="类名的增删查"><a href="#类名的增删查" class="headerlink" title="类名的增删查"></a>类名的增删查</h4><p><strong>1.读取class属性</strong></p>
<ul>
<li><p>element.className 属性，返回标签中class属性值，字符串类型。</p>
</li>
<li><p>element.classList 属性，返回标签中class属性值，伪数组类型<code>DOMTokenList</code>。</p>
</li>
<li><p>element.classList.value，返回标签中的class属性，字符串类型。</p>
</li>
<li><p>element.getAttribute(‘class’)，返回标签中class属性值，字符串类型。</p>
</li>
</ul>
<p><strong>2.增删类名</strong></p>
<ul>
<li><p>直接修改标签的class属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">element.className = <span class="hljs-string">&#x27;...&#x27;</span>;<br>element.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;...&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p><strong>封装操作className字符串的方法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用正则表达式 ⭐</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">elHasClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-built_in">String</span>.raw <span class="hljs-string">`\b<span class="hljs-subst">$&#123;cn&#125;</span>\b`</span>);<br>    <span class="hljs-keyword">return</span> reg.test(el.className);<br>&#125;<br><span class="hljs-comment">// 增加一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(!elHasClassName(el, cn)) &#123;<br>        el.className = el.className + <span class="hljs-string">&#x27; &#x27;</span> + cn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 清除一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    el.className = el.className.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\b$(cn)\\b`</span>), <span class="hljs-string">&#x27;&#x27;</span>); <br>&#125;<br><span class="hljs-comment">// 切换一个类名</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleClassName</span>(<span class="hljs-params">el, cn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(elHasClassName(el, cn)) &#123;<br>        removeClassName(el, cn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        addClassName(el, cn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>通过element.classList的各种方法增删类名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1. contains()方法，判断一个元素是否具有某一个类名</span><br>element.classList.contains(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 2. add()方法，增加一个或多个类名  兼容性:IE10+</span><br>element.classList.add(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2...&#x27;</span>);<br><br><span class="hljs-comment">// 3. remove()方法，删除1个或多个类名 兼容性 IE10+</span><br>element.classList.remove(<span class="hljs-string">&#x27;className1&#x27;</span>, <span class="hljs-string">&#x27;className2&#x27;</span>);<br><br><span class="hljs-comment">// 4. toggle()方法，切换一个类名的存在状态 兼容性:IE10+</span><br>element.classList.toggle(<span class="hljs-string">&#x27;className&#x27;</span>);<br><br><span class="hljs-comment">// 5. replace()方法，将一个类名替换为新类名 ❗ 兼容性不好，尽量不要使用。其实也不好用。</span><br>element.classList.replace(<span class="hljs-string">&#x27;oldClassName&#x27;</span>, <span class="hljs-string">&#x27;newClassName&#x27;</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>element.classList的类型<code>DOMTokenList</code>严格意义上是一个只读属性，但能通过该类型的方法（如add、remove）来改变自身的元素。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/web/api/element/classlist">参考连接</a></p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="读写样式"><a href="#读写样式" class="headerlink" title="读写样式"></a>读写样式</h4><p><strong>1. 读写内联样式</strong></p>
<ul>
<li>通过<code>element.style </code>读取css字符串，或 <code>element.style.样式名 </code>读取样式值。</li>
<li>通过 <code>element.style.样式名 = 样式值 </code>修改内联样式</li>
</ul>
<blockquote>
<p>通过JS访问元素的style属性只能够读写内联样式，不能读取到css样式表中的样式。</p>
</blockquote>
<p><strong>2.读取元素当前显示的样式</strong></p>
<ul>
<li><p><code>element.currentStyle.样式名</code></p>
<p>兼容性：<strong>只有IE支持</strong>。</p>
<p>可访问性：只读。</p>
<p>若元素未设置该样式，则返回该样式的默认值</p>
</li>
<li><p><code>window.getComputedStyle(element, null)</code></p>
<p>兼容性：只有IE9+支持。</p>
<p>可访问性：只读。</p>
<p>参数：getComputedstyle是window的方法，传入两个参数，第一个参数是所求元素，第二个参数传入一个伪元素（一般设置为null）。</p>
<p>返回值：返回一个对象，该对象封装了当前元素的样式。</p>
</li>
<li><p><code>兼容方案</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">el, prop</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle) &#123;<br>        <span class="hljs-keyword">return</span> getComputedStyle(el, <span class="hljs-literal">null</span>)[prop];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> el.currentStyle[prop];<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h3 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h3><p>事件三要素：</p>
<ol>
<li>事件源，谁发生了事件。（可以在响应函数中用event.target获取到）</li>
<li>事件类型，发生了什么事件。</li>
<li>事件处理程序，就是事件响应函数。</li>
</ol>
<h4 id="注册和移除事件的响应函数"><a href="#注册和移除事件的响应函数" class="headerlink" title="注册和移除事件的响应函数"></a>注册和移除事件的响应函数</h4><p><strong>1. 传统方式</strong></p>
<p><code>element.onclick = fn</code></p>
<p><code>element.onblur = fn</code></p>
<p><code>....</code></p>
<ul>
<li><p>这种方式具有唯一性，即同一元素只能对一个事件注册一个响应函数，后面注册的会覆盖前面的。</p>
</li>
<li><p>不存在兼容性问题。</p>
</li>
</ul>
<p><strong>移除响应函数：</strong><code>element.onclick = null</code></p>
<p><strong>2. W3C推荐的方式：监听事件</strong></p>
<p><code>element.addEventListener(事件名， listener, options/useCapture)</code></p>
<ul>
<li><p>事件名不带”on”。</p>
</li>
<li><p>可以为同一事件绑定多个响应函数，先注册的先执行。</p>
</li>
<li><p>允许输入<code>第三个参数</code>，如果第三个参数为<code>true</code>，则响应函数会在<code>捕获阶段执行</code>。</p>
</li>
<li><p>如果<code>第三个参数为Object类型</code>，则认为是一个<code>options对象</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    capture: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在捕获阶段执行listener</span><br>    once: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否在listener执行一次后移除该listener，即只执行一次</span><br>    passive: &lt;<span class="hljs-built_in">Boolean</span>&gt; <span class="hljs-comment">// 是否不允许listener中执行preventDefault()</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>移除响应函数：</strong><code>element.removeEventListener(事件名, fn)</code></p>
<p><strong>3. IE6~8的方式</strong></p>
<p><code>element.attachEvent(on事件名，fn)</code></p>
<ul>
<li>事件名带”on”。</li>
<li>可以为同一事件绑定多个响应函数，<code>先注册的后执行</code>。</li>
<li>这种方式绑定的响应函数只会在冒泡阶段执行。</li>
</ul>
<p><strong>移除响应函数：</strong> <code>element.detachEvent(on事件名，fn)</code></p>
<p><strong>4. 兼容性解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注册事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.addEventListener) &#123;<br>        el.addEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.attachEvent) &#123;<br>        el.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = fn;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 移除事件响应函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeEventListener</span>(<span class="hljs-params">el, evt, fn</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(el.removeEventListener) &#123;<br>        el.removeEventListener(evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(el.detachEvent) &#123;<br>        el.detachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + evt, fn);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el[<span class="hljs-string">&#x27;on&#x27;</span> + evt] = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<hr>
<h4 id="事件流（事件的传播）"><a href="#事件流（事件的传播）" class="headerlink" title="事件流（事件的传播）"></a>事件流（事件的传播）</h4><p><strong>概念</strong></p>
<p>事件流描述的是从页面中接收事件的顺序。</p>
<p>事件发生时会在元素节点之间按照<code>从外至内、从内向外</code>的顺序传播，这个<code>传播过程</code>叫做DOM事件流。</p>
<p>比如我们给一个div注册了单击事件的响应函数：</p>
<p><img src="/2021/04/09/JavaScript/webapis/image-20210115202428033.png" srcset="/img/loading.gif" alt="image-20210115202428033"> </p>
<p><strong>事件传播的三个阶段</strong></p>
<p>W3C综合了网景和微软的方案，将DOM事件流分为三个阶段：</p>
<ol>
<li>捕获阶段：从最外层的祖先元素向目标元素进行捕获，但默认此时不会触发事件的响应函数。（网景提出）</li>
<li>目标阶段：捕获到目标元素，按顺序执行响应函数。</li>
<li>冒泡阶段：向祖先元素传递，依次触发祖先元素上的事件响应函数。（微软提出）</li>
</ol>
<blockquote>
<ul>
<li>如果希望在捕获阶段执行响应函数，则需要将addEventListener方法的第三个参数设置为true，则该次注册的响应函数会在捕获阶段执行。</li>
<li>IE8及以下没有捕获阶段，使用<code>传统方法</code>和<code>attachEvent</code>方法注册的函数永远<code>不会在捕获阶段执行</code>。</li>
</ul>
</blockquote>
<p>❗ <strong>误区</strong> ❗：<code>在目标阶段</code>，即使是设置为捕获阶段执行的响应函数，不一定会在冒泡型响应函数之前执行。</p>
<p>举例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble body&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 body 绑定捕获阶段的响应函数</span></span><br><span class="javascript">		<span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture body&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">//true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble box&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#box 绑定捕获阶段的响应函数</span></span><br><span class="javascript">        box.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture box&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定冒泡阶段的响应函数</span></span><br><span class="javascript">        content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bubble content&#x27;</span>));</span><br><span class="javascript">        <span class="hljs-comment">// 为 div#content 绑定捕获阶段的响应函数</span></span><br><span class="javascript">       	content.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;capture content&#x27;</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// true</span></span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 👇 结果输出 👇 --&gt;</span><br>capture body<br>capture box<br>bubble content   <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 原因是在事件传播到了content时已经处于目标阶段<br>capture content  <span class="hljs-comment">&lt;!-- 👈 关键 --&gt;</span> 目标阶段会按照函数注册的顺序执行，而不会考虑该函数是在哪个阶段执行<br>bubble box<br>bubble body<br><span class="hljs-comment">&lt;!------------------&gt;</span><br><br></code></pre></td></tr></table></figure>




<hr>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p><strong>概念</strong></p>
<p>当DOM事件发生时，浏览器都会按照事件流将一个事件对象传递给各元素的响应函数。</p>
<p>在事件对象中封装了当前事件相关的一切信息，比如事件源、事件类型、鼠标的坐标、键盘的键位等。</p>
<blockquote>
<p>在捕获阶段，响应函数中的target属性已经存在，且指向事件源。</p>
</blockquote>
<p><strong>兼容性</strong></p>
<p>IE6~8浏览器将事件对象保存在了window.event属性中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>&#123;<br>    evt = evt || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-built_in">console</span>.log(evt);<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>事件对象的常见属性和方法</strong></p>
<table>
<thead>
<tr>
<th>事件对的属性和方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的源对象    ✔ 标准  ⭐</td>
</tr>
<tr>
<td>window.event.srcElement</td>
<td>返回触发事件的源对象    ❌ 非标准，IE6~8使用</td>
</tr>
<tr>
<td>e.type</td>
<td>返回时间的类型 比如 click mouseover 不带”on” ⭐</td>
</tr>
<tr>
<td>window.event.cancelBubble</td>
<td>布尔值，该属性值设为false则阻止冒泡 ❌ 非标准 ，IE6~8使用</td>
</tr>
<tr>
<td>window.event.returnValue</td>
<td>布尔值，该属性值设为false则阻止事件的默认行为 ❌非标准 IE6~8使用， Chrome、火狐兼容，IE9+反而不兼容。                                                                                    反正就不要用这个属性了, 用return false就可以。</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>该方法阻止事件的默认行为         ✔ 标准   ⭐</td>
</tr>
<tr>
<td>e.preventPropagation()</td>
<td>该方法阻止事件的传播，包括捕获和冒泡。 ✔ 标准 ⭐</td>
</tr>
</tbody></table>
<blockquote>
<p>在事件的响应函数中，要区分this 和 e.target，this不一定是事件源。</p>
</blockquote>
<hr>
<h4 id="阻止事件的默认行为"><a href="#阻止事件的默认行为" class="headerlink" title="阻止事件的默认行为"></a>阻止事件的默认行为</h4><ol>
<li><code>preventDefault()</code></li>
<li><code>return false</code></li>
<li><code>event.returnValue = false</code> ❌ 兼容性很奇葩，不推荐使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;a&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-comment">// 第一种方式</span><br>    <span class="hljs-keyword">if</span>(e.preventDefault) e.preventDefault();  <span class="hljs-comment">// IE9+支持</span><br>    <br>    <span class="hljs-comment">// .....</span><br>    <span class="hljs-comment">// 因为IE6~8 不认识 preventDefault方法</span><br><br>    <span class="hljs-comment">// 第二种方式</span><br>    e.returnValue = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ❌ IE9~11不支持，IE6~8支持，其他浏览器支持。</span><br>    <br>    <span class="hljs-comment">// 第三种方式，兼容所有浏览器的方法 👇</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 兼容性做法 </span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>


<hr>
<h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><ol>
<li><code>event.preventPropagation()</code>  👈 IE9+ 不只是阻止冒泡，也会中断事件的捕获。</li>
<li><code>window.event.cancelBubble = true</code> 👈 IE6~8</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    e = e || <span class="hljs-built_in">window</span>.event;<br>    <span class="hljs-keyword">if</span>(e.preventPropagation) &#123;<br>        e.preventPropagation();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        e.cancelBubble = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h4 id="冒泡的应用：事件委托"><a href="#冒泡的应用：事件委托" class="headerlink" title="冒泡的应用：事件委托"></a>冒泡的应用：事件委托</h4><p>事件委托也称为事件代理，在jQuery中也叫做事件委派。</p>
<p><strong>原理：</strong></p>
<p>不是在每个子节点上单独设置事件监听器，而是在父节点上设置事件监听器，然后利用冒泡原理监听所有子节点的某个事件。</p>
<hr>
<h4 id="常用的鼠标事件"><a href="#常用的鼠标事件" class="headerlink" title="常用的鼠标事件"></a>常用的鼠标事件</h4><table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标左键单击一次触发</td>
</tr>
<tr>
<td>ondbclick</td>
<td>鼠标左键双击一次触发</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标进入元素范围触发，<code>会进行冒泡</code>。</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标离开元素范围触发，<code>会进行冒泡</code>。</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得鼠标焦点</td>
</tr>
<tr>
<td>onblur</td>
<td>失去鼠标焦点</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标在元素范围内移动“1px”触发。</td>
</tr>
<tr>
<td>onmousedown</td>
<td>鼠标按下一次触发。滚轮、右键、上下翻页键也会触发。</td>
</tr>
<tr>
<td>onmouseup</td>
<td>鼠标松开一次触发。滚轮、右键、上下翻页键也会触发。</td>
</tr>
<tr>
<td>onmouseenter</td>
<td>鼠标进入元素范围触发，<code>不会冒泡</code>。⭐</td>
</tr>
<tr>
<td>onmouseleave</td>
<td>鼠标离开元素范围触发，<code>不会冒泡</code>。⭐</td>
</tr>
</tbody></table>
<ul>
<li><p>onmousedown事件，单次点击只会触发一次，直到松开鼠标键后才会触发下一次。</p>
</li>
<li><p>onmouseenter/ onmouseleave 和 onmouseover/ onmouseout 之间的区别是 “是否会触发冒泡”。</p>
<p>前一组不会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>不会触发</code>父容器的鼠标enter/ leave。</p>
<p>后一组会触发冒泡，所以当鼠标在<code>父容器</code>的<code>后代元素</code>中进出时，<code>会多次触发</code>父容器的鼠标over/ out。</p>
<blockquote>
<p><strong>mouseover和mouseenter的另外一个区别</strong></p>
<p>鼠标从父容器独有的范围内进入后代元素的范围，会先触发父容器的mouseout，再触发后代元素的mouseover，然后再冒泡父容器的mouseover。</p>
<p>鼠标从后代元素范围中挪出，进入父容器独有的范围会先冒泡onmouseout， 然后再次触发父容器的onmouseover。</p>
</blockquote>
</li>
</ul>
<p><strong>鼠标事件对象的属性</strong></p>
<ul>
<li><p><code>type</code>属性标识了鼠标事件的类型，如click, mousedown, mouseenter等。</p>
</li>
<li><p><code>which</code>属性标识了鼠标按键。</p>
<p>1：没有按键或左键</p>
<p>2：滚轮按下</p>
<p>3：右键</p>
</li>
<li><p><code>clientX</code> / <code>clientY</code> 属性，是鼠标事件发生的位置相对于浏览器视口左上角的偏移量。</p>
</li>
<li><p><code>pageX</code> / <code>pageY</code> 属性，是鼠标事件发生的位置相对于页面（布局视口）左上角的偏移量。不论页面怎么滚动，鼠标点击页面中同一位置时，event.pageX 和 event.pageY的值不会发生改变。</p>
<blockquote>
<p>pageX / pageY属性仅在 IE9+中支持。</p>
</blockquote>
</li>
<li><p><code>screenX</code> / <code>screenY</code> 属性，是鼠标事件发生的位置相对于设备屏幕左上角的偏移量。</p>
</li>
</ul>
<hr>
<h4 id="常用的键盘事件"><a href="#常用的键盘事件" class="headerlink" title="常用的键盘事件"></a>常用的键盘事件</h4><table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onkeyup</td>
<td>某个键盘按键松开时会<code>触发一次</code>。⭐ 尽可能用onkeyup，因为不会不断触发。</td>
</tr>
<tr>
<td>onkeydown</td>
<td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td>
</tr>
<tr>
<td>onkeypress</td>
<td>某个键盘按键处于按下状态时会<code>不断触发</code>。❗</td>
</tr>
</tbody></table>
<p>onkeydown和onkeypress的区别在于：</p>
<ol>
<li><p>onkeypress不会识别功能键。即Backspace、ctrl、alt、shift、箭头方向键按下时，不会触发onkeypress事件。</p>
<p>而onkeydown能够识别功能键。</p>
</li>
<li><p>onkeydown不区分按键的大小写，即按下a和大写A时都认为按下了”a”，keyCode都是97。</p>
</li>
<li><p>在函数执行顺序上，onkeydown事件绑定的响应函数会先于onkeypress事件绑定的响应函数。</p>
</li>
</ol>
<blockquote>
<p>在input标签中onkeydown/ onkeypress事件的回调函数会先于input标签更新value执行。</p>
<p>所以要获取键盘输入后的input的value值，应该在onkeyup的响应函数中才能获取。</p>
</blockquote>
<p><strong>键盘事件对象的属性</strong></p>
<ul>
<li><p><code>keyCode</code>属性</p>
<p>键盘键位的asc码值</p>
</li>
</ul>
<ul>
<li><p><code>key</code>属性，IE9+支持</p>
<p>键盘键位的特征字符串</p>
<ol>
<li>回车 Enter</li>
<li>退格 Backspace</li>
<li>大写键 CapsLock</li>
<li>大写键盘开启按a A</li>
<li>….</li>
</ol>
</li>
</ul>
<hr>
<h4 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h4><p><strong>1. 阻止鼠标右键菜单的显示</strong></p>
<p><code>contextmenu</code>事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault()); <span class="hljs-comment">// 这里好像不能用return false</span><br><span class="hljs-comment">// html.addEventListener(&#x27;contextmenu&#x27;, e =&gt; e.preventDefault()); 对html绑定也可以</span><br><span class="hljs-comment">// 对其他指定DOM元素绑定也可以，实现阻止局部范围内右键菜单的显示。</span><br></code></pre></td></tr></table></figure>


<p><strong>2. 不允许选中内容</strong></p>
<p><code>selectstart</code>事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;selectstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e.preventDefault());<br></code></pre></td></tr></table></figure>




<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model，浏览器对象模型，它提供独立于内容而与浏览器窗口进行交互的对象，其<code>核心+顶级</code>的对象是window。</p>
<p>简而言之，BOM为我们提供了一组对象，用来完成对浏览器的操作。</p>
<blockquote>
<p>BOM缺乏标准， JavaScript语法的标准化组织是ECMA，DOM的标准化阻止是W3C，而BOM最初是Netscape浏览器标准的一部分。</p>
</blockquote>
<h3 id="BOM的构成"><a href="#BOM的构成" class="headerlink" title="BOM的构成"></a>BOM的构成</h3><p>BOM比DOM更大，它包含了DOM。</p>
<p><img src="/2021/04/09/JavaScript/webapis/image-20210123104526159.png" srcset="/img/loading.gif" alt="image-20210123104526159"> </p>
<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p><font color="red">window对象是浏览器的顶级对象，它具有双重角色</font></p>
<ol>
<li><p>它是JS访问浏览器的一个接口</p>
</li>
<li><p>它是一个全局对象。定在<code>全局作用域中的变量和函数</code>会分别成为<code>window对象的属性和方法</code>。</p>
<p>在调用全局函数、访问全局变量时，可以省略书写window。</p>
<blockquote>
<p>注意：window下存在一个特殊属性window.name，所以不要在全局作用域中用”name”作为变量名。</p>
</blockquote>
</li>
</ol>
<hr>
<h4 id="onload事件"><a href="#onload事件" class="headerlink" title="onload事件"></a>onload事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    ...<br>&#125;;<br><br><span class="hljs-comment">// 或者使用标准方法可绑定多个页面加载完成的响应函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>    ...<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>window.onload是窗口（页面）加载事件，当文档的内容<code>完全加载完成</code>后才会触发该事件，<code>包括图像的加载、脚本文件、CSS文件等</code>。</p>
<hr>
<h4 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br><span class="hljs-comment">// 这个事件只能这样绑定响应函数</span><br></code></pre></td></tr></table></figure>
<p>DOMContentLoaded事件会在<code>DOM加载完成时</code>就触发，<code>不会等待图片、flash、样式表的加载</code>。</p>
<blockquote>
<p>❗ 兼容性：IE9+支持，且只能使用标准方法绑定响应函数。</p>
</blockquote>
<p>如果<code>页面的图片很多</code>的话，从页面打开到onload事件触发可能需要很长的事件，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适。</p>
<hr>
<h4 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-comment">// </span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);<br></code></pre></td></tr></table></figure>
<p>window.onresize是调整浏览器窗口大小的事件。</p>
<p>只要窗口的尺寸发生变化，就会触发这个事件。我们会利用这个事件完成<code>响应式布局、移动端适配</code>等，会用到相关的属性有<code>window.innerWidth</code>、<code>window.innerHeigth</code>。</p>
<blockquote>
<p>⭐区别：window.innerWidth / window.innerHeight和documentElement.clientWidth、clientHeight都是描述浏览器视口尺寸的属性，他们的区别在于前一组包含html滚动条的宽度，后一组不包含html滚动条的宽度。</p>
<p>此外，window还有<code>outerWidth</code>和<code>outerHeight</code>属性，他们表示整个浏览器窗口的尺寸，包含菜单、工具栏等。</p>
</blockquote>
<hr>
<h4 id="对话框方法"><a href="#对话框方法" class="headerlink" title="对话框方法"></a>对话框方法</h4><ol>
<li><p><code>alert(message)</code> 显示带有一段消息和一个确认按钮的对话框。</p>
<blockquote>
<p>参数message是对话框中要显示的信息。</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><code>confirm(message)</code>显示带有一段消息和确认、取消两个按钮的对话框。</p>
<blockquote>
<p><code>message参数</code>是对话框中的提示信息，confirm方法会<code>返回一个布尔值</code>，当用户点击确认会返回<code>true</code>，取消会返回<code>false</code>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;当前操作会引发危险，是否继续？&#x27;</span>);<br><span class="hljs-keyword">if</span>(ret) &#123;<br>    <span class="hljs-comment">// continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// stop</span><br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p><code>prompt(message, value)</code>显示可提示用户输入的对话框。</p>
<blockquote>
<p><code>message参数</code>是对话框中的提示信息，<code>value参数</code>是输入框中的默认值，默认为空字符串。<code>prompt方法会返回一个字符串</code>，该字符串是用户在对话框的输入框中输入的内容。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ret = <span class="hljs-built_in">window</span>.prompt(<span class="hljs-string">&#x27;请输入您想输入的内容&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(ret);<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="定时器方法"><a href="#定时器方法" class="headerlink" title="定时器方法"></a>定时器方法</h4><ol>
<li><p><code>setTimeout(cb, timeout) / clearTimeout(timer)</code></p>
</li>
<li><p><code>setInterval(cb, interval) / clearInterval(timer)</code></p>
</li>
</ol>
<hr>
<h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p>location对象是window对象的一个属性，它提供了读写浏览器窗体的URL的接口，并且封装了对URL的解析结果。</p>
<p>URL的一般语法格式为：</p>
<p><code>protocol://hostName[:port]/path/[?query]#fagnent</code></p>
<h4 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h4><ol>
<li><code>href</code> 整个URL</li>
<li><code>protocol</code> 协议名 + “:”</li>
<li><code>host</code> IP地址 / 域名 + 端口号</li>
<li><code>port</code> url显式的端口号，如果是域名，则该值为空串</li>
<li><code>hostname</code> IP地址 / 域名</li>
<li><code>pathname</code> path字符串，”/“ 开头</li>
<li><code>search</code> query字符串，”?” 开头</li>
<li><code>hash</code> fragnent字符串，”#” 开头</li>
</ol>
<h4 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h4><ol>
<li><p><code>assign(url)</code> </p>
<p>用于跳转页面，作用和直接修改<code>location</code>或<code>location.href</code>效果相同。</p>
</li>
<li><p><code>replace(url)</code></p>
<p>同样是用于跳转页面，用法和<code>assign</code>相同，但会重置栈顶并跳转，即无法回退到前一个url对应的页面。</p>
</li>
<li><p><code>reload([forcedReload])</code></p>
<p>用于刷新页面，作用相当于按下<code>F5</code>。forcedReload参数可选，表示是否强制清除缓存，如果为<code>true</code>，相当于按下<code>ctrl+F5</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.reload(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h4 id="通过location对象进行页面跳转"><a href="#通过location对象进行页面跳转" class="headerlink" title="通过location对象进行页面跳转"></a>通过location对象进行页面跳转</h4><p>实现跳转的方法有很多：</p>
<ul>
<li>```javascript<br>location = url;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.href = url<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
<li><pre><code class="javascript">location.assign(url);
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>+ ```javascript<br>  location.replace(url)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
&gt; url要求是一个字符串类型，可以是完整的url，也可以是相对路径，也可以是以&quot;/&quot;开头的根路径。
</code></pre>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">location.assign(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;image/1.png&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;../index.html&#x27;</span>);<br>location.assign(<span class="hljs-string">&#x27;/index.html&#x27;</span>);<br></code></pre></td></tr></table></figure>


<hr>
<h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>window对象的history属性让我们能够与浏览器的历史记录进行交互。</p>
<h4 id="history对象的属性"><a href="#history对象的属性" class="headerlink" title="history对象的属性"></a>history对象的属性</h4><ol>
<li><p><code>length</code></p>
<p>可以获取到当前访问过的链接数量，其实就是保存访问url顺序的栈结构的长度。</p>
</li>
</ol>
<h4 id="前后跳转页面的方法"><a href="#前后跳转页面的方法" class="headerlink" title="前后跳转页面的方法"></a>前后跳转页面的方法</h4><ol>
<li><p><code>history.go(n)</code></p>
<p>传入一个整数参数，表示跳转步长，正为前进，负为后退。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">history.go(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li>
<li><p><code>history.back()</code></p>
<p>回退到上一个页面，作用和浏览器回退按钮一样，相当于<code>history.go(-1)</code>。</p>
</li>
<li><p><code>history.forward()</code></p>
<p>跳转到下一个页面，作用和浏览器前进按钮一样，相当于<code>history.go(1)</code>。</p>
</li>
</ol>
<h4 id="H5新增方法（与前端路由相关）"><a href="#H5新增方法（与前端路由相关）" class="headerlink" title="H5新增方法（与前端路由相关）"></a>H5新增方法（与前端路由相关）</h4><p>🐕 后续补充</p>
<hr>
<h3 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h3><p>navigator对象包含有关客户端的信息，它有很多熟悉，我们最常用的是<code>navigator.userAgent</code>。</p>
<p><code>navigator.userAgent </code>是一个只读的字符串，声明了浏览器用于 <code>HTTP 请求的用户代理头</code>的值。</p>
<p><code>User-Agent</code>是HTTP请求中的用户标识，一般发送一个能够代表客户端类型的字符串，比如浏览器类型 操作系统等信息。User-Agent 的约定格式是：应用名，跟一个斜线，跟版本号，剩下的是自由的格式。</p>
<blockquote>
<p>一般都是以 Mozilla/5.0 开头</p>
</blockquote>
<p>对于前端而言：</p>
<p><code>navigator.userAgent</code>可以帮助我们识别设备、平台、浏览器，从而进行兼容处理。</p>
<blockquote>
<p>根据具体情况，到百度查找识别方法。因为navigator.userAgent属性值千奇百怪，缺乏标准。</p>
</blockquote>
<p>对于后端而言：</p>
<p><code>navigator.userAgent</code>会赋值给<code>HTTP</code>中头部信息的<code>User-Agent</code>，用于通知后端HTTP请求来源于什么设备、什么平台、什么浏览器。</p>
<hr>
<h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><p>PC端一般不用。🐕 后续补充内容</p>
<hr>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/25/CSS/scss/">
                        <span class="hidden-mobile">Scss</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
