

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Leman">
  <meta name="keywords" content="">
  <title>webpack4配置 - Personal Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"mzleman.gitee.io","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Leman 😀</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/profile/">
                <i class="iconfont icon-link-fill"></i>
                简历
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="webpack4配置">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-19 17:26" pubdate>
        2021年4月19日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      260
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">webpack4配置</h1>
            
            <div class="markdown-body">
              <h1 id="webpack的作用"><a href="#webpack的作用" class="headerlink" title="webpack的作用"></a>webpack的作用</h1><p>使用webpack构建前端项目工程其实是工程化、自动化思想在前端发开中的体现，把一系列流程用代码去自动实现。</p>
<ul>
<li>代码转换：将TypeScript编译成JS，SCSS编译成CSS等。</li>
<li>文件优化：压缩JS、CSS、HTML代码，压缩合并图片等。</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>
<li>自动刷新：主要是依赖于webpack-dev-server，监听本地源代码的变化，自动重新构建、刷新浏览器。</li>
<li>代码校验：主要是依赖于Eslint，对代码的正确性和规范性进行检查，以及单元测试是否通过。</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ul>
<h1 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h1><ol>
<li><p><strong>entry</strong>：入口，webpack执行构建的第一步将从Entry开始。</p>
</li>
<li><p><strong>output</strong>：输出结果，在webpack经过一系列处理并得出最终想要的代码后输出结果。</p>
</li>
<li><p><strong>module</strong>：模块，在webpack中一切皆模块，指的是一个模块对应着一个文件，webpack会从entry开始递归找出所有依赖的模块。</p>
</li>
<li><p><strong>chunk</strong>：代码块，一个chunk由多个模块组合而成，用于代码合并与分割。</p>
</li>
<li><p><strong>loader</strong>：模块转换器，用于把模块原内容按照要求转换成新内容。</p>
<blockquote>
<p>默认情况下，webpack只能识别<code>.json</code>和<code>.js</code>文件。</p>
</blockquote>
</li>
<li><p><strong>plugin</strong>：扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情。</p>
</li>
<li><p><strong>mode</strong>：模式，分为开发模式<code>development</code>和生产模式<code>production</code>。不同的模式下，对webpack的配置和webpack自身的处理流程有一些区别。</p>
</li>
</ol>
<h2 id="关于module、chunk、chunk组"><a href="#关于module、chunk、chunk组" class="headerlink" title="关于module、chunk、chunk组"></a>关于module、chunk、chunk组</h2><p><strong>以下内容来源于Webpack中文官方文档：</strong></p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/concepts/under-the-hood/#the-main-parts">链接</a></p>
<p>项目中使用的每个文件都是一个<strong>模块</strong>。</p>
<p><strong>./index.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./app.js&#x27;</span>;<br></code></pre></td></tr></table></figure>
<p><strong>./app.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;the app&#x27;</span>;<br></code></pre></td></tr></table></figure>


<p>通过互相引用，这些模块会形成一个图(<code>ModuleGraph</code>)数据结构。</p>
<p><strong>模块之间相互依赖，并形成一个连接的图(<code>ModuleGraph</code>)，入口模块就是拓扑的起点</strong>。 </p>
<p><strong>从入口模块开始分析依赖关系，将同步的模块合并生成chunk，将异步的模块、共同的依赖进行分离成chunk，这个过程中就产生了一到多个chunk，称为chunk组（<code>chunk group</code>）。</strong></p>
<p><strong>./webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./index.js&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这会创建出一个名为 <code>main</code> 的 chunk 组（<code>main</code> 是入口起点的默认名称）。 此 chunk 组包含 <code>./index.js</code> 模块。随着 parser 处理 <code>./index.js</code> 内部的 import 时， 新模块就会被添加到此 chunk 中。</p>
<p><strong>另外的一个示例：</strong></p>
<p><strong>./webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    home: <span class="hljs-string">&#x27;./home.js&#x27;</span>,<br>    about: <span class="hljs-string">&#x27;./about.js&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这会创建出两个名为 <code>home</code> 和 <code>about</code> 的 chunk 组。 每个 chunk 组都有一个包含一个模块的 chunk：<code>./home.js</code> 对应 <code>home</code>，<code>./about.js</code> 对应 <code>about</code>。</p>
<blockquote>
<p><em>一个 chunk 组中可能有多个 chunk。例如，</em><a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> <em>会将一个 chunk 拆分为一个或多个 chunk。</em></p>
</blockquote>
<p><font size="10">chunks</font></p>
<p><strong>chunk 有两种形式：</strong></p>
<ul>
<li><p><code>initial（初始化chunk）</code> ，也可以叫做主chunk，是由入口起点生成的主线。此 chunk 包含为入口起点指定的所有模块及其依赖项。</p>
</li>
<li><p><code>non-initial（非初始化chunk）</code> 。由 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports">动态导入(dynamic imports)</a> 语法或者 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 规则分离出的chunk。</p>
</li>
</ul>
<blockquote>
<p>一般而言，splitChunksPlugin分离出的非懒加载chunk打包出的js文件一般插入在initial-chunk打包出的js之前。</p>
</blockquote>
<p>所有的chunk会对应一个资源（<code>asset</code>），资源是由chunk打包出的结果，一般是js+css+图片等资源的组合。</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/index.jsx&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>./src/index.jsx</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./app.jsx&#x27;</span>).then(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> &#123;<br>  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>这会创建出一个名为 <code>main</code> 的 initial chunk。其中包含：</p>
<ul>
<li><code>./src/index.jsx</code></li>
<li><code>react</code></li>
<li><code>react-dom</code></li>
</ul>
<p>以及除 <code>./app.jsx</code> 外的所有依赖</p>
<p>然后会为 <code>./app.jsx</code> 创建 non-initial chunk，这是因为 <code>./app.jsx</code> 是动态导入的。</p>
<p><strong>输出的结果文件（<code>asset</code>）</strong>:</p>
<ul>
<li><code>/dist/main.js</code> - 一个 <code>initial</code> chunk</li>
<li><code>/dist/394.js</code> - <code>non-initial</code> chunk</li>
</ul>
<p>默认情况下，这些 <code>non-initial</code> chunk 没有名称，因此会使用唯一 ID 来替代名称。 在使用动态导入时，我们可以通过使用 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/api/module-methods/#magic-comments">magic comment(魔术注释)</a> 来显式指定 chunk 名称：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<br>  <span class="hljs-comment">/* webpackChunkName: &quot;app&quot; */</span><br>  <span class="hljs-string">&#x27;./app.jsx&#x27;</span><br>).then(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> &#123;<br>  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);<br>&#125;);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Webpack5中，异步导入的模块的webpackChunkName默认为由下划线和中划线连接的文件解析路径，这是与Webpack4的不同之处之一。</p>
</blockquote>
<p><strong>输出文件的名称会受配置中的两个字段的影响：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/output/#outputfilename"><code>output.filename</code></a> - 用于 <code>initial</code> chunk 文件</li>
<li><a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/output/#outputchunkfilename"><code>output.chunkFilename</code></a> - 用于 <code>non-initial</code> chunk 文件</li>
</ul>
<h1 id="模块的初级打包"><a href="#模块的初级打包" class="headerlink" title="模块的初级打包"></a>模块的初级打包</h1><h2 id="webpack的hello-world"><a href="#webpack的hello-world" class="headerlink" title="webpack的hello world"></a>webpack的hello world</h2><ol>
<li><p>创建工程目录</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir project<br></code></pre></td></tr></table></figure></li>
<li><p>创建源代码目录</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> project<br>mkdir src<br></code></pre></td></tr></table></figure></li>
<li><p>创建输出目录（可省略，换在webpack配置中声明）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir dist<br></code></pre></td></tr></table></figure></li>
<li><p>初始化npm包并安装<code>webpack</code>、<code>webpack-cli</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm init <span class="hljs-literal">-y</span><br>npm install webpack webpack<span class="hljs-literal">-cli</span> <span class="hljs-literal">-D</span><br></code></pre></td></tr></table></figure></li>
<li><p>新建<code>webpack.config.js</code>，配置入口和输出路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">// 入口为src目录下main.js</span><br>    output: &#123;<br>        filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>, <span class="hljs-comment">// 打包后的主文件名</span><br>        path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>) <span class="hljs-comment">// 输出目录，必须是绝对路径</span><br>    &#125;,<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>package.json</code>中配置npm脚本</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>    <span class="hljs-comment">//....</span><br>    <span class="hljs-comment">// 新增scripts字段</span><br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>新建<code>src/main.js</code>，执行<code>npm run build</code>打包文件。打包后在dist目录下新建<code>index.html</code>，引入<code>bundle.js</code>进行测试</p>
<p>– dist</p>
<p>—- bundle.js</p>
<p>—- index.html</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//# src/main.js</span><br><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p><img src="/2021/04/19/Webpack/webpack4/image-20210213175816749.png" srcset="/img/loading.gif"> </p>
</li>
</ol>
<h2 id="打包JS"><a href="#打包JS" class="headerlink" title="打包JS"></a>打包JS</h2><p>webpack会从入口js文件开始自动递归打包依赖，所以设置好入口后就能够打包js文件。</p>
<p>在不分割代码、没有懒加载的情况下，一个入口js文件会对应一个chunk，多个入口文件会对应多个chunk，每个chunk打包出一个bundle。</p>
<h3 id="单入口"><a href="#单入口" class="headerlink" title="单入口"></a>单入口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">/* ⭐ 这其实是语法糖写法，相当于 entry: &#123; main: &#x27;./src/main.js&#x27; &#125;*/</span><br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>) <span class="hljs-comment">// 打包的输出目录</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    <span class="hljs-comment">/* 多入口时，entry采用键值对写法, key为入口chunk的name，value为入口文件的路径/第三方包名 </span><br><span class="hljs-comment">    	单入口语法糖写法时，chunk的name默认为main */</span><br>    main: <span class="hljs-string">&#x27;main.js&#x27;</span>,<br>    index: <span class="hljs-string">&#x27;index.js&#x27;</span>,<br>    vendor: <span class="hljs-string">&#x27;jquery&#x27;</span><br>  &#125;<br>  output: &#123;<br>  	<span class="hljs-comment">// 👇 多入口时文件名应该这样写，[name]为entry中定义的key，也就是chunk的name。[hash]为可选</span><br>    filename: <span class="hljs-string">&#x27;[name].[hash].js&#x27;</span>, <span class="hljs-comment">// 比如说jquery打包后就是为vendor.[hash].js</span><br>  	path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






<h2 id="打包单页HTML"><a href="#打包单页HTML" class="headerlink" title="打包单页HTML"></a>打包单页HTML</h2><p>使用插件<code>html-webpack-plugin</code>读取模板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>            template: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> <span class="hljs-comment">// 指定以哪个html文件作为模板</span><br>        	<span class="hljs-comment">// 其他可配置项</span><br>        	<span class="hljs-comment">/*</span><br><span class="hljs-comment">        	filename: &#x27;index.html&#x27;, 👈 可以更改输出的文件路径</span><br><span class="hljs-comment">        	hash: true, 👈 为html引用的其他资源的url后加上查询hash，例如：bundle.js?29ab09214532</span><br><span class="hljs-comment">        	chunks: [&#x27;main&#x27;], 👈 指定html.body末尾插入哪些chunk的script标签，数组中元素为chunk的name</span><br><span class="hljs-comment">        	chunksSortMode: &#x27;maunal&#x27; 👈 手动设置chunk的插入顺序，即按照上一行chunks数组中的顺序插入</span><br><span class="hljs-comment">        	*/</span><br>        &#125;)<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>❗ 新版html-webpack-plugin中默认会将script插入到<head>标签中，但同时插入的script标签会拥有<code>defer=&quot;defer&quot;</code> 属性</strong>。这个属性会标记js脚本在页面加载完后执行，但是能够在<strong>高级浏览器中</strong>提高页面加载的性能，这种技术叫做非阻塞JavaScript加载（non-blocking javascript loading）。</p>
<p>如果仍然需要将script标签插入到body最后，需要在<code>options</code>中多配置一条：<code>inject: &#39;body&#39;</code>。但由于defer属性的存在，仅仅将script标签插入到body最后，有点画蛇添足。这是因为只要有defer属性的存在，script标签指向的外部js脚本都会非阻塞加载。</p>
<p>如果不想使用非阻塞加载并且将script标签插入到body最后，则需要在<code>options</code>中再多配置一条：<code>scriptLoading: &#39;blocking&#39;</code>，该值默认为<code>defer</code>。</p>
</blockquote>
<h2 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h2><h3 id="开发环境内联"><a href="#开发环境内联" class="headerlink" title="开发环境内联"></a>开发环境内联</h3><p>开发环境下样式内联，将一个chunk中的css打包结果插入到style标签中。使用<code>css-loader</code>和<code>style-loader</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;  <span class="hljs-comment">// 所有的loader匹配规则在module.rules中配置</span><br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,<br>                use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>] <span class="hljs-comment">// loader的执行顺序是从后向前</span><br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生产环境分离"><a href="#生产环境分离" class="headerlink" title="生产环境分离"></a>生产环境分离</h3><p>生产环境中如果样式仍然打包到head中的style标签中，由于css文件体积过大，解析需要短暂的时间，会出现闪屏现象，所以我们用<code>mini-css-extract-plugin</code>的loader代替<code>style-loader</code>，<strong>将css文件分离。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;  <br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.css$/</span>,<br>                use: [MiniCssExtractPlugin.loader, <span class="hljs-string">&#x27;css-loader&#x27;</span>] ⭐ <span class="hljs-comment">// 替换掉style-loader</span><br>            &#125;<br>        ]<br>    &#125;,<br>    plugins: [<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;<br>            filename: <span class="hljs-string">&#x27;[name].css&#x27;</span> <span class="hljs-comment">// name是所在chunk的name，单入口时为main.css</span><br>        &#125;)<br>    ]<br>&#125;<br><br></code></pre></td></tr></table></figure>


<h2 id="打包图片"><a href="#打包图片" class="headerlink" title="打包图片"></a>打包图片</h2><h3 id="处理js中引入的图片"><a href="#处理js中引入的图片" class="headerlink" title="处理js中引入的图片"></a>处理js中引入的图片</h3><p>例如，在如下的代码块中引入了一个图片模块，webpack是识别不了图片的，所以需要loader的帮助</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//# main.js</span><br><span class="hljs-keyword">const</span> imgSrc = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./images/xxx.jpg&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>webpack建议我们使用<code>url-loader</code>或<code>file-loader</code>处理图片，<code>url-loader</code>内置了<code>file-loader</code>，功能更强大。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)$/</span>,<br>        use: &#123;<br>          <span class="hljs-comment">/* 当需要对一个loader进行配置时，采用对象写法 */</span><br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>, <br>          options: &#123;             <span class="hljs-comment">// 配置写在options中</span><br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// limit限制了多大的图片以下采用Base64内联，单位为Byte。这里限制了12KB</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="处理html模板中的图片标签"><a href="#处理html模板中的图片标签" class="headerlink" title="处理html模板中的图片标签"></a>处理html模板中的图片标签</h3><p>HTML模板中如果用img标签引入了开发目录下的图片资源，如果不进行处理，webpack是不会打包引入的图片的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!--....--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./images/xxx.jpg&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!--👈打包后dist目录中index.html的img标签不会变化，但是没有打包图片--&gt;</span><br><span class="hljs-comment">&lt;!----&gt;</span><br></code></pre></td></tr></table></figure>
<p>所以我们要使用<code>html-withimg-loader</code>处理html文件, 发现其中的图片引用，从而交给<code>url-loader</code>处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)$/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>          options: &#123;<br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>,<br>            esModule: <span class="hljs-literal">false</span> <span class="hljs-comment">/*👈⭐⭐ 有时需要指定url-loader使用commonJS导入,否则和html-webpack-plugin之间会存在bug*/</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>      &#123;<br>        test: <span class="hljs-regexp">/\.html$/</span>,<br>        use: <span class="hljs-string">&#x27;html-withimg-loader&#x27;</span> <span class="hljs-comment">// 配置html-withimg-loader</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="处理css中的文件"><a href="#处理css中的文件" class="headerlink" title="处理css中的文件"></a>处理css中的文件</h3><p>css中使用<code>url(...)</code>这样的语法引用的图片资源会被<code>css-loader</code>进行处理。</p>
<h1 id="模块的高级处理"><a href="#模块的高级处理" class="headerlink" title="模块的高级处理"></a>模块的高级处理</h1><h2 id="静态资源分离与重命名"><a href="#静态资源分离与重命名" class="headerlink" title="静态资源分离与重命名"></a>静态资源分离与重命名</h2><p>之前对js、图片、css的处理都只会将打包的结果全部保存在dist目录下，这无疑是混乱的，我们需要将不同的静态资源分类，存放在<code>dist</code>或<code>dist/static</code>目录下。</p>
<h3 id="将js打包到dist-js-或-dist-static-js"><a href="#将js打包到dist-js-或-dist-static-js" class="headerlink" title="将js打包到dist/js 或 dist/static/js"></a>将js打包到dist/js 或 dist/static/js</h3><p>webpack会从<code>entry</code>开始打包js，并输出到<code>output</code>，所以js打包到指定目录需要在<code>output</code>中处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123;resolve&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/bundle.js&#x27;</span> <br>    <span class="hljs-comment">// ⭐ 如果打包结果要保存到dist/static， 则filename: &#x27;static/js/bundle.js&#x27;</span><br>    <span class="hljs-comment">// ⭐ 如果多入口且结果保存到js目录下，则filename: &#x27;js/[name].[hash].js&#x27;</span><br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  	publicPath: <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-comment">// ⭐ 最好设置一下publicPath为&quot;/&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="将图片打包到dist-image或dist-static-image"><a href="#将图片打包到dist-image或dist-static-image" class="headerlink" title="将图片打包到dist/image或dist/static/image"></a>将图片打包到dist/image或dist/static/image</h3><p>图片打包到指定目录需要在<code>url-loader</code>的<code>options</code>中处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">//...</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  output: &#123;<br>    <span class="hljs-comment">//...</span><br>    publicPath: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// 👈 这里配合output.publicPath</span><br>  &#125;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>          options: &#123;<br>            limit: <span class="hljs-number">12</span> * <span class="hljs-number">1024</span>,<br>    		esModule: <span class="hljs-literal">false</span>,<br>            <span class="hljs-comment">// 👇 ⭐</span><br>    		outputPath: <span class="hljs-string">&#x27;static/image&#x27;</span> <span class="hljs-comment">// outputPath为file-loader中的可选项，资源的统一存放路径。</span><br>            name: <span class="hljs-string">&#x27;[name].[contenthash:10].[ext]&#x27;</span>, <span class="hljs-comment">// name可以省略，文件名直接由hash值替代</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="将css打包到dist-css-或-dist-static-css"><a href="#将css打包到dist-css-或-dist-static-css" class="headerlink" title="将css打包到dist/css 或 dist/static/css"></a>将css打包到dist/css 或 dist/static/css</h3><p>生产环境下，css打包到指定目录需要在<code>mini-css-extract-plugin</code>中配置<code>filename</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  output: &#123;<br>    <span class="hljs-comment">//...</span><br>    publicPath: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-comment">// 👈 这里配合output.publicPath</span><br>  &#125;<br>  plugins: [<br>    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;<br>      <span class="hljs-comment">// 👇 ⭐ </span><br>      filename: <span class="hljs-string">&#x27;css/[name].[contenthash].css&#x27;</span> <span class="hljs-comment">// 或 &#x27;static/css/[name].[contenthash].css&#x27;     </span><br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="hash-、-chunkhash-、-contenthash"><a href="#hash-、-chunkhash-、-contenthash" class="headerlink" title="[hash]、[chunkhash]、[contenthash]"></a>[hash]、[chunkhash]、[contenthash]</h3><p>以上三个文件名占位符可以叫做<strong>文件指纹</strong>。</p>
<p>区别在于：</p>
<ul>
<li><p>[hash]：同一次webpack打包的所有文件具有同一个[hash]。</p>
</li>
<li><p>[chunkhash]：即使进行多次打包，只要同一个chunk内的模块没有发生改变，[chunkhash]不变。</p>
</li>
<li><p>[contenthash]：该哈希值只与文件内容有关，文件内容改变该哈希值才会改变。</p>
</li>
</ul>
<h2 id="处理CSS兼容性问题"><a href="#处理CSS兼容性问题" class="headerlink" title="处理CSS兼容性问题"></a>处理CSS兼容性问题</h2><p>我们一般使用<code>postcss</code>来处理css兼容性问题，为各种样式添加厂商前缀。</p>
<p>使用<code>postcss-loader</code>和 <code>postcss-preset-env</code>帮助我们根据需要适配的浏览器版本对css进行兼容性处理。</p>
<blockquote>
<p><strong>postcss-preset-dev</strong> 的作用是帮助 <strong>postcss-loader</strong> 读取 <strong>browserslist</strong> 定义的各种环境下需要适配的浏览器版本，再根据当前运行环境  <strong>process.env.BROWSERSLIST_ENV</strong>  ，处理css样式。</p>
</blockquote>
<h3 id="新版postcss-loader"><a href="#新版postcss-loader" class="headerlink" title="新版postcss-loader"></a>新版postcss-loader</h3><p><strong>配置步骤：</strong></p>
<p><strong>1. 首先下载需要的包<code>postcss-loader postcss-preset-env</code></strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> postcss-loader postcss-preset-env -D<br></code></pre></td></tr></table></figure>
<p><strong>2. 配置<code>browserslist</code>，声明各个环境下需要适配的浏览器版本，以下两种方法取其一：</strong></p>
<p>⭐方法1：在<code>package.json</code>的<code>browserslist</code>字段中声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">//...</span><br>  browserslist: &#123;<br>    <span class="hljs-comment">/* 生开发环境需要兼容的浏览器 */</span><br>    &quot;development&quot;: [ <br>      &quot;last 1 chrome version&quot;,<br>      &quot;last 1 firefox version&quot;,<br>      <span class="hljs-string">&quot;last 1 safari version&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 生产环境需要兼容的浏览器 */</span><br>    &quot;production&quot;: [<br>      &quot;&gt; 1%&quot;,<br>      &quot;not dead&quot;,<br>      <span class="hljs-string">&quot;not op_mini all&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 自定义的环境1 */</span><br>    &quot;chrome&quot;: [<br>      <span class="hljs-string">&quot;last 1 chrome version&quot;</span><br>    ],<br>    <span class="hljs-comment">/* 自定义的环境2 */</span><br>    &quot;modern&quot;: [<br>      <span class="hljs-string">&quot;&gt; 10%&quot;</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>⭐方法2：在工程目录下的<code>.browserslistrc</code>文件中声明。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vim">[development]<br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> chrome <span class="hljs-keyword">version</span><br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> firefox <span class="hljs-keyword">version</span><br>  <span class="hljs-keyword">last</span> <span class="hljs-number">1</span> safari <span class="hljs-keyword">version</span><br>[production]<br>  &gt; <span class="hljs-number">1</span>%<br>  not dead<br>  not op_mini <span class="hljs-keyword">all</span><br>[chrome]<br>	<span class="hljs-keyword">last</span> <span class="hljs-number">1</span> <span class="hljs-keyword">version</span> chrome<br>[modern]<br>	&gt; <span class="hljs-number">10</span>%<br></code></pre></td></tr></table></figure>


<p><strong>3. 在<code>webpack.config.js</code>中配置<code>postcss-loader</code>对css文件进行处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// 👇 最近版本的postcss-loader结合postcss-preset-env的配置如下</span><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  postcssOptions: &#123;<br>    plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>]<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// process.env.BROWSERSLIST_ENV = &#x27;production&#x27;;</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-comment">//👇 开始配置postcss-loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>⭐ 默认情况下，postcss-preset-env会告诉postcss-loader兼容<strong>生产环境</strong>下的浏览器。</p>
<p>如果在开发环境下，只需要兼容开发环境需要兼容的浏览器，则应该在webpack.config.js中通过process.env.BROWSERSLIST_ENV声明环境为开发环境或其他在browserslist中声明的环境。</p>
</blockquote>
<p><strong>4. 声明何种环境下的浏览器</strong></p>
<p>通过修改<code>process.env.BROWERSLIST_ENV</code>环境变量，告诉<code>postcss</code>当前运行环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">//👇⭐</span><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>; <span class="hljs-comment">// 默认情况下该值是&quot;production&quot;</span><br><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  postcssOptions: &#123;<br>    plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>]<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="旧版postcss-loader的options"><a href="#旧版postcss-loader的options" class="headerlink" title="旧版postcss-loader的options"></a>旧版postcss-loader的options</h3><p>旧版<code>postcss-loader</code>结合<code>postcss-preset-env</code>的<code>options</code>的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// 👇 ⭐只需要将postcssLoaderOptions修改为：</span><br><span class="hljs-keyword">const</span> postcssLoaderOptions = &#123;<br>  ident: <span class="hljs-string">&#x27;postcss&#x27;</span>,<br>  plugins: <span class="hljs-function">() =&gt;</span> [<br>    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>)()<br>  ]<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-comment">//👇 开始配置postcss-loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>            options: postcssLoaderOptions<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="处理Sass和Less"><a href="#处理Sass和Less" class="headerlink" title="处理Sass和Less"></a>处理Sass和Less</h2><h3 id="处理scss"><a href="#处理scss" class="headerlink" title="处理scss"></a>处理scss</h3><p>首先下载需要的包 <code>npm install sass sass-loader -D</code></p>
<p>然后在进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;sass-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="处理less"><a href="#处理less" class="headerlink" title="处理less"></a>处理less</h3><p>首先下载需要的包 <code>npm install less less-loader -D</code></p>
<p>然后在进行配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [<br>          MiniCssExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;less-loader&#x27;</span><br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="配合postcss使用"><a href="#配合postcss使用" class="headerlink" title="配合postcss使用"></a>配合postcss使用</h3><p>以处理sass为例，需要配置<code>sass-loader</code>处理<code>.scss</code>文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>);<br><br><span class="hljs-comment">// 👇 定义一般css的处理流程使用到的loader数组</span><br><span class="hljs-keyword">const</span> cssProcessingLoaders = [<br>  MiniCssExtractPlugin.loader,<br>  <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>  &#123;<br>    loader: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,<br>    options: &#123;<br>      postcssOptions: &#123;<br>        plugins: [<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>],<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>];<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.scss$/</span>,<br>        use: [...cssProcessingLoaders, <span class="hljs-string">&#x27;sass-loader&#x27;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<h2 id="处理JS兼容性问题"><a href="#处理JS兼容性问题" class="headerlink" title="处理JS兼容性问题"></a>处理JS兼容性问题</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>不同浏览器对<code>ECMAScript</code>的版本支持不同，所以对不同的浏览器需要做<strong>JS语法的兼容性处理</strong>。</p>
<p>推荐的做法是根据需要适配的浏览器环境，动态调整polyfill的内容：</p>
<p><strong>1. 下载<code>babel-loader</code>、<code>@bable/core</code>、<code>@bable/preset-env</code>、<code>core-js</code></strong></p>
<ul>
<li><code>babel-loader</code>是一个loader，相当于处理兼容性的入口。</li>
<li><code>@bable/core</code>是babel的核心，负责控制处理流程。</li>
<li><code>@bable/preset-env</code>根据所要兼容的环境，指示<strong>babel</strong>如何做最基本的JS语法兼容性处理。</li>
<li><code>core-js</code>用来指示<strong>bable</strong>按需做更高级的JS语法兼容处理，如 <strong>promise</strong>。</li>
</ul>
<p><strong>2. 配置<code>babel-loader</code>，但其<code>options</code>有两种写法：</strong></p>
<p>⭐ 方法1： 内联在<code>webpack.config.js</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// ⭐⭐⭐ 一定要去除node_modules，不对第三方包做兼容处理</span><br>        												<span class="hljs-comment">// 否则会产生不可预计的后果。	</span><br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-comment">// 开始对babel-loader进行配置，也可以用use &#123;loader: &#x27;babel-loader&#x27;, options:&#123;...&#125;&#125;</span><br>        options: &#123;<br>          presets: [<br>            [ <span class="hljs-comment">// 👈 注意这里又有一层数组，</span><br>              <span class="hljs-comment">//    所有babel预设和插件如果需要添加参数，写法是：[preset/plugin, optionsObject]</span><br>              <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>              <span class="hljs-comment">// 👇 @babel/preset-env.options</span><br>              &#123;<br>                modules: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 👈 该字段与tree-shaking相关</span><br>                <br>                useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span>, <span class="hljs-comment">// 👈 根据具体的浏览器运行环境，调整polyfill，按需加载。</span><br>                <br>                corejs: &#123;<br>                  version: <span class="hljs-number">3</span>,<br>                &#125;,<br>                <br>                targets: &#123;  <br>                  chrome: <span class="hljs-string">&quot;60&quot;</span>,<br>                  ie: <span class="hljs-string">&quot;9&quot;</span><br>                &#125;<br>             	<span class="hljs-comment">// targets的类型可以是string | Array&lt;string&gt; | &#123; [string]: string &#125;</span><br>                <span class="hljs-comment">// 默认值是 &#123;&#125;，将所有的ES2015-ES2020转为ES5. 注: ES2015 = ES6</span><br>                targets: <span class="hljs-string">&#x27;&gt; 0.25%, not dead&#x27;</span>,<br>                targets: [<span class="hljs-string">&#x27;&gt; 0.25%&#x27;</span>, <span class="hljs-string">&#x27;not dead&#x27;</span>, <span class="hljs-string">&#x27;not op_mini all&#x27;</span>]<br>              &#125;<br>            ]<br>          ]<br>        &#125;<br>      &#125;,<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>⭐ 方法2：<code>options</code>分离到<code>.babelrc</code>中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># .babelrc<br>&#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-string">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>        <span class="hljs-string">&quot;corejs&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-comment">// 数字或者字符串都可以，具体到版本号第一位即可</span><br>        &#125;,<br>        <span class="hljs-string">&quot;targets&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;60&quot;</span>, <span class="hljs-comment">// 数字或者字符串都可以，尽量写字符串</span><br>          <span class="hljs-string">&quot;ie&quot;</span>: <span class="hljs-string">&quot;9&quot;</span> <span class="hljs-comment">// 数字或者字符串都可以，尽量写字符串</span><br>        &#125;<br>      &#125;<br>    ]<br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: []<br>&#125;<br><span class="hljs-comment">// 以下是.babelrc最基本的结构</span><br>&#123;<br>  <span class="hljs-string">&quot;preset&quot;</span>: [],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: []<br>&#125;<br><span class="hljs-comment">//=======================================================================</span><br># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 👈 ⭐⭐ 一定要去除node_modules，不对第三方包做兼容处理</span><br>     	loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br> ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p><strong>使用：</strong><code>@babel/preset-env</code>+ <code>@babel/plugin-transform-runtime</code>  + <code>@babel/runtime-corejs3</code></p>
<p><strong>使用方案二的好处：</strong></p>
<ol>
<li><p>同样可以根据<code>@babel/preset-env.options.targets</code>设定的目标兼容环境进行JS的转译。</p>
</li>
<li><p>新增的<code>api</code>都会从<code>runtime-corejs3</code>提供的统一命名空间中获取，<font color='red'>不会污染当前环境。</font></p>
<p>例如 IE9 不支持Promise，使用方案二后，在全局仍然不存在<code>window.Promise</code>。</p>
</li>
<li><p>方案一中每个模块中都会含有帮助转译语法的<code>helper</code>方法，不同的打包结果会含有重复的<code>helper</code>代码。</p>
<p>方案二会从<code>runtime-corejs3</code>提供的统一命名空间中获取<code>helpers</code>。</p>
</li>
</ol>
<blockquote>
<p>但使用方案二有时候打包的结果还是比方案一来的大。。不知道是为什么。。。</p>
<p>所以方案二的最大好处还是可以避免污染环境吧。。</p>
</blockquote>
<p><strong>使用步骤：</strong></p>
<ol>
<li><p>安装<code>babel-loader</code>、<code>@babel/core</code>、<code>@babel/preset-env</code>、<code>@babel/plugin-transform-runtime</code>、<code>@babel/runtime-corejs3</code>。</p>
<blockquote>
<p>@babel/runtime-corejs3包含了corejs3和@babel/runtime。</p>
</blockquote>
</li>
<li><p>配置<code>babel-loader</code>处理JS文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          presets: [<br>            [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>              modules: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 不允许将ES6模块化语法转译，和tree-shaking有关</span><br>              targets: <span class="hljs-string">&quot;ie&gt;=9&quot;</span>, <span class="hljs-comment">// 👈 声明需要兼容的环境</span><br>            &#125;]<br>          ],<br>          plugins: [<br>            [<span class="hljs-string">&#x27;@babel/plugin-transform-runtime&#x27;</span>, &#123;<br>              corejs: &#123;<br>                version: <span class="hljs-string">&quot;3&quot;</span>,<br>              &#125;<br>            &#125;],<br>          ]<br>        &#125;,<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="开启babel缓存"><a href="#开启babel缓存" class="headerlink" title="开启babel缓存"></a>开启babel缓存</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          cacheDirectory: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 👈 构建时会读取上一次的缓存</span><br>          <span class="hljs-comment">//.....</span><br>        &#125;,<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="对Webpack5的特殊处理"><a href="#对Webpack5的特殊处理" class="headerlink" title="对Webpack5的特殊处理"></a>对Webpack5的特殊处理</h3><p>由于webpack5在打包后的JS代码由一个箭头函数包裹，所以在不支持ES6的浏览器中运行不了webpack5打包的结果。</p>
<p>因此，如果是用webpack5构建项目，在上述的配置的基础上，需要多增加一条配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">// 👇 </span><br>  target: [<span class="hljs-string">&#x27;web&#x27;</span>, <span class="hljs-string">&#x27;es5&#x27;</span>],<br>&#125;<br></code></pre></td></tr></table></figure>
<p>增加该条配置后，最外层的箭头函数就会变为普通函数。</p>
<h2 id="配置ESlint和airbnb语法规范"><a href="#配置ESlint和airbnb语法规范" class="headerlink" title="配置ESlint和airbnb语法规范"></a>配置ESlint和airbnb语法规范</h2><p><strong>1. 首先安装<code>eslint</code>、<code>eslint-loader</code>、<code>eslint-config-airbnb-base</code>、<code>eslint-plugin-import</code></strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm i eslint eslint-loader eslint-<span class="hljs-built_in">config</span>-airbnb-base eslint-plugin-<span class="hljs-keyword">import</span> -D<br></code></pre></td></tr></table></figure>
<p><strong>2. 在<code>webpack.config.js</code>中配置<code>eslint-loader</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      <span class="hljs-comment">//...</span><br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;eslint-loader&#x27;</span>,<br>        exclude: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// ⭐⭐ 不对node_modules目录下的第三方模块作检查</span><br>        enforce: <span class="hljs-string">&#x27;pre&#x27;</span>, <span class="hljs-comment">// ⭐⭐ 强制该eslint-loader最先执行 </span><br>        options: &#123;<br>          fix: <span class="hljs-literal">true</span> <span class="hljs-comment">// 通知eslint自动修改开发源码中错误的语法</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 配置<code>eslintConfig</code>，有两种方法：</strong></p>
<p>⭐方法1：内联在<code>package.json</code>中</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-attr">&quot;eslintConfig&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;extends&quot;</span>: <span class="hljs-string">&quot;airbnb-base&quot;</span>, <span class="hljs-comment">// 继承airbnb-base的规则</span><br>    <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;browser&quot;</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 按浏览器环境语法进行检查，允许存在window等全局对象</span><br>    &#125;,<br>    <span class="hljs-comment">// 👇 还可以覆盖掉airbnb-base中一些检查规则</span><br>    <span class="hljs-attr">&quot;rules&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>, <span class="hljs-comment">// 允许出现console.log等</span><br>      <span class="hljs-attr">&quot;no-alert&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>, <span class="hljs-comment">// 允许出现alert()</span><br>      <span class="hljs-attr">&quot;linebreak-style&quot;</span>: <span class="hljs-string">&quot;off&quot;</span> <span class="hljs-comment">// 不检查换行符是LF还是CRLF</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>⭐方法2：分离到工程目录下的<code>.eslintrc</code>文件中，<code>eslint</code>会自动读取该文件。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"># .eslintrc<br>&#123;<br>  <span class="hljs-attr">&quot;extends&quot;</span>: <span class="hljs-string">&quot;airbnb-base&quot;</span>,<br>  <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;browser&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;rules&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;no-console&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>    <span class="hljs-attr">&quot;no-alert&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>,<br>    <span class="hljs-attr">&quot;linebreak-style&quot;</span>: <span class="hljs-string">&quot;off&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>4. VSCode中安装ESlint扩展， 同时在项目目录下新增<code>.eslintignore</code>文件</strong></p>
<blockquote>
<p>该步骤为可选，目的是让扩展插件帮我们及时检查出代码书写不规范的地方，避免编译时再报错修改。</p>
</blockquote>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># .eslintignore</span><br><span class="hljs-comment"># 在允许vscode读取工程目录下的eslint配置文件时，</span><br><span class="hljs-comment"># ESlint扩展会根据.eslintrc中配置的规则对工程目录下的文件进行检查，</span><br><span class="hljs-comment"># 同时跳过.eslintignore指定的文件区域</span><br><br><span class="hljs-regexp">/dist/</span><br><span class="hljs-regexp">/node_modules/</span><br></code></pre></td></tr></table></figure>


<h2 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h2><h3 id="压缩JS"><a href="#压缩JS" class="headerlink" title="压缩JS"></a>压缩JS</h3><p>在Webpack4及其以上版本中，在<code>production</code>模式下，Webpack会自动将打包后的JS代码进行压缩。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h3><p>在生产环境下，webpack会自动压缩js，但不会压缩css资源。</p>
<p>所以我们要使用<code>optimize-css-assets-webpack-plugin</code>插件来帮助压缩css代码。</p>
<p><strong>1. 首先安装插件</strong></p>
<p><code>npm install optimize-css-assets-webpack-plugin</code></p>
<p><strong>2. 使用插件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><span class="hljs-comment">//...</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(), <span class="hljs-comment">// 在这里使用插件即可</span><br>  ],<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-comment">// 生产环境使用 （开发环境下也可以使用，配置即可）</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="压缩HTML"><a href="#压缩HTML" class="headerlink" title="压缩HTML"></a>压缩HTML</h3><p>在<strong>Webpack5</strong>中，在<code>production</code>模式下，Webpack会压缩编译后的HTML文件（清除空白字符+注释）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>而在<strong>Webpack4</strong>中，Webpack是不会自动打包HTML的，需要用到打包时用到的插件<code>html-webpack-plugin</code>。</p>
<p>也就是要对打包HTML的插件进行配置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;produciton&#x27;</span>,<br>  <span class="hljs-comment">//....</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      template: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>,<br>      <span class="hljs-comment">//⭐ 配置 minify参数</span><br>      minify: &#123;<br>        collapseWhitespace: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 压缩空白字符</span><br>        removeComments: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 清除注释</span><br>      &#125;<br>    &#125;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h3><p>压缩图片后，图片的质量会下降。</p>
<p><strong>使用loader：</strong><code>image-webpack-loader</code></p>
<p><strong>1. 首先安装loader</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm install <span class="hljs-built_in">image</span>-webpack-loader -D<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗ 注意：这个包下的会有点慢</p>
</blockquote>
<p><strong>2. 对图片使用loader</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-comment">// 分离出image-webpack-loader的配置</span><br><span class="hljs-comment">// 以下为官方实例的配置 https://www.npmjs.com/package/image-webpack-loader</span><br><span class="hljs-keyword">const</span> imageWebpackLoaderOptions = &#123;<br>  mozjpeg: &#123;<br>    progressive: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  <span class="hljs-comment">// optipng.enabled: false will disable optipng</span><br>  optipng: &#123;<br>    enabled: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  pngquant: &#123;<br>    quality: [<span class="hljs-number">0.65</span>, <span class="hljs-number">0.90</span>],<br>    speed: <span class="hljs-number">4</span><br>  &#125;,<br>  gifsicle: &#123;<br>    interlaced: <span class="hljs-literal">false</span>,<br>  &#125;,<br>  <span class="hljs-comment">// the webp option will enable WEBP</span><br>  webp: &#123;<br>    quality: <span class="hljs-number">75</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;file-loader&#x27;</span>,<br>          <span class="hljs-comment">// 👇 使用该loader</span><br>          &#123;<br>            loader: <span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>,<br>            options: imageWebpackLoaderOptions<br>          &#125;,<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






<h1 id="Webpack高级功能"><a href="#Webpack高级功能" class="headerlink" title="Webpack高级功能"></a>Webpack高级功能</h1><h2 id="devServer-⭐"><a href="#devServer-⭐" class="headerlink" title="devServer ⭐"></a>devServer ⭐</h2><h3 id="开启devServer"><a href="#开启devServer" class="headerlink" title="开启devServer"></a>开启devServer</h3><p>配置本地开发服务器，原理是将打包的结果保存到内存中。</p>
<ol>
<li><p>首先安装<code>npm i webpack-dev-server -D</code></p>
</li>
<li><p>在<code>webpack.config.js</code>中配置<code>devServer</code>字段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  devServer: &#123;<br>    <span class="hljs-comment">//👇 此条是配置devServer服务器根目录，这里定位到打包后的dist，要使用绝对路径。</span><br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-comment">// 以下内容为可选</span><br>    compress: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 一切资源使用gzip压缩</span><br>    port: <span class="hljs-number">8080</span>, <span class="hljs-comment">// 端口号</span><br>    open: <span class="hljs-literal">true</span> <span class="hljs-comment">// 启动服务后自动打开浏览器访问，配置后就不需要在运行devServer时输入--open参数</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在<code>package.json</code>中配置<code>scripts</code>脚本</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">/*....*/</span><br> 	<span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open&quot;</span>,<span class="hljs-comment">/* 如果配置了open为true，就不需要--open */</span><br>    <span class="hljs-comment">/* &quot;start&quot;: &quot;webpack serve --open&quot;  👈 webpack5 中的命令脚本 */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗❗ <strong>注意</strong>：在<code> webpack5</code> 中，运行<code>webpack-dev-server</code>的命令发生了变化，需要用<code>webpack serve</code>代替原来的<code>webpack-dev-server</code>命令。</p>
</blockquote>
</li>
</ol>
<h3 id="proxy-代理"><a href="#proxy-代理" class="headerlink" title="proxy 代理"></a>proxy 代理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port: <span class="hljs-number">8080</span>,<br>    compress: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 转发写法：</span><br>    proxy: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: <span class="hljs-string">&#x27;http://127.0.0.1:5000&#x27;</span>, <span class="hljs-comment">// 如果path部分以/api开头，将请求转发到本地的5000端口。</span><br>    &#125;,<br>    <span class="hljs-comment">// 重写写法：</span><br>    proxy: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        target: <span class="hljs-string">&#x27;http://127.0.0.1:5000&#x27;</span>,<br>        pathRewrite: &#123;<br>          <span class="hljs-string">&quot;^/api&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-comment">// 👈 将开头的api去除</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h3 id="模拟接口"><a href="#模拟接口" class="headerlink" title="模拟接口"></a>模拟接口</h3><p>使用devServer中的before钩子来为内置的express服务器添加路由。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> mockUsers = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ley&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;mz&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">23</span>&#125;,<br>]<br><span class="hljs-keyword">const</span> mockObj = &#123;<br>  foo: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port: <span class="hljs-number">8080</span>,<br>    compress: <span class="hljs-literal">true</span>,<br>	<span class="hljs-function"><span class="hljs-title">before</span>(<span class="hljs-params">app</span>)</span> &#123;<br>      app.get(<span class="hljs-string">&#x27;/api/home&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.redirect(<span class="hljs-string">&#x27;/&#x27;</span>));<br>      <span class="hljs-comment">// 在这里就可以在一些路由中返回mock数据。</span><br>      app.get(<span class="hljs-string">&#x27;/api/users&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.json(mockUsers));<br>      app.get(<span class="hljs-string">&#x27;/api/obj&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.end(<span class="hljs-built_in">JSON</span>.stringify(mockObj)));<br>    &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>webpack-dev-server实际是一个基于Express框架的服务器，before钩子函数会在服务器启动前执行。</p>
<p>可以在before钩子中扩展devServer服务器的功能。</p>
</blockquote>
<h2 id="one-of"><a href="#one-of" class="headerlink" title="one-of"></a>one-of</h2><p>webpack对各个模块的文件名进行模式匹配时，会将每个文件与module.rules中设置的每条规则进行匹配，这在某些情况下是多余的。比如说css文件只会交由一组loader处理（style-loader, css-loader），而不会交给babel-loader处理，所以有些模式匹配是多余的。</p>
<p>所以webpack提供了one-of功能，对于某些类型文件，只匹配某一条规则，即只交由一组loader处理，匹配成功后就不再与剩余的模式进行匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>                loader: <span class="hljs-string">&#x27;eslint-loader&#x27;</span>,<br>                enforce: <span class="hljs-string">&#x27;pre&#x27;</span><br>            &#125;,<br>            <br>            one-<span class="hljs-keyword">of</span>: [<br>            	&#123;<br>            		test: <span class="hljs-regexp">/\.css$/</span>,<br>            		use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]<br>        		&#125;, &#123;<br>    				test: <span class="hljs-regexp">/\.(jpe?g|png|gif|svg|bmp)/</span>,<br>    				use: <span class="hljs-string">&#x27;url-loader&#x27;</span><br>				&#125;,&#123;<br>    				test: <span class="hljs-regexp">/\.js$/</span>,<br>    				exclude: <span class="hljs-regexp">/node_modules/</span>,<br>    				loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>				&#125;<br>				<span class="hljs-comment">//....</span><br>            ]<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>开启webpack的watch功能，可以在代码修改时自动重新编译</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  watch: <span class="hljs-literal">true</span>,<br>  watchOptions: &#123;<br>    ignored: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 不需要监听的内容，支持正则</span><br>    aggregate: <span class="hljs-number">300</span>, <span class="hljs-comment">// 节流时间，开始重新编译后，300ms内不再重新编译</span><br>    poll: <span class="hljs-number">10</span>, <span class="hljs-comment">// watch是通过不断询问文件指针来判断是否要重新编译的，poll为1秒内询问的次数</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>webpack配置中如果配置了<code>context</code>字段，则配置对象内的所有相对路径都是基于<code>context</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  context: __dirname, <span class="hljs-comment">// 默认就是工程项目目录</span><br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  ouput: &#123;<br>    filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>    path: <span class="hljs-string">&#x27;./dist&#x27;</span>, <span class="hljs-comment">// 这里不再使用绝对路径</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="devtool-“source-map”-⭐"><a href="#devtool-“source-map”-⭐" class="headerlink" title="devtool: “source-map” ⭐"></a>devtool: “source-map” ⭐</h2><p>SourceMap是一种提供源代码到构建后代码映射的技术，如果构建后源代码出错了，通过映射可以追踪到源代码错误。在浏览器中运行Webpack打包后的JS和CSS，如果存在问题，可以通过SourceMap找到打包前出错的位置。</p>
<h3 id="关键字解析"><a href="#关键字解析" class="headerlink" title="关键字解析"></a>关键字解析</h3><p>在<code>webpack.config.js</code>的<code>devtool</code>属性中可以配置SourceMap选项，可选的值有：</p>
<p><code>[inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></p>
<p><strong>不添加关键字</strong></p>
<ul>
<li><p><code>source-map</code></p>
<p><font color='cornflowerblue'>作用</font>：构建项目代码时，为每个chunk打包的结果和css文件生成一个map文件。</p>
<p><font color='cornflowerblue'>效果</font>：可以追踪到错误发生在哪个源代码文件的哪一行哪一列。</p>
</li>
</ul>
<p><strong>解释第一组关键字</strong></p>
<blockquote>
<p>❗ 以下关键字不能互相组合，但是能够后面两组关键字组合。</p>
</blockquote>
<ul>
<li><p><code>inline</code></p>
<p><font color='cornflowerblue'>作用</font>：让source-map映射信息内联到构建后的文件中，不单独形成一个文件。</p>
<p><font color='cornflowerblue'>效果</font>：映射信息内联，比<code>source-map</code>编译速度快，但因为内联，最终打包后的文件体积大。</p>
</li>
<li><p><code>eval</code></p>
<p><font color='cornflowerblue'>作用</font>：使用eval函数包裹构建后的代码和映射信息，同时每一个模块的映射信息写在自己的代码块中。</p>
<p><font color='cornflowerblue'>效果</font>：映射信息内联，速度比<code>inline-source-map</code>还快。</p>
</li>
<li><p><code>hidden</code></p>
<p><font color='cornflowerblue'>作用</font>：映射信息单独成立一个文件，不再映射到源代码，而是映射到webpack构建后的代码。</p>
<p><font color='cornflowerblue'>效果</font>：如果代码出错，能够反映错误发生在构建后的代码中的位置。</p>
<blockquote>
<p>hidden-source-map不再显示开发源代码目录的内容，只显示dist中的内容。一般只在生产环境下使用，映射到的是webpack转换、压缩后的代码。由于是映射到构建后的代码，生产环境下相当于没有提供任何与源代码有关的信息。</p>
</blockquote>
</li>
</ul>
<p><strong>解释第二组关键字</strong></p>
<blockquote>
<p>nosources关键字可以和其他两组关键字组合。</p>
</blockquote>
<ul>
<li><p><code>nosources</code></p>
<p><font color='cornflowerblue'>作用</font>：不再显示任何源代码。</p>
<p><font color='cornflowerblue'>效果</font>：构建代码发生的错误，只能定位错误发生在源代码中的位置，但看不到相应代码内容。<font color='red'>会向客户端暴露源代码目录结构。</font></p>
<p><font color='red'>注意</font>：一般不和<code>hidden</code>结合使用。</p>
</li>
</ul>
<p><strong>解释第三组关键字</strong></p>
<blockquote>
<p>以下关键字可以和前两组中的关键字组合。</p>
</blockquote>
<ul>
<li><p><code>cheap</code></p>
<p><font color='cornflowerblue'>作用</font>：简化<code>source-map</code>的行为，生成map文件，但不再包含<code>loader</code>的source-map，不再计算列号。</p>
<p><font color='cornflowerblue'>效果</font>：只能追踪到<code>loader</code>处理后的中间代码的位置，同时不能精确到列，但比<code>source-map</code>编译更快。</p>
</li>
<li><p><code>cheap-module</code></p>
<p>作用：在<code>cheap-source-map</code>和<code>source-map</code>之间折衷，囊括<code>loader</code>的source-map，但也不计算列号。</p>
<p>效果：能追踪到源代码位置，但同样不能精确到列。生成的map文件比<code>cheap-source-map</code>大。</p>
</li>
</ul>
<h3 id="开发环境-devtool配置"><a href="#开发环境-devtool配置" class="headerlink" title="开发环境 devtool配置"></a>开发环境 devtool配置</h3><p>对开发环境的代码进行调试时，要考虑<strong>编译的速度</strong>和<strong>调试友好程度</strong>。</p>
<blockquote>
<p>调试友好程度无非就是能否准确定位到错误在源代码中的位置。    </p>
<p>由于内联模式编译速度快于非内联，所以开发环境只考虑内联模式。</p>
</blockquote>
<p><strong>按编译速度排名：</strong></p>
<ol>
<li><code>eval-cheap-source-map</code></li>
<li><code>eval-cheap-module-source-map</code>和<code>eval-source-map</code></li>
<li><code>cheap-source-map</code></li>
</ol>
<p><strong>按调试友好程度排名</strong></p>
<ol>
<li><code>eval-source-map</code> 和 <code>inline-source-map</code> 精确到某文件中的某行某列</li>
<li><code>[inline-|eval-]cheap-module-source-map</code> 精确到某文件中的某行</li>
</ol>
<p><strong>综上所述：</strong></p>
<p>一般开发环境推荐使用<code>eval-source-map</code>或<code>eval-cheap-module-source-map</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  devtool: <span class="hljs-string">&#x27;eval-source-map&#x27;</span> <span class="hljs-comment">// 在vue和react脚手架中，开发环境默认使用的是eval-source-map</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="生产环境-devtool配置"><a href="#生产环境-devtool配置" class="headerlink" title="生产环境 devtool配置"></a>生产环境 devtool配置</h3><p>对生产环境的代码进行调试时，要考虑<strong>是否隐藏源代码</strong>和<strong>调试友好程度</strong>。</p>
<blockquote>
<p>SourceMapingURL如果内联会导致单个文件体积过大，所以生产环境不考虑SourceMap内联模式。</p>
</blockquote>
<p><strong>按照调试友好程度排名</strong></p>
<ol>
<li><code>source-map</code> 会暴露源码</li>
<li><code>cheap-module-source-map</code> 会暴露源码</li>
<li><code>nosources-source-map</code> 👈 能够定位错误发生在源代码中的位置，但无法在浏览器中看到源码</li>
</ol>
<p><strong>按对源码的保护程度排名</strong></p>
<ol>
<li><p><code>不使用SourceMap，即不配置devtool</code></p>
</li>
<li><p><code>hidden-source-map</code></p>
</li>
<li><p><code>nosources-source-map</code> </p>
</li>
</ol>
<p><strong>综上所述：</strong></p>
<p>如果既要保护源代码，又要能够定位到错误发生在源代码中的位置：</p>
<p>​    方法1 使用<code>nosources-source-map</code>。</p>
<p>​    方法2 使用<code>source-map</code>打包后，上线时规定不允许前端加载map文件。</p>
<p>如果不需要保护源代码，可以使用<code>source-map</code>。</p>
<p>如果不需要进行生产环境下的调试，则不需要配置<code>devtool</code>。</p>
<h3 id="官方指南"><a href="#官方指南" class="headerlink" title="官方指南"></a>官方指南</h3><p><a target="_blank" rel="noopener" href="http://doc.codingdict.com/webpack-cn-doc/configuration/devtool/">http://doc.codingdict.com/webpack-cn-doc/configuration/devtool/</a></p>
<h2 id="resolve-解析查找模块和包-⭐"><a href="#resolve-解析查找模块和包-⭐" class="headerlink" title="resolve 解析查找模块和包 ⭐"></a>resolve 解析查找模块和包 ⭐</h2><p><strong>webpack.config.js中可以配置resolve字段帮助我们优化对文件模块解析查找的过程。</strong></p>
<h3 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h3><p><code>resolove.extensions</code>中包含的扩展名可以在使用<code>require</code>和<code>import</code>语句时省略，webpack会依次尝试添加扩展名进行匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>  &#125;, <br>&#125;<br><span class="hljs-comment">//============================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../webpack.config&#x27;</span>); <span class="hljs-comment">// 省略 &quot;.js&quot;</span><br><br></code></pre></td></tr></table></figure>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><code>resolve.alias</code>可以定义路径别名。</p>
<p>如果在<code>require</code>和<code>import</code>加载的路径中使用别名，真正的路径是将<font color='red'>别名</font>和<font color='red'>被别名分割的字符串</font>传入到<code>path.join</code>方法得到的结果。</p>
<p>如果使用别名没有匹配到，那么会将别名作为真名再去匹配一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>, <span class="hljs-string">&#x27;vue&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>],<br>    alias: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>      <span class="hljs-string">&#x27;@components&#x27;</span>: resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;component&#x27;</span>),<br>    &#125;<br>  &#125;, <br>&#125;<br><span class="hljs-comment">//============================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> indexJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/foo&#x27;</span>); <br><br></code></pre></td></tr></table></figure>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>对于在文件模块依赖的包（如vue，jquery），webpack会按照Node.js的规则一路向上查找<code>node_modules</code>目录。</p>
<p>而<code>resolve.modules</code>提供了一种方式让webpack去指定的目录中查找模块所依赖的包。</p>
<p>这样做有两个好处：① 减少搜索的目录，提高查询速度 ，② 可以自定义添加查询目录。</p>
<blockquote>
<p>❗ 但是需要注意的是，到自定义的查询目录去查找包时，仍旧按照Node.js规范去加载包的入口模块。</p>
<p>换句话说，本地开发目录下，要先将自定义的包按照Node.js的规范整理好，然后将包的文件夹放在自定义查询目录下。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 目录结构<br>.<br>|  src<br>|  |  modules<br>|  |  |  bar<br>|  |  |  |--index.js<br>|  |--main.js<br>|--webpack.config.js<br><br><span class="hljs-comment">// =======================================================================</span><br><br># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  resolve: &#123;<br>    <span class="hljs-comment">/* 设置搜寻目录为工程目录下的node_modules以及src目录下的modules，</span><br><span class="hljs-comment">    *  该目录存放自定义的包。</span><br><span class="hljs-comment">    */</span><br>    modules: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;src/modules&#x27;</span>], <br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ======================================================================</span><br><br># .src/main.js<br><span class="hljs-comment">// 假设此时在src/modules目录下存在自定义的包bar，以文件夹形式存储，其中含有index.js文件</span><br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;bar&#x27;</span>; <span class="hljs-comment">// 如果node_modules下不存在bar包，则回到src/modules加载bar</span><br><br></code></pre></td></tr></table></figure>


<h3 id="mainFileds"><a href="#mainFileds" class="headerlink" title="mainFileds"></a>mainFileds</h3><p>默认情况下，在导入一个包时，会查找该包目录下<code>package.json</code>的<code>main</code>字段标记的路径作为入口模块的路径。</p>
<p>但是这个入口字段是可以配置的，不一定非要是<code>main</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.configs.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    mainFields: [<span class="hljs-string">&#x27;my-entry&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>], <span class="hljs-comment">// 先看my-entry，再看main</span><br>    <span class="hljs-comment">// 配置 target === web 或者 target ==== webworker时，mainFields的值：</span><br>    mainFields: [<span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>    <span class="hljs-comment">// target的值为其他时，mainfields默认值为：</span><br>    mainFields: [<span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="mainFiles"><a href="#mainFiles" class="headerlink" title="mainFiles"></a>mainFiles</h3><p>当一个包的主目录下没有<code>package.json</code>文件，或<code>package.json</code>没有指示入口文件时，默认入口为包的主目录下的<code>index.js</code>文件，其实这个也是可以配置的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.configs.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    mainFiles: [<span class="hljs-string">&#x27;index&#x27;</span>, <span class="hljs-string">&#x27;entry&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span> ],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="resolveLoader-解析查找loader"><a href="#resolveLoader-解析查找loader" class="headerlink" title="resolveLoader 解析查找loader"></a>resolveLoader 解析查找loader</h2><p><code>resolve</code>是用来指定如何解析查找模块和包，而<code>resolveLoader</code>用于指定如何查找loader。</p>
<p>这个字段的配置与<code>resolve</code>配置类似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;my-loader&#x27;</span>, <span class="hljs-comment">// 👈 自定义loader</span><br>      &#125;<br>    ]<br>  &#125;<br>  <span class="hljs-comment">//👇  配置loader如何查找</span><br>  resolveLoader: &#123;<br>    extensions: [<span class="hljs-string">&#x27;.js&#x27;</span>],<br>    modules: [<span class="hljs-string">&#x27;node_modules&#x27;</span>, <span class="hljs-string">&#x27;loaders&#x27;</span>, <span class="hljs-string">&#x27;src/loaders&#x27;</span>],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>




<h2 id="module-noParse"><a href="#module-noParse" class="headerlink" title="module.noParse"></a>module.noParse</h2><p><code>module.noParse</code>字段可以用于配置哪些模块文件的内容不需要解析依赖。</p>
<p>一些第三方库比较独立，不依赖于别的模块，所以我们可以通过<code>module.noParse</code>告诉webpack不去解析这些模块的依赖，从而一定程度上<font color='red'>提高构建速度</font>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [],<br>    <span class="hljs-comment">// 👇 使用正则表达式</span><br>    noParse: <span class="hljs-regexp">/jquery|lodash/</span>,<br>    <span class="hljs-comment">// 👇 或者改用函数</span><br>    <span class="hljs-function"><span class="hljs-title">noParse</span>(<span class="hljs-params">id</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/jquery|lodash/</span>.test(id);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="stats-日志优化"><a href="#stats-日志优化" class="headerlink" title="stats 日志优化"></a>stats 日志优化</h2><p>webpack编译时，控制台日志太多或太少都不美观。通过配置<code>stats</code>字段可以优化日志的输出。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;normal&quot;</code></td>
<td>默认值，标准输出</td>
</tr>
<tr>
<td><code>&quot;none&quot;</code></td>
<td>没有日志输出</td>
</tr>
<tr>
<td><code>&quot;errors-only&quot;</code></td>
<td>只有发生错误时输出</td>
</tr>
<tr>
<td><code>&quot;minimal&quot;</code></td>
<td>发生错误或有新的编译内容时输出</td>
</tr>
<tr>
<td><code>&quot;verbose&quot;</code></td>
<td>全部输出</td>
</tr>
</tbody></table>
<h2 id="tree-shaking-⭐"><a href="#tree-shaking-⭐" class="headerlink" title="tree-shaking ⭐"></a>tree-shaking ⭐</h2><p>当 Javascript 项目达到一定体积时，将代码分成模块会更易于管理。但是当这样做时，我们最终可能会导入实际上未使用的代码(<code>dead code</code>)。Tree Shaking 是一种通过消除最终文件中未使用的代码来优化体积的方法。</p>
<h3 id="依赖于ES6模块化"><a href="#依赖于ES6模块化" class="headerlink" title="依赖于ES6模块化"></a>依赖于ES6模块化</h3><p>Tree-shaking主要依赖于<code>ES6的模块化import和export</code>。</p>
<p>我们都知道ES6的module只能是在模块顶部出现，和运行时无关，不能运行时加载，Tree-shaking主要就是依靠这个基础进行静态分析，不执行代码就能对模块依赖关系进行判定。</p>
<p>而<code>commonJS模块化规范</code>支持动态导入，需要执行模块代码后才知道有没有运行某个<code>require</code>语句。CommonJS 模块的这种 <code>dynamic</code> 性质意味着无法 Tree Shaking，因为在实际运行代码之前无法确定需要哪些模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myDynamicModule;<br><br><span class="hljs-keyword">if</span> (condition) &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    myDynamicModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br>&#125; <br></code></pre></td></tr></table></figure>
<p>在 ES6 中，引入了模块的新语法，这是 <code>static</code> 的。使用<code>import</code>语法，我们不再能够动态导入模块。</p>
<p>如下所示的代码是不被允许的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相反，我们必须在任何条件之外定义全局范围内的所有导入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-keyword">import</span> bar <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;bar&quot;</span>;<br><br><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-comment">// do stuff with foo</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// do stuff with bar</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="关闭babel的模块化转译"><a href="#关闭babel的模块化转译" class="headerlink" title="关闭babel的模块化转译"></a>关闭babel的模块化转译</h3><p>先要了解，Tree Shaking 实现的前提，是基于 「必须用 ES Modules 组织代码」。</p>
<p>即交给webpack处理的代码，必须使用 <code>ES6 modules</code>方式实现模块化。</p>
<blockquote>
<p>MDN：Tree shaking 依赖于ES6中的import和export语句，用来检测代码模块是否被导出、导入，且被Javascript文件使用。</p>
</blockquote>
<p>webpack优化的过程是先将代码交给loader去处理，然后再将处理结果优化输出。</p>
<p>而为了转换代码中的 ECMAScript 新特性，一般会选择<code>babel-loader</code>去处理JS。</p>
<p><font color='red'>而在<code>babel-loader</code>处理代码时，就有可能将代码中的 <code>ES6 modules</code> 转换为 <code>CommonJS</code>。</font></p>
<blockquote>
<p>PS：实际上这取决于是否使用了转换ESM的babel插件，而常用的插件集合 @babel/preset-env 就包含转换ESM的插件。</p>
</blockquote>
<p><font color='red'>所以当 @babel/preset-env 工作时，代码中的 ESM 就应该被转换为 CommonJS。</font></p>
<p>因此webpack在打包时，拿到的就是 CommonJS 组织的代码，从而 Tree Shaking 也就不能生效。</font></p>
<p><strong>但是现在的效果并不是这样。</strong></p>
<p>在项目中使用babel-loader，并仅开启usedExports，查看打包结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;none&#x27;</span>,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        use: &#123;<br>          loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>          options: &#123;<br>            presets: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>],<br>          &#125;,<br>        &#125;,<br>      &#125;,<br>    ],<br>  &#125;,<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>,<br>  &#125;,<br>&#125;<br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;<br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">/* harmony export (binding) */</span> __webpack_require__.d(__webpack_exports__, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> Button; &#125;);<br>  <br><span class="hljs-comment">// usedExports 生效了，也就是Tree Shaking 生效了</span><br>  <br><span class="hljs-comment">/* unused harmony export Link */</span><br><span class="hljs-comment">/* unused harmony export Heading */</span><br>  <br><span class="hljs-keyword">var</span> Button = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;dead-code&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> Link = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Link</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> Heading = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Heading</span>(<span class="hljs-params">level</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h&#x27;</span> + level);<br>&#125;;<br><br>&#125;)<br><br></code></pre></td></tr></table></figure>
<p>发现 usedExports 生效了，也就表示 Tree Shaking 并没有失效。</p>
<p><strong>这是因为在最新版本的 babel-loader 中自动关闭了 转换ESM 的插件。</strong></p>
<hr>
<p>可以通过修改插件集合的配置，开启 ESM 转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>: &#123;<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>  <br>  &#125;,<br>  rules: [<br>    &#123;<br>      test: <span class="hljs-regexp">/\.js$/</span>,<br>      use: &#123;<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          <span class="hljs-comment">// 注意：仅使用时，是将插件集合名称放到一个数组中</span><br>          <span class="hljs-comment">// presets: [&#x27;@babel/preset-env&#x27;],</span><br><br>          <span class="hljs-comment">// 当对插件集合编写配置时，就需要再套一个数组</span><br>          <span class="hljs-comment">// 数组的第一个元素是插件集合的名称</span><br>          <span class="hljs-comment">// 第二个元素是它的配置对象</span><br>          presets: [<br>            [<br>              <span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>,<br>              &#123;<br>                <span class="hljs-comment">// modules默认是auto，即根据环境去判断是否开启转换ESM插件</span><br>                <span class="hljs-comment">// 这里设置为强制转换为commonjs</span><br>                modules: <span class="hljs-string">&#x27;commonjs&#x27;</span>,<br>              &#125;,<br>            ],<br>          ],<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;,<br><br></code></pre></td></tr></table></figure>
<p>再次打包查看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>, <span class="hljs-built_in">exports</span>, __webpack_require__</span>) </span>&#123;<br><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;<br>  value: <span class="hljs-literal">true</span><br>&#125;);<br><span class="hljs-built_in">exports</span>.Heading = <span class="hljs-built_in">exports</span>.Link = <span class="hljs-built_in">exports</span>.Button = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">var</span> Button = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Button</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;button&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;dead-code&#x27;</span>);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Button = Button;<br><br><span class="hljs-keyword">var</span> Link = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Link</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Link = Link;<br><br><span class="hljs-keyword">var</span> Heading = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Heading</span>(<span class="hljs-params">level</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h&#x27;</span> + level);<br>&#125;;<br><br><span class="hljs-built_in">exports</span>.Heading = Heading;<br><br>&#125;)<br><br></code></pre></td></tr></table></figure>
<p>3个成员都被导出，从而压缩优化时，也不会将它们删除。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>通过以上实验发现，最新版本的babel-loader，并不会导致Tree Shaking失效。即不需要配置<code>modules</code>，默认为<code>auto</code>。</p>
</li>
<li><p>如果还不确定，也可以尝试将<code>@babel/preset-env</code>配置中的<code>modules</code>，设置为<code>false</code>。这样就会确保，preset-env不会开启 转换ESM 的插件。同时确保了Tree Shaking工作的前提。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>,<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        options: &#123;<br>          presets: [<br>            [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>, &#123;<br>              <span class="hljs-comment">// 👇 标记不允许将ES6转换为commonjs，最新版本的babel-loader不需要配置该项</span><br>              modules: <span class="hljs-literal">false</span>, <br>              useBuiltIns: <span class="hljs-string">&#x27;usage&#x27;</span>,<br>              corejs: &#123;<br>              	version: <span class="hljs-number">3</span>,<br>            	&#125;,<br>              targets: <span class="hljs-string">&#x27;&gt; 0.25%&#x27;</span>,<br>            &#125;],<br>          ]<br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="模块的副作用"><a href="#模块的副作用" class="headerlink" title="模块的副作用"></a>模块的副作用</h3><p>副作用是：有一些代码，是在 <code>import</code> 时执行了一些行为，这些行为不一定和任何导出相关。</p>
<p>简单来说，如果模块仅仅在导入后就会对全局、外部环境产生影响，那么它就属于具有副作用的模块。</p>
<p>例如 <code>polyfill</code> ，Polyfills 通常是在项目中向全局注入新的内容，而不是在导入后调用。</p>
<h3 id="开启tree-shaking"><a href="#开启tree-shaking" class="headerlink" title="开启tree-shaking"></a>开启tree-shaking</h3><h4 id="生产模式下自动开启"><a href="#生产模式下自动开启" class="headerlink" title="生产模式下自动开启"></a>生产模式下自动开启</h4><p>将webpack的<code>mode</code>设置为<code>production</code>，将自动开启tree-shaking，<font color='red'>但要考虑模块的副作用问题。</font></p>
<ul>
<li><p>在<code>package.json</code>中全局标记或在<code>module.rules</code>中对每种规则的文件标记是否有副作用<code>sideEffects</code>。</p>
<p>如果确定全部文件没有副作用，则在<code>package.json</code>设置<code>&quot;sideEffect&quot;: false</code>，项目内所有引用的文件都会被<code>tree-shaking</code>；</p>
<p>如果某些文件会存在副作用，则在<code>package.json</code>中标明哪些文件存在副作用。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"># package.json<br>&#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-attr">&quot;sideEffects&quot;</span>: [<span class="hljs-string">&quot;./src/some-side-effectful-file.js&quot;</span>, <span class="hljs-string">&quot;*.css&quot;</span>] <span class="hljs-comment">//👈 一般css文件都有副作用 </span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>如果某些规则的文件会存在副作用，比如css文件，则在<code>module.rules</code>中标记<code>sideEffects: true</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          MiniCSSExtractPlugin.loader,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>        ],<br>        sideEffects: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 👈 标记存在副作用，优先级高于package.json中的sideEffects</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="开发模式下手动开启"><a href="#开发模式下手动开启" class="headerlink" title="开发模式下手动开启"></a>开发模式下手动开启</h4><blockquote>
<p>Tree Shaking并不是 webpack 的某个配置选项。它是一组功能搭配使用后的优化效果。这组功能会在生产模式production下自动使用。</p>
</blockquote>
<p>在开发模式下<code>mode: &#39;development&#39;</code>，通过配置optimization中的<code>usedExports</code>、<code>minimize</code>以及<code>minimizer</code>，能够模仿Tree Shaking的开启。</p>
<p><code>usedExports: true</code> 表示在输出结果中模块只导出外部使用了的成员。</p>
<p>打包查看输出文件：</p>
<p><img src="/webpack4.assets/image-20210222182858889.png" srcset="/img/loading.gif" alt="image-20210222182858889"></p>
<p>此时就可以通过压缩优化，删除掉「没有用到的代码」。</p>
<p><code>minimize: true</code>： 表示要删除被标记为<code>unused</code>的代码块。</p>
<p>删除注释、删除没有用到的代码、删除空白、替换变量名为简短的名称等。</p>
<blockquote>
<p>它默认使用的是TerserPlugin， 除非在optimization .minimizer中指定使用哪个插件。</p>
</blockquote>
<p>再次打包：</p>
<p><img src="/webpack4.assets/image-20210222183217915.png" srcset="/img/loading.gif" alt="image-20210222183217915"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  optimization: &#123;<br>    usedExports: <span class="hljs-literal">true</span>,<br>    minimize: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 以下为可选</span><br>    minimizer: [....]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






<h3 id="正确编写可以tree-shaking的模块"><a href="#正确编写可以tree-shaking的模块" class="headerlink" title="正确编写可以tree-shaking的模块"></a>正确编写可以tree-shaking的模块</h3><ol>
<li>使用<code>ES6 modules</code>进行导出和导入。</li>
<li>第三方内容按需加载。</li>
<li>避免在模块顶层作用域写具有副作用的代码。</li>
<li>如果某个模块具有副作用，导入该模块又没有访问该模块的内容，则必须注明该模块有副作用。</li>
</ol>
<h2 id="Scope-Hoisting-作用域提升"><a href="#Scope-Hoisting-作用域提升" class="headerlink" title="Scope Hoisting 作用域提升"></a>Scope Hoisting 作用域提升</h2><p>Scope Hoisting可以让webpack打包出来的代码文件更小、运行的更快，是Webpack3新推出的功能。</p>
<p>开发环境下，webpack会对转换后的模块包裹上一层函数，这样的弊端在于：</p>
<ul>
<li>大量的函数声明语句增大了代码量。 </li>
<li>运行时嵌套的函数作用域变多，内存开销变大。</li>
</ul>
<p>Scope Hoisting功能会将所有的模块按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止命名冲突。</p>
<p><strong>如何开启？</strong></p>
<p>这个功能在<code>mode: &#39;production&#39;</code>下默认开启。</p>
<p>而开发环境要用到<code>wepack.optimize.ModuleConcatenationPlugin</code>插件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  resolve: &#123;<br>    <span class="hljs-comment">// 针对nom中的第三方模块优先采用 jsnext:main中指向的ES6模块化语法的插件</span><br>    mainFields: [<span class="hljs-string">&#x27;jsnext:main&#x27;</span>, <span class="hljs-string">&#x27;browser&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>],<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 开启 Scope Hoisting</span><br>    <span class="hljs-keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h2><p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/split-chunks-plugin/">官方文档链接</a></p>
<p>简单的来说splitChunks就是Webpack中一个提取或分离代码的插件，<strong>主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件。</strong></p>
<p>提到前端优化，提取公共代码是必不可少的手段。在Webpack出现前，提取公共代码是人为去处理，而SplitChunks插件的作用就是通过配置让Webpack去帮你提取公共代码。Webpack创始人的初衷也是希望能有更多时间写更多代码，所以这种纯体力的劳动交给Webpack去完成。</p>
<h3 id="基本配置项"><a href="#基本配置项" class="headerlink" title="基本配置项"></a>基本配置项</h3><ul>
<li><p><code>chunks</code>选项，决定要提取那些模块。</p>
</li>
<li><ul>
<li><p>默认是<code>async</code>：将每个异步模块提取成一个chunk，再提取不同异步模块的相同依赖，并打包到一个新的chunk中。</p>
</li>
<li><blockquote>
<p>异步加载的模块：通过<code>import(&#39;xxx&#39;)</code>或<code>require([&#39;xxx&#39;],() =&gt;&#123;&#125;)</code>加载的模块。</p>
</blockquote>
</li>
</ul>
</li>
<li><ul>
<li><p><code>initial</code>：从每个入口进行深度遍历，将一个入口依赖的所有同步模块生成一个initial chunk，然后对不同的initial chunk的相同依赖进行提取并打包到新的chunk中。（每个异步模块也会打包成单独chunk。）</p>
</li>
<li><blockquote>
<p>同步加载的模块：通过 <code>import xxx</code>或<code>require(&#39;xxx&#39;)</code>加载的模块。</p>
</blockquote>
</li>
</ul>
</li>
<li><ul>
<li><code>all</code>：将所有initial chunk以及所有异步模块生成的non-initial chunk放在一起进行分析提取。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>minSize</code>选项：规定被提取的模块在压缩前的大小最小值，单位为字节，默认为30000，只有超过了30000字节才会被提取。</p>
</li>
<li><p><code>maxSize</code>选项：把提取出来的模块打包生成的文件大小不能超过maxSize值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为0，表示不限制大小。</p>
</li>
<li><p><code>minChunks</code>选项：表示要被提取的模块最小被引用次数，引用次数超过或等于minChunks值，才能被提取。</p>
</li>
<li><p><code>maxAsyncRequests</code>选项：最大的按需(异步)加载次数，默认为 6。</p>
</li>
<li><p><code>maxInitialRequests</code>选项：打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件），默认为4。</p>
<blockquote>
<p>优先级 ：</p>
<ul>
<li>webpack5中 maxInitialRequests / maxAsyncRequests&lt; maxSize &lt; minSize。</li>
<li>webpack4中好像存在bug，minSize/maxSize的优先级没有maxInitialRequests / maxAsyncRequests高。</li>
</ul>
</blockquote>
</li>
<li><p><code>automaticNameDelimiter</code>选项：打包生成的js文件名的分割符，默认为<code>~</code>。</p>
</li>
<li><p><code>name</code>选项：打包生成js文件的名称。</p>
</li>
<li><p><code>cacheGroups</code>选项，核心重点，<strong>配置提取模块的方案</strong>。里面每一项代表一个提取模块的方案。下面是<code>cacheGroups</code>每项中特有的选项，其余选项和外面一致，若<code>cacheGroups</code>每项中有，就按配置的，没有就使用外面配置的。</p>
</li>
<li><ul>
<li><code>test</code>选项：用来匹配要提取的模块的资源路径或名称。值是正则或函数。</li>
<li><code>priority</code>选项：方案的优先级，值越大表示提取模块时优先采用此方案。默认值为0。</li>
<li><code>reuseExistingChunk</code>选项：<code>true</code>/<code>false</code>。为<code>true</code>时，如果当前要提取的模块，在已经在打包生成的<em>js</em>文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的<em>js</em>文件。</li>
<li><code>enforce</code>选项：<code>true</code>/<code>false</code>。为<code>true</code>时，忽略<code>minSize</code>，<code>minChunks</code>，<code>maxAsyncRequests</code>和<code>maxInitialRequests</code>外面选项</li>
</ul>
</li>
</ul>
<h3 id="自己分析出的默认分割策略"><a href="#自己分析出的默认分割策略" class="headerlink" title="自己分析出的默认分割策略"></a>自己分析出的默认分割策略</h3><p>简单情况下，Webpack的splitChunks插件<strong>基本策略</strong>（priority为0，即默认策略）：</p>
<ol>
<li><p>从依赖图的拓扑顶点<code>vi</code>开始对<code>vi</code>所依赖的node_modules目录下的所有第三方模块进行分离，命名为<code>vendors~vi</code>。</p>
</li>
<li><p>如果不同的拓扑顶点<code>v1、v2</code>依赖相同的<strong>一个或多个node_modules下的第三方模块</strong>，则对<code>vendors~v1、vendors~v2</code>进一步分离为<code>vendors~v1~v2</code>和<code>vendor~v1、vendors~v2</code>，这种分离保证了<code>vendors~v1</code>和<code>vendors~v2</code>不再具有交集。</p>
<p>例如：v1、v2同时依赖了lodash和vue，则lodash和vue会被打包到<code>vendors~v1~v2</code>的chunk中。</p>
</li>
<li><p>找到被<code>v1、v2...vn</code>依赖了两次及其上，且压缩前模块大于等于30000b（约等于30kb）的<strong>文件模块</strong>，此类模块会被一起打包到名为<code>v1~v2~...vn</code>的chunk。小于30kb的模块，即使是被多个initial chunk依赖，也只会打包到initial chunk中，不会单独分离，<strong>这样虽然重复打包了，但可以减少请求次数</strong>。</p>
<p>例如：如果v1、v2、v3同时依赖了src/lib/a.js、src/lib/b.js，且这两个文件都大于30kb，则src/lib/a.js、src/lib/b.js会被打包到名为<code>v1~v2~v3</code>的chunk中。</p>
</li>
<li><p>对动态导入的懒加载模块（异步/懒加载）单独分离，如果懒加载模块中依赖了intial chunk中已经打包了的同步模块，则懒加载模块中不会再打包这些模块，而是只记录引用。</p>
</li>
</ol>
<blockquote>
<p>由于splitChunks.chunks 默认值为”async”，所以只会对不同的懒加载模块进行上述分离操作，而不会对不同的入口模块initial chunk进行依赖分离。下面就来说说如何选取需要进行分割操作的模块。</p>
</blockquote>
<h3 id="chunks属性"><a href="#chunks属性" class="headerlink" title="chunks属性"></a>chunks属性</h3><p>在splitChunks中，chunks是一个可配置的属性，它用于指示插件对哪些chunk分离相同的依赖，该属性既可以在splitChunks.chunks中全局配置，也可以在cacheGroups[group].chunks中配置并覆盖全局的配置。</p>
<p>该属性的可选值有：</p>
<ol>
<li><p>“async”：默认值，将懒加载模块进行分离，然后只对懒加载模块进行默认的分割处理。</p>
<p>例如单入口的情况：</p>
<p><img src="/webpack4.assets/image-20210329155145451.png" srcset="/img/loading.gif" alt="image-20210329155145451"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 单入口</span><br>entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span><br>optimization: &#123;<br>    splitChunks: &#123;<br>        chunks: <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-comment">// 👈 默认就为&#x27;async&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// main.js内动态导入了两个模块</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./async.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// 👆 此时，webpack只会对 src/async.js 和 src/lazy.js进行依赖分析。并分离出他们的共同依赖。</span><br><span class="hljs-comment">// 在ModuleGraph中 src/async.js就是v1顶点，src/lazy就是v2顶点</span><br></code></pre></td></tr></table></figure>
<p><img src="/webpack4.assets/image-20210329155225599.png" srcset="/img/loading.gif" alt="分析async"></p>
</li>
</ol>
<p>   又例如多入口的情况：</p>
<p>   <img src="/webpack4.assets/image-20210329154956362.png" srcset="/img/loading.gif" alt="Module Graph"></p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 多入口</span><br><span class="hljs-comment">// ================= webpack.config.js ==================</span><br>entry: &#123;<br>	main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>    index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>&#125;,<br>optimization: &#123;<br>    splitChunks: &#123;<br>        chunks: <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-comment">// 👈 默认就为&#x27;async&#x27;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// =============== main.js内动态导入了两个模块 ==================</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./async.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// ================ index.js内动态导入了一个模块 ==================</span><br><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./index-lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(m.default));<br>    <br><span class="hljs-comment">// 👆 此时，webpack只会对 src/async.js、src/lazy.js、src/index-lazy进行依赖分析。并分离出他们的共同依赖。</span><br><span class="hljs-comment">// 在ModuleGraph中 src/async.js就是v1顶点，src/lazy就是v2顶点，src/index-lazy就是v3顶点。</span><br></code></pre></td></tr></table></figure>
<p>   <img src="/webpack4.assets/image-20210329155347635.png" srcset="/img/loading.gif" alt="多入口async依赖图"></p>
<ol start="2">
<li><p>“initial”：只对initial chunk进行分割处理，即在<code>Module Graph</code>中将<strong>懒加载模块及其独立依赖的模块移除后</strong>再进行依赖分析。</p>
<p>单入口依赖图：</p>
<p><img src="/webpack4.assets/image-20210329155522181.png" srcset="/img/loading.gif" alt="image-20210329155522181"></p>
<p>单入口initial chunk依赖分析：</p>
<p><img src="/webpack4.assets/image-20210329155613618.png" srcset="/img/loading.gif" alt="image-20210329155613618"></p>
<p>多入口依赖图：</p>
<p><img src="/webpack4.assets/image-20210329154956362.png" srcset="/img/loading.gif" alt="Module Graph"></p>
<p>多入口initial chunks依赖分析：</p>
<p><img src="/webpack4.assets/image-20210329155813684.png" srcset="/img/loading.gif" alt="image-20210329155813684"></p>
</li>
<li><p>“all”：配置chunk为该值时，<strong>会对initial chunk和non-initial chunk同时分析依赖，分离出共有的依赖项。</strong></p>
<p>单入口情况下，采取默认策略时，splitChunks.chunks = “all”<strong>只有一个作用</strong>，就是提取出懒加载模块依赖的node_modules目录下第三方模块，并打包到intial chunk中。</p>
<p>多入口情况下，采取默认策略时，splitChunks.chunks = “all”<strong>还有另外一个作用</strong>，就是提取出main.js入口的懒加载模块与index.js的initial chunk的相同依赖项，并打包成单独的chunk。</p>
<blockquote>
<p>一般来说，在splitChunks.chunks = “all”时，打包出的总体积是最小的，分离出的文件数量是最多的。</p>
</blockquote>
</li>
</ol>
<h3 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a>cacheGroups</h3><p>splitChunks.cacheGroups可以用于提取一些模块打包成一个chunk。</p>
<p>配置该属性有以下用处：</p>
<ol>
<li><p>⭐ 将过大的chunk分割，提取一些首屏依赖的第三方代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>            <span class="hljs-comment">// 👇 将element-ui 提取成单独一个chunk</span><br>            cacheGroups: &#123;<br>                elementUI: &#123;<br>                    chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                    name: <span class="hljs-string">&#x27;element-ui&#x27;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/].*element-ui/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;,<br>                jquery: &#123;<br>                    chunks: <span class="hljs-string">&#x27;all&#x27;</span>,<br>                    name: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/].*jquery/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>合并太过琐碎的chunk，减少请求次数。</p>
<p>例如：在单入口且splitChunks.chunks = ‘all’时，懒加载会分离出第三方依赖<code>vendors~lazy</code>，如果不想让它和<code>vendors~initial-chunk</code>割裂开来，可以将异步模块依赖的第三方模块提前加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    optimization: &#123;<br>        splitChunks: &#123;<br>            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>            cacheGroups: &#123;<br>                <span class="hljs-string">&quot;vendors&quot;</span>: &#123;<br>                    name: <span class="hljs-string">&quot;vendors&quot;</span>,<br>                    test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="chunkName和fileName"><a href="#chunkName和fileName" class="headerlink" title="chunkName和fileName"></a>chunkName和fileName</h3><p>在Webpack中，模块打包成chunk，chunk分离成chunk组，每一个chunk应该拥有一个名字，chunk打包出的文件也应该拥有一个名字。</p>
<p>在之前提到，chunk分为<code>initial chunk</code>和<code>no-initial chunk</code>。</p>
<ul>
<li><p><code>initial chunk</code>即主chunk，是根据入口模块的依赖生成的主线。该类型的chunk名字是在定义<code>entry</code>时设定的，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    entry: &#123;<br>        main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <span class="hljs-comment">// 此入口生成的intial chunk的chunkName为main</span><br>        index: <span class="hljs-string">&#x27;./src/index.js&#x27;</span> <span class="hljs-comment">// 此入口生成的initial chunk的chunkName为index</span><br>    &#125;,<br>    output: &#123;<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>        filename: <span class="hljs-string">&quot;initial-chunk-[name].[hash].js&quot;</span> <span class="hljs-comment">// intial chunk打包结果文件名</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>initial chunk打包后的文件名（<code>asset</code>）是在output.filename配置的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">output: &#123;<br> filename: <span class="hljs-string">&quot;[name].[hash:8].js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p><code>non-initial chunk</code>一般由三种情况生成。① 异步导入（懒加载）。 ② 由splitChunks默认的分割策略生成。③ 由splitChunks.cacheGroups自定义的分割策略生成。</p>
<p>对于异步导入的模块生成的chunk命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;lazy&quot; */</span><span class="hljs-string">&#x27;./lib/lazy.js&#x27;</span>) <span class="hljs-comment">// 使用魔法注释为chunk命名。</span><br></code></pre></td></tr></table></figure>
<p>对于node_modules或者&gt; 30kb的共同依赖项命名规则：</p>
<ul>
<li><p><code>vendors-v1~v2</code> 👈 node_modules</p>
</li>
<li><p><code>v1~v2</code>  &gt; 30kb共同依赖项。</p>
</li>
</ul>
<p>对splitChunks.cacheGroups分割出的chunk命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//....</span><br>    optimization: &#123;<br>        <span class="hljs-comment">//....</span><br>        splitChunks: &#123;<br>            cacheGroups: &#123;<br>                lodash: &#123;  <span class="hljs-comment">// 👈 key的作用在于 假如v1和v2依赖了lodash</span><br>                    	  <span class="hljs-comment">// Webpack4 默认的chunkName为 key~v1~v2</span><br>                    name: <span class="hljs-string">&#x27;lodash&#x27;</span>,  <span class="hljs-comment">// name的作用在于替换掉默认的chunkName</span><br>                    test: <span class="hljs-regexp">/lodash/</span>,<br>                    chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,<br>                    priority: <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>⭐ non-initial chunk打包出的文件名在output.chunkFilename中配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">output: &#123;<br> <span class="hljs-comment">//...</span><br> chunkFilename: <span class="hljs-string">&quot;non-initial-[name].js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
</ul>
<h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><p>HMR功能就是热更新功能。开发环境下，当我们修改了js代码，webpack会重新打包，devServer会刷新页面。而当我们开启HMR后，webpack不会将所有资源重新打包，而是只更新修改了的模块，从而<strong>提高构建速度，而且能够在保留页面原有数据状态的基础上，快速地将修改了的内容体现到页面上。</strong></p>
<p>CSS的HMR：style-loader已经内部实现了~</p>
<p>JS的HMR：需要在devServer中配置，同时需要手写每个模块更新的逻辑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    devServer: &#123;<br>        <span class="hljs-comment">//...</span><br>        hot: <span class="hljs-literal">true</span> <span class="hljs-comment">// 👈 开启HMR</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> A <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./lib/a.js&#x27;</span><br><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#app&#x27;</span>).innerHTML = A.msg;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">module</span>.hot) &#123;<br>    <span class="hljs-comment">// 👇 手写当 src/lib/a.js修改时热更新的逻辑</span><br>    <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">&#x27;./lib/a.js&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#app&#x27;</span>).innerHTML = A.msg;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗❗   以上是webpack4的配置，webpack5中，HMR的配置有点不一样。</p>
</blockquote>
<h2 id="preFetch"><a href="#preFetch" class="headerlink" title="preFetch"></a>preFetch</h2><p>懒加载的模块一般在真正需要时才会向服务器发送请求，而何时才是懒加载模块被真正需要了呢？</p>
<p>：当真正执行<code>import(&#39;./lazy.js&#39;)</code>时，浏览器就会向服务器请求懒加载模块。</p>
<p>所以一般<code>import(./lazy.js)</code>会封装到UI交互的回调函数中，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.lazyLoaded) &#123;<br>        <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./lazy.js&#x27;</span>).then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.innerHTML = m.default.text&#125; );<br>        <span class="hljs-built_in">this</span>.lazyLoaded = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有当button的click事件第一次触发时才会向服务器请求 lazy.js。</p>
<p>但是webpack提供另外一种技术，当浏览器空闲时会自动请求设置了prefetch的懒加载模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;button&#x27;</span>).onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.lazyLoaded) &#123;<br>        <span class="hljs-comment">// 👇 在魔法注释中设置prefetch为true</span><br>        <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &#x27;lazy&#x27;, webpackPrefetch: true */</span><span class="hljs-string">&#x27;./lazy.js&#x27;</span>)<br>            .then( <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> &#123;<span class="hljs-built_in">this</span>.innerHTML = m.default.text&#125; );<br>        <span class="hljs-built_in">this</span>.lazyLoaded = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时，浏览器空闲时已经把lazy.js请求到了，当button第一次触发点击事件时，lazy.js会从缓存获取。</p>
<h1 id="其他常见操作与相关插件"><a href="#其他常见操作与相关插件" class="headerlink" title="其他常见操作与相关插件"></a>其他常见操作与相关插件</h1><h2 id="构建前自动清空打包目录-⭐"><a href="#构建前自动清空打包目录-⭐" class="headerlink" title="构建前自动清空打包目录 ⭐"></a>构建前自动清空打包目录 ⭐</h2><p><strong>使用的插件：</strong><code>clean-webpack-plugin</code> <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clean-webpack-plugin">参考链接https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<p>该插件会帮助我们在重新打包项目时，清空<code>output.path</code>中设定的输出目录的内容。</p>
<p><strong>安装插件</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> clean-webpack-<span class="hljs-keyword">plugin</span> -D<br></code></pre></td></tr></table></figure>
<p><strong>使用插件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-comment">// </span><br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>); ❗❗ <span class="hljs-comment">// 需要解构！</span><br><br><span class="hljs-comment">// ⭐ 该插件的options对象</span><br><span class="hljs-keyword">const</span> CleanPluginOptions = &#123;<br>  <br>  <span class="hljs-comment">// 下面这个选项用于配置删除哪些文件， **代表任意级目录</span><br>  <span class="hljs-comment">// 如：&#x27;**/foo&#x27; 可以匹配 /bar/foo、/foo等。</span><br>  cleanOnceBeforeBuildPatterns: [<span class="hljs-string">&#x27;**/*&#x27;</span>],<br>  <br>  <span class="hljs-comment">// ❗ 如果希望排除某些目录，则要用`!`感叹号排除。</span><br>  dry: <span class="hljs-literal">true</span>, <span class="hljs-comment">//👈 必须设置该字段为true，感叹号才起作用</span><br>  cleanOnceBeforeBuildPatterns: [<span class="hljs-string">&#x27;**/*&#x27;</span>, <span class="hljs-string">&#x27;!dll/*&#x27;</span>],<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports =  &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/[name].[hash:10].js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">// 👈 默认会情况该目录下的内容</span><br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(CleanPluginOptions), <span class="hljs-comment">// 👈 使用插件即可</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><p><strong>使用loader：</strong><code>thread-loader</code></p>
<p>使用方法：module.rules中规定了各种类型文件使用的转换loader，当需要使用多进程加快打包速度时，只需要在某个类型的文件处理流程的最后使用一下<code>thread-loader</code>。</p>
<p>例如多进程打包js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                exclude: <span class="hljs-regexp">/node_modules/</span>,<br>                use: [<br>                    <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>                    <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 👇 进一步配置打包的进程数</span><br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-built_in">module</span>: &#123;<br>        rules: [<br>            &#123;<br>                test: <span class="hljs-regexp">/\.js$/</span>,<br>                use: [<br>                    &#123;<br>                        loader: <span class="hljs-string">&#x27;thread-loader&#x27;</span>,<br>                        options: &#123;<br>                            workers: <span class="hljs-number">2</span> <span class="hljs-comment">// 👈使用两个核心</span><br>                        &#125;<br>                    &#125;<br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>使用thread-loader的优点是提升打包速度，缺点是每个进程的开启和交流都会有开销</strong>（babel-loader消耗时间最久，所以使用thread-loader针对其进行优化）。</p>
</blockquote>
<h2 id="向HTML模板中添加本地资源链接"><a href="#向HTML模板中添加本地资源链接" class="headerlink" title="向HTML模板中添加本地资源链接"></a>向HTML模板中添加本地资源链接</h2><p><strong>使用插件：</strong><code>add-asset-html-webpack-plugin</code></p>
<p>该插件能够帮助我们将源码区域的某些JS或CSS资源复制到打包输出目录，并在指定的HTML模板插入这些资源的引用标签。（<strong>复制资源、插入引用标签</strong>）</p>
<p><strong><a target="_blank" rel="noopener" href="https://github.com/SimenB/add-asset-html-webpack-plugin">可配置项</a></strong></p>
<ul>
<li><p><strong>filepath</strong>：指示需要将哪些JS/CSS以标签的形式添加到HTML中。</p>
<p>Type: <code>string|Glob</code>, mandatory</p>
<p>The absolute path of the file you want to add to the compilation, and resulting HTML file. Also support globby string.</p>
</li>
<li><p><strong>files</strong>：为哪些模板添加filepath中包含的所有文件。</p>
<p>Type: <code>string|Array&lt;string&gt;</code>, default `[]</p>
<p>Files that the assets will be added to.</p>
<p>By default the assets will be included in all files. If files are defined, the assets will only be included in specified file globs.</p>
</li>
<li><p><strong>hash</strong>：是否为资源文件名后添加hash值。</p>
<p>Type: <code>boolean</code>, default: <code>false</code></p>
<p>If <code>true</code>, will append a unique hash of the file to the filename. This is useful for cache busting.</p>
</li>
<li><p><strong>includeRelatedFiles</strong>：一般不用，直接在filepath中使用glob语法即可。</p>
<p>Type: <code>boolean</code>, default: <code>true</code></p>
<p>If <code>true</code>, will add <code>filepath + &#39;.*&#39;</code> to the compilation as well. E.g <code>filepath.map</code> and <code>filepath.gz</code>.</p>
</li>
<li><p><strong>outputPath</strong>：资源复制到哪个目录下，默认为output.path。</p>
<p>Type: <code>string</code></p>
<p>If set, will be used as the output directory of the file.</p>
</li>
<li><p><strong>publicPath</strong>：标签的公共路径。</p>
<p>Type: <code>string</code></p>
<p>If set, will be used as the public path of the script or link tag.</p>
</li>
<li><p><strong>typeOfAsset</strong>：可以指示是为资源添加CSS还是JS标签。</p>
<p>Type: <code>string</code>, default: <code>js</code></p>
<p>Can be set to <code>css</code> to create a <code>link</code>-tag instead of a <code>script</code>-tag.</p>
</li>
<li><p><strong>attributes</strong>：可以用于为标签添加额外属性。</p>
<p>Type: <code>object</code>, default: <code>&#123;&#125;</code></p>
<p>Extra attributes to be added to the generated tag. Useful to for instance add <code>nomodule</code> to a polyfill script. The <code>attributes</code> object uses the key as the name of the attribute, and the value as the value of it. If value is simply <code>true</code> no value will be added.</p>
<p>An example of this is included in the repository.</p>
<p>Currently only supports script tags.</p>
</li>
</ul>
<p><strong>添加JS资源</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            filepath: <span class="hljs-string">&quot;./dll/*.dll.js&quot;</span>, <span class="hljs-comment">// 👈 使用glob语法，添加开发目录下的dll脚本。</span><br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <span class="hljs-comment">// 👈 只为dist目录中的该模板添加资源</span><br>            <span class="hljs-comment">// typeOfAsset默认为&#x27;js&#x27;</span><br>        &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>添加CSS资源</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            typeOfAsset: <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-comment">// 👈 一定要指明css</span><br>            filepath: <span class="hljs-string">&quot;src/static/**/*.css&quot;</span>, <br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <br>        &#125;),<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>同时添加JS和CSS资源</strong></p>
<p>需要使用两次插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-comment">//...</span><br>    plugins: [<br>        <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            filepath: <span class="hljs-string">&quot;./dll/*.dll.js&quot;</span>,<br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>],<br>        &#125;),<br>		<span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>            typeOfAsset: <span class="hljs-string">&#x27;css&#x27;</span>,<br>            publicPath: <span class="hljs-string">&#x27;/static/&#x27;</span>, <span class="hljs-comment">// ⭐ publicPath需要和outputPath配合使用，</span><br>            outputPath: <span class="hljs-string">&#x27;static&#x27;</span>,  <span class="hljs-comment">// outputPath相对于dist</span><br>            filepath: <span class="hljs-string">&quot;src/static/**/*.css&quot;</span>, <br>            files: [<span class="hljs-string">&#x27;index.html&#x27;</span>], <br>        &#125;),        <br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>❗ <strong>注意：</strong></p>
<p><strong>add-asset-html-webpack-plugin会将CSS的link标签插入到head中，而JS标签的插入位置与html-webpack-plugin的配置有关。</strong></p>
</blockquote>
<h2 id="大型框架打包成Dll-js"><a href="#大型框架打包成Dll-js" class="headerlink" title="大型框架打包成Dll.js"></a>大型框架打包成Dll.js</h2><p><strong>使用插件：</strong><code>webpack/lib/DllPlugin</code>   👉 生成Dll.js和接口文件manifest.json</p>
<p><strong>使用插件：</strong><code>webpack/lib/DllReferencePlugin</code> 👉 引用Dll内容</p>
<p><strong>注意：</strong></p>
<p>此种做法还需要我们手动将生成后的dll文件以script标签的方式插入到模板中，所以还不是很完善。</p>
<p><font color="red">开发环境下为了提高打包速度，我们可以这样做。</font></p>
<p><strong>前言：</strong></p>
<p>像<code>react</code>这种大型框架，在反复打包时会多次分析依赖，会消耗大量编译时间。</p>
<p>对于此类包或依赖，我们可以先将其打包成Dll，通过接口访问其内容。</p>
<p>由于<code>react</code>要转义<code>jsx</code>，所以方便起见，下面以将<code>Vue</code>打包成<code>Dll</code>为例：</p>
<p><strong>总体流程：</strong></p>
<p>首先建立单独的webpack配置，用于将某个大型第三方包打包成dll。</p>
<p>然后在构建项目的webpack配置中引用该dll。</p>
<p><strong>1. 新建用于打包dll的webpack.config.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 新建 webpack.dll.js<br><br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> DllPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/DllPlugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: &#123;<br>    vue: [<span class="hljs-string">&#x27;vue&#x27;</span>]<br>  &#125;,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;Dll&#x27;</span>),<br>    library: <span class="hljs-string">&#x27;__dll__[name]&#x27;</span>,<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> DllPlugin(&#123;<br>      name: <span class="hljs-string">&#x27;__dll__[name]&#x27;</span>,<br>      path: resolve(__dirname, <span class="hljs-string">&#x27;dll&#x27;</span>, <span class="hljs-string">&#x27;[name].manifest.json&#x27;</span>)<br>    &#125;)<br>  ],<br>&#125;<br><br><span class="hljs-comment">// ==========================</span><br># package.json<br><br>&#123;<br>  scripts: &#123;<br>    <span class="hljs-string">&quot;dll&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.dll.js&quot;</span> , <span class="hljs-comment">// 👈 配置一条构建vue dll的脚本</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p><strong>2. 将vue打包成Dll</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm <span class="hljs-keyword">run</span><span class="bash"> dll</span><br></code></pre></td></tr></table></figure>
<p>此时dist/dll目录下生成两个文件：</p>
<p> <img src="/webpack4.assets/image-20210329232433059.png" srcset="/img/loading.gif" alt="image-20210329232433059"></p>
<p><strong>3. 在构建项目的webpack配置中读取Dll接口，并向模板中添加对vue.dll.js的引用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> CleanWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br><br>⭐ <span class="hljs-keyword">const</span> DllReferencePlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack/lib/DllReferencePlugin&#x27;</span>);<br>⭐ <span class="hljs-keyword">const</span> AddAssetHTMLWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;add-asset-html-webpack-plugin&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>;<br><br><span class="hljs-keyword">const</span> devConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,<br>  plugins: [<br>    <span class="hljs-comment">// 👇 配置引用DLL插件,该插件读取vue.mainfest.json后会知道哪些第三方包是不需要打包的。</span><br>    <span class="hljs-comment">// 同时在打包构建过程中，如果某些模块依赖了这些没有打包的第三方包的内容时，</span><br>    <span class="hljs-comment">// 插件通过读取mainifest.json，能够告诉模块到全局的哪个属性中获取依赖的内容。</span><br>    <span class="hljs-keyword">new</span> DllReferencePlugin(&#123;<br>      manifest: resolve(__dirname, <span class="hljs-string">&#x27;dll&#x27;</span>, <span class="hljs-string">&#x27;vue.manifest.json&#x27;</span>),<br>    &#125;),<br>    <span class="hljs-comment">// ⭐ 将vue.dll.js复制到dist目录，并向HTML中插入vue.dll.js的引用标签</span><br>    <span class="hljs-keyword">new</span> AddAssetHTMLWebpackPlugin(&#123;<br>      filepath: <span class="hljs-string">&#x27;./dll/vue.dll.js&#x27;</span>,<br>      files: [<span class="hljs-string">&#x27;index.html&#x27;</span>]<br>    &#125;),<br>      <br>  ],<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, devConfig);<br><br></code></pre></td></tr></table></figure>


<h2 id="模块免导入"><a href="#模块免导入" class="headerlink" title="模块免导入"></a>模块免导入</h2><p><strong>使用插件：</strong><code>webpack.ProvidePlugin</code></p>
<p>webpack配置ProvidePlugin后，在使用时将不再需要import和require进行引入，直接使用即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br> <br><span class="hljs-built_in">module</span>.exports = &#123;<br>  plugins: [<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">new</span> webpack.ProvidePlugin(&#123;<br>      <span class="hljs-string">&#x27;$&#x27;</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>      <span class="hljs-string">&#x27;Vue&#x27;</span>: <span class="hljs-string">&#x27;vue&#x27;</span><br>    &#125;),<br>   <span class="hljs-comment">// ...</span><br>	]<br>&#125;<br><br><span class="hljs-comment">//-------------------------------------</span><br># .src/index.js<br><br><span class="hljs-comment">// 无需导入，就可以使用该变量。（手动导入了也不影响效果）</span><br><span class="hljs-built_in">console</span>.log($);<br><span class="hljs-built_in">console</span>.log(Vue);<br></code></pre></td></tr></table></figure>


<h2 id="在页面中使用CDN引入第三方包"><a href="#在页面中使用CDN引入第三方包" class="headerlink" title="在页面中使用CDN引入第三方包"></a>在页面中使用CDN引入第三方包</h2><h3 id="方法1：使用插件处理"><a href="#方法1：使用插件处理" class="headerlink" title="方法1：使用插件处理"></a>方法1：使用插件处理</h3><p><strong>使用的插件：</strong><code>html-webpack-externals-plugin</code></p>
<p>正常情况下，我们在本地开发时使用<code>import</code>或<code>require</code>导入第三方模块，都是到 <strong>node_modules</strong> 目录或缓存中导入。<code>html-webpack-externals-plugin</code>为我们提供了另外一种导入方式，即CDN引入。</p>
<p><font color='red'>该插件自动将CDN script标签插入到模板HTML中</font>，第三方内容<code>foo</code>就挂载到了全局对象window下（这里假设第三方包将自己挂载到<code>Foo</code>属性上），在其他模块导入<code>foo</code>时，会将<code>window.Foo</code>作为导入。</p>
<p><strong>下面以CDN导入jQuery为例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> HTMLWebPackExternalsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-externals-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  output: &#123;<br>    filename: <span class="hljs-string">&#x27;js/[name].[hash].js&#x27;</span>,<br>    path: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>);<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-comment">// 使用插件</span><br>    <span class="hljs-keyword">new</span> HTMLWebpackExternalsPlugin(&#123;<br>      <span class="hljs-comment">// 👇 注意是复数 externals</span><br>      externals: [ <span class="hljs-comment">// 可以定义多个CDN扩展，用对象数组的形式</span><br>        &#123;<br>          <span class="hljs-built_in">module</span>: <span class="hljs-string">&#x27;jquery&#x27;</span>,<br>          entry: <span class="hljs-string">&#x27;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&#x27;</span> <span class="hljs-comment">// cdn链接</span><br>          <span class="hljs-built_in">global</span>: <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-comment">// 到全局的该属性上获取</span><br>        &#125;,<br>      ],<br>      <span class="hljs-comment">/* ⭐⭐</span><br><span class="hljs-comment">      *	如果是多页面应用，就会有多个html文件，`html-webpack-externals-plugin`默认将cdn插入到所有页面中</span><br><span class="hljs-comment">      * 如果开发时只需要将cdn加入到某些html中。则需要指定 files: [...]，来指示需要cdn的HTML文件</span><br><span class="hljs-comment">      */</span><br>      files: [<span class="hljs-string">&#x27;index.html&#x27;</span>]  <span class="hljs-comment">// 👈 files数组中填的是打包后的html文件相对于输出目录的路径</span><br>			<span class="hljs-comment">// 如果html打包到了dist/static中，files: [&#x27;static/index.html&#x27;]</span><br>      <br>    &#125;)<br>  ]<br>&#125;<br><br><span class="hljs-comment">//====================================</span><br># .src/main.js<br><span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jquery&#x27;</span>; <span class="hljs-comment">// 将会从全局获取jquery</span><br><br><span class="hljs-built_in">console</span>.log($);<br></code></pre></td></tr></table></figure>




<h3 id="方法2：手动插入配合externals"><a href="#方法2：手动插入配合externals" class="headerlink" title="方法2：手动插入配合externals"></a>方法2：手动插入配合externals</h3><blockquote>
<p>当我们在开发时也可以直接在模板HTML中插入了第三方包的CDN script标签，但我们需要让webpack在打包时告诉JS模块到全局去获取。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- .src/index.html --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在模板中直接cdn引入--&gt;</span><br>  	<span class="hljs-tag">&lt;<span class="hljs-name">scripts</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">scripts</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  externals: &#123;<br>    jquery: <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-comment">// 指示引入jquery时，访问全局对象的$属性</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>






<h2 id="将资源目录拷贝到打包目录"><a href="#将资源目录拷贝到打包目录" class="headerlink" title="将资源目录拷贝到打包目录"></a>将资源目录拷贝到打包目录</h2><p><strong>使用的插件：</strong><code>copy-webpack-plugin</code></p>
<p>在一定场合下需要使用该功能，比如将开发目录下的mock数据拷贝到打包后的输出目录中。</p>
<p>现在假设将<code>.src/mock</code>拷贝到<code>.dist/mock</code></p>
<p><strong>安装插件</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">npm install <span class="hljs-keyword">copy</span><span class="bash">-webpack-plugin -D</span><br></code></pre></td></tr></table></figure>
<p><strong>使用插件</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;copy-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  plugins: [<br>    <span class="hljs-comment">// 该插件的配置是一个数组，数组中的元素要求含有from和to两个属性，分别代表源路径和目标路径</span><br>    <span class="hljs-keyword">new</span> CopyWebpackPlugin([<br>      &#123;<br>        <span class="hljs-keyword">from</span>: resolve(__dirname, <span class="hljs-string">&#x27;src/mock&#x27;</span>), <span class="hljs-comment">// 需要使用绝对路径</span><br>        to: resolve(__dirname, <span class="hljs-string">&#x27;dist/mock&#x27;</span>),<br>      &#125;,<br>    ]),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="模拟将打包结果部署到Express服务器"><a href="#模拟将打包结果部署到Express服务器" class="headerlink" title="模拟将打包结果部署到Express服务器"></a>模拟将打包结果部署到Express服务器</h2><p><strong>使用Express中间件</strong>：<code>webpack-dev-middleware</code></p>
<p><strong>1. 安装express和webpack-dev-middleware</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">express</span> webpack-dev-middleware --<span class="hljs-built_in">save</span><br></code></pre></td></tr></table></figure>
<p><strong>2. 在前端项目页面下新建server.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># ./server.js<br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> webpackDevMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-middleware&#x27;</span>);<br><br><span class="hljs-keyword">const</span> webpackConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config&#x27;</span>); <span class="hljs-comment">// 引入webpack配置</span><br><br><span class="hljs-keyword">const</span> compiler = webpack(webpackConfig); <span class="hljs-comment">// 执行webpack函数，生成编译对象</span><br><br><span class="hljs-keyword">const</span> app = express(); <span class="hljs-comment">// 新建Express服务器</span><br><br>app.use(webpackDevMiddleware(compiler, &#123;&#125;)); <span class="hljs-comment">// 执行中间件，将编译对象传入</span><br><span class="hljs-comment">/* 该中间件会做两件事：</span><br><span class="hljs-comment">* 1. 调用compiler.run()，执行编译。</span><br><span class="hljs-comment">* 2. 使用一个中间件，响应客户端对打包后的文件的请求。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 以下开始express项目的正常逻辑，这里模拟一个&#x27;/api/mock&#x27; 路由。</span><br>app.get(<span class="hljs-string">&#x27;/api/mock&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> res.json(&#123; <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;ok&#x27;</span> &#125;));<br><br>app.listen(<span class="hljs-number">3000</span>); <span class="hljs-comment">// 监听3000端口</span><br><br><span class="hljs-comment">// 输入命令：node ./server.js 启动服务器</span><br><br></code></pre></td></tr></table></figure>


<h2 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h2><p><strong>使用插件：</strong><code>webpack.DefinePlugin</code></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/define-plugin/">参考链接：https://webpack.js.org/plugins/define-plugin/</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;<br>  <span class="hljs-string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="hljs-built_in">JSON</span>.stringify(process.env.NODE_ENV),<br>  <span class="hljs-string">&#x27;SERVICE_URL&#x27;</span>: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;https://dev.example.com&#x27;</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>


<h2 id="添加版权声明"><a href="#添加版权声明" class="headerlink" title="添加版权声明"></a>添加版权声明</h2><p><strong>使用插件：</strong><code>webpack.BannerPlugin</code></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/banner-plugin/">参考链接：https://webpack.js.org/plugins/banner-plugin/</a></p>
<h2 id="拆分配置-⭐"><a href="#拆分配置-⭐" class="headerlink" title="拆分配置 ⭐"></a>拆分配置 ⭐</h2><p><strong>安装<code>webpack-merge</code>，将<code>webpack.config.js</code>拆分成：</strong></p>
<ol>
<li><code>webpack.config.base.js</code></li>
<li><code>webpack.config.dev.js</code></li>
<li><code>webpack.config.prod.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.dev.js<br><span class="hljs-comment">// ⭐ 需要使用webpack-merge的merge方法去合并配置</span><br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>); <br><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-comment">// 👇导入基本配置对象</span><br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;development&#x27;</span>;<br><br><span class="hljs-keyword">const</span> devConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;development&#x27;</span>,<br>  devServer: &#123;<br>    contentBase: resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  devtool: <span class="hljs-string">&#x27;source-map&#x27;</span>,<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, devConfig);<br><br><span class="hljs-comment">//-----------------------------------------------------------</span><br># webpack.config.prod.js<br><span class="hljs-keyword">const</span> &#123; merge &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>);<br><span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> baseConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.config.base&#x27;</span>);<br><br>process.env.BROWSERSLIST_ENV = <span class="hljs-string">&#x27;production&#x27;</span>;<br><br><span class="hljs-keyword">const</span> prodConfig = &#123;<br>  mode: <span class="hljs-string">&#x27;production&#x27;</span>,<br>  devtool: <span class="hljs-string">&#x27;nosources-source-map&#x27;</span>,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(),<br>  ],<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = merge(baseConfig, prodConfig);<br><br><span class="hljs-comment">//------------------------------------------------------------</span><br># webpack.config.base.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  *    基本配置内容</span><br><span class="hljs-comment">  */</span><br>&#125;<br><br><span class="hljs-comment">//------------------------------------------------------------</span><br># package.json<br><span class="hljs-comment">// ⭐⭐ 配置脚本</span><br>&#123;<br>  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack server --config ./webpack.config.dev.js&quot;</span>,<br>    <span class="hljs-string">&quot;build:dev&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.config.dev.js&quot;</span>,<br>    <span class="hljs-string">&quot;build:prod&quot;</span>: <span class="hljs-string">&quot;webpack --config ./webpack.config.prod.js&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="MPA-多页面打包"><a href="#MPA-多页面打包" class="headerlink" title="MPA 多页面打包"></a>MPA 多页面打包</h2><p>在模块的初级打包中提到过“多入口”如何配置。当一个项目不再是SPA，而是多页面应用程序时，我们就要打包多个HTML和每个页面对应的入口JS。</p>
<h3 id="多次使用插件"><a href="#多次使用插件" class="headerlink" title="多次使用插件"></a>多次使用插件</h3><p><strong>使用插件：</strong><code>html-webpack-plugin</code></p>
<p>我们依然是使用该插件打包html和入口文件，多页面时，每个页面都要<code>new</code>一个<code>html-webpack-plugin</code>。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><span class="hljs-keyword">const</span> HTMLWebpackPlugin = reuqire(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>	entry: &#123;<br>    <span class="hljs-comment">// 👇 定义两个入口，一个叫home，一个叫app</span><br>    main: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>, <br>    app: <span class="hljs-string">&#x27;./src/app.js&#x27;</span>,<br>    vendor: [<span class="hljs-string">&#x27;jquery&#x27;</span>],<br>  &#125;,<br>  plugins: [<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      <span class="hljs-comment">// 以src/pages目录下的index.html为模板</span><br>      template: <span class="hljs-string">&#x27;./src/pages/index.html&#x27;</span>,<br>       <span class="hljs-comment">// 👈 标记该页面依赖于jquery，同时入口为home</span><br>      chunks: [<span class="hljs-string">&#x27;vendor&#x27;</span>,<span class="hljs-string">&#x27;main&#x27;</span>],<br>      chunksSortMode: <span class="hljs-string">&#x27;manual&#x27;</span>,<br>      filename: <span class="hljs-string">&#x27;index.js&#x27;</span>, <span class="hljs-comment">// ❗⭐❗ 一定要为每个打包的页面注明文件名，否则会报错</span><br>      <span class="hljs-comment">// chunk: [&#x27;main&#x27;]</span><br>    &#125;),<br>    <span class="hljs-keyword">new</span> HTMLWebpackPlugin(&#123;<br>      <span class="hljs-comment">// 以src/pages目录下的sub.html为模板</span><br>      template: <span class="hljs-string">&#x27;./src/pages/sub.html&#x27;</span>,<br>      <span class="hljs-comment">// 标记该页面的入口为app</span><br>      chunks: [<span class="hljs-string">&#x27;app&#x27;</span>],<br>      filename: <span class="hljs-string">&#x27;sub.html&#x27;</span> <span class="hljs-comment">// ❗⭐❗ 一定要为每个打包的页面注明文件名，否则会报错</span><br>    &#125;),<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>多页面时，如果配置了html-webpack-externals-plugin，需要指明依赖于cdn的打包后的html文件。</p>
<p>具体查看 html-webpack-externals-plugin 的 files字段配置。</p>
</blockquote>
<h3 id="页面和入口JS的约定"><a href="#页面和入口JS的约定" class="headerlink" title="页面和入口JS的约定"></a>页面和入口JS的约定</h3><p>当我们约定一个页面模板和其入口JS文件名相同时，我们可以将页面和入口JS分别放在<code>pages</code>和<code>entries</code>目录下，然后按文件名进行一一对应，并通过<code>html-webpack-plugin</code>绑定起来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> &#123; resolve, basename &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">// 通过glob这个第三方库去读取一个文件夹下的js文件</span><br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);<br><br><span class="hljs-comment">// 新建一个匹配模式，去匹配src/entries目录下的入口js文件</span><br><span class="hljs-keyword">const</span> entryFilesPattern = resolve(__dirname, <span class="hljs-string">&#x27;src/entries/*.js&#x27;</span>);<br><span class="hljs-keyword">const</span> entryFilePaths = glob.sync(entryFilesPattern);<br><br><span class="hljs-comment">// 👇 多入口对象</span><br><span class="hljs-keyword">const</span> entries = &#123;&#125;;<br>entryFilePaths.forEach(<span class="hljs-function">(<span class="hljs-params">entryPath</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> entryName = basename(entryPath, <span class="hljs-string">&#x27;.js&#x27;</span>); <span class="hljs-comment">// 通过path.basename方法获得不带扩展名.js的文件名</span><br>  entries[entryName] = entryPath;<br>&#125;);<br><br><span class="hljs-comment">// 页面模板所在目录</span><br><span class="hljs-keyword">const</span> pagesDirPath = resolve(__dirname, <span class="hljs-string">&#x27;src/pages&#x27;</span>);<br><span class="hljs-comment">// 👇 用数组保存多页面对应的插件</span><br><span class="hljs-keyword">const</span> htmlWebpackPlugins = <span class="hljs-built_in">Object</span>.keys(entries).map(<span class="hljs-function">(<span class="hljs-params">entryName</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> chunkName = entryName;<br>  <span class="hljs-keyword">const</span> options = &#123;<br>    template: resolve(pagesDirPath, <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkName&#125;</span>.html`</span>),<br>    chunks: [chunkName],<br>    <span class="hljs-comment">// ⭐ 必须指明打包后的文件名，同时可以加入子目录路径，如 `static/&#123;chunkName&#125;.html`</span><br>    filename: <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkName&#125;</span>.html`</span>,<br>    <span class="hljs-comment">// 以下为可选</span><br>    chunksSortMode: <span class="hljs-string">&#x27;manual&#x27;</span>,<br>    inject: <span class="hljs-string">&#x27;body&#x27;</span>,<br>    hash: <span class="hljs-literal">true</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HTMLWebpackPlugin(options);<br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//...</span><br>  entry: entries,<br>  plugins: [<br>    ...htmlWebpackPlugins, <span class="hljs-comment">// 👈 配置多页面</span><br>    <span class="hljs-comment">//...</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="html-webpack-plugin模板字符串-❓"><a href="#html-webpack-plugin模板字符串-❓" class="headerlink" title="html-webpack-plugin模板字符串 ❓"></a>html-webpack-plugin模板字符串 ❓</h2><p><code>html-webpack-plugin</code>能够识别<code>$&#123;...&#125;</code>这样的插值语法，配合<code>raw-loader</code>可以将导入的资源文件的内容放入到插值语法的位置。</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--👇 内联html --&gt;</span><br>    $&#123;require(&#x27;!!raw-loader!./src/head.html&#x27;)&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>      &lt;* 👇 内联css *&gt;<br>      $&#123;require(&#x27;!!raw-loader!./src/css/index.css&#x27;)&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">// 👇 内联js</span></span><br><span class="javascript">      $&#123;<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;!!raw-loader!./src/js/jquery.min.js&#x27;</span>)&#125;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><p><code>require()</code>中的<code>raw-loader![source-id]</code>的写法是<strong>行内loader</strong>，用<code>!</code>分割loader和参数。</p>
</li>
<li><p><code>!!raw-loader</code>中，前面的两个<code>!!</code>是标记该条引用的资源不需要再被<code>rules</code>中配置的loader处理。</p>
</li>
</ul>
<h2 id="分析plugins和loaders耗时"><a href="#分析plugins和loaders耗时" class="headerlink" title="分析plugins和loaders耗时"></a>分析plugins和loaders耗时</h2><p><strong>使用插件：</strong><code>speed-measure-webpack-plugin</code></p>
<p><strong>1. 安装</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> speed-measure-webpack-<span class="hljs-keyword">plugin</span> -D<br></code></pre></td></tr></table></figure>
<p><strong>2. 新建插件对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> SpeedMeasureWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;speed-measure-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> smw = <span class="hljs-keyword">new</span> SpeedMeasureWebpackPlugin();<br><br></code></pre></td></tr></table></figure>
<p><strong>3. 使用wrap方法包裹webpack配置对象并导出</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># webpack.config.js<br><br><span class="hljs-keyword">const</span> SpeedMeasureWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;speed-measure-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> smw = <span class="hljs-keyword">new</span> SpeedMeasureWebpackPlugin();<br><br><span class="hljs-built_in">module</span>.exports = smw.wrap(&#123;<br>  entry: <span class="hljs-string">&#x27;./src/main.js&#x27;</span>,<br>  ouput: &#123;<span class="hljs-comment">/*...*/</span>&#125;,<br>  <span class="hljs-built_in">module</span>: &#123;<span class="hljs-comment">/*...*/</span>&#125;<br>  <span class="hljs-comment">//...</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>4. npm run build</strong></p>
<h2 id="生成打包过程的分析报告"><a href="#生成打包过程的分析报告" class="headerlink" title="生成打包过程的分析报告"></a>生成打包过程的分析报告</h2><p><strong>使用插件：</strong><code>webpack-bundle-analyzer</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack-bundle-analyzer –save-dev<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接使用插件：</span><br>plugins: [<br>    <span class="hljs-keyword">new</span> BundleAnalyzerPlugin()<br>]<br><br>👇 该插件的默认配置，一般无需修改：<br>&#123;<br>  <span class="hljs-comment">//  可以是`server`，`static`或`disabled`。</span><br>  <span class="hljs-comment">//  在`server`模式下，分析器将启动HTTP服务器来显示软件包报告。</span><br>  <span class="hljs-comment">//  在“静态”模式下，会生成带有报告的单个HTML文件。</span><br>  <span class="hljs-comment">//  在`disabled`模式下，你可以使用这个插件来将`generateStatsFile`设置为`true`来生成Webpack Stats JSON文件。</span><br>  analyzerMode: <span class="hljs-string">&#x27;server&#x27;</span>,<br>  <span class="hljs-comment">//  将在“服务器”模式下使用的主机启动HTTP服务器。</span><br>  analyzerHost: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>  <span class="hljs-comment">//  将在“服务器”模式下使用的端口启动HTTP服务器。</span><br>  analyzerPort: <span class="hljs-number">8888</span>, <br>  <span class="hljs-comment">//  路径捆绑，将在`static`模式下生成的报告文件。</span><br>  <span class="hljs-comment">//  相对于捆绑输出目录。</span><br>  reportFilename: <span class="hljs-string">&#x27;report.html&#x27;</span>,<br>  <span class="hljs-comment">//  模块大小默认显示在报告中。</span><br>  <span class="hljs-comment">//  应该是`stat`，`parsed`或者`gzip`中的一个。</span><br>  <span class="hljs-comment">//  有关更多信息，请参见“定义”一节。</span><br>  defaultSizes: <span class="hljs-string">&#x27;parsed&#x27;</span>,<br>  <span class="hljs-comment">//  在默认浏览器中自动打开报告</span><br>  openAnalyzer: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">//  如果为true，则Webpack Stats JSON文件将在bundle输出目录中生成</span><br>  generateStatsFile: <span class="hljs-literal">false</span>, <br>  <span class="hljs-comment">//  如果`generateStatsFile`为`true`，将会生成Webpack Stats JSON文件的名字。</span><br>  <span class="hljs-comment">//  相对于捆绑输出目录。</span><br>  statsFilename: <span class="hljs-string">&#x27;stats.json&#x27;</span>,<br>  <span class="hljs-comment">//  stats.toJson（）方法的选项。</span><br>  <span class="hljs-comment">//  例如，您可以使用`source：false`选项排除统计文件中模块的来源。</span><br>  <span class="hljs-comment">//  在这里查看更多选项：https：  //github.com/webpack/webpack/blob/webpack-1/lib/Stats.js#L21</span><br>  statsOptions: <span class="hljs-literal">null</span>,<br>  logLevel: <span class="hljs-string">&#x27;info&#x27;</span> <span class="hljs-comment">// 日志级别。可以是&#x27;信息&#x27;，&#x27;警告&#x27;，&#x27;错误&#x27;或&#x27;沉默&#x27;。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/webpack4.assets/image-20210328200605532.png" srcset="/img/loading.gif" alt="image-20210328200605532"></p>
<h2 id="样式表px自动换算rem"><a href="#样式表px自动换算rem" class="headerlink" title="样式表px自动换算rem"></a>样式表px自动换算rem</h2><p><strong>使用loader：</strong><code>px2rem-loader</code></p>
<p><strong>前言</strong></p>
<p>移动端开发rem布局中，我们会使用内联的JS脚本改变rem的大小。<font color='red'>而这个JS脚本中会耦合设计稿的信息</font>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> html = <span class="hljs-built_in">document</span>.documentElement;<br><span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.body;<br><br><span class="hljs-keyword">const</span> designWidth = <span class="hljs-number">750</span>; <span class="hljs-comment">// 👈 设计稿宽度，耦合了设计稿信息</span><br><span class="hljs-keyword">const</span> zoomRatio = <span class="hljs-number">100</span>; <span class="hljs-comment">// rem放大比例，便于换算。</span><br>html.style.fontSize = html.clientWidth / designWidth * zoomRatio + <span class="hljs-string">&#x27;px&#x27;</span>;<br>body.style.fontSize = <span class="hljs-string">&#x27;16px&#x27;</span>;<br><br></code></pre></td></tr></table></figure>


<p><strong>现在提供一种方式：</strong> 抽离控制rem的JS脚本中的设计稿宽度信息，将设计稿宽度的变化由wepack的插件来适配。<font color='red'>同时在写css文件时，不再需要进行人为的换算, 插件会帮助我们换算。</font></p>
<p>😄 <strong>在如下配置下，我们的css文件中不再需要开发者换算啦 ~ 量多少，写多少。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># 控制rem大小的脚本或者其他类似的通用脚本/插件<br><br><span class="hljs-keyword">const</span> html = <span class="hljs-built_in">document</span>.documentElement;<br><span class="hljs-keyword">const</span> body = <span class="hljs-built_in">document</span>.body;<br><br><span class="hljs-keyword">const</span> ratio = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/* 👇 剥离设计稿信息，rem大小永远为理想视口宽度的十分之一。插件换算比例 = 设计稿宽度 / 10</span><br><span class="hljs-comment">*			ratio也可以是别的值，但是插件换算比例  = 设计稿 / ratio</span><br><span class="hljs-comment">*/</span><br>html.style.fontSize = html.clientWidth / ratio; <br><br>body.style.fontSize = <span class="hljs-string">&#x27;16px&#x27;</span>;<br><br><span class="hljs-comment">//====================================================================</span><br># webpack.config.js<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//..</span><br>  <span class="hljs-built_in">module</span>: &#123;<br>    rules: [<br>      &#123;<br>        test: <span class="hljs-regexp">/\.css$/</span>,<br>        use: [<br>          <span class="hljs-string">&#x27;style-loader&#x27;</span>,<br>          <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>          &#123;<br>            loader: <span class="hljs-string">&#x27;px2rem-loader&#x27;</span>,<br>            options: &#123;<br>              remPrecesion: <span class="hljs-number">8</span>, <span class="hljs-comment">// 👈 换算成rem后，保留多少位小数</span><br>              remunit: <span class="hljs-number">75</span>, <span class="hljs-comment">// 👈 换算比例，即在css样式表中75px换算为1rem，相当于设计稿 750/10</span><br>              <br>              <span class="hljs-comment">// 假如说设计稿是1080，控制rem大小JS脚本中的ratio设置为10，则：</span><br>              remunit: <span class="hljs-number">108</span>,<br>              <span class="hljs-comment">// 假如说设计稿是1000，ratio设置为20，则：</span><br>              remunit: <span class="hljs-number">50</span>,<br>              <br>            &#125;<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*</span><br><span class="hljs-comment">假如设计稿上一个div宽度是 250px</span><br><span class="hljs-comment">px2rem-loader中设置了remunit是75</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">250px</span> <span class="hljs-comment">/* 👉 loader 编译后 width: 3.33333333rem */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>❗ ❗  需要注意的是：内联样式不会被 <code>px2rem-loader</code>处理，仍然需要开发者换算。</p>
<blockquote>
<p>所以可能还是 remunit 固定为100，根据不同设计稿调整ratio来的好。</p>
</blockquote>
<h1 id="归纳小结"><a href="#归纳小结" class="headerlink" title="归纳小结"></a>归纳小结</h1><h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="webpack4、cli、html-webpack-plugin兼容"><a href="#webpack4、cli、html-webpack-plugin兼容" class="headerlink" title="webpack4、cli、html-webpack-plugin兼容"></a>webpack4、cli、html-webpack-plugin兼容</h2><ul>
<li>现在使用<code>npm install webpack -D</code>默认安装的是webpack5。</li>
<li>webpack-cli、html-webpack-plugin默认安装的最新版本是配合webpack5使用，所以当使用webpack4时，也需要降低webpack-cli、html-webpack-plugin的版本。</li>
</ul>
<p><strong>安装组合：</strong><code>npm install -D wepack@4 webpack-cli@3 html-webpack-plugin@4 </code></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/webpack/">webpack</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/29/Vue/vue3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue3笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/09/JavaScript/webapis/">
                        <span class="hidden-mobile">WebAPIs</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
